/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/.pnpm/async-lock@1.3.0/node_modules/async-lock/index.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/async-lock@1.3.0/node_modules/async-lock/index.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(/*! ./lib */ "../../node_modules/.pnpm/async-lock@1.3.0/node_modules/async-lock/lib/index.js");


/***/ }),

/***/ "../../node_modules/.pnpm/async-lock@1.3.0/node_modules/async-lock/lib/index.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/async-lock@1.3.0/node_modules/async-lock/lib/index.js ***!
  \**************************************************************************************/
/***/ ((module) => {

"use strict";


var AsyncLock = function (opts) {
	opts = opts || {};

	this.Promise = opts.Promise || Promise;

	// format: {key : [fn, fn]}
	// queues[key] = null indicates no job running for key
	this.queues = Object.create(null);

	// lock is reentrant for same domain
	this.domainReentrant = opts.domainReentrant || false;
	if (this.domainReentrant) {
		if (typeof process === 'undefined' || typeof process.domain === 'undefined') {
			throw new Error(
				'Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, ' +
				'use a NodeJS version that still implements Domain, or install a browser polyfill.');
		}
		// domain of current running func {key : fn}
		this.domains = Object.create(null);
	}

	this.timeout = opts.timeout || AsyncLock.DEFAULT_TIMEOUT;
	this.maxOccupationTime = opts.maxOccupationTime || AsyncLock.DEFAULT_MAX_OCCUPATION_TIME;
	if (opts.maxPending === Infinity || (Number.isInteger(opts.maxPending) && opts.maxPending >= 0)) {
		this.maxPending = opts.maxPending;
	} else {
		this.maxPending = AsyncLock.DEFAULT_MAX_PENDING;
	}
};

AsyncLock.DEFAULT_TIMEOUT = 0; //Never
AsyncLock.DEFAULT_MAX_OCCUPATION_TIME = 0; //Never
AsyncLock.DEFAULT_MAX_PENDING = 1000;

/**
 * Acquire Locks
 *
 * @param {String|Array} key 	resource key or keys to lock
 * @param {function} fn 	async function
 * @param {function} cb 	callback function, otherwise will return a promise
 * @param {Object} opts 	options
 */
AsyncLock.prototype.acquire = function (key, fn, cb, opts) {
	if (Array.isArray(key)) {
		return this._acquireBatch(key, fn, cb, opts);
	}

	if (typeof (fn) !== 'function') {
		throw new Error('You must pass a function to execute');
	}

	// faux-deferred promise using new Promise() (as Promise.defer is deprecated)
	var deferredResolve = null;
	var deferredReject = null;
	var deferred = null;

	if (typeof (cb) !== 'function') {
		opts = cb;
		cb = null;

		// will return a promise
		deferred = new this.Promise(function(resolve, reject) {
			deferredResolve = resolve;
			deferredReject = reject;
		});
	}

	opts = opts || {};

	var resolved = false;
	var timer = null;
	var occupationTimer = null;
	var self = this;

	var done = function (locked, err, ret) {

		if (occupationTimer) {
			clearTimeout(occupationTimer);
			occupationTimer = null;
		}

		if (locked) {
			if (!!self.queues[key] && self.queues[key].length === 0) {
				delete self.queues[key];
			}
			if (self.domainReentrant) {
				delete self.domains[key];
			}
		}

		if (!resolved) {
			if (!deferred) {
				if (typeof (cb) === 'function') {
					cb(err, ret);
				}
			}
			else {
				//promise mode
				if (err) {
					deferredReject(err);
				}
				else {
					deferredResolve(ret);
				}
			}
			resolved = true;
		}

		if (locked) {
			//run next func
			if (!!self.queues[key] && self.queues[key].length > 0) {
				self.queues[key].shift()();
			}
		}
	};

	var exec = function (locked) {
		if (resolved) { // may due to timed out
			return done(locked);
		}

		if (timer) {
			clearTimeout(timer);
			timer = null;
		}

		if (self.domainReentrant && locked) {
			self.domains[key] = process.domain;
		}

		// Callback mode
		if (fn.length === 1) {
			var called = false;
			fn(function (err, ret) {
				if (!called) {
					called = true;
					done(locked, err, ret);
				}
			});
		}
		else {
			// Promise mode
			self._promiseTry(function () {
				return fn();
			})
			.then(function(ret){
				done(locked, undefined, ret);
			}, function(error){
				done(locked, error);
			});
		}
	};

	if (self.domainReentrant && !!process.domain) {
		exec = process.domain.bind(exec);
	}

	if (!self.queues[key]) {
		self.queues[key] = [];
		exec(true);
	}
	else if (self.domainReentrant && !!process.domain && process.domain === self.domains[key]) {
		// If code is in the same domain of current running task, run it directly
		// Since lock is re-enterable
		exec(false);
	}
	else if (self.queues[key].length >= self.maxPending) {
		done(false, new Error('Too much pending tasks'));
	}
	else {
		var taskFn = function () {
			exec(true);
		};
		if (opts.skipQueue) {
			self.queues[key].unshift(taskFn);
		} else {
			self.queues[key].push(taskFn);
		}

		var timeout = opts.timeout || self.timeout;
		if (timeout) {
			timer = setTimeout(function () {
				timer = null;
				done(false, new Error('async-lock timed out'));
			}, timeout);
		}
	}

	var maxOccupationTime = opts.maxOccupationTime || self.maxOccupationTime;
		if (maxOccupationTime) {
			occupationTimer = setTimeout(function () {
				if (!!self.queues[key]) {
					done(false, new Error('Maximum occupation time is exceeded'));
				}
			}, maxOccupationTime);
		}

	if (deferred) {
		return deferred;
	}
};

/*
 * Below is how this function works:
 *
 * Equivalent code:
 * self.acquire(key1, function(cb){
 *     self.acquire(key2, function(cb){
 *         self.acquire(key3, fn, cb);
 *     }, cb);
 * }, cb);
 *
 * Equivalent code:
 * var fn3 = getFn(key3, fn);
 * var fn2 = getFn(key2, fn3);
 * var fn1 = getFn(key1, fn2);
 * fn1(cb);
 */
AsyncLock.prototype._acquireBatch = function (keys, fn, cb, opts) {
	if (typeof (cb) !== 'function') {
		opts = cb;
		cb = null;
	}

	var self = this;
	var getFn = function (key, fn) {
		return function (cb) {
			self.acquire(key, fn, cb, opts);
		};
	};

	var fnx = fn;
	keys.reverse().forEach(function (key) {
		fnx = getFn(key, fnx);
	});

	if (typeof (cb) === 'function') {
		fnx(cb);
	}
	else {
		return new this.Promise(function (resolve, reject) {
			// check for promise mode in case keys is empty array
			if (fnx.length === 1) {
				fnx(function (err, ret) {
					if (err) {
						reject(err);
					}
					else {
						resolve(ret);
					}
				});
			} else {
				resolve(fnx());
			}
		});
	}
};

/*
 *	Whether there is any running or pending asyncFunc
 *
 *	@param {String} key
 */
AsyncLock.prototype.isBusy = function (key) {
	if (!key) {
		return Object.keys(this.queues).length > 0;
	}
	else {
		return !!this.queues[key];
	}
};

/**
 * Promise.try() implementation to become independent of Q-specific methods
 */
AsyncLock.prototype._promiseTry = function(fn) {
	try {
		return this.Promise.resolve(fn());
	} catch (e) {
		return this.Promise.reject(e);
	}
};

module.exports = AsyncLock;


/***/ }),

/***/ "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js ***!
  \******************************************************************************************/
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var concatMap = __webpack_require__(/*! concat-map */ "../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js");
var balanced = __webpack_require__(/*! balanced-match */ "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js");

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ "../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(/*! base64-js */ "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js")
const ieee754 = __webpack_require__(/*! ieee754 */ "../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js")
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ "../../node_modules/.pnpm/clean-git-ref@2.0.1/node_modules/clean-git-ref/lib/index.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/clean-git-ref@2.0.1/node_modules/clean-git-ref/lib/index.js ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";


function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
}

function replaceAll(str, search, replacement) {
  search = search instanceof RegExp ? search : new RegExp(escapeRegExp(search), 'g');

  return str.replace(search, replacement);
}

var CleanGitRef = {
  clean: function clean(value) {
    if (typeof value !== 'string') {
      throw new Error('Expected a string, received: ' + value);
    }

    value = replaceAll(value, './', '/');
    value = replaceAll(value, '..', '.');
    value = replaceAll(value, ' ', '-');
    value = replaceAll(value, /^[~^:?*\\\-]/g, '');
    value = replaceAll(value, /[~^:?*\\]/g, '-');
    value = replaceAll(value, /[~^:?*\\\-]$/g, '');
    value = replaceAll(value, '@{', '-');
    value = replaceAll(value, /\.$/g, '');
    value = replaceAll(value, /\/$/g, '');
    value = replaceAll(value, /\.lock$/g, '');
    return value;
  }
};

module.exports = CleanGitRef;

/***/ }),

/***/ "../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js ***!
  \**********************************************************************************/
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "../../node_modules/.pnpm/crc-32@1.2.0/node_modules/crc-32/crc32.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/.pnpm/crc-32@1.2.0/node_modules/crc-32/crc32.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/* crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
/* vim: set ts=2: */
/*exported CRC32 */
var CRC32;
(function (factory) {
	/*jshint ignore:start */
	/*eslint-disable */
	if(typeof DO_NOT_EXPORT_CRC === 'undefined') {
		if(true) {
			factory(exports);
		} else {}
	} else {
		factory(CRC32 = {});
	}
	/*eslint-enable */
	/*jshint ignore:end */
}(function(CRC32) {
CRC32.version = '1.2.0';
/* see perf/crc32table.js */
/*global Int32Array */
function signed_crc_table() {
	var c = 0, table = new Array(256);

	for(var n =0; n != 256; ++n){
		c = n;
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		c = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));
		table[n] = c;
	}

	return typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;
}

var T = signed_crc_table();
function crc32_bstr(bstr, seed) {
	var C = seed ^ -1, L = bstr.length - 1;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^bstr.charCodeAt(i++))&0xFF];
		C = (C>>>8) ^ T[(C^bstr.charCodeAt(i++))&0xFF];
	}
	if(i === L) C = (C>>>8) ^ T[(C ^ bstr.charCodeAt(i))&0xFF];
	return C ^ -1;
}

function crc32_buf(buf, seed) {
	if(buf.length > 10000) return crc32_buf_8(buf, seed);
	var C = seed ^ -1, L = buf.length - 3;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	}
	while(i < L+3) C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	return C ^ -1;
}

function crc32_buf_8(buf, seed) {
	var C = seed ^ -1, L = buf.length - 7;
	for(var i = 0; i < L;) {
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
		C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	}
	while(i < L+7) C = (C>>>8) ^ T[(C^buf[i++])&0xFF];
	return C ^ -1;
}

function crc32_str(str, seed) {
	var C = seed ^ -1;
	for(var i = 0, L=str.length, c, d; i < L;) {
		c = str.charCodeAt(i++);
		if(c < 0x80) {
			C = (C>>>8) ^ T[(C ^ c)&0xFF];
		} else if(c < 0x800) {
			C = (C>>>8) ^ T[(C ^ (192|((c>>6)&31)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(c&63)))&0xFF];
		} else if(c >= 0xD800 && c < 0xE000) {
			c = (c&1023)+64; d = str.charCodeAt(i++)&1023;
			C = (C>>>8) ^ T[(C ^ (240|((c>>8)&7)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((c>>2)&63)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((d>>6)&15)|((c&3)<<4)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(d&63)))&0xFF];
		} else {
			C = (C>>>8) ^ T[(C ^ (224|((c>>12)&15)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|((c>>6)&63)))&0xFF];
			C = (C>>>8) ^ T[(C ^ (128|(c&63)))&0xFF];
		}
	}
	return C ^ -1;
}
CRC32.table = T;
// $FlowIgnore
CRC32.bstr = crc32_bstr;
// $FlowIgnore
CRC32.buf = crc32_buf;
// $FlowIgnore
CRC32.str = crc32_str;
}));


/***/ }),

/***/ "../../node_modules/.pnpm/diff3@0.0.3/node_modules/diff3/diff3.js":
/*!************************************************************************!*\
  !*** ../../node_modules/.pnpm/diff3@0.0.3/node_modules/diff3/diff3.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright (c) 2006, 2008 Tony Garnock-Jones <tonyg@lshift.net>
// Copyright (c) 2006, 2008 LShift Ltd. <query@lshift.net>
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
// BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

var onp = __webpack_require__(/*! ./onp */ "../../node_modules/.pnpm/diff3@0.0.3/node_modules/diff3/onp.js");

function longestCommonSubsequence(file1, file2) {
  var diff = new onp(file1, file2);
  diff.compose();
  var ses = diff.getses();

  var root;
  var prev;
  var file1RevIdx = file1.length - 1,
      file2RevIdx = file2.length - 1;
  for (var i = ses.length - 1; i >= 0; --i) {
      if (ses[i].t === diff.SES_COMMON) {
        if (prev) {
          prev.chain = {
            file1index: file1RevIdx,
            file2index: file2RevIdx,
            chain: null
          };
          prev = prev.chain;
        } else {
          root = {
            file1index: file1RevIdx,
            file2index: file2RevIdx,
            chain: null
          };
          prev = root;
        }
        file1RevIdx--;
        file2RevIdx--;
      } else if (ses[i].t === diff.SES_DELETE) {
        file1RevIdx--;
      } else if (ses[i].t === diff.SES_ADD) {
        file2RevIdx--;
      }
  }

  var tail = {
    file1index: -1,
    file2index: -1,
    chain: null
  };

  if (!prev) {
    return tail;
  }

  prev.chain = tail;

  return root;
}

function diffIndices(file1, file2) {
  // We apply the LCS to give a simple representation of the
  // offsets and lengths of mismatched chunks in the input
  // files. This is used by diff3_merge_indices below.

  var result = [];
  var tail1 = file1.length;
  var tail2 = file2.length;

  for (var candidate = longestCommonSubsequence(file1, file2); candidate !== null; candidate = candidate.chain) {
    var mismatchLength1 = tail1 - candidate.file1index - 1;
    var mismatchLength2 = tail2 - candidate.file2index - 1;
    tail1 = candidate.file1index;
    tail2 = candidate.file2index;

    if (mismatchLength1 || mismatchLength2) {
      result.push({
        file1: [tail1 + 1, mismatchLength1],
        file2: [tail2 + 1, mismatchLength2]
      });
    }
  }

  result.reverse();
  return result;
}

function diff3MergeIndices(a, o, b) {
  // Given three files, A, O, and B, where both A and B are
  // independently derived from O, returns a fairly complicated
  // internal representation of merge decisions it's taken. The
  // interested reader may wish to consult
  //
  // Sanjeev Khanna, Keshav Kunal, and Benjamin C. Pierce. "A
  // Formal Investigation of Diff3." In Arvind and Prasad,
  // editors, Foundations of Software Technology and Theoretical
  // Computer Science (FSTTCS), December 2007.
  //
  // (http://www.cis.upenn.edu/~bcpierce/papers/diff3-short.pdf)
  var i;

  var m1 = diffIndices(o, a);
  var m2 = diffIndices(o, b);

  var hunks = [];

  function addHunk(h, side) {
    hunks.push([h.file1[0], side, h.file1[1], h.file2[0], h.file2[1]]);
  }
  for (i = 0; i < m1.length; i++) {
    addHunk(m1[i], 0);
  }
  for (i = 0; i < m2.length; i++) {
    addHunk(m2[i], 2);
  }
  hunks.sort(function(x, y) {
    return x[0] - y[0]
  });

  var result = [];
  var commonOffset = 0;

  function copyCommon(targetOffset) {
    if (targetOffset > commonOffset) {
      result.push([1, commonOffset, targetOffset - commonOffset]);
      commonOffset = targetOffset;
    }
  }

  for (var hunkIndex = 0; hunkIndex < hunks.length; hunkIndex++) {
    var firstHunkIndex = hunkIndex;
    var hunk = hunks[hunkIndex];
    var regionLhs = hunk[0];
    var regionRhs = regionLhs + hunk[2];
    while (hunkIndex < hunks.length - 1) {
      var maybeOverlapping = hunks[hunkIndex + 1];
      var maybeLhs = maybeOverlapping[0];
      if (maybeLhs > regionRhs) break;
      regionRhs = Math.max(regionRhs, maybeLhs + maybeOverlapping[2]);
      hunkIndex++;
    }

    copyCommon(regionLhs);
    if (firstHunkIndex == hunkIndex) {
      // The "overlap" was only one hunk long, meaning that
      // there's no conflict here. Either a and o were the
      // same, or b and o were the same.
      if (hunk[4] > 0) {
        result.push([hunk[1], hunk[3], hunk[4]]);
      }
    } else {
      // A proper conflict. Determine the extents of the
      // regions involved from a, o and b. Effectively merge
      // all the hunks on the left into one giant hunk, and
      // do the same for the right; then, correct for skew
      // in the regions of o that each side changed, and
      // report appropriate spans for the three sides.
      var regions = {
        0: [a.length, -1, o.length, -1],
        2: [b.length, -1, o.length, -1]
      };
      for (i = firstHunkIndex; i <= hunkIndex; i++) {
        hunk = hunks[i];
        var side = hunk[1];
        var r = regions[side];
        var oLhs = hunk[0];
        var oRhs = oLhs + hunk[2];
        var abLhs = hunk[3];
        var abRhs = abLhs + hunk[4];
        r[0] = Math.min(abLhs, r[0]);
        r[1] = Math.max(abRhs, r[1]);
        r[2] = Math.min(oLhs, r[2]);
        r[3] = Math.max(oRhs, r[3]);
      }
      var aLhs = regions[0][0] + (regionLhs - regions[0][2]);
      var aRhs = regions[0][1] + (regionRhs - regions[0][3]);
      var bLhs = regions[2][0] + (regionLhs - regions[2][2]);
      var bRhs = regions[2][1] + (regionRhs - regions[2][3]);
      result.push([-1,
        aLhs, aRhs - aLhs,
        regionLhs, regionRhs - regionLhs,
        bLhs, bRhs - bLhs
      ]);
    }
    commonOffset = regionRhs;
  }

  copyCommon(o.length);
  return result;
}

function diff3Merge(a, o, b) {
  // Applies the output of Diff.diff3_merge_indices to actually
  // construct the merged file; the returned result alternates
  // between "ok" and "conflict" blocks.

  var result = [];
  var files = [a, o, b];
  var indices = diff3MergeIndices(a, o, b);

  var okLines = [];

  function flushOk() {
    if (okLines.length) {
      result.push({
        ok: okLines
      });
    }
    okLines = [];
  }

  function pushOk(xs) {
    for (var j = 0; j < xs.length; j++) {
      okLines.push(xs[j]);
    }
  }

  function isTrueConflict(rec) {
    if (rec[2] != rec[6]) return true;
    var aoff = rec[1];
    var boff = rec[5];
    for (var j = 0; j < rec[2]; j++) {
      if (a[j + aoff] != b[j + boff]) return true;
    }
    return false;
  }

  for (var i = 0; i < indices.length; i++) {
    var x = indices[i];
    var side = x[0];
    if (side == -1) {
      if (!isTrueConflict(x)) {
        pushOk(files[0].slice(x[1], x[1] + x[2]));
      } else {
        flushOk();
        result.push({
          conflict: {
            a: a.slice(x[1], x[1] + x[2]),
            aIndex: x[1],
            o: o.slice(x[3], x[3] + x[4]),
            oIndex: x[3],
            b: b.slice(x[5], x[5] + x[6]),
            bIndex: x[5]
          }
        });
      }
    } else {
      pushOk(files[side].slice(x[1], x[1] + x[2]));
    }
  }

  flushOk();
  return result;
}

module.exports = diff3Merge;


/***/ }),

/***/ "../../node_modules/.pnpm/diff3@0.0.3/node_modules/diff3/onp.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/.pnpm/diff3@0.0.3/node_modules/diff3/onp.js ***!
  \**********************************************************************/
/***/ ((module) => {

/*
 * URL: https://github.com/cubicdaiya/onp
 *
 * Copyright (c) 2013 Tatsuhiko Kubo <cubicdaiya@gmail.com>
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */

/**
 * The algorithm implemented here is based on "An O(NP) Sequence Comparison Algorithm"
 * by described by Sun Wu, Udi Manber and Gene Myers
*/
module.exports = function (a_, b_) {
    var a          = a_,
        b          = b_,
        m          = a.length,
        n          = b.length,
        reverse    = false,
        ed         = null,
        offset     = m + 1,
        path       = [],
        pathposi   = [],
        ses        = [],
        lcs        = "",
        SES_DELETE = -1,
        SES_COMMON = 0,
        SES_ADD    = 1;

    var tmp1,
        tmp2;

    var init = function () {
        if (m >= n) {
            tmp1    = a;
            tmp2    = m;
            a       = b;
            b       = tmp1;
            m       = n;
            n       = tmp2;
            reverse = true;
            offset = m + 1;
        }
    };

    var P = function (x, y, k) {
        return {
            'x' : x,
            'y' : y,
            'k' : k,
        };
    };

    var seselem = function (elem, t) {
        return {
            'elem' : elem,
            't'    : t,
        };
    };

    var snake = function (k, p, pp) {
        var r, x, y;
        if (p > pp) {
            r = path[k-1+offset];
        } else {
            r = path[k+1+offset];
        }

        y = Math.max(p, pp);
        x = y - k;
        while (x < m && y < n && a[x] === b[y]) {
            ++x;
            ++y;
        }

        path[k+offset] = pathposi.length;
        pathposi[pathposi.length] = new P(x, y, r);
        return y;
    };

    var recordseq = function (epc) {
        var x_idx, y_idx, px_idx, py_idx, i;
        x_idx  = y_idx  = 1;
        px_idx = py_idx = 0;
        for (i=epc.length-1;i>=0;--i) {
            while(px_idx < epc[i].x || py_idx < epc[i].y) {
                if (epc[i].y - epc[i].x > py_idx - px_idx) {
                    if (reverse) {
                        ses[ses.length] = new seselem(b[py_idx], SES_DELETE);
                    } else {
                        ses[ses.length] = new seselem(b[py_idx], SES_ADD);
                    }
                    ++y_idx;
                    ++py_idx;
                } else if (epc[i].y - epc[i].x < py_idx - px_idx) {
                    if (reverse) {
                        ses[ses.length] = new seselem(a[px_idx], SES_ADD);
                    } else {
                        ses[ses.length] = new seselem(a[px_idx], SES_DELETE);
                    }
                    ++x_idx;
                    ++px_idx;
                } else {
                    ses[ses.length] = new seselem(a[px_idx], SES_COMMON);
                    lcs += a[px_idx];
                    ++x_idx;
                    ++y_idx;
                    ++px_idx;
                    ++py_idx;
                }
            }
        }
    };

    init();

    return {
        SES_DELETE : -1,
        SES_COMMON :  0,
        SES_ADD    :  1,
        editdistance : function () {
            return ed;
        },
        getlcs : function () {
            return lcs;
        },
        getses : function () {
            return ses;
        },
        compose : function () {
            var delta, size, fp, p, r, epc, i, k;
            delta  = n - m;
            size   = m + n + 3;
            fp     = {};
            for (i=0;i<size;++i) {
                fp[i] = -1;
                path[i] = -1;
            }
            p = -1;
            do {
                ++p;
                for (k=-p;k<=delta-1;++k) {
                    fp[k+offset] = snake(k, fp[k-1+offset]+1, fp[k+1+offset]);
                }
                for (k=delta+p;k>=delta+1;--k) {
                    fp[k+offset] = snake(k, fp[k-1+offset]+1, fp[k+1+offset]);
                }
                fp[delta+offset] = snake(delta, fp[delta-1+offset]+1, fp[delta+1+offset]);
            } while (fp[delta+offset] !== n);

            ed = delta + 2 * p;

            r = path[delta+offset];

            epc  = [];
            while (r !== -1) {
                epc[epc.length] = new P(pathposi[r].x, pathposi[r].y, null);
                r = pathposi[r].k;
            }
            recordseq(epc);
        }
    };
};


/***/ }),

/***/ "../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "../../node_modules/.pnpm/ignore@5.2.0/node_modules/ignore/index.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/.pnpm/ignore@5.2.0/node_modules/ignore/index.js ***!
  \**************************************************************************/
/***/ ((module) => {

// A simple implementation of make-array
function makeArray (subject) {
  return Array.isArray(subject)
    ? subject
    : [subject]
}

const EMPTY = ''
const SPACE = ' '
const ESCAPE = '\\'
const REGEX_TEST_BLANK_LINE = /^\s+$/
const REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/
const REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/
const REGEX_SPLITALL_CRLF = /\r?\n/g
// /foo,
// ./foo,
// ../foo,
// .
// ..
const REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/

const SLASH = '/'
const KEY_IGNORE = typeof Symbol !== 'undefined'
  ? Symbol.for('node-ignore')
  /* istanbul ignore next */
  : 'node-ignore'

const define = (object, key, value) =>
  Object.defineProperty(object, key, {value})

const REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g

const RETURN_FALSE = () => false

// Sanitize the range of a regular expression
// The cases are complicated, see test cases for details
const sanitizeRange = range => range.replace(
  REGEX_REGEXP_RANGE,
  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)
    ? match
    // Invalid range (out of order) which is ok for gitignore rules but
    //   fatal for JavaScript regular expression, so eliminate it.
    : EMPTY
)

// See fixtures #59
const cleanRangeBackSlash = slashes => {
  const {length} = slashes
  return slashes.slice(0, length - length % 2)
}

// > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`

// '`foo/`' should not continue with the '`..`'
const REPLACERS = [

  // > Trailing spaces are ignored unless they are quoted with backslash ("\")
  [
    // (a\ ) -> (a )
    // (a  ) -> (a)
    // (a \ ) -> (a  )
    /\\?\s+$/,
    match => match.indexOf('\\') === 0
      ? SPACE
      : EMPTY
  ],

  // replace (\ ) with ' '
  [
    /\\\s/g,
    () => SPACE
  ],

  // Escape metacharacters
  // which is written down by users but means special for regular expressions.

  // > There are 12 characters with special meanings:
  // > - the backslash \,
  // > - the caret ^,
  // > - the dollar sign $,
  // > - the period or dot .,
  // > - the vertical bar or pipe symbol |,
  // > - the question mark ?,
  // > - the asterisk or star *,
  // > - the plus sign +,
  // > - the opening parenthesis (,
  // > - the closing parenthesis ),
  // > - and the opening square bracket [,
  // > - the opening curly brace {,
  // > These special characters are often called "metacharacters".
  [
    /[\\$.|*+(){^]/g,
    match => `\\${match}`
  ],

  [
    // > a question mark (?) matches a single character
    /(?!\\)\?/g,
    () => '[^/]'
  ],

  // leading slash
  [

    // > A leading slash matches the beginning of the pathname.
    // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
    // A leading slash matches the beginning of the pathname
    /^\//,
    () => '^'
  ],

  // replace special metacharacter slash after the leading slash
  [
    /\//g,
    () => '\\/'
  ],

  [
    // > A leading "**" followed by a slash means match in all directories.
    // > For example, "**/foo" matches file or directory "foo" anywhere,
    // > the same as pattern "foo".
    // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
    // >   under directory "foo".
    // Notice that the '*'s have been replaced as '\\*'
    /^\^*\\\*\\\*\\\//,

    // '**/foo' <-> 'foo'
    () => '^(?:.*\\/)?'
  ],

  // starting
  [
    // there will be no leading '/'
    //   (which has been replaced by section "leading slash")
    // If starts with '**', adding a '^' to the regular expression also works
    /^(?=[^^])/,
    function startingReplacer () {
      // If has a slash `/` at the beginning or middle
      return !/\/(?!$)/.test(this)
        // > Prior to 2.22.1
        // > If the pattern does not contain a slash /,
        // >   Git treats it as a shell glob pattern
        // Actually, if there is only a trailing slash,
        //   git also treats it as a shell glob pattern

        // After 2.22.1 (compatible but clearer)
        // > If there is a separator at the beginning or middle (or both)
        // > of the pattern, then the pattern is relative to the directory
        // > level of the particular .gitignore file itself.
        // > Otherwise the pattern may also match at any level below
        // > the .gitignore level.
        ? '(?:^|\\/)'

        // > Otherwise, Git treats the pattern as a shell glob suitable for
        // >   consumption by fnmatch(3)
        : '^'
    }
  ],

  // two globstars
  [
    // Use lookahead assertions so that we could match more than one `'/**'`
    /\\\/\\\*\\\*(?=\\\/|$)/g,

    // Zero, one or several directories
    // should not use '*', or it will be replaced by the next replacer

    // Check if it is not the last `'/**'`
    (_, index, str) => index + 6 < str.length

      // case: /**/
      // > A slash followed by two consecutive asterisks then a slash matches
      // >   zero or more directories.
      // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
      // '/**/'
      ? '(?:\\/[^\\/]+)*'

      // case: /**
      // > A trailing `"/**"` matches everything inside.

      // #21: everything inside but it should not include the current folder
      : '\\/.+'
  ],

  // intermediate wildcards
  [
    // Never replace escaped '*'
    // ignore rule '\*' will match the path '*'

    // 'abc.*/' -> go
    // 'abc.*'  -> skip this rule
    /(^|[^\\]+)\\\*(?=.+)/g,

    // '*.js' matches '.js'
    // '*.js' doesn't match 'abc'
    (_, p1) => `${p1}[^\\/]*`
  ],

  [
    // unescape, revert step 3 except for back slash
    // For example, if a user escape a '\\*',
    // after step 3, the result will be '\\\\\\*'
    /\\\\\\(?=[$.|*+(){^])/g,
    () => ESCAPE
  ],

  [
    // '\\\\' -> '\\'
    /\\\\/g,
    () => ESCAPE
  ],

  [
    // > The range notation, e.g. [a-zA-Z],
    // > can be used to match one of the characters in a range.

    // `\` is escaped by step 3
    /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE
      // '\\[bar]' -> '\\\\[bar\\]'
      ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}`
      : close === ']'
        ? endEscape.length % 2 === 0
          // A normal case, and it is a range notation
          // '[bar]'
          // '[bar\\\\]'
          ? `[${sanitizeRange(range)}${endEscape}]`
          // Invalid range notaton
          // '[bar\\]' -> '[bar\\\\]'
          : '[]'
        : '[]'
  ],

  // ending
  [
    // 'js' will not match 'js.'
    // 'ab' will not match 'abc'
    /(?:[^*])$/,

    // WTF!
    // https://git-scm.com/docs/gitignore
    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
    // which re-fixes #24, #38

    // > If there is a separator at the end of the pattern then the pattern
    // > will only match directories, otherwise the pattern can match both
    // > files and directories.

    // 'js*' will not match 'a.js'
    // 'js/' will not match 'a.js'
    // 'js' will match 'a.js' and 'a.js/'
    match => /\/$/.test(match)
      // foo/ will not match 'foo'
      ? `${match}$`
      // foo matches 'foo' and 'foo/'
      : `${match}(?=$|\\/$)`
  ],

  // trailing wildcard
  [
    /(\^|\\\/)?\\\*$/,
    (_, p1) => {
      const prefix = p1
        // '\^':
        // '/*' does not match EMPTY
        // '/*' does not match everything

        // '\\\/':
        // 'abc/*' does not match 'abc/'
        ? `${p1}[^/]+`

        // 'a*' matches 'a'
        // 'a*' matches 'aa'
        : '[^/]*'

      return `${prefix}(?=$|\\/$)`
    }
  ],
]

// A simple cache, because an ignore rule only has only one certain meaning
const regexCache = Object.create(null)

// @param {pattern}
const makeRegex = (pattern, ignoreCase) => {
  let source = regexCache[pattern]

  if (!source) {
    source = REPLACERS.reduce(
      (prev, current) => prev.replace(current[0], current[1].bind(pattern)),
      pattern
    )
    regexCache[pattern] = source
  }

  return ignoreCase
    ? new RegExp(source, 'i')
    : new RegExp(source)
}

const isString = subject => typeof subject === 'string'

// > A blank line matches no files, so it can serve as a separator for readability.
const checkPattern = pattern => pattern
  && isString(pattern)
  && !REGEX_TEST_BLANK_LINE.test(pattern)

  // > A line starting with # serves as a comment.
  && pattern.indexOf('#') !== 0

const splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)

class IgnoreRule {
  constructor (
    origin,
    pattern,
    negative,
    regex
  ) {
    this.origin = origin
    this.pattern = pattern
    this.negative = negative
    this.regex = regex
  }
}

const createRule = (pattern, ignoreCase) => {
  const origin = pattern
  let negative = false

  // > An optional prefix "!" which negates the pattern;
  if (pattern.indexOf('!') === 0) {
    negative = true
    pattern = pattern.substr(1)
  }

  pattern = pattern
  // > Put a backslash ("\") in front of the first "!" for patterns that
  // >   begin with a literal "!", for example, `"\!important!.txt"`.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')
  // > Put a backslash ("\") in front of the first hash for patterns that
  // >   begin with a hash.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')

  const regex = makeRegex(pattern, ignoreCase)

  return new IgnoreRule(
    origin,
    pattern,
    negative,
    regex
  )
}

const throwError = (message, Ctor) => {
  throw new Ctor(message)
}

const checkPath = (path, originalPath, doThrow) => {
  if (!isString(path)) {
    return doThrow(
      `path must be a string, but got \`${originalPath}\``,
      TypeError
    )
  }

  // We don't know if we should ignore EMPTY, so throw
  if (!path) {
    return doThrow(`path must not be empty`, TypeError)
  }

  // Check if it is a relative path
  if (checkPath.isNotRelative(path)) {
    const r = '`path.relative()`d'
    return doThrow(
      `path should be a ${r} string, but got "${originalPath}"`,
      RangeError
    )
  }

  return true
}

const isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)

checkPath.isNotRelative = isNotRelative
checkPath.convert = p => p

class Ignore {
  constructor ({
    ignorecase = true,
    ignoreCase = ignorecase,
    allowRelativePaths = false
  } = {}) {
    define(this, KEY_IGNORE, true)

    this._rules = []
    this._ignoreCase = ignoreCase
    this._allowRelativePaths = allowRelativePaths
    this._initCache()
  }

  _initCache () {
    this._ignoreCache = Object.create(null)
    this._testCache = Object.create(null)
  }

  _addPattern (pattern) {
    // #32
    if (pattern && pattern[KEY_IGNORE]) {
      this._rules = this._rules.concat(pattern._rules)
      this._added = true
      return
    }

    if (checkPattern(pattern)) {
      const rule = createRule(pattern, this._ignoreCase)
      this._added = true
      this._rules.push(rule)
    }
  }

  // @param {Array<string> | string | Ignore} pattern
  add (pattern) {
    this._added = false

    makeArray(
      isString(pattern)
        ? splitPattern(pattern)
        : pattern
    ).forEach(this._addPattern, this)

    // Some rules have just added to the ignore,
    // making the behavior changed.
    if (this._added) {
      this._initCache()
    }

    return this
  }

  // legacy
  addPattern (pattern) {
    return this.add(pattern)
  }

  //          |           ignored : unignored
  // negative |   0:0   |   0:1   |   1:0   |   1:1
  // -------- | ------- | ------- | ------- | --------
  //     0    |  TEST   |  TEST   |  SKIP   |    X
  //     1    |  TESTIF |  SKIP   |  TEST   |    X

  // - SKIP: always skip
  // - TEST: always test
  // - TESTIF: only test if checkUnignored
  // - X: that never happen

  // @param {boolean} whether should check if the path is unignored,
  //   setting `checkUnignored` to `false` could reduce additional
  //   path matching.

  // @returns {TestResult} true if a file is ignored
  _testOne (path, checkUnignored) {
    let ignored = false
    let unignored = false

    this._rules.forEach(rule => {
      const {negative} = rule
      if (
        unignored === negative && ignored !== unignored
        || negative && !ignored && !unignored && !checkUnignored
      ) {
        return
      }

      const matched = rule.regex.test(path)

      if (matched) {
        ignored = !negative
        unignored = negative
      }
    })

    return {
      ignored,
      unignored
    }
  }

  // @returns {TestResult}
  _test (originalPath, cache, checkUnignored, slices) {
    const path = originalPath
      // Supports nullable path
      && checkPath.convert(originalPath)

    checkPath(
      path,
      originalPath,
      this._allowRelativePaths
        ? RETURN_FALSE
        : throwError
    )

    return this._t(path, cache, checkUnignored, slices)
  }

  _t (path, cache, checkUnignored, slices) {
    if (path in cache) {
      return cache[path]
    }

    if (!slices) {
      // path/to/a.js
      // ['path', 'to', 'a.js']
      slices = path.split(SLASH)
    }

    slices.pop()

    // If the path has no parent directory, just test it
    if (!slices.length) {
      return cache[path] = this._testOne(path, checkUnignored)
    }

    const parent = this._t(
      slices.join(SLASH) + SLASH,
      cache,
      checkUnignored,
      slices
    )

    // If the path contains a parent directory, check the parent first
    return cache[path] = parent.ignored
      // > It is not possible to re-include a file if a parent directory of
      // >   that file is excluded.
      ? parent
      : this._testOne(path, checkUnignored)
  }

  ignores (path) {
    return this._test(path, this._ignoreCache, false).ignored
  }

  createFilter () {
    return path => !this.ignores(path)
  }

  filter (paths) {
    return makeArray(paths).filter(this.createFilter())
  }

  // @returns {TestResult}
  test (path) {
    return this._test(path, this._testCache, true)
  }
}

const factory = options => new Ignore(options)

const isPathValid = path =>
  checkPath(path && checkPath.convert(path), path, RETURN_FALSE)

factory.isPathValid = isPathValid

// Fixes typescript
factory.default = factory

module.exports = factory

// Windows
// --------------------------------------------------------------
/* istanbul ignore if  */
if (
  // Detect `process` so that it can run in browsers.
  typeof process !== 'undefined'
  && (
    process.env && process.env.IGNORE_TEST_WIN32
    || process.platform === 'win32'
  )
) {
  /* eslint no-control-regex: "off" */
  const makePosix = str => /^\\\\\?\\/.test(str)
  || /["<>|\u0000-\u001F]+/u.test(str)
    ? str
    : str.replace(/\\/g, '/')

  checkPath.convert = makePosix

  // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
  // 'd:\\foo'
  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i
  checkPath.isNotRelative = path =>
    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)
    || isNotRelative(path)
}


/***/ }),

/***/ "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js ***!
  \*****************************************************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "../../node_modules/.pnpm/jszip@3.7.1/node_modules/jszip/dist/jszip.min.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/.pnpm/jszip@3.7.1/node_modules/jszip/dist/jszip.min.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];
/*!

JSZip v3.7.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/

!function(t){if(true)module.exports=t();else {}}(function(){return function s(a,o,h){function u(r,t){if(!o[r]){if(!a[r]){var e=undefined;if(!t&&e)return require(r,!0);if(l)return l(r,!0);var i=new Error("Cannot find module '"+r+"'");throw i.code="MODULE_NOT_FOUND",i}var n=o[r]={exports:{}};a[r][0].call(n.exports,function(t){var e=a[r][1][t];return u(e||t)},n,n.exports,s,a,o,h)}return o[r].exports}for(var l=undefined,t=0;t<h.length;t++)u(h[t]);return u}({1:[function(t,e,r){"use strict";var c=t("./utils"),d=t("./support"),p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";r.encode=function(t){for(var e,r,i,n,s,a,o,h=[],u=0,l=t.length,f=l,d="string"!==c.getTypeOf(t);u<t.length;)f=l-u,i=d?(e=t[u++],r=u<l?t[u++]:0,u<l?t[u++]:0):(e=t.charCodeAt(u++),r=u<l?t.charCodeAt(u++):0,u<l?t.charCodeAt(u++):0),n=e>>2,s=(3&e)<<4|r>>4,a=1<f?(15&r)<<2|i>>6:64,o=2<f?63&i:64,h.push(p.charAt(n)+p.charAt(s)+p.charAt(a)+p.charAt(o));return h.join("")},r.decode=function(t){var e,r,i,n,s,a,o=0,h=0,u="data:";if(t.substr(0,u.length)===u)throw new Error("Invalid base64 input, it looks like a data url.");var l,f=3*(t=t.replace(/[^A-Za-z0-9\+\/\=]/g,"")).length/4;if(t.charAt(t.length-1)===p.charAt(64)&&f--,t.charAt(t.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error("Invalid base64 input, bad content length.");for(l=d.uint8array?new Uint8Array(0|f):new Array(0|f);o<t.length;)e=p.indexOf(t.charAt(o++))<<2|(n=p.indexOf(t.charAt(o++)))>>4,r=(15&n)<<4|(s=p.indexOf(t.charAt(o++)))>>2,i=(3&s)<<6|(a=p.indexOf(t.charAt(o++))),l[h++]=e,64!==s&&(l[h++]=r),64!==a&&(l[h++]=i);return l}},{"./support":30,"./utils":32}],2:[function(t,e,r){"use strict";var i=t("./external"),n=t("./stream/DataWorker"),s=t("./stream/Crc32Probe"),a=t("./stream/DataLengthProbe");function o(t,e,r,i,n){this.compressedSize=t,this.uncompressedSize=e,this.crc32=r,this.compression=i,this.compressedContent=n}o.prototype={getContentWorker:function(){var t=new n(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")),e=this;return t.on("end",function(){if(this.streamInfo.data_length!==e.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),t},getCompressedWorker:function(){return new n(i.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},o.createWorkerFrom=function(t,e,r){return t.pipe(new s).pipe(new a("uncompressedSize")).pipe(e.compressWorker(r)).pipe(new a("compressedSize")).withStreamInfo("compression",e)},e.exports=o},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(t,e,r){"use strict";var i=t("./stream/GenericWorker");r.STORE={magic:"\0\0",compressWorker:function(t){return new i("STORE compression")},uncompressWorker:function(){return new i("STORE decompression")}},r.DEFLATE=t("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(t,e,r){"use strict";var i=t("./utils");var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e){return void 0!==t&&t.length?"string"!==i.getTypeOf(t)?function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}(0|e,t,t.length,0):function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e.charCodeAt(a))];return-1^t}(0|e,t,t.length,0):0}},{"./utils":32}],5:[function(t,e,r){"use strict";r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null},{}],6:[function(t,e,r){"use strict";var i=null;i="undefined"!=typeof Promise?Promise:t("lie"),e.exports={Promise:i}},{lie:37}],7:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,n=t("pako"),s=t("./utils"),a=t("./stream/GenericWorker"),o=i?"uint8array":"array";function h(t,e){a.call(this,"FlateWorker/"+t),this._pako=null,this._pakoAction=t,this._pakoOptions=e,this.meta={}}r.magic="\b\0",s.inherits(h,a),h.prototype.processChunk=function(t){this.meta=t.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,t.data),!1)},h.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},h.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null},h.prototype._createPako=function(){this._pako=new n[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var e=this;this._pako.onData=function(t){e.push({data:t,meta:e.meta})}},r.compressWorker=function(t){return new h("Deflate",t)},r.uncompressWorker=function(){return new h("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:38}],8:[function(t,e,r){"use strict";function A(t,e){var r,i="";for(r=0;r<e;r++)i+=String.fromCharCode(255&t),t>>>=8;return i}function i(t,e,r,i,n,s){var a,o,h=t.file,u=t.compression,l=s!==O.utf8encode,f=I.transformTo("string",s(h.name)),d=I.transformTo("string",O.utf8encode(h.name)),c=h.comment,p=I.transformTo("string",s(c)),m=I.transformTo("string",O.utf8encode(c)),_=d.length!==h.name.length,g=m.length!==c.length,b="",v="",y="",w=h.dir,k=h.date,x={crc32:0,compressedSize:0,uncompressedSize:0};e&&!r||(x.crc32=t.crc32,x.compressedSize=t.compressedSize,x.uncompressedSize=t.uncompressedSize);var S=0;e&&(S|=8),l||!_&&!g||(S|=2048);var z=0,C=0;w&&(z|=16),"UNIX"===n?(C=798,z|=function(t,e){var r=t;return t||(r=e?16893:33204),(65535&r)<<16}(h.unixPermissions,w)):(C=20,z|=function(t){return 63&(t||0)}(h.dosPermissions)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v=A(1,1)+A(B(f),4)+d,b+="up"+A(v.length,2)+v),g&&(y=A(1,1)+A(B(p),4)+m,b+="uc"+A(y.length,2)+y);var E="";return E+="\n\0",E+=A(S,2),E+=u.magic,E+=A(a,2),E+=A(o,2),E+=A(x.crc32,4),E+=A(x.compressedSize,4),E+=A(x.uncompressedSize,4),E+=A(f.length,2),E+=A(b.length,2),{fileRecord:R.LOCAL_FILE_HEADER+E+f+b,dirRecord:R.CENTRAL_FILE_HEADER+A(C,2)+E+A(p.length,2)+"\0\0\0\0"+A(z,4)+A(i,4)+f+b+p}}var I=t("../utils"),n=t("../stream/GenericWorker"),O=t("../utf8"),B=t("../crc32"),R=t("../signature");function s(t,e,r,i){n.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=e,this.zipPlatform=r,this.encodeFileName=i,this.streamFiles=t,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}I.inherits(s,n),s.prototype.push=function(t){var e=t.meta.percent||0,r=this.entriesCount,i=this._sources.length;this.accumulate?this.contentBuffer.push(t):(this.bytesWritten+=t.data.length,n.prototype.push.call(this,{data:t.data,meta:{currentFile:this.currentFile,percent:r?(e+100*(r-i-1))/r:100}}))},s.prototype.openedSource=function(t){this.currentSourceOffset=this.bytesWritten,this.currentFile=t.file.name;var e=this.streamFiles&&!t.file.dir;if(e){var r=i(t,e,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}})}else this.accumulate=!0},s.prototype.closedSource=function(t){this.accumulate=!1;var e=this.streamFiles&&!t.file.dir,r=i(t,e,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(r.dirRecord),e)this.push({data:function(t){return R.DATA_DESCRIPTOR+A(t.crc32,4)+A(t.compressedSize,4)+A(t.uncompressedSize,4)}(t),meta:{percent:100}});else for(this.push({data:r.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},s.prototype.flush=function(){for(var t=this.bytesWritten,e=0;e<this.dirRecords.length;e++)this.push({data:this.dirRecords[e],meta:{percent:100}});var r=this.bytesWritten-t,i=function(t,e,r,i,n){var s=I.transformTo("string",n(i));return R.CENTRAL_DIRECTORY_END+"\0\0\0\0"+A(t,2)+A(t,2)+A(e,4)+A(r,4)+A(s.length,2)+s}(this.dirRecords.length,r,t,this.zipComment,this.encodeFileName);this.push({data:i,meta:{percent:100}})},s.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},s.prototype.registerPrevious=function(t){this._sources.push(t);var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.closedSource(e.previous.streamInfo),e._sources.length?e.prepareNextSource():e.end()}),t.on("error",function(t){e.error(t)}),this},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},s.prototype.error=function(t){var e=this._sources;if(!n.prototype.error.call(this,t))return!1;for(var r=0;r<e.length;r++)try{e[r].error(t)}catch(t){}return!0},s.prototype.lock=function(){n.prototype.lock.call(this);for(var t=this._sources,e=0;e<t.length;e++)t[e].lock()},e.exports=s},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(t,e,r){"use strict";var u=t("../compressions"),i=t("./ZipFileWorker");r.generateWorker=function(t,a,e){var o=new i(a.streamFiles,e,a.platform,a.encodeFileName),h=0;try{t.forEach(function(t,e){h++;var r=function(t,e){var r=t||e,i=u[r];if(!i)throw new Error(r+" is not a valid compression method !");return i}(e.options.compression,a.compression),i=e.options.compressionOptions||a.compressionOptions||{},n=e.dir,s=e.date;e._compressWorker(r,i).withStreamInfo("file",{name:t,dir:n,date:s,comment:e.comment||"",unixPermissions:e.unixPermissions,dosPermissions:e.dosPermissions}).pipe(o)}),o.entriesCount=h}catch(t){o.error(t)}return o}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(t,e,r){"use strict";function i(){if(!(this instanceof i))return new i;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files=Object.create(null),this.comment=null,this.root="",this.clone=function(){var t=new i;for(var e in this)"function"!=typeof this[e]&&(t[e]=this[e]);return t}}(i.prototype=t("./object")).loadAsync=t("./load"),i.support=t("./support"),i.defaults=t("./defaults"),i.version="3.7.1",i.loadAsync=function(t,e){return(new i).loadAsync(t,e)},i.external=t("./external"),e.exports=i},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(t,e,r){"use strict";var i=t("./utils"),n=t("./external"),o=t("./utf8"),h=t("./zipEntries"),s=t("./stream/Crc32Probe"),u=t("./nodejsUtils");function l(i){return new n.Promise(function(t,e){var r=i.decompressed.getContentWorker().pipe(new s);r.on("error",function(t){e(t)}).on("end",function(){r.streamInfo.crc32!==i.decompressed.crc32?e(new Error("Corrupted zip : CRC32 mismatch")):t()}).resume()})}e.exports=function(t,s){var a=this;return s=i.extend(s||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:o.utf8decode}),u.isNode&&u.isStream(t)?n.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):i.prepareContent("the loaded zip file",t,!0,s.optimizedBinaryString,s.base64).then(function(t){var e=new h(s);return e.load(t),e}).then(function(t){var e=[n.Promise.resolve(t)],r=t.files;if(s.checkCRC32)for(var i=0;i<r.length;i++)e.push(l(r[i]));return n.Promise.all(e)}).then(function(t){for(var e=t.shift(),r=e.files,i=0;i<r.length;i++){var n=r[i];a.file(n.fileNameStr,n.decompressed,{binary:!0,optimizedBinaryString:!0,date:n.date,dir:n.dir,comment:n.fileCommentStr.length?n.fileCommentStr:null,unixPermissions:n.unixPermissions,dosPermissions:n.dosPermissions,createFolders:s.createFolders})}return e.zipComment.length&&(a.comment=e.zipComment),a})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../stream/GenericWorker");function s(t,e){n.call(this,"Nodejs stream input adapter for "+t),this._upstreamEnded=!1,this._bindStream(e)}i.inherits(s,n),s.prototype._bindStream=function(t){var e=this;(this._stream=t).pause(),t.on("data",function(t){e.push({data:t,meta:{percent:0}})}).on("error",function(t){e.isPaused?this.generatedError=t:e.error(t)}).on("end",function(){e.isPaused?e._upstreamEnded=!0:e.end()})},s.prototype.pause=function(){return!!n.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},e.exports=s},{"../stream/GenericWorker":28,"../utils":32}],13:[function(t,e,r){"use strict";var n=t("readable-stream").Readable;function i(t,e,r){n.call(this,e),this._helper=t;var i=this;t.on("data",function(t,e){i.push(t)||i._helper.pause(),r&&r(e)}).on("error",function(t){i.emit("error",t)}).on("end",function(){i.push(null)})}t("../utils").inherits(i,n),i.prototype._read=function(){this._helper.resume()},e.exports=i},{"../utils":32,"readable-stream":16}],14:[function(t,e,r){"use strict";e.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(t,e){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(t,e);if("number"==typeof t)throw new Error('The "data" argument must not be a number');return new Buffer(t,e)},allocBuffer:function(t){if(Buffer.alloc)return Buffer.alloc(t);var e=new Buffer(t);return e.fill(0),e},isBuffer:function(t){return Buffer.isBuffer(t)},isStream:function(t){return t&&"function"==typeof t.on&&"function"==typeof t.pause&&"function"==typeof t.resume}}},{}],15:[function(t,e,r){"use strict";function s(t,e,r){var i,n=u.getTypeOf(e),s=u.extend(r||{},f);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),"string"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(t=g(t)),s.createFolders&&(i=_(t))&&b.call(this,i,!0);var a="string"===n&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!a),(e instanceof d&&0===e.uncompressedSize||s.dir||!e||0===e.length)&&(s.base64=!1,s.binary=!0,e="",s.compression="STORE",n="string");var o=null;o=e instanceof d||e instanceof l?e:p.isNode&&p.isStream(e)?new m(t,e):u.prepareContent(t,e,s.binary,s.optimizedBinaryString,s.base64);var h=new c(t,o,s);this.files[t]=h}var n=t("./utf8"),u=t("./utils"),l=t("./stream/GenericWorker"),a=t("./stream/StreamHelper"),f=t("./defaults"),d=t("./compressedObject"),c=t("./zipObject"),o=t("./generate"),p=t("./nodejsUtils"),m=t("./nodejs/NodejsStreamInputAdapter"),_=function(t){"/"===t.slice(-1)&&(t=t.substring(0,t.length-1));var e=t.lastIndexOf("/");return 0<e?t.substring(0,e):""},g=function(t){return"/"!==t.slice(-1)&&(t+="/"),t},b=function(t,e){return e=void 0!==e?e:f.createFolders,t=g(t),this.files[t]||s.call(this,t,null,{dir:!0,createFolders:e}),this.files[t]};function h(t){return"[object RegExp]"===Object.prototype.toString.call(t)}var i={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(t){var e,r,i;for(e in this.files)i=this.files[e],(r=e.slice(this.root.length,e.length))&&e.slice(0,this.root.length)===this.root&&t(r,i)},filter:function(r){var i=[];return this.forEach(function(t,e){r(t,e)&&i.push(e)}),i},file:function(t,e,r){if(1!==arguments.length)return t=this.root+t,s.call(this,t,e,r),this;if(h(t)){var i=t;return this.filter(function(t,e){return!e.dir&&i.test(t)})}var n=this.files[this.root+t];return n&&!n.dir?n:null},folder:function(r){if(!r)return this;if(h(r))return this.filter(function(t,e){return e.dir&&r.test(t)});var t=this.root+r,e=b.call(this,t),i=this.clone();return i.root=e.name,i},remove:function(r){r=this.root+r;var t=this.files[r];if(t||("/"!==r.slice(-1)&&(r+="/"),t=this.files[r]),t&&!t.dir)delete this.files[r];else for(var e=this.filter(function(t,e){return e.name.slice(0,r.length)===r}),i=0;i<e.length;i++)delete this.files[e[i].name];return this},generate:function(t){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(t){var e,r={};try{if((r=u.extend(t||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:n.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),"binarystring"===r.type&&(r.type="string"),!r.type)throw new Error("No output type specified.");u.checkSupport(r.type),"darwin"!==r.platform&&"freebsd"!==r.platform&&"linux"!==r.platform&&"sunos"!==r.platform||(r.platform="UNIX"),"win32"===r.platform&&(r.platform="DOS");var i=r.comment||this.comment||"";e=o.generateWorker(this,r,i)}catch(t){(e=new l("error")).error(t)}return new a(e,r.type||"string",r.mimeType)},generateAsync:function(t,e){return this.generateInternalStream(t).accumulate(e)},generateNodeStream:function(t,e){return(t=t||{}).type||(t.type="nodebuffer"),this.generateInternalStream(t).toNodejsStream(e)}};e.exports=i},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(t,e,r){e.exports=t("stream")},{stream:void 0}],17:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t);for(var e=0;e<this.data.length;e++)t[e]=255&t[e]}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data[this.zero+t]},n.prototype.lastIndexOfSignature=function(t){for(var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===e&&this.data[s+1]===r&&this.data[s+2]===i&&this.data[s+3]===n)return s-this.zero;return-1},n.prototype.readAndCheckSignature=function(t){var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.readData(4);return e===s[0]&&r===s[1]&&i===s[2]&&n===s[3]},n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return[];var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],18:[function(t,e,r){"use strict";var i=t("../utils");function n(t){this.data=t,this.length=t.length,this.index=0,this.zero=0}n.prototype={checkOffset:function(t){this.checkIndex(this.index+t)},checkIndex:function(t){if(this.length<this.zero+t||t<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+t+"). Corrupted zip ?")},setIndex:function(t){this.checkIndex(t),this.index=t},skip:function(t){this.setIndex(this.index+t)},byteAt:function(t){},readInt:function(t){var e,r=0;for(this.checkOffset(t),e=this.index+t-1;e>=this.index;e--)r=(r<<8)+this.byteAt(e);return this.index+=t,r},readString:function(t){return i.transformTo("string",this.readData(t))},readData:function(t){},lastIndexOfSignature:function(t){},readAndCheckSignature:function(t){},readDate:function(){var t=this.readInt(4);return new Date(Date.UTC(1980+(t>>25&127),(t>>21&15)-1,t>>16&31,t>>11&31,t>>5&63,(31&t)<<1))}},e.exports=n},{"../utils":32}],19:[function(t,e,r){"use strict";var i=t("./Uint8ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(t,e,r){"use strict";var i=t("./DataReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.byteAt=function(t){return this.data.charCodeAt(this.zero+t)},n.prototype.lastIndexOfSignature=function(t){return this.data.lastIndexOf(t)-this.zero},n.prototype.readAndCheckSignature=function(t){return t===this.readData(4)},n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./DataReader":18}],21:[function(t,e,r){"use strict";var i=t("./ArrayReader");function n(t){i.call(this,t)}t("../utils").inherits(n,i),n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return new Uint8Array(0);var e=this.data.subarray(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{"../utils":32,"./ArrayReader":17}],22:[function(t,e,r){"use strict";var i=t("../utils"),n=t("../support"),s=t("./ArrayReader"),a=t("./StringReader"),o=t("./NodeBufferReader"),h=t("./Uint8ArrayReader");e.exports=function(t){var e=i.getTypeOf(t);return i.checkSupport(e),"string"!==e||n.uint8array?"nodebuffer"===e?new o(t):n.uint8array?new h(i.transformTo("uint8array",t)):new s(i.transformTo("array",t)):new a(t)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(t,e,r){"use strict";r.LOCAL_FILE_HEADER="PK",r.CENTRAL_FILE_HEADER="PK",r.CENTRAL_DIRECTORY_END="PK",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",r.ZIP64_CENTRAL_DIRECTORY_END="PK",r.DATA_DESCRIPTOR="PK\b"},{}],24:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../utils");function s(t){i.call(this,"ConvertWorker to "+t),this.destType=t}n.inherits(s,i),s.prototype.processChunk=function(t){this.push({data:n.transformTo(this.destType,t.data),meta:t.meta})},e.exports=s},{"../utils":32,"./GenericWorker":28}],25:[function(t,e,r){"use strict";var i=t("./GenericWorker"),n=t("../crc32");function s(){i.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}t("../utils").inherits(s,i),s.prototype.processChunk=function(t){this.streamInfo.crc32=n(t.data,this.streamInfo.crc32||0),this.push(t)},e.exports=s},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataLengthProbe for "+t),this.propName=t,this.withStreamInfo(t,0)}i.inherits(s,n),s.prototype.processChunk=function(t){if(t){var e=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=e+t.data.length}n.prototype.processChunk.call(this,t)},e.exports=s},{"../utils":32,"./GenericWorker":28}],27:[function(t,e,r){"use strict";var i=t("../utils"),n=t("./GenericWorker");function s(t){n.call(this,"DataWorker");var e=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,t.then(function(t){e.dataIsReady=!0,e.data=t,e.max=t&&t.length||0,e.type=i.getTypeOf(t),e.isPaused||e._tickAndRepeat()},function(t){e.error(t)})}i.inherits(s,n),s.prototype.cleanUp=function(){n.prototype.cleanUp.call(this),this.data=null},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,i.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(i.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var t=null,e=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case"string":t=this.data.substring(this.index,e);break;case"uint8array":t=this.data.subarray(this.index,e);break;case"array":case"nodebuffer":t=this.data.slice(this.index,e)}return this.index=e,this.push({data:t,meta:{percent:this.max?this.index/this.max*100:0}})},e.exports=s},{"../utils":32,"./GenericWorker":28}],28:[function(t,e,r){"use strict";function i(t){this.name=t||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}i.prototype={push:function(t){this.emit("data",t)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(t){this.emit("error",t)}return!0},error:function(t){return!this.isFinished&&(this.isPaused?this.generatedError=t:(this.isFinished=!0,this.emit("error",t),this.previous&&this.previous.error(t),this.cleanUp()),!0)},on:function(t,e){return this._listeners[t].push(e),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(t,e){if(this._listeners[t])for(var r=0;r<this._listeners[t].length;r++)this._listeners[t][r].call(this,e)},pipe:function(t){return t.registerPrevious(this)},registerPrevious:function(t){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=t.streamInfo,this.mergeStreamInfo(),this.previous=t;var e=this;return t.on("data",function(t){e.processChunk(t)}),t.on("end",function(){e.end()}),t.on("error",function(t){e.error(t)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var t=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),t=!0),this.previous&&this.previous.resume(),!t},flush:function(){},processChunk:function(t){this.push(t)},withStreamInfo:function(t,e){return this.extraStreamInfo[t]=e,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var t in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(t)&&(this.streamInfo[t]=this.extraStreamInfo[t])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var t="Worker "+this.name;return this.previous?this.previous+" -> "+t:t}},e.exports=i},{}],29:[function(t,e,r){"use strict";var h=t("../utils"),n=t("./ConvertWorker"),s=t("./GenericWorker"),u=t("../base64"),i=t("../support"),a=t("../external"),o=null;if(i.nodestream)try{o=t("../nodejs/NodejsStreamOutputAdapter")}catch(t){}function l(t,o){return new a.Promise(function(e,r){var i=[],n=t._internalType,s=t._outputType,a=t._mimeType;t.on("data",function(t,e){i.push(t),o&&o(e)}).on("error",function(t){i=[],r(t)}).on("end",function(){try{var t=function(t,e,r){switch(t){case"blob":return h.newBlob(h.transformTo("arraybuffer",e),r);case"base64":return u.encode(e);default:return h.transformTo(t,e)}}(s,function(t,e){var r,i=0,n=null,s=0;for(r=0;r<e.length;r++)s+=e[r].length;switch(t){case"string":return e.join("");case"array":return Array.prototype.concat.apply([],e);case"uint8array":for(n=new Uint8Array(s),r=0;r<e.length;r++)n.set(e[r],i),i+=e[r].length;return n;case"nodebuffer":return Buffer.concat(e);default:throw new Error("concat : unsupported type '"+t+"'")}}(n,i),a);e(t)}catch(t){r(t)}i=[]}).resume()})}function f(t,e,r){var i=e;switch(e){case"blob":case"arraybuffer":i="uint8array";break;case"base64":i="string"}try{this._internalType=i,this._outputType=e,this._mimeType=r,h.checkSupport(i),this._worker=t.pipe(new n(i)),t.lock()}catch(t){this._worker=new s("error"),this._worker.error(t)}}f.prototype={accumulate:function(t){return l(this,t)},on:function(t,e){var r=this;return"data"===t?this._worker.on(t,function(t){e.call(r,t.data,t.meta)}):this._worker.on(t,function(){h.delay(e,arguments,r)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(t){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new o(this,{objectMode:"nodebuffer"!==this._outputType},t)}},e.exports=f},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(t,e,r){"use strict";if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,r.nodebuffer="undefined"!=typeof Buffer,r.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)r.blob=!1;else{var i=new ArrayBuffer(0);try{r.blob=0===new Blob([i],{type:"application/zip"}).size}catch(t){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);n.append(i),r.blob=0===n.getBlob("application/zip").size}catch(t){r.blob=!1}}}try{r.nodestream=!!t("readable-stream").Readable}catch(t){r.nodestream=!1}},{"readable-stream":16}],31:[function(t,e,s){"use strict";for(var o=t("./utils"),h=t("./support"),r=t("./nodejsUtils"),i=t("./stream/GenericWorker"),u=new Array(256),n=0;n<256;n++)u[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;u[254]=u[254]=1;function a(){i.call(this,"utf-8 decode"),this.leftOver=null}function l(){i.call(this,"utf-8 encode")}s.utf8encode=function(t){return h.nodebuffer?r.newBufferFrom(t,"utf-8"):function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=h.uint8array?new Uint8Array(o):new Array(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e}(t)},s.utf8decode=function(t){return h.nodebuffer?o.transformTo("nodebuffer",t).toString("utf-8"):function(t){var e,r,i,n,s=t.length,a=new Array(2*s);for(e=r=0;e<s;)if((i=t[e++])<128)a[r++]=i;else if(4<(n=u[i]))a[r++]=65533,e+=n-1;else{for(i&=2===n?31:3===n?15:7;1<n&&e<s;)i=i<<6|63&t[e++],n--;1<n?a[r++]=65533:i<65536?a[r++]=i:(i-=65536,a[r++]=55296|i>>10&1023,a[r++]=56320|1023&i)}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(t=o.transformTo(h.uint8array?"uint8array":"array",t))},o.inherits(a,i),a.prototype.processChunk=function(t){var e=o.transformTo(h.uint8array?"uint8array":"array",t.data);if(this.leftOver&&this.leftOver.length){if(h.uint8array){var r=e;(e=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),e.set(r,this.leftOver.length)}else e=this.leftOver.concat(e);this.leftOver=null}var i=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}(e),n=e;i!==e.length&&(h.uint8array?(n=e.subarray(0,i),this.leftOver=e.subarray(i,e.length)):(n=e.slice(0,i),this.leftOver=e.slice(i,e.length))),this.push({data:s.utf8decode(n),meta:t.meta})},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=a,o.inherits(l,i),l.prototype.processChunk=function(t){this.push({data:s.utf8encode(t.data),meta:t.meta})},s.Utf8EncodeWorker=l},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(t,e,a){"use strict";var o=t("./support"),h=t("./base64"),r=t("./nodejsUtils"),i=t("set-immediate-shim"),u=t("./external");function n(t){return t}function l(t,e){for(var r=0;r<t.length;++r)e[r]=255&t.charCodeAt(r);return e}a.newBlob=function(e,r){a.checkSupport("blob");try{return new Blob([e],{type:r})}catch(t){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return i.append(e),i.getBlob(r)}catch(t){throw new Error("Bug : can't construct the Blob.")}}};var s={stringifyByChunk:function(t,e,r){var i=[],n=0,s=t.length;if(s<=r)return String.fromCharCode.apply(null,t);for(;n<s;)"array"===e||"nodebuffer"===e?i.push(String.fromCharCode.apply(null,t.slice(n,Math.min(n+r,s)))):i.push(String.fromCharCode.apply(null,t.subarray(n,Math.min(n+r,s)))),n+=r;return i.join("")},stringifyByChar:function(t){for(var e="",r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},applyCanBeUsed:{uint8array:function(){try{return o.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(t){return!1}}(),nodebuffer:function(){try{return o.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(t){return!1}}()}};function f(t){var e=65536,r=a.getTypeOf(t),i=!0;if("uint8array"===r?i=s.applyCanBeUsed.uint8array:"nodebuffer"===r&&(i=s.applyCanBeUsed.nodebuffer),i)for(;1<e;)try{return s.stringifyByChunk(t,r,e)}catch(t){e=Math.floor(e/2)}return s.stringifyByChar(t)}function d(t,e){for(var r=0;r<t.length;r++)e[r]=t[r];return e}a.applyFromCharCode=f;var c={};c.string={string:n,array:function(t){return l(t,new Array(t.length))},arraybuffer:function(t){return c.string.uint8array(t).buffer},uint8array:function(t){return l(t,new Uint8Array(t.length))},nodebuffer:function(t){return l(t,r.allocBuffer(t.length))}},c.array={string:f,array:n,arraybuffer:function(t){return new Uint8Array(t).buffer},uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(t)}},c.arraybuffer={string:function(t){return f(new Uint8Array(t))},array:function(t){return d(new Uint8Array(t),new Array(t.byteLength))},arraybuffer:n,uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(new Uint8Array(t))}},c.uint8array={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return t.buffer},uint8array:n,nodebuffer:function(t){return r.newBufferFrom(t)}},c.nodebuffer={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return c.nodebuffer.uint8array(t).buffer},uint8array:function(t){return d(t,new Uint8Array(t.length))},nodebuffer:n},a.transformTo=function(t,e){if(e=e||"",!t)return e;a.checkSupport(t);var r=a.getTypeOf(e);return c[r][t](e)},a.getTypeOf=function(t){return"string"==typeof t?"string":"[object Array]"===Object.prototype.toString.call(t)?"array":o.nodebuffer&&r.isBuffer(t)?"nodebuffer":o.uint8array&&t instanceof Uint8Array?"uint8array":o.arraybuffer&&t instanceof ArrayBuffer?"arraybuffer":void 0},a.checkSupport=function(t){if(!o[t.toLowerCase()])throw new Error(t+" is not supported by this platform")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(t){var e,r,i="";for(r=0;r<(t||"").length;r++)i+="\\x"+((e=t.charCodeAt(r))<16?"0":"")+e.toString(16).toUpperCase();return i},a.delay=function(t,e,r){i(function(){t.apply(r||null,e||[])})},a.inherits=function(t,e){function r(){}r.prototype=e.prototype,t.prototype=new r},a.extend=function(){var t,e,r={};for(t=0;t<arguments.length;t++)for(e in arguments[t])arguments[t].hasOwnProperty(e)&&void 0===r[e]&&(r[e]=arguments[t][e]);return r},a.prepareContent=function(r,t,i,n,s){return u.Promise.resolve(t).then(function(i){return o.blob&&(i instanceof Blob||-1!==["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(i)))&&"undefined"!=typeof FileReader?new u.Promise(function(e,r){var t=new FileReader;t.onload=function(t){e(t.target.result)},t.onerror=function(t){r(t.target.error)},t.readAsArrayBuffer(i)}):i}).then(function(t){var e=a.getTypeOf(t);return e?("arraybuffer"===e?t=a.transformTo("uint8array",t):"string"===e&&(s?t=h.decode(t):i&&!0!==n&&(t=function(t){return l(t,o.uint8array?new Uint8Array(t.length):new Array(t.length))}(t))),t):u.Promise.reject(new Error("Can't read the data of '"+r+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"set-immediate-shim":54}],33:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),n=t("./utils"),s=t("./signature"),a=t("./zipEntry"),o=(t("./utf8"),t("./support"));function h(t){this.files=[],this.loadOptions=t}h.prototype={checkSignature:function(t){if(!this.reader.readAndCheckSignature(t)){this.reader.index-=4;var e=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+n.pretty(e)+", expected "+n.pretty(t)+")")}},isSignature:function(t,e){var r=this.reader.index;this.reader.setIndex(t);var i=this.reader.readString(4)===e;return this.reader.setIndex(r),i},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var t=this.reader.readData(this.zipCommentLength),e=o.uint8array?"uint8array":"array",r=n.transformTo(e,t);this.zipComment=this.loadOptions.decodeFileName(r)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var t,e,r,i=this.zip64EndOfCentralSize-44;0<i;)t=this.reader.readInt(2),e=this.reader.readInt(4),r=this.reader.readData(e),this.zip64ExtensibleData[t]={id:t,length:e,value:r}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var t,e;for(t=0;t<this.files.length;t++)e=this.files[t],this.reader.setIndex(e.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),e.readLocalPart(this.reader),e.handleUTF8(),e.processAttributes()},readCentralDir:function(){var t;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(t=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(t);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var t=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(t<0)throw!this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory");this.reader.setIndex(t);var e=t;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===n.MAX_VALUE_16BITS||this.diskWithCentralDirStart===n.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===n.MAX_VALUE_16BITS||this.centralDirRecords===n.MAX_VALUE_16BITS||this.centralDirSize===n.MAX_VALUE_32BITS||this.centralDirOffset===n.MAX_VALUE_32BITS){if(this.zip64=!0,(t=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(t),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var i=e-r;if(0<i)this.isSignature(e,s.CENTRAL_FILE_HEADER)||(this.reader.zero=i);else if(i<0)throw new Error("Corrupted zip: missing "+Math.abs(i)+" bytes.")},prepareReader:function(t){this.reader=i(t)},load:function(t){this.prepareReader(t),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},e.exports=h},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(t,e,r){"use strict";var i=t("./reader/readerFor"),s=t("./utils"),n=t("./compressedObject"),a=t("./crc32"),o=t("./utf8"),h=t("./compressions"),u=t("./support");function l(t,e){this.options=t,this.loadOptions=e}l.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(t){var e,r;if(t.skip(22),this.fileNameLength=t.readInt(2),r=t.readInt(2),this.fileName=t.readData(this.fileNameLength),t.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(null===(e=function(t){for(var e in h)if(h.hasOwnProperty(e)&&h[e].magic===t)return h[e];return null}(this.compressionMethod)))throw new Error("Corrupted zip : compression "+s.pretty(this.compressionMethod)+" unknown (inner file : "+s.transformTo("string",this.fileName)+")");this.decompressed=new n(this.compressedSize,this.uncompressedSize,this.crc32,e,t.readData(this.compressedSize))},readCentralPart:function(t){this.versionMadeBy=t.readInt(2),t.skip(2),this.bitFlag=t.readInt(2),this.compressionMethod=t.readString(2),this.date=t.readDate(),this.crc32=t.readInt(4),this.compressedSize=t.readInt(4),this.uncompressedSize=t.readInt(4);var e=t.readInt(2);if(this.extraFieldsLength=t.readInt(2),this.fileCommentLength=t.readInt(2),this.diskNumberStart=t.readInt(2),this.internalFileAttributes=t.readInt(2),this.externalFileAttributes=t.readInt(4),this.localHeaderOffset=t.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");t.skip(e),this.readExtraFields(t),this.parseZIP64ExtraField(t),this.fileComment=t.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var t=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==t&&(this.dosPermissions=63&this.externalFileAttributes),3==t&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(t){if(this.extraFields[1]){var e=i(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4))}},readExtraFields:function(t){var e,r,i,n=t.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});t.index+4<n;)e=t.readInt(2),r=t.readInt(2),i=t.readData(r),this.extraFields[e]={id:e,length:r,value:i};t.setIndex(n)},handleUTF8:function(){var t=u.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else{var e=this.findExtraFieldUnicodePath();if(null!==e)this.fileNameStr=e;else{var r=s.transformTo(t,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r)}var i=this.findExtraFieldUnicodeComment();if(null!==i)this.fileCommentStr=i;else{var n=s.transformTo(t,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(n)}}},findExtraFieldUnicodePath:function(){var t=this.extraFields[28789];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileName)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null},findExtraFieldUnicodeComment:function(){var t=this.extraFields[25461];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileComment)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null}},e.exports=l},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(t,e,r){"use strict";function i(t,e,r){this.name=t,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=e,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions}}var s=t("./stream/StreamHelper"),n=t("./stream/DataWorker"),a=t("./utf8"),o=t("./compressedObject"),h=t("./stream/GenericWorker");i.prototype={internalStream:function(t){var e=null,r="string";try{if(!t)throw new Error("No output type specified.");var i="string"===(r=t.toLowerCase())||"text"===r;"binarystring"!==r&&"text"!==r||(r="string"),e=this._decompressWorker();var n=!this._dataBinary;n&&!i&&(e=e.pipe(new a.Utf8EncodeWorker)),!n&&i&&(e=e.pipe(new a.Utf8DecodeWorker))}catch(t){(e=new h("error")).error(t)}return new s(e,r,"")},async:function(t,e){return this.internalStream(t).accumulate(e)},nodeStream:function(t,e){return this.internalStream(t||"nodebuffer").toNodejsStream(e)},_compressWorker:function(t,e){if(this._data instanceof o&&this._data.compression.magic===t.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,t,e)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof h?this._data:new n(this._data)}};for(var u=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],l=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},f=0;f<u.length;f++)i.prototype[u[f]]=l;e.exports=i},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(t,l,e){(function(e){"use strict";var r,i,t=e.MutationObserver||e.WebKitMutationObserver;if(t){var n=0,s=new t(u),a=e.document.createTextNode("");s.observe(a,{characterData:!0}),r=function(){a.data=n=++n%2}}else if(e.setImmediate||void 0===e.MessageChannel)r="document"in e&&"onreadystatechange"in e.document.createElement("script")?function(){var t=e.document.createElement("script");t.onreadystatechange=function(){u(),t.onreadystatechange=null,t.parentNode.removeChild(t),t=null},e.document.documentElement.appendChild(t)}:function(){setTimeout(u,0)};else{var o=new e.MessageChannel;o.port1.onmessage=u,r=function(){o.port2.postMessage(0)}}var h=[];function u(){var t,e;i=!0;for(var r=h.length;r;){for(e=h,h=[],t=-1;++t<r;)e[t]();r=h.length}i=!1}l.exports=function(t){1!==h.push(t)||i||r()}}).call(this,"undefined"!=typeof __webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],37:[function(t,e,r){"use strict";var n=t("immediate");function u(){}var l={},s=["REJECTED"],a=["FULFILLED"],i=["PENDING"];function o(t){if("function"!=typeof t)throw new TypeError("resolver must be a function");this.state=i,this.queue=[],this.outcome=void 0,t!==u&&c(this,t)}function h(t,e,r){this.promise=t,"function"==typeof e&&(this.onFulfilled=e,this.callFulfilled=this.otherCallFulfilled),"function"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function f(e,r,i){n(function(){var t;try{t=r(i)}catch(t){return l.reject(e,t)}t===e?l.reject(e,new TypeError("Cannot resolve promise with itself")):l.resolve(e,t)})}function d(t){var e=t&&t.then;if(t&&("object"==typeof t||"function"==typeof t)&&"function"==typeof e)return function(){e.apply(t,arguments)}}function c(e,t){var r=!1;function i(t){r||(r=!0,l.reject(e,t))}function n(t){r||(r=!0,l.resolve(e,t))}var s=p(function(){t(n,i)});"error"===s.status&&i(s.value)}function p(t,e){var r={};try{r.value=t(e),r.status="success"}catch(t){r.status="error",r.value=t}return r}(e.exports=o).prototype.finally=function(e){if("function"!=typeof e)return this;var r=this.constructor;return this.then(function(t){return r.resolve(e()).then(function(){return t})},function(t){return r.resolve(e()).then(function(){throw t})})},o.prototype.catch=function(t){return this.then(null,t)},o.prototype.then=function(t,e){if("function"!=typeof t&&this.state===a||"function"!=typeof e&&this.state===s)return this;var r=new this.constructor(u);this.state!==i?f(r,this.state===a?t:e,this.outcome):this.queue.push(new h(r,t,e));return r},h.prototype.callFulfilled=function(t){l.resolve(this.promise,t)},h.prototype.otherCallFulfilled=function(t){f(this.promise,this.onFulfilled,t)},h.prototype.callRejected=function(t){l.reject(this.promise,t)},h.prototype.otherCallRejected=function(t){f(this.promise,this.onRejected,t)},l.resolve=function(t,e){var r=p(d,e);if("error"===r.status)return l.reject(t,r.value);var i=r.value;if(i)c(t,i);else{t.state=a,t.outcome=e;for(var n=-1,s=t.queue.length;++n<s;)t.queue[n].callFulfilled(e)}return t},l.reject=function(t,e){t.state=s,t.outcome=e;for(var r=-1,i=t.queue.length;++r<i;)t.queue[r].callRejected(e);return t},o.resolve=function(t){if(t instanceof this)return t;return l.resolve(new this(u),t)},o.reject=function(t){var e=new this(u);return l.reject(e,t)},o.all=function(t){var r=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var i=t.length,n=!1;if(!i)return this.resolve([]);var s=new Array(i),a=0,e=-1,o=new this(u);for(;++e<i;)h(t[e],e);return o;function h(t,e){r.resolve(t).then(function(t){s[e]=t,++a!==i||n||(n=!0,l.resolve(o,s))},function(t){n||(n=!0,l.reject(o,t))})}},o.race=function(t){var e=this;if("[object Array]"!==Object.prototype.toString.call(t))return this.reject(new TypeError("must be an array"));var r=t.length,i=!1;if(!r)return this.resolve([]);var n=-1,s=new this(u);for(;++n<r;)a=t[n],e.resolve(a).then(function(t){i||(i=!0,l.resolve(s,t))},function(t){i||(i=!0,l.reject(s,t))});var a;return s}},{immediate:36}],38:[function(t,e,r){"use strict";var i={};(0,t("./lib/utils/common").assign)(i,t("./lib/deflate"),t("./lib/inflate"),t("./lib/zlib/constants")),e.exports=i},{"./lib/deflate":39,"./lib/inflate":40,"./lib/utils/common":41,"./lib/zlib/constants":44}],39:[function(t,e,r){"use strict";var a=t("./zlib/deflate"),o=t("./utils/common"),h=t("./utils/strings"),n=t("./zlib/messages"),s=t("./zlib/zstream"),u=Object.prototype.toString,l=0,f=-1,d=0,c=8;function p(t){if(!(this instanceof p))return new p(t);this.options=o.assign({level:f,method:c,chunkSize:16384,windowBits:15,memLevel:8,strategy:d,to:""},t||{});var e=this.options;e.raw&&0<e.windowBits?e.windowBits=-e.windowBits:e.gzip&&0<e.windowBits&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(r!==l)throw new Error(n[r]);if(e.header&&a.deflateSetHeader(this.strm,e.header),e.dictionary){var i;if(i="string"==typeof e.dictionary?h.string2buf(e.dictionary):"[object ArrayBuffer]"===u.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,(r=a.deflateSetDictionary(this.strm,i))!==l)throw new Error(n[r]);this._dict_set=!0}}function i(t,e){var r=new p(e);if(r.push(t,!0),r.err)throw r.msg||n[r.err];return r.result}p.prototype.push=function(t,e){var r,i,n=this.strm,s=this.options.chunkSize;if(this.ended)return!1;i=e===~~e?e:!0===e?4:0,"string"==typeof t?n.input=h.string2buf(t):"[object ArrayBuffer]"===u.call(t)?n.input=new Uint8Array(t):n.input=t,n.next_in=0,n.avail_in=n.input.length;do{if(0===n.avail_out&&(n.output=new o.Buf8(s),n.next_out=0,n.avail_out=s),1!==(r=a.deflate(n,i))&&r!==l)return this.onEnd(r),!(this.ended=!0);0!==n.avail_out&&(0!==n.avail_in||4!==i&&2!==i)||("string"===this.options.to?this.onData(h.buf2binstring(o.shrinkBuf(n.output,n.next_out))):this.onData(o.shrinkBuf(n.output,n.next_out)))}while((0<n.avail_in||0===n.avail_out)&&1!==r);return 4===i?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==i||(this.onEnd(l),!(n.avail_out=0))},p.prototype.onData=function(t){this.chunks.push(t)},p.prototype.onEnd=function(t){t===l&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Deflate=p,r.deflate=i,r.deflateRaw=function(t,e){return(e=e||{}).raw=!0,i(t,e)},r.gzip=function(t,e){return(e=e||{}).gzip=!0,i(t,e)}},{"./utils/common":41,"./utils/strings":42,"./zlib/deflate":46,"./zlib/messages":51,"./zlib/zstream":53}],40:[function(t,e,r){"use strict";var d=t("./zlib/inflate"),c=t("./utils/common"),p=t("./utils/strings"),m=t("./zlib/constants"),i=t("./zlib/messages"),n=t("./zlib/zstream"),s=t("./zlib/gzheader"),_=Object.prototype.toString;function a(t){if(!(this instanceof a))return new a(t);this.options=c.assign({chunkSize:16384,windowBits:0,to:""},t||{});var e=this.options;e.raw&&0<=e.windowBits&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(0<=e.windowBits&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),15<e.windowBits&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new n,this.strm.avail_out=0;var r=d.inflateInit2(this.strm,e.windowBits);if(r!==m.Z_OK)throw new Error(i[r]);this.header=new s,d.inflateGetHeader(this.strm,this.header)}function o(t,e){var r=new a(e);if(r.push(t,!0),r.err)throw r.msg||i[r.err];return r.result}a.prototype.push=function(t,e){var r,i,n,s,a,o,h=this.strm,u=this.options.chunkSize,l=this.options.dictionary,f=!1;if(this.ended)return!1;i=e===~~e?e:!0===e?m.Z_FINISH:m.Z_NO_FLUSH,"string"==typeof t?h.input=p.binstring2buf(t):"[object ArrayBuffer]"===_.call(t)?h.input=new Uint8Array(t):h.input=t,h.next_in=0,h.avail_in=h.input.length;do{if(0===h.avail_out&&(h.output=new c.Buf8(u),h.next_out=0,h.avail_out=u),(r=d.inflate(h,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&l&&(o="string"==typeof l?p.string2buf(l):"[object ArrayBuffer]"===_.call(l)?new Uint8Array(l):l,r=d.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===f&&(r=m.Z_OK,f=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);h.next_out&&(0!==h.avail_out&&r!==m.Z_STREAM_END&&(0!==h.avail_in||i!==m.Z_FINISH&&i!==m.Z_SYNC_FLUSH)||("string"===this.options.to?(n=p.utf8border(h.output,h.next_out),s=h.next_out-n,a=p.buf2string(h.output,n),h.next_out=s,h.avail_out=u-s,s&&c.arraySet(h.output,h.output,n,s,0),this.onData(a)):this.onData(c.shrinkBuf(h.output,h.next_out)))),0===h.avail_in&&0===h.avail_out&&(f=!0)}while((0<h.avail_in||0===h.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(i=m.Z_FINISH),i===m.Z_FINISH?(r=d.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):i!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(h.avail_out=0))},a.prototype.onData=function(t){this.chunks.push(t)},a.prototype.onEnd=function(t){t===m.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=c.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Inflate=a,r.inflate=o,r.inflateRaw=function(t,e){return(e=e||{}).raw=!0,o(t,e)},r.ungzip=o},{"./utils/common":41,"./utils/strings":42,"./zlib/constants":44,"./zlib/gzheader":47,"./zlib/inflate":49,"./zlib/messages":51,"./zlib/zstream":53}],41:[function(t,e,r){"use strict";var i="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;r.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var r=e.shift();if(r){if("object"!=typeof r)throw new TypeError(r+"must be non-object");for(var i in r)r.hasOwnProperty(i)&&(t[i]=r[i])}}return t},r.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var n={arraySet:function(t,e,r,i,n){if(e.subarray&&t.subarray)t.set(e.subarray(r,r+i),n);else for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){var e,r,i,n,s,a;for(e=i=0,r=t.length;e<r;e++)i+=t[e].length;for(a=new Uint8Array(i),e=n=0,r=t.length;e<r;e++)s=t[e],a.set(s,n),n+=s.length;return a}},s={arraySet:function(t,e,r,i,n){for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){return[].concat.apply([],t)}};r.setTyped=function(t){t?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,n)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s))},r.setTyped(i)},{}],42:[function(t,e,r){"use strict";var h=t("./common"),n=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(t){n=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){s=!1}for(var u=new h.Buf8(256),i=0;i<256;i++)u[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;function l(t,e){if(e<65537&&(t.subarray&&s||!t.subarray&&n))return String.fromCharCode.apply(null,h.shrinkBuf(t,e));for(var r="",i=0;i<e;i++)r+=String.fromCharCode(t[i]);return r}u[254]=u[254]=1,r.string2buf=function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=new h.Buf8(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e},r.buf2binstring=function(t){return l(t,t.length)},r.binstring2buf=function(t){for(var e=new h.Buf8(t.length),r=0,i=e.length;r<i;r++)e[r]=t.charCodeAt(r);return e},r.buf2string=function(t,e){var r,i,n,s,a=e||t.length,o=new Array(2*a);for(r=i=0;r<a;)if((n=t[r++])<128)o[i++]=n;else if(4<(s=u[n]))o[i++]=65533,r+=s-1;else{for(n&=2===s?31:3===s?15:7;1<s&&r<a;)n=n<<6|63&t[r++],s--;1<s?o[i++]=65533:n<65536?o[i++]=n:(n-=65536,o[i++]=55296|n>>10&1023,o[i++]=56320|1023&n)}return l(o,i)},r.utf8border=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}},{"./common":41}],43:[function(t,e,r){"use strict";e.exports=function(t,e,r,i){for(var n=65535&t|0,s=t>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(n=n+e[i++]|0)|0,--a;);n%=65521,s%=65521}return n|s<<16|0}},{}],44:[function(t,e,r){"use strict";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(t,e,r){"use strict";var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}},{}],46:[function(t,e,r){"use strict";var h,d=t("../utils/common"),u=t("./trees"),c=t("./adler32"),p=t("./crc32"),i=t("./messages"),l=0,f=4,m=0,_=-2,g=-1,b=4,n=2,v=8,y=9,s=286,a=30,o=19,w=2*s+1,k=15,x=3,S=258,z=S+x+1,C=42,E=113,A=1,I=2,O=3,B=4;function R(t,e){return t.msg=i[e],e}function T(t){return(t<<1)-(4<t?9:0)}function D(t){for(var e=t.length;0<=--e;)t[e]=0}function F(t){var e=t.state,r=e.pending;r>t.avail_out&&(r=t.avail_out),0!==r&&(d.arraySet(t.output,e.pending_buf,e.pending_out,r,t.next_out),t.next_out+=r,e.pending_out+=r,t.total_out+=r,t.avail_out-=r,e.pending-=r,0===e.pending&&(e.pending_out=0))}function N(t,e){u._tr_flush_block(t,0<=t.block_start?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,F(t.strm)}function U(t,e){t.pending_buf[t.pending++]=e}function P(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function L(t,e){var r,i,n=t.max_chain_length,s=t.strstart,a=t.prev_length,o=t.nice_match,h=t.strstart>t.w_size-z?t.strstart-(t.w_size-z):0,u=t.window,l=t.w_mask,f=t.prev,d=t.strstart+S,c=u[s+a-1],p=u[s+a];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do{if(u[(r=e)+a]===p&&u[r+a-1]===c&&u[r]===u[s]&&u[++r]===u[s+1]){s+=2,r++;do{}while(u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&s<d);if(i=S-(d-s),s=d-S,a<i){if(t.match_start=e,o<=(a=i))break;c=u[s+a-1],p=u[s+a]}}}while((e=f[e&l])>h&&0!=--n);return a<=t.lookahead?a:t.lookahead}function j(t){var e,r,i,n,s,a,o,h,u,l,f=t.w_size;do{if(n=t.window_size-t.lookahead-t.strstart,t.strstart>=f+(f-z)){for(d.arraySet(t.window,t.window,f,f,0),t.match_start-=f,t.strstart-=f,t.block_start-=f,e=r=t.hash_size;i=t.head[--e],t.head[e]=f<=i?i-f:0,--r;);for(e=r=f;i=t.prev[--e],t.prev[e]=f<=i?i-f:0,--r;);n+=f}if(0===t.strm.avail_in)break;if(a=t.strm,o=t.window,h=t.strstart+t.lookahead,u=n,l=void 0,l=a.avail_in,u<l&&(l=u),r=0===l?0:(a.avail_in-=l,d.arraySet(o,a.input,a.next_in,l,h),1===a.state.wrap?a.adler=c(a.adler,o,l,h):2===a.state.wrap&&(a.adler=p(a.adler,o,l,h)),a.next_in+=l,a.total_in+=l,l),t.lookahead+=r,t.lookahead+t.insert>=x)for(s=t.strstart-t.insert,t.ins_h=t.window[s],t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+x-1])&t.hash_mask,t.prev[s&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=s,s++,t.insert--,!(t.lookahead+t.insert<x)););}while(t.lookahead<z&&0!==t.strm.avail_in)}function Z(t,e){for(var r,i;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==r&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r)),t.match_length>=x)if(i=u._tr_tally(t,t.strstart-t.match_start,t.match_length-x),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=x){for(t.match_length--;t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart,0!=--t.match_length;);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function W(t,e){for(var r,i,n;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=x-1,0!==r&&t.prev_length<t.max_lazy_match&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r),t.match_length<=5&&(1===t.strategy||t.match_length===x&&4096<t.strstart-t.match_start)&&(t.match_length=x-1)),t.prev_length>=x&&t.match_length<=t.prev_length){for(n=t.strstart+t.lookahead-x,i=u._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-x),t.lookahead-=t.prev_length-1,t.prev_length-=2;++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!=--t.prev_length;);if(t.match_available=0,t.match_length=x-1,t.strstart++,i&&(N(t,!1),0===t.strm.avail_out))return A}else if(t.match_available){if((i=u._tr_tally(t,0,t.window[t.strstart-1]))&&N(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return A}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=u._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function M(t,e,r,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=r,this.max_chain=i,this.func=n}function H(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=v,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new d.Buf16(2*w),this.dyn_dtree=new d.Buf16(2*(2*a+1)),this.bl_tree=new d.Buf16(2*(2*o+1)),D(this.dyn_ltree),D(this.dyn_dtree),D(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new d.Buf16(k+1),this.heap=new d.Buf16(2*s+1),D(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new d.Buf16(2*s+1),D(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function G(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=n,(e=t.state).pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?C:E,t.adler=2===e.wrap?0:1,e.last_flush=l,u._tr_init(e),m):R(t,_)}function K(t){var e=G(t);return e===m&&function(t){t.window_size=2*t.w_size,D(t.head),t.max_lazy_match=h[t.level].max_lazy,t.good_match=h[t.level].good_length,t.nice_match=h[t.level].nice_length,t.max_chain_length=h[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=x-1,t.match_available=0,t.ins_h=0}(t.state),e}function Y(t,e,r,i,n,s){if(!t)return _;var a=1;if(e===g&&(e=6),i<0?(a=0,i=-i):15<i&&(a=2,i-=16),n<1||y<n||r!==v||i<8||15<i||e<0||9<e||s<0||b<s)return R(t,_);8===i&&(i=9);var o=new H;return(t.state=o).strm=t,o.wrap=a,o.gzhead=null,o.w_bits=i,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=n+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+x-1)/x),o.window=new d.Buf8(2*o.w_size),o.head=new d.Buf16(o.hash_size),o.prev=new d.Buf16(o.w_size),o.lit_bufsize=1<<n+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new d.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=e,o.strategy=s,o.method=r,K(t)}h=[new M(0,0,0,0,function(t,e){var r=65535;for(r>t.pending_buf_size-5&&(r=t.pending_buf_size-5);;){if(t.lookahead<=1){if(j(t),0===t.lookahead&&e===l)return A;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+r;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,N(t,!1),0===t.strm.avail_out))return A;if(t.strstart-t.block_start>=t.w_size-z&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):(t.strstart>t.block_start&&(N(t,!1),t.strm.avail_out),A)}),new M(4,4,8,4,Z),new M(4,5,16,8,Z),new M(4,6,32,32,Z),new M(4,4,16,16,W),new M(8,16,32,32,W),new M(8,16,128,128,W),new M(8,32,128,256,W),new M(32,128,258,1024,W),new M(32,258,258,4096,W)],r.deflateInit=function(t,e){return Y(t,e,v,15,8,0)},r.deflateInit2=Y,r.deflateReset=K,r.deflateResetKeep=G,r.deflateSetHeader=function(t,e){return t&&t.state?2!==t.state.wrap?_:(t.state.gzhead=e,m):_},r.deflate=function(t,e){var r,i,n,s;if(!t||!t.state||5<e||e<0)return t?R(t,_):_;if(i=t.state,!t.output||!t.input&&0!==t.avail_in||666===i.status&&e!==f)return R(t,0===t.avail_out?-5:_);if(i.strm=t,r=i.last_flush,i.last_flush=e,i.status===C)if(2===i.wrap)t.adler=0,U(i,31),U(i,139),U(i,8),i.gzhead?(U(i,(i.gzhead.text?1:0)+(i.gzhead.hcrc?2:0)+(i.gzhead.extra?4:0)+(i.gzhead.name?8:0)+(i.gzhead.comment?16:0)),U(i,255&i.gzhead.time),U(i,i.gzhead.time>>8&255),U(i,i.gzhead.time>>16&255),U(i,i.gzhead.time>>24&255),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,255&i.gzhead.os),i.gzhead.extra&&i.gzhead.extra.length&&(U(i,255&i.gzhead.extra.length),U(i,i.gzhead.extra.length>>8&255)),i.gzhead.hcrc&&(t.adler=p(t.adler,i.pending_buf,i.pending,0)),i.gzindex=0,i.status=69):(U(i,0),U(i,0),U(i,0),U(i,0),U(i,0),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,3),i.status=E);else{var a=v+(i.w_bits-8<<4)<<8;a|=(2<=i.strategy||i.level<2?0:i.level<6?1:6===i.level?2:3)<<6,0!==i.strstart&&(a|=32),a+=31-a%31,i.status=E,P(i,a),0!==i.strstart&&(P(i,t.adler>>>16),P(i,65535&t.adler)),t.adler=1}if(69===i.status)if(i.gzhead.extra){for(n=i.pending;i.gzindex<(65535&i.gzhead.extra.length)&&(i.pending!==i.pending_buf_size||(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending!==i.pending_buf_size));)U(i,255&i.gzhead.extra[i.gzindex]),i.gzindex++;i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),i.gzindex===i.gzhead.extra.length&&(i.gzindex=0,i.status=73)}else i.status=73;if(73===i.status)if(i.gzhead.name){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.name.length?255&i.gzhead.name.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.gzindex=0,i.status=91)}else i.status=91;if(91===i.status)if(i.gzhead.comment){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.comment.length?255&i.gzhead.comment.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.status=103)}else i.status=103;if(103===i.status&&(i.gzhead.hcrc?(i.pending+2>i.pending_buf_size&&F(t),i.pending+2<=i.pending_buf_size&&(U(i,255&t.adler),U(i,t.adler>>8&255),t.adler=0,i.status=E)):i.status=E),0!==i.pending){if(F(t),0===t.avail_out)return i.last_flush=-1,m}else if(0===t.avail_in&&T(e)<=T(r)&&e!==f)return R(t,-5);if(666===i.status&&0!==t.avail_in)return R(t,-5);if(0!==t.avail_in||0!==i.lookahead||e!==l&&666!==i.status){var o=2===i.strategy?function(t,e){for(var r;;){if(0===t.lookahead&&(j(t),0===t.lookahead)){if(e===l)return A;break}if(t.match_length=0,r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):3===i.strategy?function(t,e){for(var r,i,n,s,a=t.window;;){if(t.lookahead<=S){if(j(t),t.lookahead<=S&&e===l)return A;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=x&&0<t.strstart&&(i=a[n=t.strstart-1])===a[++n]&&i===a[++n]&&i===a[++n]){s=t.strstart+S;do{}while(i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&n<s);t.match_length=S-(s-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=x?(r=u._tr_tally(t,1,t.match_length-x),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):h[i.level].func(i,e);if(o!==O&&o!==B||(i.status=666),o===A||o===O)return 0===t.avail_out&&(i.last_flush=-1),m;if(o===I&&(1===e?u._tr_align(i):5!==e&&(u._tr_stored_block(i,0,0,!1),3===e&&(D(i.head),0===i.lookahead&&(i.strstart=0,i.block_start=0,i.insert=0))),F(t),0===t.avail_out))return i.last_flush=-1,m}return e!==f?m:i.wrap<=0?1:(2===i.wrap?(U(i,255&t.adler),U(i,t.adler>>8&255),U(i,t.adler>>16&255),U(i,t.adler>>24&255),U(i,255&t.total_in),U(i,t.total_in>>8&255),U(i,t.total_in>>16&255),U(i,t.total_in>>24&255)):(P(i,t.adler>>>16),P(i,65535&t.adler)),F(t),0<i.wrap&&(i.wrap=-i.wrap),0!==i.pending?m:1)},r.deflateEnd=function(t){var e;return t&&t.state?(e=t.state.status)!==C&&69!==e&&73!==e&&91!==e&&103!==e&&e!==E&&666!==e?R(t,_):(t.state=null,e===E?R(t,-3):m):_},r.deflateSetDictionary=function(t,e){var r,i,n,s,a,o,h,u,l=e.length;if(!t||!t.state)return _;if(2===(s=(r=t.state).wrap)||1===s&&r.status!==C||r.lookahead)return _;for(1===s&&(t.adler=c(t.adler,e,l,0)),r.wrap=0,l>=r.w_size&&(0===s&&(D(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new d.Buf8(r.w_size),d.arraySet(u,e,l-r.w_size,r.w_size,0),e=u,l=r.w_size),a=t.avail_in,o=t.next_in,h=t.input,t.avail_in=l,t.next_in=0,t.input=e,j(r);r.lookahead>=x;){for(i=r.strstart,n=r.lookahead-(x-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[i+x-1])&r.hash_mask,r.prev[i&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=i,i++,--n;);r.strstart=i,r.lookahead=x-1,j(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=x-1,r.match_available=0,t.next_in=o,t.input=h,t.avail_in=a,r.wrap=s,m},r.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./messages":51,"./trees":52}],47:[function(t,e,r){"use strict";e.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}},{}],48:[function(t,e,r){"use strict";e.exports=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C;r=t.state,i=t.next_in,z=t.input,n=i+(t.avail_in-5),s=t.next_out,C=t.output,a=s-(e-t.avail_out),o=s+(t.avail_out-257),h=r.dmax,u=r.wsize,l=r.whave,f=r.wnext,d=r.window,c=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;t:do{p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=m[c&g];e:for(;;){if(c>>>=y=v>>>24,p-=y,0===(y=v>>>16&255))C[s++]=65535&v;else{if(!(16&y)){if(0==(64&y)){v=m[(65535&v)+(c&(1<<y)-1)];continue e}if(32&y){r.mode=12;break t}t.msg="invalid literal/length code",r.mode=30;break t}w=65535&v,(y&=15)&&(p<y&&(c+=z[i++]<<p,p+=8),w+=c&(1<<y)-1,c>>>=y,p-=y),p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=_[c&b];r:for(;;){if(c>>>=y=v>>>24,p-=y,!(16&(y=v>>>16&255))){if(0==(64&y)){v=_[(65535&v)+(c&(1<<y)-1)];continue r}t.msg="invalid distance code",r.mode=30;break t}if(k=65535&v,p<(y&=15)&&(c+=z[i++]<<p,(p+=8)<y&&(c+=z[i++]<<p,p+=8)),h<(k+=c&(1<<y)-1)){t.msg="invalid distance too far back",r.mode=30;break t}if(c>>>=y,p-=y,(y=s-a)<k){if(l<(y=k-y)&&r.sane){t.msg="invalid distance too far back",r.mode=30;break t}if(S=d,(x=0)===f){if(x+=u-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}}else if(f<y){if(x+=u+f-y,(y-=f)<w){for(w-=y;C[s++]=d[x++],--y;);if(x=0,f<w){for(w-=y=f;C[s++]=d[x++],--y;);x=s-k,S=C}}}else if(x+=f-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}for(;2<w;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],w-=3;w&&(C[s++]=S[x++],1<w&&(C[s++]=S[x++]))}else{for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(w-=3););w&&(C[s++]=C[x++],1<w&&(C[s++]=C[x++]))}break}}break}}while(i<n&&s<o);i-=w=p>>3,c&=(1<<(p-=w<<3))-1,t.next_in=i,t.next_out=s,t.avail_in=i<n?n-i+5:5-(i-n),t.avail_out=s<o?o-s+257:257-(s-o),r.hold=c,r.bits=p}},{}],49:[function(t,e,r){"use strict";var I=t("../utils/common"),O=t("./adler32"),B=t("./crc32"),R=t("./inffast"),T=t("./inftrees"),D=1,F=2,N=0,U=-2,P=1,i=852,n=592;function L(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function a(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg="",e.wrap&&(t.adler=1&e.wrap),e.mode=P,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new I.Buf32(i),e.distcode=e.distdyn=new I.Buf32(n),e.sane=1,e.back=-1,N):U}function o(t){var e;return t&&t.state?((e=t.state).wsize=0,e.whave=0,e.wnext=0,a(t)):U}function h(t,e){var r,i;return t&&t.state?(i=t.state,e<0?(r=0,e=-e):(r=1+(e>>4),e<48&&(e&=15)),e&&(e<8||15<e)?U:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=r,i.wbits=e,o(t))):U}function u(t,e){var r,i;return t?(i=new s,(t.state=i).window=null,(r=h(t,e))!==N&&(t.state=null),r):U}var l,f,d=!0;function j(t){if(d){var e;for(l=new I.Buf32(512),f=new I.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(T(D,t.lens,0,288,l,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;T(F,t.lens,0,32,f,0,t.work,{bits:5}),d=!1}t.lencode=l,t.lenbits=9,t.distcode=f,t.distbits=5}function Z(t,e,r,i){var n,s=t.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),i>=s.wsize?(I.arraySet(s.window,e,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(i<(n=s.wsize-s.wnext)&&(n=i),I.arraySet(s.window,e,r-i,n,s.wnext),(i-=n)?(I.arraySet(s.window,e,r-i,i,0),s.wnext=i,s.whave=s.wsize):(s.wnext+=n,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=n))),0}r.inflateReset=o,r.inflateReset2=h,r.inflateResetKeep=a,r.inflateInit=function(t){return u(t,15)},r.inflateInit2=u,r.inflate=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return U;12===(r=t.state).mode&&(r.mode=13),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,f=o,d=h,x=N;t:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(2&r.wrap&&35615===u){E[r.check=0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0),l=u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){t.msg="incorrect header check",r.mode=30;break}if(8!=(15&u)){t.msg="unknown compression method",r.mode=30;break}if(l-=4,k=8+(15&(u>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){t.msg="invalid window size",r.mode=30;break}r.dmax=1<<k,t.adler=r.check=1,r.mode=512&u?10:12,l=u=0;break;case 2:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.flags=u,8!=(255&r.flags)){t.msg="unknown compression method",r.mode=30;break}if(57344&r.flags){t.msg="unknown header flags set",r.mode=30;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=3;case 3:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.time=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,E[2]=u>>>16&255,E[3]=u>>>24&255,r.check=B(r.check,E,4,0)),l=u=0,r.mode=4;case 4:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=5;case 5:if(1024&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(c=r.length)&&(c=o),c&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,i,s,c,k)),512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,r.length-=c),r.length))break t;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(65535&r.check)){t.msg="header crc mismatch",r.mode=30;break}l=u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),t.adler=r.check=0,r.mode=12;break;case 10:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}t.adler=r.check=L(u),l=u=0,r.mode=11;case 11:if(0===r.havedict)return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,2;t.adler=r.check=1,r.mode=12;case 12:if(5===e||6===e)break t;case 13:if(r.last){u>>>=7&l,l-=7&l,r.mode=27;break}for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}switch(r.last=1&u,l-=1,3&(u>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==e)break;u>>>=2,l-=2;break t;case 2:r.mode=17;break;case 3:t.msg="invalid block type",r.mode=30}u>>>=2,l-=2;break;case 14:for(u>>>=7&l,l-=7&l;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if((65535&u)!=(u>>>16^65535)){t.msg="invalid stored block lengths",r.mode=30;break}if(r.length=65535&u,l=u=0,r.mode=15,6===e)break t;case 15:r.mode=16;case 16:if(c=r.length){if(o<c&&(c=o),h<c&&(c=h),0===c)break t;I.arraySet(n,i,s,c,a),o-=c,s+=c,h-=c,a+=c,r.length-=c;break}r.mode=12;break;case 17:for(;l<14;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.nlen=257+(31&u),u>>>=5,l-=5,r.ndist=1+(31&u),u>>>=5,l-=5,r.ncode=4+(15&u),u>>>=4,l-=4,286<r.nlen||30<r.ndist){t.msg="too many length or distance symbols",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.lens[A[r.have++]]=7&u,u>>>=3,l-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid code lengths set",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(b<16)u>>>=_,l-=_,r.lens[r.have++]=b;else{if(16===b){for(z=_+2;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u>>>=_,l-=_,0===r.have){t.msg="invalid bit length repeat",r.mode=30;break}k=r.lens[r.have-1],c=3+(3&u),u>>>=2,l-=2}else if(17===b){for(z=_+3;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=3+(7&(u>>>=_)),u>>>=3,l-=3}else{for(z=_+7;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=11+(127&(u>>>=_)),u>>>=7,l-=7}if(r.have+c>r.nlen+r.ndist){t.msg="invalid bit length repeat",r.mode=30;break}for(;c--;)r.lens[r.have++]=k}}if(30===r.mode)break;if(0===r.lens[256]){t.msg="invalid code -- missing end-of-block",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg="invalid literal/lengths set",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){t.msg="invalid distances set",r.mode=30;break}if(r.mode=20,6===e)break t;case 20:r.mode=21;case 21:if(6<=o&&258<=h){t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,R(t,d),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(g&&0==(240&g)){for(v=_,y=g,w=b;g=(C=r.lencode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,r.length=b,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){t.msg="invalid literal/length code",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[u&(1<<r.distbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(0==(240&g)){for(v=_,y=g,w=b;g=(C=r.distcode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,64&g){t.msg="invalid distance code",r.mode=30;break}r.offset=b,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){t.msg="invalid distance too far back",r.mode=30;break}r.mode=25;case 25:if(0===h)break t;if(c=d-h,r.offset>c){if((c=r.offset-c)>r.whave&&r.sane){t.msg="invalid distance too far back",r.mode=30;break}p=c>r.wnext?(c-=r.wnext,r.wsize-c):r.wnext-c,c>r.length&&(c=r.length),m=r.window}else m=n,p=a-r.offset,c=r.length;for(h<c&&(c=h),h-=c,r.length-=c;n[a++]=m[p++],--c;);0===r.length&&(r.mode=21);break;case 26:if(0===h)break t;n[a++]=r.length,h--,r.mode=21;break;case 27:if(r.wrap){for(;l<32;){if(0===o)break t;o--,u|=i[s++]<<l,l+=8}if(d-=h,t.total_out+=d,r.total+=d,d&&(t.adler=r.check=r.flags?B(r.check,n,d,a-d):O(r.check,n,d,a-d)),d=h,(r.flags?u:L(u))!==r.check){t.msg="incorrect data check",r.mode=30;break}l=u=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(4294967295&r.total)){t.msg="incorrect length check",r.mode=30;break}l=u=0}r.mode=29;case 29:x=1;break t;case 30:x=-3;break t;case 31:return-4;case 32:default:return U}return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,(r.wsize||d!==t.avail_out&&r.mode<30&&(r.mode<27||4!==e))&&Z(t,t.output,t.next_out,d-t.avail_out)?(r.mode=31,-4):(f-=t.avail_in,d-=t.avail_out,t.total_in+=f,t.total_out+=d,r.total+=d,r.wrap&&d&&(t.adler=r.check=r.flags?B(r.check,n,d,t.next_out-d):O(r.check,n,d,t.next_out-d)),t.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==f&&0===d||4===e)&&x===N&&(x=-5),x)},r.inflateEnd=function(t){if(!t||!t.state)return U;var e=t.state;return e.window&&(e.window=null),t.state=null,N},r.inflateGetHeader=function(t,e){var r;return t&&t.state?0==(2&(r=t.state).wrap)?U:((r.head=e).done=!1,N):U},r.inflateSetDictionary=function(t,e){var r,i=e.length;return t&&t.state?0!==(r=t.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,e,i,0)!==r.check?-3:Z(t,e,i,i)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":41,"./adler32":43,"./crc32":45,"./inffast":48,"./inftrees":50}],50:[function(t,e,r){"use strict";var D=t("../utils/common"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(t,e,r,i,n,s,a,o){var h,u,l,f,d,c,p,m,_,g=o.bits,b=0,v=0,y=0,w=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(b=0;b<=15;b++)O[b]=0;for(v=0;v<i;v++)O[e[r+v]]++;for(k=g,w=15;1<=w&&0===O[w];w--);if(w<k&&(k=w),0===w)return n[s++]=20971520,n[s++]=20971520,o.bits=1,0;for(y=1;y<w&&0===O[y];y++);for(k<y&&(k=y),b=z=1;b<=15;b++)if(z<<=1,(z-=O[b])<0)return-1;if(0<z&&(0===t||1!==w))return-1;for(B[1]=0,b=1;b<15;b++)B[b+1]=B[b]+O[b];for(v=0;v<i;v++)0!==e[r+v]&&(a[B[e[r+v]]++]=v);if(c=0===t?(A=R=a,19):1===t?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),b=y,d=s,S=v=E=0,l=-1,f=(C=1<<(x=k))-1,1===t&&852<C||2===t&&592<C)return 1;for(;;){for(p=b-S,_=a[v]<c?(m=0,a[v]):a[v]>c?(m=R[T+a[v]],A[I+a[v]]):(m=96,0),h=1<<b-S,y=u=1<<x;n[d+(E>>S)+(u-=h)]=p<<24|m<<16|_|0,0!==u;);for(h=1<<b-1;E&h;)h>>=1;if(0!==h?(E&=h-1,E+=h):E=0,v++,0==--O[b]){if(b===w)break;b=e[r+a[v]]}if(k<b&&(E&f)!==l){for(0===S&&(S=k),d+=y,z=1<<(x=b-S);x+S<w&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===t&&852<C||2===t&&592<C)return 1;n[l=E&f]=k<<24|x<<16|d-s|0}}return 0!==E&&(n[d+E]=b-S<<24|64<<16|0),o.bits=k,0}},{"../utils/common":41}],51:[function(t,e,r){"use strict";e.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],52:[function(t,e,r){"use strict";var n=t("../utils/common"),o=0,h=1;function i(t){for(var e=t.length;0<=--e;)t[e]=0}var s=0,a=29,u=256,l=u+1+a,f=30,d=19,_=2*l+1,g=15,c=16,p=7,m=256,b=16,v=17,y=18,w=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],k=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],x=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=new Array(2*(l+2));i(z);var C=new Array(2*f);i(C);var E=new Array(512);i(E);var A=new Array(256);i(A);var I=new Array(a);i(I);var O,B,R,T=new Array(f);function D(t,e,r,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=r,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function F(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function N(t){return t<256?E[t]:E[256+(t>>>7)]}function U(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function P(t,e,r){t.bi_valid>c-r?(t.bi_buf|=e<<t.bi_valid&65535,U(t,t.bi_buf),t.bi_buf=e>>c-t.bi_valid,t.bi_valid+=r-c):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=r)}function L(t,e,r){P(t,r[2*e],r[2*e+1])}function j(t,e){for(var r=0;r|=1&t,t>>>=1,r<<=1,0<--e;);return r>>>1}function Z(t,e,r){var i,n,s=new Array(g+1),a=0;for(i=1;i<=g;i++)s[i]=a=a+r[i-1]<<1;for(n=0;n<=e;n++){var o=t[2*n+1];0!==o&&(t[2*n]=j(s[o]++,o))}}function W(t){var e;for(e=0;e<l;e++)t.dyn_ltree[2*e]=0;for(e=0;e<f;e++)t.dyn_dtree[2*e]=0;for(e=0;e<d;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*m]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function M(t){8<t.bi_valid?U(t,t.bi_buf):0<t.bi_valid&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function H(t,e,r,i){var n=2*e,s=2*r;return t[n]<t[s]||t[n]===t[s]&&i[e]<=i[r]}function G(t,e,r){for(var i=t.heap[r],n=r<<1;n<=t.heap_len&&(n<t.heap_len&&H(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!H(e,i,t.heap[n],t.depth));)t.heap[r]=t.heap[n],r=n,n<<=1;t.heap[r]=i}function K(t,e,r){var i,n,s,a,o=0;if(0!==t.last_lit)for(;i=t.pending_buf[t.d_buf+2*o]<<8|t.pending_buf[t.d_buf+2*o+1],n=t.pending_buf[t.l_buf+o],o++,0===i?L(t,n,e):(L(t,(s=A[n])+u+1,e),0!==(a=w[s])&&P(t,n-=I[s],a),L(t,s=N(--i),r),0!==(a=k[s])&&P(t,i-=T[s],a)),o<t.last_lit;);L(t,m,e)}function Y(t,e){var r,i,n,s=e.dyn_tree,a=e.stat_desc.static_tree,o=e.stat_desc.has_stree,h=e.stat_desc.elems,u=-1;for(t.heap_len=0,t.heap_max=_,r=0;r<h;r++)0!==s[2*r]?(t.heap[++t.heap_len]=u=r,t.depth[r]=0):s[2*r+1]=0;for(;t.heap_len<2;)s[2*(n=t.heap[++t.heap_len]=u<2?++u:0)]=1,t.depth[n]=0,t.opt_len--,o&&(t.static_len-=a[2*n+1]);for(e.max_code=u,r=t.heap_len>>1;1<=r;r--)G(t,s,r);for(n=h;r=t.heap[1],t.heap[1]=t.heap[t.heap_len--],G(t,s,1),i=t.heap[1],t.heap[--t.heap_max]=r,t.heap[--t.heap_max]=i,s[2*n]=s[2*r]+s[2*i],t.depth[n]=(t.depth[r]>=t.depth[i]?t.depth[r]:t.depth[i])+1,s[2*r+1]=s[2*i+1]=n,t.heap[1]=n++,G(t,s,1),2<=t.heap_len;);t.heap[--t.heap_max]=t.heap[1],function(t,e){var r,i,n,s,a,o,h=e.dyn_tree,u=e.max_code,l=e.stat_desc.static_tree,f=e.stat_desc.has_stree,d=e.stat_desc.extra_bits,c=e.stat_desc.extra_base,p=e.stat_desc.max_length,m=0;for(s=0;s<=g;s++)t.bl_count[s]=0;for(h[2*t.heap[t.heap_max]+1]=0,r=t.heap_max+1;r<_;r++)p<(s=h[2*h[2*(i=t.heap[r])+1]+1]+1)&&(s=p,m++),h[2*i+1]=s,u<i||(t.bl_count[s]++,a=0,c<=i&&(a=d[i-c]),o=h[2*i],t.opt_len+=o*(s+a),f&&(t.static_len+=o*(l[2*i+1]+a)));if(0!==m){do{for(s=p-1;0===t.bl_count[s];)s--;t.bl_count[s]--,t.bl_count[s+1]+=2,t.bl_count[p]--,m-=2}while(0<m);for(s=p;0!==s;s--)for(i=t.bl_count[s];0!==i;)u<(n=t.heap[--r])||(h[2*n+1]!==s&&(t.opt_len+=(s-h[2*n+1])*h[2*n],h[2*n+1]=s),i--)}}(t,e),Z(s,u,t.bl_count)}function X(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),e[2*(r+1)+1]=65535,i=0;i<=r;i++)n=a,a=e[2*(i+1)+1],++o<h&&n===a||(o<u?t.bl_tree[2*n]+=o:0!==n?(n!==s&&t.bl_tree[2*n]++,t.bl_tree[2*b]++):o<=10?t.bl_tree[2*v]++:t.bl_tree[2*y]++,s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4))}function V(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),i=0;i<=r;i++)if(n=a,a=e[2*(i+1)+1],!(++o<h&&n===a)){if(o<u)for(;L(t,n,t.bl_tree),0!=--o;);else 0!==n?(n!==s&&(L(t,n,t.bl_tree),o--),L(t,b,t.bl_tree),P(t,o-3,2)):o<=10?(L(t,v,t.bl_tree),P(t,o-3,3)):(L(t,y,t.bl_tree),P(t,o-11,7));s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4)}}i(T);var q=!1;function J(t,e,r,i){P(t,(s<<1)+(i?1:0),3),function(t,e,r,i){M(t),i&&(U(t,r),U(t,~r)),n.arraySet(t.pending_buf,t.window,e,r,t.pending),t.pending+=r}(t,e,r,!0)}r._tr_init=function(t){q||(function(){var t,e,r,i,n,s=new Array(g+1);for(i=r=0;i<a-1;i++)for(I[i]=r,t=0;t<1<<w[i];t++)A[r++]=i;for(A[r-1]=i,i=n=0;i<16;i++)for(T[i]=n,t=0;t<1<<k[i];t++)E[n++]=i;for(n>>=7;i<f;i++)for(T[i]=n<<7,t=0;t<1<<k[i]-7;t++)E[256+n++]=i;for(e=0;e<=g;e++)s[e]=0;for(t=0;t<=143;)z[2*t+1]=8,t++,s[8]++;for(;t<=255;)z[2*t+1]=9,t++,s[9]++;for(;t<=279;)z[2*t+1]=7,t++,s[7]++;for(;t<=287;)z[2*t+1]=8,t++,s[8]++;for(Z(z,l+1,s),t=0;t<f;t++)C[2*t+1]=5,C[2*t]=j(t,5);O=new D(z,w,u+1,l,g),B=new D(C,k,0,f,g),R=new D(new Array(0),x,0,d,p)}(),q=!0),t.l_desc=new F(t.dyn_ltree,O),t.d_desc=new F(t.dyn_dtree,B),t.bl_desc=new F(t.bl_tree,R),t.bi_buf=0,t.bi_valid=0,W(t)},r._tr_stored_block=J,r._tr_flush_block=function(t,e,r,i){var n,s,a=0;0<t.level?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,r=4093624447;for(e=0;e<=31;e++,r>>>=1)if(1&r&&0!==t.dyn_ltree[2*e])return o;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return h;for(e=32;e<u;e++)if(0!==t.dyn_ltree[2*e])return h;return o}(t)),Y(t,t.l_desc),Y(t,t.d_desc),a=function(t){var e;for(X(t,t.dyn_ltree,t.l_desc.max_code),X(t,t.dyn_dtree,t.d_desc.max_code),Y(t,t.bl_desc),e=d-1;3<=e&&0===t.bl_tree[2*S[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),n=t.opt_len+3+7>>>3,(s=t.static_len+3+7>>>3)<=n&&(n=s)):n=s=r+5,r+4<=n&&-1!==e?J(t,e,r,i):4===t.strategy||s===n?(P(t,2+(i?1:0),3),K(t,z,C)):(P(t,4+(i?1:0),3),function(t,e,r,i){var n;for(P(t,e-257,5),P(t,r-1,5),P(t,i-4,4),n=0;n<i;n++)P(t,t.bl_tree[2*S[n]+1],3);V(t,t.dyn_ltree,e-1),V(t,t.dyn_dtree,r-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,a+1),K(t,t.dyn_ltree,t.dyn_dtree)),W(t),i&&M(t)},r._tr_tally=function(t,e,r){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&r,t.last_lit++,0===e?t.dyn_ltree[2*r]++:(t.matches++,e--,t.dyn_ltree[2*(A[r]+u+1)]++,t.dyn_dtree[2*N(e)]++),t.last_lit===t.lit_bufsize-1},r._tr_align=function(t){P(t,2,3),L(t,m,z),function(t){16===t.bi_valid?(U(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):8<=t.bi_valid&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},{"../utils/common":41}],53:[function(t,e,r){"use strict";e.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(t,e,r){"use strict";e.exports="function"==typeof setImmediate?setImmediate:function(){var t=[].slice.apply(arguments);t.splice(1,0,0),setTimeout.apply(null,t)}},{}]},{},[10])(10)});

/***/ }),

/***/ "../../node_modules/.pnpm/minimatch@3.0.5/node_modules/minimatch/minimatch.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/minimatch@3.0.5/node_modules/minimatch/minimatch.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

const path = (() => { try { return __webpack_require__(/*! path */ "../../node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js") } catch (e) {}})() || {
  sep: '/'
}
minimatch.sep = path.sep

const GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
const expand = __webpack_require__(/*! brace-expansion */ "../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js")

const plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]'

// * => any number of characters
const star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
const reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
const slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  const t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  const orig = minimatch

  const m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = options => {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  assertValidPattern(pattern)

  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

const MAX_PATTERN_LENGTH = 1024 * 64
const assertValidPattern = pattern => {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
const SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = false
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/': /* istanbul ignore next */ {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  const mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else /* istanbul ignore else */ if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    return (fi === fl - 1) && (file[fi] === '')
  }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Top level file is just a mixin of submodules & constants


var assign    = (__webpack_require__(/*! ./lib/utils/common */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js").assign);

var deflate   = __webpack_require__(/*! ./lib/deflate */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/deflate.js");
var inflate   = __webpack_require__(/*! ./lib/inflate */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/inflate.js");
var constants = __webpack_require__(/*! ./lib/zlib/constants */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js");

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/deflate.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/deflate.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";



var zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js");
var utils        = __webpack_require__(/*! ./utils/common */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js");
var strings      = __webpack_require__(/*! ./utils/strings */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js");
var msg          = __webpack_require__(/*! ./zlib/messages */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js");
var ZStream      = __webpack_require__(/*! ./zlib/zstream */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js");

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/inflate.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/inflate.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";



var zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js");
var utils        = __webpack_require__(/*! ./utils/common */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js");
var strings      = __webpack_require__(/*! ./utils/strings */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js");
var c            = __webpack_require__(/*! ./zlib/constants */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js");
var msg          = __webpack_require__(/*! ./zlib/messages */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js");
var ZStream      = __webpack_require__(/*! ./zlib/zstream */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js");
var GZheader     = __webpack_require__(/*! ./zlib/gzheader */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js");

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";



var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/strings.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
// String encode/decode helpers



var utils = __webpack_require__(/*! ./common */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js");


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";


// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/constants.js ***!
  \************************************************************************************/
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js ***!
  \********************************************************************************/
/***/ ((module) => {

"use strict";


// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/deflate.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = __webpack_require__(/*! ../utils/common */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js");
var trees   = __webpack_require__(/*! ./trees */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js");
var adler32 = __webpack_require__(/*! ./adler32 */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js");
var crc32   = __webpack_require__(/*! ./crc32 */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js");
var msg     = __webpack_require__(/*! ./messages */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js");

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/gzheader.js ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inflate.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = __webpack_require__(/*! ../utils/common */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js");
var adler32       = __webpack_require__(/*! ./adler32 */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/adler32.js");
var crc32         = __webpack_require__(/*! ./crc32 */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/crc32.js");
var inflate_fast  = __webpack_require__(/*! ./inffast */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inffast.js");
var inflate_table = __webpack_require__(/*! ./inftrees */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js");

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/inftrees.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js");

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/messages.js ***!
  \***********************************************************************************/
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/trees.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

var utils = __webpack_require__(/*! ../utils/common */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/utils/common.js");

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;


/***/ }),

/***/ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/lib/zlib/zstream.js ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;


/***/ }),

/***/ "../../node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;


/***/ }),

/***/ "../../node_modules/.pnpm/pify@4.0.1/node_modules/pify/index.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/.pnpm/pify@4.0.1/node_modules/pify/index.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


const processFn = (fn, options) => function (...args) {
	const P = options.promiseModule;

	return new P((resolve, reject) => {
		if (options.multiArgs) {
			args.push((...result) => {
				if (options.errorFirst) {
					if (result[0]) {
						reject(result);
					} else {
						result.shift();
						resolve(result);
					}
				} else {
					resolve(result);
				}
			});
		} else if (options.errorFirst) {
			args.push((error, result) => {
				if (error) {
					reject(error);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(resolve);
		}

		fn.apply(this, args);
	});
};

module.exports = (input, options) => {
	options = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, options);

	const objType = typeof input;
	if (!(input !== null && (objType === 'object' || objType === 'function'))) {
		throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? 'null' : objType}\``);
	}

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return options.include ? options.include.some(match) : !options.exclude.some(match);
	};

	let ret;
	if (objType === 'function') {
		ret = function (...args) {
			return options.excludeMain ? input(...args) : processFn(input, options).apply(this, args);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(input));
	}

	for (const key in input) { // eslint-disable-line guard-for-in
		const property = input[key];
		ret[key] = typeof property === 'function' && filter(key) ? processFn(property, options) : property;
	}

	return ret;
};


/***/ }),

/***/ "../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js ***!
  \************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "../../node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(/*! safe-buffer */ "../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ "../../node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha1.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha1.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = __webpack_require__(/*! inherits */ "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js")
var Hash = __webpack_require__(/*! ./hash */ "../../node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/hash.js")
var Buffer = (__webpack_require__(/*! safe-buffer */ "../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js").Buffer)

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1


/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/index.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NIL": () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "parse": () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "stringify": () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "v1": () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "v3": () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "v4": () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "v5": () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "validate": () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "version": () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v1.js");
/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v3.js");
/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v4.js");
/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v5.js");
/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/nil.js");
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/version.js");
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/validate.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/parse.js");










/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/md5.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/md5.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);

    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }

  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */


function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = '0123456789abcdef';

  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 0xff;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }

  return output;
}
/**
 * Calculate output length with padding and bit length
 */


function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */


function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */


function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }

  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));

  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }

  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */


function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);

/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/nil.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/nil.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');

/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/parse.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/parse.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/validate.js");


function parse(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  var v;
  var arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);

/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/regex.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/regex.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/rng.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/rng.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rng)
/* harmony export */ });
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
    // find the complete implementation of crypto (msCrypto) on IE11.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/sha1.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/sha1.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;

    case 1:
      return x ^ y ^ z;

    case 2:
      return x & y ^ x & z ^ y & z;

    case 3:
      return x ^ y ^ z;
  }
}

function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}

function sha1(bytes) {
  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

  if (typeof bytes === 'string') {
    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];

    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }

  bytes.push(0x80);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);

  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);

    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }

    M[_i] = arr;
  }

  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);

    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }

    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }

    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];

    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }

    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }

  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);

/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/stringify.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/validate.js");

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

var byteToHex = [];

for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);

/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v1.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v1.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/stringify.js");

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;

var _clockseq; // Previous uuid creation time


var _lastMSecs = 0;
var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || new Array(16);
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(b);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);

/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v3.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v3.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/md5.js");


var v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);

/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v35.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v35.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DNS": () => (/* binding */ DNS),
/* harmony export */   "URL": () => (/* binding */ URL),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/stringify.js");
/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/parse.js");



function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  var bytes = [];

  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v4.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v4.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/rng.js");
/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/stringify.js");



function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__["default"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__["default"])(rnds);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);

/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v5.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v5.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v35.js");
/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/sha1.js");


var v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__["default"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);

/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/validate.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/validate.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/regex.js");


function validate(uuid) {
  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__["default"].test(uuid);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);

/***/ }),

/***/ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/version.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/version.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/validate.js");


function version(uuid) {
  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);

/***/ }),

/***/ "../editor/dist/api/EditorEnvelopeLocator.js":
/*!***************************************************!*\
  !*** ../editor/dist/api/EditorEnvelopeLocator.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditorEnvelopeLocator = exports.EnvelopeMapping = exports.EnvelopeContentType = void 0;
var minimatch_1 = __webpack_require__(/*! minimatch */ "../../node_modules/.pnpm/minimatch@3.0.5/node_modules/minimatch/minimatch.js");
var EnvelopeContentType;
(function (EnvelopeContentType) {
    EnvelopeContentType[EnvelopeContentType["PATH"] = 0] = "PATH";
    EnvelopeContentType[EnvelopeContentType["CONTENT"] = 1] = "CONTENT";
})(EnvelopeContentType = exports.EnvelopeContentType || (exports.EnvelopeContentType = {}));
var EnvelopeMapping = (function () {
    function EnvelopeMapping(args) {
        this.args = args;
        this.matcher = new minimatch_1.Minimatch(args.filePathGlob, { nocase: true, dot: true });
    }
    Object.defineProperty(EnvelopeMapping.prototype, "type", {
        get: function () {
            return this.args.type;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EnvelopeMapping.prototype, "filePathGlob", {
        get: function () {
            return this.args.filePathGlob;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EnvelopeMapping.prototype, "resourcesPathPrefix", {
        get: function () {
            return this.args.resourcesPathPrefix;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EnvelopeMapping.prototype, "envelopeContent", {
        get: function () {
            return this.args.envelopeContent;
        },
        enumerable: false,
        configurable: true
    });
    return EnvelopeMapping;
}());
exports.EnvelopeMapping = EnvelopeMapping;
var EditorEnvelopeLocator = (function () {
    function EditorEnvelopeLocator(targetOrigin, envelopeMappings) {
        this.targetOrigin = targetOrigin;
        this.envelopeMappings = envelopeMappings;
    }
    EditorEnvelopeLocator.prototype.getEnvelopeMapping = function (path) {
        return this.envelopeMappings.find(function (mapping) {
            return mapping.matcher.match(path);
        });
    };
    EditorEnvelopeLocator.prototype.hasMappingFor = function (path) {
        return this.getEnvelopeMapping(path) !== undefined;
    };
    return EditorEnvelopeLocator;
}());
exports.EditorEnvelopeLocator = EditorEnvelopeLocator;


/***/ }),

/***/ "../envelope-bus/dist/api/index.js":
/*!*****************************************!*\
  !*** ../envelope-bus/dist/api/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvelopeBusMessageDirectSender = exports.EnvelopeBusMessagePurpose = void 0;
var EnvelopeBusMessagePurpose;
(function (EnvelopeBusMessagePurpose) {
    EnvelopeBusMessagePurpose["REQUEST"] = "request";
    EnvelopeBusMessagePurpose["RESPONSE"] = "response";
    EnvelopeBusMessagePurpose["NOTIFICATION_SUBSCRIPTION"] = "subscription";
    EnvelopeBusMessagePurpose["NOTIFICATION_UNSUBSCRIPTION"] = "unsubscription";
    EnvelopeBusMessagePurpose["NOTIFICATION"] = "notification";
    EnvelopeBusMessagePurpose["SHARED_VALUE_GET_DEFAULT"] = "shared-value-get-default";
    EnvelopeBusMessagePurpose["SHARED_VALUE_UPDATE"] = "shared-value-update";
})(EnvelopeBusMessagePurpose = exports.EnvelopeBusMessagePurpose || (exports.EnvelopeBusMessagePurpose = {}));
var EnvelopeBusMessageDirectSender;
(function (EnvelopeBusMessageDirectSender) {
    EnvelopeBusMessageDirectSender["ENVELOPE_CLIENT"] = "envelopeClient";
    EnvelopeBusMessageDirectSender["ENVELOPE_SERVER"] = "envelopeServer";
})(EnvelopeBusMessageDirectSender = exports.EnvelopeBusMessageDirectSender || (exports.EnvelopeBusMessageDirectSender = {}));


/***/ }),

/***/ "../envelope-bus/dist/common/EnvelopeBusMessageManager.js":
/*!****************************************************************!*\
  !*** ../envelope-bus/dist/common/EnvelopeBusMessageManager.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvelopeBusMessageManager = void 0;
var api_1 = __webpack_require__(/*! ../api */ "../envelope-bus/dist/api/index.js");
var EnvelopeBusMessageManager = (function () {
    function EnvelopeBusMessageManager(send, name) {
        var _this = this;
        if (name === void 0) { name = "".concat(new Date().getMilliseconds()); }
        this.send = send;
        this.name = name;
        this.requestHandlers = new Map();
        this.localNotificationsSubscriptions = new Map();
        this.remoteNotificationsSubscriptions = [];
        this.localSharedValueSubscriptions = new Map();
        this.localSharedValuesStore = new Map();
        this.clientApi = {
            requests: cachedProxy(new Map(), {
                get: function (target, name) {
                    return function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return _this.request.apply(_this, __spreadArray([name], __read(args), false));
                    };
                },
            }),
            notifications: cachedProxy(new Map(), {
                get: function (target, name) { return ({
                    subscribe: function (callback) { return _this.subscribeToNotification(name, callback); },
                    unsubscribe: function (callback) { return _this.unsubscribeFromNotification(name, callback); },
                    send: function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return _this.notify.apply(_this, __spreadArray([name], __read(args), false));
                    },
                }); },
            }),
            shared: cachedProxy(new Map(), {
                get: function (target, name) { return ({
                    set: function (value) { return _this.setSharedValue(name, value); },
                    subscribe: function (callback) { return _this.subscribeToSharedValue(name, callback, { owned: false }); },
                    unsubscribe: function (callback) { return _this.unsubscribeFromSharedValue(name, callback); },
                }); },
            }),
        };
        this.shared = cachedProxy(new Map(), {
            get: function (target, name) { return ({
                set: function (value) { return _this.setSharedValue(name, value); },
                subscribe: function (callback) { return _this.subscribeToSharedValue(name, callback, { owned: true }); },
                unsubscribe: function (callback) { return _this.unsubscribeFromSharedValue(name, callback); },
            }); },
        });
        this.requestIdCounter = 0;
    }
    Object.defineProperty(EnvelopeBusMessageManager.prototype, "server", {
        get: function () {
            var _this = this;
            return {
                receive: function (m, apiImpl) {
                    console.debug(m);
                    _this.receive(m, apiImpl);
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    EnvelopeBusMessageManager.prototype.setSharedValue = function (method, value) {
        var _a;
        this.localSharedValuesStore.set(method, value);
        (_a = this.localSharedValueSubscriptions.get(method)) === null || _a === void 0 ? void 0 : _a.forEach(function (callback) { return callback(value); });
        this.send({
            type: method,
            purpose: api_1.EnvelopeBusMessagePurpose.SHARED_VALUE_UPDATE,
            data: value,
        });
    };
    EnvelopeBusMessageManager.prototype.subscribeToSharedValue = function (method, callback, config) {
        var _a;
        var activeSubscriptions = (_a = this.localSharedValueSubscriptions.get(method)) !== null && _a !== void 0 ? _a : [];
        this.localSharedValueSubscriptions.set(method, __spreadArray(__spreadArray([], __read(activeSubscriptions), false), [callback], false));
        if (config.owned || this.localSharedValuesStore.get(method)) {
            callback(this.getCurrentStoredSharedValueOrDefault(method, this.currentApiImpl));
        }
        else {
            this.send({
                type: method,
                purpose: api_1.EnvelopeBusMessagePurpose.SHARED_VALUE_GET_DEFAULT,
                data: [],
            });
        }
        return callback;
    };
    EnvelopeBusMessageManager.prototype.unsubscribeFromSharedValue = function (name, callback) {
        var activeSubscriptions = this.localSharedValueSubscriptions.get(name);
        if (!activeSubscriptions) {
            return;
        }
        var index = activeSubscriptions.indexOf(callback);
        if (index < 0) {
            return;
        }
        activeSubscriptions.splice(index, 1);
    };
    EnvelopeBusMessageManager.prototype.getCurrentStoredSharedValueOrDefault = function (method, apiImpl) {
        var _a, _b;
        var m = method;
        return ((_a = this.localSharedValuesStore.get(m)) !== null && _a !== void 0 ? _a : this.localSharedValuesStore.set(m, (_b = apiImpl === null || apiImpl === void 0 ? void 0 : apiImpl[m]) === null || _b === void 0 ? void 0 : _b.apply(apiImpl).defaultValue).get(method));
    };
    EnvelopeBusMessageManager.prototype.subscribeToNotification = function (method, callback) {
        var _a;
        var activeSubscriptions = (_a = this.localNotificationsSubscriptions.get(method)) !== null && _a !== void 0 ? _a : [];
        this.localNotificationsSubscriptions.set(method, __spreadArray(__spreadArray([], __read(activeSubscriptions), false), [callback], false));
        this.send({
            type: method,
            purpose: api_1.EnvelopeBusMessagePurpose.NOTIFICATION_SUBSCRIPTION,
            data: [],
        });
        return callback;
    };
    EnvelopeBusMessageManager.prototype.unsubscribeFromNotification = function (method, callback) {
        var activeSubscriptions = this.localNotificationsSubscriptions.get(method);
        if (!activeSubscriptions) {
            return;
        }
        var index = activeSubscriptions.indexOf(callback);
        if (index < 0) {
            return;
        }
        activeSubscriptions.splice(index, 1);
        this.send({
            type: method,
            purpose: api_1.EnvelopeBusMessagePurpose.NOTIFICATION_UNSUBSCRIPTION,
            data: [],
        });
    };
    EnvelopeBusMessageManager.prototype.request = function (method) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var requestId = this.getNextRequestId();
        this.send({
            requestId: requestId,
            type: method,
            data: args,
            purpose: api_1.EnvelopeBusMessagePurpose.REQUEST,
        });
        return new Promise(function (resolve, reject) {
            _this.requestHandlers.set(requestId, { resolve: resolve, reject: reject });
        });
    };
    EnvelopeBusMessageManager.prototype.notify = function (method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.send({
            type: method,
            data: args,
            purpose: api_1.EnvelopeBusMessagePurpose.NOTIFICATION,
        });
    };
    EnvelopeBusMessageManager.prototype.respond = function (request, data, error) {
        if (request.purpose !== api_1.EnvelopeBusMessagePurpose.REQUEST) {
            throw new Error("Cannot respond a message that is not a request");
        }
        if (!request.requestId) {
            throw new Error("Cannot respond a request without a requestId");
        }
        this.send({
            requestId: request.requestId,
            purpose: api_1.EnvelopeBusMessagePurpose.RESPONSE,
            type: request.type,
            data: data,
            error: error instanceof Error ? error.message : JSON.stringify(error),
        });
    };
    EnvelopeBusMessageManager.prototype.callback = function (response) {
        if (response.purpose !== api_1.EnvelopeBusMessagePurpose.RESPONSE) {
            throw new Error("Cannot invoke callback with a message that is not a response");
        }
        if (!response.requestId) {
            throw new Error("Cannot acknowledge a response without a requestId");
        }
        var callback = this.requestHandlers.get(response.requestId);
        if (!callback) {
            throw new Error("Callback not found for " + response);
        }
        this.requestHandlers.delete(response.requestId);
        if (!response.error) {
            callback.resolve(response.data);
        }
        else {
            callback.reject(new Error(response.error));
        }
    };
    EnvelopeBusMessageManager.prototype.receive = function (message, apiImpl) {
        var _this = this;
        var _a, _b;
        this.currentApiImpl = apiImpl;
        if (message.purpose === api_1.EnvelopeBusMessagePurpose.RESPONSE) {
            this.callback(message);
            return;
        }
        if (message.purpose === api_1.EnvelopeBusMessagePurpose.REQUEST) {
            var request_1 = message;
            var response = void 0;
            try {
                response = apiImpl[request_1.type].apply(apiImpl, request_1.data);
            }
            catch (err) {
                console.error(err);
                this.respond(request_1, undefined, err);
                return;
            }
            if (!(response instanceof Promise)) {
                throw new Error("Cannot make a request to '".concat(request_1.type, "' because it does not return a Promise"));
            }
            response
                .then(function (data) {
                _this.respond(request_1, data);
            })
                .catch(function (err) {
                console.error(err);
                _this.respond(request_1, undefined, err);
            });
            return;
        }
        if (message.purpose === api_1.EnvelopeBusMessagePurpose.NOTIFICATION) {
            var method = message.type;
            (_a = apiImpl[method]) === null || _a === void 0 ? void 0 : _a.apply(apiImpl, message.data);
            if (this.remoteNotificationsSubscriptions.indexOf(method) >= 0) {
                this.send({
                    type: method,
                    purpose: api_1.EnvelopeBusMessagePurpose.NOTIFICATION,
                    data: message.data,
                });
            }
            var localSubscriptionMethod = message.type;
            (_b = this.localNotificationsSubscriptions.get(localSubscriptionMethod)) === null || _b === void 0 ? void 0 : _b.forEach(function (callback) {
                callback.apply(void 0, __spreadArray([], __read(message.data), false));
            });
            return;
        }
        if (message.purpose === api_1.EnvelopeBusMessagePurpose.NOTIFICATION_SUBSCRIPTION) {
            var method = message.type;
            if (this.remoteNotificationsSubscriptions.indexOf(method) < 0) {
                this.remoteNotificationsSubscriptions.push(method);
            }
            return;
        }
        if (message.purpose === api_1.EnvelopeBusMessagePurpose.NOTIFICATION_UNSUBSCRIPTION) {
            var method = message.type;
            var index = this.remoteNotificationsSubscriptions.indexOf(method);
            if (index >= 0) {
                this.remoteNotificationsSubscriptions.splice(index, 1);
            }
            return;
        }
        if (message.purpose === api_1.EnvelopeBusMessagePurpose.SHARED_VALUE_GET_DEFAULT) {
            var method = message.type;
            this.send({
                type: method,
                purpose: api_1.EnvelopeBusMessagePurpose.SHARED_VALUE_UPDATE,
                data: this.getCurrentStoredSharedValueOrDefault(method, apiImpl),
            });
            return;
        }
        if (message.purpose === api_1.EnvelopeBusMessagePurpose.SHARED_VALUE_UPDATE) {
            var method = message.type;
            var subscriptions = this.localSharedValueSubscriptions.get(method);
            this.localSharedValuesStore.set(method, message.data);
            subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions.forEach(function (callback) { return callback(message.data); });
            return;
        }
    };
    EnvelopeBusMessageManager.prototype.getNextRequestId = function () {
        return "".concat(this.name, "_").concat(this.requestIdCounter++);
    };
    return EnvelopeBusMessageManager;
}());
exports.EnvelopeBusMessageManager = EnvelopeBusMessageManager;
function cachedProxy(cache, p) {
    return new Proxy({}, {
        set: function (target, name, value) {
            cache.set(name, value);
            return true;
        },
        get: function (target, name) {
            var _a, _b;
            return (_a = cache.get(name)) !== null && _a !== void 0 ? _a : cache.set(name, (_b = p.get) === null || _b === void 0 ? void 0 : _b.call(p, target, name)).get(name);
        },
    });
}


/***/ }),

/***/ "../envelope-bus/dist/common/index.js":
/*!********************************************!*\
  !*** ../envelope-bus/dist/common/index.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./EnvelopeBusMessageManager */ "../envelope-bus/dist/common/EnvelopeBusMessageManager.js"), exports);


/***/ }),

/***/ "../workspace/dist/api/ContentType.js":
/*!********************************************!*\
  !*** ../workspace/dist/api/ContentType.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContentType = void 0;
var ContentType;
(function (ContentType) {
    ContentType["TEXT"] = "text";
    ContentType["BINARY"] = "binary";
})(ContentType = exports.ContentType || (exports.ContentType = {}));


/***/ }),

/***/ "../workspace/dist/api/ResourceContent.js":
/*!************************************************!*\
  !*** ../workspace/dist/api/ResourceContent.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResourceContent = void 0;
var ContentType_1 = __webpack_require__(/*! ./ContentType */ "../workspace/dist/api/ContentType.js");
var ResourceContent = (function () {
    function ResourceContent(path, content, type) {
        this.path = path;
        this.content = content;
        this.type = type || ContentType_1.ContentType.TEXT;
    }
    return ResourceContent;
}());
exports.ResourceContent = ResourceContent;


/***/ }),

/***/ "../workspace/dist/api/ResourceContentOptions.js":
/*!*******************************************************!*\
  !*** ../workspace/dist/api/ResourceContentOptions.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../workspace/dist/api/ResourceContentRequest.js":
/*!*******************************************************!*\
  !*** ../workspace/dist/api/ResourceContentRequest.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../workspace/dist/api/ResourceContentService.js":
/*!*******************************************************!*\
  !*** ../workspace/dist/api/ResourceContentService.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../workspace/dist/api/ResourceListOptions.js":
/*!****************************************************!*\
  !*** ../workspace/dist/api/ResourceListOptions.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../workspace/dist/api/ResourceListRequest.js":
/*!****************************************************!*\
  !*** ../workspace/dist/api/ResourceListRequest.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../workspace/dist/api/ResourcesList.js":
/*!**********************************************!*\
  !*** ../workspace/dist/api/ResourcesList.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ResourcesList = void 0;
var ResourcesList = (function () {
    function ResourcesList(pattern, paths) {
        this.pattern = pattern;
        this.paths = paths;
    }
    return ResourcesList;
}());
exports.ResourcesList = ResourcesList;


/***/ }),

/***/ "../workspace/dist/api/SearchType.js":
/*!*******************************************!*\
  !*** ../workspace/dist/api/SearchType.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchType = void 0;
var SearchType;
(function (SearchType) {
    SearchType["TRAVERSAL"] = "traversal";
    SearchType["ASSET_FOLDER"] = "asset-folder";
})(SearchType = exports.SearchType || (exports.SearchType = {}));


/***/ }),

/***/ "../workspace/dist/api/WorkspaceChannelApi.js":
/*!****************************************************!*\
  !*** ../workspace/dist/api/WorkspaceChannelApi.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../workspace/dist/api/WorkspaceEdit.js":
/*!**********************************************!*\
  !*** ../workspace/dist/api/WorkspaceEdit.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceEdit = void 0;
var WorkspaceEdit = (function () {
    function WorkspaceEdit(id) {
        this.id = id;
    }
    return WorkspaceEdit;
}());
exports.WorkspaceEdit = WorkspaceEdit;


/***/ }),

/***/ "../workspace/dist/api/index.js":
/*!**************************************!*\
  !*** ../workspace/dist/api/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./WorkspaceChannelApi */ "../workspace/dist/api/WorkspaceChannelApi.js"), exports);
__exportStar(__webpack_require__(/*! ./ResourceContentOptions */ "../workspace/dist/api/ResourceContentOptions.js"), exports);
__exportStar(__webpack_require__(/*! ./ResourceListOptions */ "../workspace/dist/api/ResourceListOptions.js"), exports);
__exportStar(__webpack_require__(/*! ./SearchType */ "../workspace/dist/api/SearchType.js"), exports);
__exportStar(__webpack_require__(/*! ./ResourceContentRequest */ "../workspace/dist/api/ResourceContentRequest.js"), exports);
__exportStar(__webpack_require__(/*! ./ResourceContentService */ "../workspace/dist/api/ResourceContentService.js"), exports);
__exportStar(__webpack_require__(/*! ./WorkspaceEdit */ "../workspace/dist/api/WorkspaceEdit.js"), exports);
__exportStar(__webpack_require__(/*! ./ResourcesList */ "../workspace/dist/api/ResourcesList.js"), exports);
__exportStar(__webpack_require__(/*! ./ResourceListRequest */ "../workspace/dist/api/ResourceListRequest.js"), exports);
__exportStar(__webpack_require__(/*! ./ResourceContent */ "../workspace/dist/api/ResourceContent.js"), exports);
__exportStar(__webpack_require__(/*! ./ContentType */ "../workspace/dist/api/ContentType.js"), exports);


/***/ }),

/***/ "../workspaces-git-fs/dist/constants/GitConstants.js":
/*!***********************************************************!*\
  !*** ../workspaces-git-fs/dist/constants/GitConstants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GIST_DEFAULT_BRANCH = exports.GIT_DEFAULT_BRANCH = exports.GIT_ORIGIN_REMOTE_NAME = exports.GIST_ORIGIN_REMOTE_NAME = void 0;
exports.GIST_ORIGIN_REMOTE_NAME = "origin";
exports.GIT_ORIGIN_REMOTE_NAME = "origin";
exports.GIT_DEFAULT_BRANCH = "main";
exports.GIST_DEFAULT_BRANCH = "main";


/***/ }),

/***/ "../workspaces-git-fs/dist/encoderdecoder/EncoderDecoder.js":
/*!******************************************************************!*\
  !*** ../workspaces-git-fs/dist/encoderdecoder/EncoderDecoder.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decoder = exports.encoder = void 0;
exports.encoder = new TextEncoder();
exports.decoder = new TextDecoder("utf-8");


/***/ }),

/***/ "../workspaces-git-fs/dist/relativePath/WorkspaceFileRelativePathParser.js":
/*!*********************************************************************************!*\
  !*** ../workspaces-git-fs/dist/relativePath/WorkspaceFileRelativePathParser.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractExtension = exports.parseWorkspaceFileRelativePath = void 0;
var path_1 = __webpack_require__(/*! path */ "../../node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js");
function parseWorkspaceFileRelativePath(relativePath) {
    var extension = extractExtension(relativePath);
    return {
        relativePathWithoutExtension: relativePath.replace(".".concat(extension), ""),
        relativeDirPath: (0, path_1.parse)(relativePath).dir,
        extension: extension,
        nameWithoutExtension: (0, path_1.basename)(relativePath, ".".concat(extension)),
        name: (0, path_1.basename)(relativePath),
    };
}
exports.parseWorkspaceFileRelativePath = parseWorkspaceFileRelativePath;
function extractExtension(relativePath) {
    var fileName = (0, path_1.basename)(relativePath);
    if (fileName.startsWith(".")) {
        return fileName.slice(1);
    }
    var matchDots = fileName.match(/\./g);
    if (matchDots && matchDots.length > 1) {
        return fileName
            .split(/\.(.*)/s)
            .slice(1)
            .join("");
    }
    return (0, path_1.extname)(relativePath).replace(".", "");
}
exports.extractExtension = extractExtension;


/***/ }),

/***/ "../workspaces-git-fs/dist/services/FsCache.js":
/*!*****************************************************!*\
  !*** ../workspaces-git-fs/dist/services/FsCache.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fsSchemaDir = exports.FsCache = void 0;
var path_1 = __webpack_require__(/*! path */ "../../node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js");
var EncoderDecoder_1 = __webpack_require__(/*! ../encoderdecoder/EncoderDecoder */ "../workspaces-git-fs/dist/encoderdecoder/EncoderDecoder.js");
var MAX_NUMBER_OF_CACHED_FS_INSTANCES = 3;
var FsCache = (function () {
    function FsCache() {
        this.schemasCache = {};
        this.cache = new Map();
    }
    FsCache.prototype.hasSpaceFor = function (fsMountPoint) {
        return this.cache.has(fsMountPoint) || this.cache.size < MAX_NUMBER_OF_CACHED_FS_INSTANCES;
    };
    FsCache.prototype.getLastRecentlyUsed = function () {
        var _a = __read(__spreadArray([], __read(this.cache.entries()), false).sort(function (_a, _b) {
            var _c = __read(_a, 2), _ = _c[0], a = _c[1];
            var _d = __read(_b, 2), __ = _d[0], b = _d[1];
            return a.lastHit.valueOf() - b.lastHit.valueOf();
        })[0], 2), lruFsMountPoint = _a[0], _ = _a[1];
        return lruFsMountPoint;
    };
    FsCache.prototype.getOrLoadFsSchema = function (fsMountPoint) {
        var schema = this.schemasCache[fsMountPoint];
        if (schema) {
            return schema;
        }
        var newFsSchemaPromise = this.loadFsSchema(fsMountPoint);
        this.schemasCache[fsMountPoint] = newFsSchemaPromise;
        return newFsSchemaPromise;
    };
    FsCache.prototype.getOrLoadFs = function (fsMountPoint) {
        var hit = this.cache.get(fsMountPoint);
        if (hit) {
            this.cache.set(fsMountPoint, { fs: hit.fs, lastHit: new Date() });
            return hit.fs;
        }
        var newFsPromise = this.loadFs(fsMountPoint);
        this.cache.set(fsMountPoint, { fs: newFsPromise, lastHit: new Date() });
        return newFsPromise;
    };
    FsCache.prototype.loadFsSchema = function (fsMountPoint) {
        return __awaiter(this, void 0, void 0, function () {
            var fsSchemaIndexJson;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        console.debug("Loading FS Schema for ".concat(fsMountPoint));
                        console.time("Load FS Schema for ".concat(fsMountPoint));
                        this.createFsSchemaStructure(fsMountPoint);
                        return [4, this.syncFsSchema(true, fsMountPoint)];
                    case 1:
                        _a.sent();
                        try {
                            fsSchemaIndexJson = FS.readFile(fsSchemaJsonPath(fsMountPoint), toReadWriteFileOptions({ encoding: "utf8" }));
                            return [2, new Map(JSON.parse(fsSchemaIndexJson))];
                        }
                        catch (e) {
                            try {
                                throwWasiErrorToNodeError("Reading FS Schema JSON", e);
                            }
                            catch (err) {
                                if (err.code === "ENOENT") {
                                    return [2, new Map()];
                                }
                                else {
                                    throw err;
                                }
                            }
                        }
                        finally {
                            console.timeEnd("Load FS Schema for ".concat(fsMountPoint));
                        }
                        return [2];
                }
            });
        });
    };
    FsCache.prototype.syncFsSchema = function (isRestore, fsMountPoint) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, new Promise(function (res) {
                        try {
                            IDBFS.syncfs({ mountpoint: fsSchemaDir(fsMountPoint) }, isRestore, res);
                        }
                        catch (e) {
                            try {
                                throwWasiErrorToNodeError("Sync FS Schema '".concat(fsMountPoint, "' (").concat(isRestore, ")"), e);
                            }
                            catch (err) {
                                console.error(err);
                                throw err;
                            }
                        }
                    })];
            });
        });
    };
    FsCache.prototype.createFsSchemaStructure = function (fsMountPoint) {
        try {
            FS.stat(fsSchemaDir(fsMountPoint));
            console.debug("FS Schema already loaded for ".concat(fsMountPoint));
        }
        catch (e) {
            FS.mkdir(fsSchemaDir(fsMountPoint));
            FS.mount(IDBFS, {}, fsSchemaDir(fsMountPoint));
        }
    };
    FsCache.prototype.flushFsSchema = function (fsMountPoint) {
        return __awaiter(this, void 0, void 0, function () {
            var fsSchemaToFlush, _a, _b, _c, _d, _e, _f;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        _b = (_a = EncoderDecoder_1.encoder).encode;
                        _d = (_c = JSON).stringify;
                        _f = (_e = Array).from;
                        return [4, this.getOrLoadFsSchema(fsMountPoint)];
                    case 1:
                        fsSchemaToFlush = _b.apply(_a, [_d.apply(_c, [_f.apply(_e, [(_g.sent()).entries()])])]);
                        try {
                            FS.writeFile(fsSchemaJsonPath(fsMountPoint), fsSchemaToFlush, toReadWriteFileOptions({ encoding: "utf8" }));
                        }
                        catch (e) {
                            throwWasiErrorToNodeError("Writing FS Schema JSON", e);
                        }
                        return [4, this.syncFsSchema(false, fsMountPoint)];
                    case 2:
                        _g.sent();
                        return [2];
                }
            });
        });
    };
    FsCache.prototype.loadFs = function (fsMountPoint) {
        return __awaiter(this, void 0, void 0, function () {
            var newFs;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        newFs = {
                            promises: {
                                rename: function (path, newPath) { return __awaiter(_this, void 0, void 0, function () {
                                    var e_1;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                _a.trys.push([0, 3, , 4]);
                                                FS.rename(path, newPath);
                                                return [4, this.getOrLoadFsSchema(fsMountPoint)];
                                            case 1:
                                                (_a.sent()).delete(path);
                                                return [4, newFs.promises.lstat(newPath)];
                                            case 2:
                                                _a.sent();
                                                return [3, 4];
                                            case 3:
                                                e_1 = _a.sent();
                                                throwWasiErrorToNodeError("rename", e_1, path, newPath);
                                                return [3, 4];
                                            case 4: return [2];
                                        }
                                    });
                                }); },
                                readFile: function (path, options) { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        try {
                                            return [2, FS.readFile(path, toReadWriteFileOptions(options))];
                                        }
                                        catch (e) {
                                            throwWasiErrorToNodeError("readFile", e, path, options);
                                        }
                                        return [2];
                                    });
                                }); },
                                writeFile: function (path, data, options) { return __awaiter(_this, void 0, void 0, function () {
                                    var e_2;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                _a.trys.push([0, 2, , 3]);
                                                FS.writeFile(path, data, toReadWriteFileOptions(options));
                                                return [4, newFs.promises.lstat(path)];
                                            case 1:
                                                _a.sent();
                                                return [3, 3];
                                            case 2:
                                                e_2 = _a.sent();
                                                throwWasiErrorToNodeError("writeFile", e_2, path, data, options);
                                                return [3, 3];
                                            case 3: return [2];
                                        }
                                    });
                                }); },
                                unlink: function (path) { return __awaiter(_this, void 0, void 0, function () {
                                    var e_3;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                _a.trys.push([0, 2, , 3]);
                                                FS.unlink(path);
                                                return [4, this.getOrLoadFsSchema(fsMountPoint)];
                                            case 1:
                                                (_a.sent()).delete(path);
                                                return [3, 3];
                                            case 2:
                                                e_3 = _a.sent();
                                                throwWasiErrorToNodeError("unlink", e_3, path);
                                                return [3, 3];
                                            case 3: return [2];
                                        }
                                    });
                                }); },
                                readdir: function (path, options) { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        try {
                                            return [2, removeDotPaths(FS.readdir(path, options))];
                                        }
                                        catch (e) {
                                            throwWasiErrorToNodeError("readdir", e, path, options);
                                        }
                                        return [2];
                                    });
                                }); },
                                mkdir: function (path, mode) { return __awaiter(_this, void 0, void 0, function () {
                                    var e_4;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                _a.trys.push([0, 2, , 3]);
                                                FS.mkdir(path, mode);
                                                return [4, newFs.promises.lstat(path)];
                                            case 1:
                                                _a.sent();
                                                return [3, 3];
                                            case 2:
                                                e_4 = _a.sent();
                                                throwWasiErrorToNodeError("mkdir", e_4, path, mode);
                                                return [3, 3];
                                            case 3: return [2];
                                        }
                                    });
                                }); },
                                rmdir: function (path) { return __awaiter(_this, void 0, void 0, function () {
                                    var e_5;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                _a.trys.push([0, 2, , 3]);
                                                FS.rmdir(path);
                                                return [4, this.getOrLoadFsSchema(fsMountPoint)];
                                            case 1:
                                                (_a.sent()).delete(path);
                                                return [3, 3];
                                            case 2:
                                                e_5 = _a.sent();
                                                throwWasiErrorToNodeError("rmdir", e_5, path);
                                                return [3, 3];
                                            case 3: return [2];
                                        }
                                    });
                                }); },
                                stat: function (path) { return __awaiter(_this, void 0, void 0, function () {
                                    var e_6;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                _a.trys.push([0, 2, , 3]);
                                                return [4, toLfsStat(this, fsMountPoint, path, FS.stat(path))];
                                            case 1: return [2, _a.sent()];
                                            case 2:
                                                e_6 = _a.sent();
                                                throwWasiErrorToNodeError("stat", e_6, path);
                                                return [3, 3];
                                            case 3: return [2];
                                        }
                                    });
                                }); },
                                lstat: function (path) { return __awaiter(_this, void 0, void 0, function () {
                                    var e_7;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                _a.trys.push([0, 2, , 3]);
                                                return [4, toLfsStat(this, fsMountPoint, path, FS.stat(path))];
                                            case 1: return [2, _a.sent()];
                                            case 2:
                                                e_7 = _a.sent();
                                                throwWasiErrorToNodeError("lstat", e_7, path);
                                                return [3, 3];
                                            case 3: return [2];
                                        }
                                    });
                                }); },
                                readlink: function (path, options) { return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_a) {
                                        try {
                                            return [2, FS.readlink(path)];
                                        }
                                        catch (e) {
                                            throwWasiErrorToNodeError("readlink", e, path, options);
                                        }
                                        return [2];
                                    });
                                }); },
                                symlink: function (target, path, type) { return __awaiter(_this, void 0, void 0, function () {
                                    var e_8;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                _a.trys.push([0, 2, , 3]);
                                                FS.symlink(target, path);
                                                return [4, newFs.promises.lstat(path)];
                                            case 1:
                                                _a.sent();
                                                return [3, 3];
                                            case 2:
                                                e_8 = _a.sent();
                                                throwWasiErrorToNodeError("symlink", e_8, target, path, type);
                                                return [3, 3];
                                            case 3: return [2];
                                        }
                                    });
                                }); },
                                chmod: function (path, mode) { return __awaiter(_this, void 0, void 0, function () {
                                    var e_9;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                _a.trys.push([0, 2, , 3]);
                                                FS.chmod(path, mode);
                                                return [4, newFs.promises.lstat(path)];
                                            case 1:
                                                _a.sent();
                                                return [3, 3];
                                            case 2:
                                                e_9 = _a.sent();
                                                throwWasiErrorToNodeError("chmod", e_9, path, mode);
                                                return [3, 3];
                                            case 3: return [2];
                                        }
                                    });
                                }); },
                            },
                        };
                        console.time("Load FS to memory - ".concat(fsMountPoint));
                        console.debug("Loading FS to memory - ".concat(fsMountPoint));
                        return [4, this.createFsStructure(fsMountPoint)];
                    case 1:
                        _a.sent();
                        return [4, this.syncFs(true, fsMountPoint)];
                    case 2:
                        _a.sent();
                        return [4, this.getOrLoadFsSchema(fsMountPoint)];
                    case 3:
                        _a.sent();
                        console.timeEnd("Load FS to memory - ".concat(fsMountPoint));
                        return [2, newFs];
                }
            });
        });
    };
    FsCache.prototype.syncFs = function (isRestore, fsMountPoint) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, new Promise(function (res) {
                            try {
                                IDBFS.syncfs({ mountpoint: fsMountPoint }, isRestore, res);
                            }
                            catch (e) {
                                try {
                                    throwWasiErrorToNodeError("Sync FS '".concat(fsMountPoint, "' (").concat(isRestore, ")"), e);
                                }
                                catch (err) {
                                    console.error(err);
                                    throw err;
                                }
                            }
                        })];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    FsCache.prototype.createFsStructure = function (fsMountPoint) {
        console.time("Load FS - ".concat(fsMountPoint));
        console.debug("Loading FS - ".concat(fsMountPoint));
        try {
            FS.mkdir(fsMountPoint);
            FS.mount(IDBFS, {}, fsMountPoint);
            this.createFsSchemaStructure(fsMountPoint);
        }
        catch (e) {
            try {
                throwWasiErrorToNodeError("Load FS ".concat(fsMountPoint), e, fsMountPoint);
            }
            catch (err) {
                console.error("Error loading FS - ".concat(fsMountPoint));
                console.error(err);
            }
        }
        finally {
            console.timeEnd("Load FS - ".concat(fsMountPoint));
        }
    };
    FsCache.prototype.unloadFs = function (fsMountPoint) {
        console.debug("Unloading FS - ".concat(fsMountPoint));
        console.time("Unload FS - ".concat(fsMountPoint));
        this.cache.delete(fsMountPoint);
        try {
            FS.unmount(fsMountPoint);
            FS.rmdir(fsMountPoint);
        }
        catch (e) {
            try {
                throwWasiErrorToNodeError("Unload FS ".concat(fsMountPoint), e, fsMountPoint);
            }
            catch (err) {
                console.error("Error unloading FS - ".concat(fsMountPoint));
                console.error(err);
            }
        }
        finally {
            console.timeEnd("Unload FS - ".concat(fsMountPoint));
        }
    };
    FsCache.prototype.flushFs = function (fsMountPoint) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        console.time("Flush FS - ".concat(fsMountPoint));
                        console.debug("Flushing FS - ".concat(fsMountPoint));
                        return [4, this.syncFs(false, fsMountPoint)];
                    case 1:
                        _a.sent();
                        return [4, this.flushFsSchema(fsMountPoint)];
                    case 2:
                        _a.sent();
                        console.timeEnd("Flush FS - ".concat(fsMountPoint));
                        return [2];
                }
            });
        });
    };
    return FsCache;
}());
exports.FsCache = FsCache;
function fsSchemaDir(fsMountPoint) {
    return "".concat(fsMountPoint, "_schema");
}
exports.fsSchemaDir = fsSchemaDir;
function fsSchemaJsonPath(fsMountPoint) {
    return (0, path_1.join)(fsSchemaDir(fsMountPoint), "schema.json");
}
function toReadWriteFileOptions(options) {
    return typeof options === "string" ? { encoding: options } : options;
}
function removeDotPaths(paths) {
    return paths.slice(2);
}
function toLfsStat(fsCache, fsMountPoint, path, stat) {
    var _a;
    return __awaiter(this, void 0, void 0, function () {
        var schema, perpetualStat, isDir, isFile, isLink;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4, fsCache.getOrLoadFsSchema(fsMountPoint)];
                case 1:
                    schema = _b.sent();
                    perpetualStat = schema.set(path, (_a = schema.get(path)) !== null && _a !== void 0 ? _a : { ino: stat.ino, mode: stat.mode }).get(path);
                    isDir = FS.isDir(perpetualStat.mode);
                    isFile = FS.isFile(perpetualStat.mode);
                    isLink = FS.isLink(perpetualStat.mode);
                    return [2, {
                            mode: perpetualStat.mode,
                            size: stat.size,
                            ino: perpetualStat.ino,
                            mtimeMs: stat.mtime,
                            ctimeMs: stat.ctime,
                            uid: 1,
                            gid: 1,
                            dev: 1,
                            isDirectory: function () { return isDir; },
                            isFile: function () { return isFile; },
                            isSymbolicLink: function () { return isLink; },
                        }];
            }
        });
    });
}
function throwWasiErrorToNodeError(id, e) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    switch (e.errno) {
        case 20:
            throw { id: id, code: "EEXIST", message: "EEXIST", args: args };
        case 44:
            throw { id: id, code: "ENOENT", message: "ENOENT", args: args };
        case 54:
            throw { id: id, code: "ENOTDIR", message: "ENOTDIR", args: args };
        case 55:
            throw { id: id, code: "ENOTEMPTY", message: "ENOTEMPTY", args: args };
        case 73:
            throw { id: id, code: "ETIMEDOUT", message: "ETIMEDOUT", args: args };
        default:
            throw { id: id, e: e, code: "UNKNOWN", args: args };
    }
}


/***/ }),

/***/ "../workspaces-git-fs/dist/services/FsFlushManager.js":
/*!************************************************************!*\
  !*** ../workspaces-git-fs/dist/services/FsFlushManager.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FsFlushManager = exports.FlushStateStatus = void 0;
var Subscribable_1 = __webpack_require__(/*! ./Subscribable */ "../workspaces-git-fs/dist/services/Subscribable.js");
var FlushStateStatus;
(function (FlushStateStatus) {
    FlushStateStatus[FlushStateStatus["FLUSH_IN_PROGRESS"] = 0] = "FLUSH_IN_PROGRESS";
    FlushStateStatus[FlushStateStatus["FLUSH_SCHEDULED"] = 1] = "FLUSH_SCHEDULED";
    FlushStateStatus[FlushStateStatus["FLUSH_PAUSED"] = 2] = "FLUSH_PAUSED";
})(FlushStateStatus = exports.FlushStateStatus || (exports.FlushStateStatus = {}));
var FsFlushManager = (function () {
    function FsFlushManager() {
        var _this = this;
        this.stateControl = new Map();
        this.subscribable = new Subscribable_1.Subscribable({
            newValueSupplier: function () { return __spreadArray([], __read(_this.stateControl.keys()), false); },
        });
    }
    FsFlushManager.prototype.pauseScheduledFlushIfScheduled = function (fsMountPoint) {
        var state = this.stateControl.get(fsMountPoint);
        if ((state === null || state === void 0 ? void 0 : state.status) === FlushStateStatus.FLUSH_SCHEDULED) {
            console.debug("Pausing scheduled flush for ".concat(fsMountPoint));
            clearTimeout(state.scheduledFlush);
            this.stateControl.set(fsMountPoint, { status: FlushStateStatus.FLUSH_PAUSED });
            this.subscribable._notifySubscribers();
        }
    };
    FsFlushManager.prototype.requestFsFlush = function (fsCache, fsMountPoint, debounceArgs) {
        return __awaiter(this, void 0, void 0, function () {
            var state;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        state = this.stateControl.get(fsMountPoint);
                        if (!!state) return [3, 1];
                        console.debug("Scheduling flush for ".concat(fsMountPoint));
                        this.scheduleFsFlush(fsCache, fsMountPoint, debounceArgs);
                        return [3, 7];
                    case 1:
                        if (!(state.status === FlushStateStatus.FLUSH_SCHEDULED)) return [3, 2];
                        console.debug("Debouncing flush request for ".concat(fsMountPoint));
                        clearTimeout(state.scheduledFlush);
                        this.scheduleFsFlush(fsCache, fsMountPoint, debounceArgs);
                        return [3, 7];
                    case 2:
                        if (!(state.status === FlushStateStatus.FLUSH_PAUSED)) return [3, 3];
                        console.debug("Resuming paused flush for ".concat(fsMountPoint));
                        this.scheduleFsFlush(fsCache, fsMountPoint, debounceArgs);
                        return [3, 7];
                    case 3:
                        if (!(state.status === FlushStateStatus.FLUSH_IN_PROGRESS)) return [3, 6];
                        console.debug("Flush requested while in progress for ".concat(fsMountPoint, ". Requesting another flush after completed."));
                        return [4, state.flushPromise];
                    case 4:
                        _a.sent();
                        console.debug("Flush requested right after one completed for ".concat(fsMountPoint, "."));
                        return [4, this.requestFsFlush(fsCache, fsMountPoint, debounceArgs)];
                    case 5:
                        _a.sent();
                        return [3, 7];
                    case 6: throw new Error("Oops! Impossible scenario for flushing '".concat(fsMountPoint, "'"));
                    case 7: return [2];
                }
            });
        });
    };
    FsFlushManager.prototype.executeFlush = function (fsCache, fsMountPoint) {
        return __awaiter(this, void 0, void 0, function () {
            var flush;
            var _this = this;
            return __generator(this, function (_a) {
                flush = fsCache.flushFs(fsMountPoint).then(function () {
                    console.debug("Flush complete for ".concat(fsMountPoint));
                    _this.stateControl.delete(fsMountPoint);
                    _this.subscribable._notifySubscribers();
                });
                this.stateControl.set(fsMountPoint, {
                    status: FlushStateStatus.FLUSH_IN_PROGRESS,
                    flushPromise: flush,
                });
                this.subscribable._notifySubscribers();
                return [2, flush];
            });
        });
    };
    FsFlushManager.prototype.scheduleFsFlush = function (fsCache, fsMountPoint, debounceArgs) {
        var _this = this;
        var flushScheduledTask = setTimeout(function () { return _this.executeFlush(fsCache, fsMountPoint); }, debounceArgs.debounceTimeoutInMs);
        this.stateControl.set(fsMountPoint, {
            status: FlushStateStatus.FLUSH_SCHEDULED,
            scheduledFlush: flushScheduledTask,
        });
        this.subscribable._notifySubscribers();
        return flushScheduledTask;
    };
    FsFlushManager.prototype.expediteFlush = function (fsCache, fsMountPoint, flushArgs) {
        return __awaiter(this, void 0, void 0, function () {
            var flushState;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        flushState = this.stateControl.get(fsMountPoint);
                        if (!!flushState) return [3, 3];
                        if (!flushArgs.executeEvenIfNotScheduled) return [3, 2];
                        return [4, this.executeFlush(fsCache, fsMountPoint)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [3, 12];
                    case 3:
                        if (!((flushState === null || flushState === void 0 ? void 0 : flushState.status) === FlushStateStatus.FLUSH_IN_PROGRESS)) return [3, 7];
                        return [4, flushState.flushPromise];
                    case 4:
                        _a.sent();
                        if (!flushArgs.executeEvenIfNotScheduled) return [3, 6];
                        return [4, this.executeFlush(fsCache, fsMountPoint)];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6: return [3, 12];
                    case 7:
                        if (!((flushState === null || flushState === void 0 ? void 0 : flushState.status) === FlushStateStatus.FLUSH_SCHEDULED)) return [3, 9];
                        clearTimeout(flushState.scheduledFlush);
                        return [4, this.executeFlush(fsCache, fsMountPoint)];
                    case 8:
                        _a.sent();
                        return [3, 12];
                    case 9:
                        if (!((flushState === null || flushState === void 0 ? void 0 : flushState.status) === FlushStateStatus.FLUSH_PAUSED)) return [3, 11];
                        return [4, this.executeFlush(fsCache, fsMountPoint)];
                    case 10:
                        _a.sent();
                        return [3, 12];
                    case 11: throw new Error("Catastrophic error while expediting flush of ".concat(fsMountPoint, "."));
                    case 12: return [2];
                }
            });
        });
    };
    return FsFlushManager;
}());
exports.FsFlushManager = FsFlushManager;


/***/ }),

/***/ "../workspaces-git-fs/dist/services/FsService.js":
/*!*******************************************************!*\
  !*** ../workspaces-git-fs/dist/services/FsService.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FsService = exports.Broadcaster = exports.Broadcastee = void 0;
var FsCache_1 = __webpack_require__(/*! ./FsCache */ "../workspaces-git-fs/dist/services/FsCache.js");
var FsUsageCounter_1 = __webpack_require__(/*! ./FsUsageCounter */ "../workspaces-git-fs/dist/services/FsUsageCounter.js");
var FsUnloadManager_1 = __webpack_require__(/*! ./FsUnloadManager */ "../workspaces-git-fs/dist/services/FsUnloadManager.js");
var Broadcastee = (function () {
    function Broadcastee() {
    }
    Broadcastee.prototype.watch = function (args) { };
    Broadcastee.prototype.dispose = function () { };
    return Broadcastee;
}());
exports.Broadcastee = Broadcastee;
var Broadcaster = (function () {
    function Broadcaster() {
    }
    Broadcaster.prototype.broadcast = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var bc, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        bc = new BroadcastChannel(args.channel);
                        _b = (_a = bc).postMessage;
                        return [4, args.message()];
                    case 1:
                        _b.apply(_a, [_c.sent()]);
                        bc.close();
                        return [2];
                }
            });
        });
    };
    return Broadcaster;
}());
exports.Broadcaster = Broadcaster;
var DEFAULT_FS_FLUSH_DEBOUNCE_TIMEOUT_IN_MS = 100;
var BIG_FS_FLUSH_DEBOUNCE_TIMEOUT_IN_MS = 500;
var BIG_FS_SIZE_IN_ENTRIES_COUNT = 1000;
var FsService = (function () {
    function FsService(args, fsFlushManager, readWriteFsUsageCounter, readonlyFsUsageCounter, fsCache, fsUnloadManager) {
        if (readWriteFsUsageCounter === void 0) { readWriteFsUsageCounter = new FsUsageCounter_1.FsUsageCounter(); }
        if (readonlyFsUsageCounter === void 0) { readonlyFsUsageCounter = new FsUsageCounter_1.FsUsageCounter(); }
        if (fsCache === void 0) { fsCache = new FsCache_1.FsCache(); }
        if (fsUnloadManager === void 0) { fsUnloadManager = new FsUnloadManager_1.FsUnloadManager(fsCache, readWriteFsUsageCounter, readonlyFsUsageCounter, fsFlushManager); }
        this.args = args;
        this.fsFlushManager = fsFlushManager;
        this.readWriteFsUsageCounter = readWriteFsUsageCounter;
        this.readonlyFsUsageCounter = readonlyFsUsageCounter;
        this.fsCache = fsCache;
        this.fsUnloadManager = fsUnloadManager;
    }
    FsService.prototype.withReadonlyFsSchema = function (fsMountPoint, callback) {
        return __awaiter(this, void 0, void 0, function () {
            var schema;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.fsCache.getOrLoadFsSchema(fsMountPoint)];
                    case 1:
                        schema = _a.sent();
                        return [4, callback({ schema: schema })];
                    case 2: return [2, _a.sent()];
                }
            });
        });
    };
    FsService.prototype.withReadWriteInMemoryFs = function (fsMountPoint, callback) {
        return __awaiter(this, void 0, void 0, function () {
            var schema, fs, usagesLeft, didTriggerUnload, debounceTimeoutInMs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.fsUnloadManager.makeSpaceForOrWaitUnloadOf(fsMountPoint)];
                    case 1:
                        _a.sent();
                        this.readWriteFsUsageCounter.addUsage(fsMountPoint);
                        return [4, this.fsCache.getOrLoadFsSchema(fsMountPoint)];
                    case 2:
                        schema = _a.sent();
                        return [4, this.fsCache.getOrLoadFs(fsMountPoint)];
                    case 3:
                        fs = _a.sent();
                        _a.label = 4;
                    case 4:
                        _a.trys.push([4, , 6, 12]);
                        this.fsFlushManager.pauseScheduledFlushIfScheduled(fsMountPoint);
                        return [4, callback({ fs: fs, schema: schema, broadcaster: new Broadcaster() })];
                    case 5: return [2, _a.sent()];
                    case 6:
                        usagesLeft = this.readWriteFsUsageCounter.releaseUsage(fsMountPoint).usagesLeft;
                        if (!(usagesLeft > 0)) return [3, 7];
                        console.log("[".concat(this.args.name, "] Skipping flush/unload for ").concat(fsMountPoint, ". (").concat(usagesLeft, " usages left.)"));
                        return [3, 11];
                    case 7:
                        didTriggerUnload = this.fsUnloadManager.unloadFsIfMarkedAndNotInUse(fsMountPoint).didTriggerUnload;
                        if (!didTriggerUnload) return [3, 8];
                        console.log("[".concat(this.args.name, "] Unload triggered for ").concat(fsMountPoint));
                        return [3, 11];
                    case 8:
                        console.log("[".concat(this.args.name, "] Requesting flush for ").concat(fsMountPoint));
                        return [4, this.getFlushDebounceTimeoutInMs(this.fsCache, fsMountPoint)];
                    case 9:
                        debounceTimeoutInMs = _a.sent();
                        return [4, this.fsFlushManager.requestFsFlush(this.fsCache, fsMountPoint, { debounceTimeoutInMs: debounceTimeoutInMs })];
                    case 10:
                        _a.sent();
                        _a.label = 11;
                    case 11: return [7];
                    case 12: return [2];
                }
            });
        });
    };
    FsService.prototype.withReadonlyInMemoryFs = function (fsMountPoint, callback) {
        return __awaiter(this, void 0, void 0, function () {
            var schema, fs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.fsUnloadManager.makeSpaceForOrWaitUnloadOf(fsMountPoint)];
                    case 1:
                        _a.sent();
                        this.readonlyFsUsageCounter.addUsage(fsMountPoint);
                        return [4, this.fsCache.getOrLoadFsSchema(fsMountPoint)];
                    case 2:
                        schema = _a.sent();
                        return [4, this.fsCache.getOrLoadFs(fsMountPoint)];
                    case 3:
                        fs = _a.sent();
                        _a.label = 4;
                    case 4:
                        _a.trys.push([4, , 6, 7]);
                        return [4, callback({ fs: this.getReadonlyFs(fsMountPoint, fs), schema: schema })];
                    case 5: return [2, _a.sent()];
                    case 6:
                        this.readonlyFsUsageCounter.releaseUsage(fsMountPoint);
                        this.fsUnloadManager.unloadFsIfMarkedAndNotInUse(fsMountPoint);
                        return [7];
                    case 7: return [2];
                }
            });
        });
    };
    FsService.prototype.getReadonlyFs = function (fsMountPoint, readWriteFs) {
        var _this = this;
        var throwCantMutateReadonlyFsException = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw new Error("[".concat(this.args.name, "] Can't mutate read-only FS - ").concat(fsMountPoint));
            });
        }); };
        return {
            promises: {
                writeFile: throwCantMutateReadonlyFsException,
                unlink: throwCantMutateReadonlyFsException,
                mkdir: throwCantMutateReadonlyFsException,
                rmdir: throwCantMutateReadonlyFsException,
                symlink: throwCantMutateReadonlyFsException,
                chmod: throwCantMutateReadonlyFsException,
                rename: throwCantMutateReadonlyFsException,
                readFile: function (path, options) { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        return [2, readWriteFs.promises.readFile(path, options)];
                    });
                }); },
                readdir: function (path, options) { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        return [2, readWriteFs.promises.readdir(path, options)];
                    });
                }); },
                stat: function (path) { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        return [2, readWriteFs.promises.stat(path)];
                    });
                }); },
                lstat: function (path) { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        return [2, readWriteFs.promises.lstat(path)];
                    });
                }); },
                readlink: function (path, options) { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        return [2, readWriteFs.promises.readlink(path, options)];
                    });
                }); },
            },
        };
    };
    FsService.prototype.getFlushDebounceTimeoutInMs = function (fsCache, fsMountPoint) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, fsCache.getOrLoadFsSchema(fsMountPoint)];
                    case 1:
                        if ((_a.sent()).size > BIG_FS_SIZE_IN_ENTRIES_COUNT) {
                            return [2, BIG_FS_FLUSH_DEBOUNCE_TIMEOUT_IN_MS];
                        }
                        else {
                            return [2, DEFAULT_FS_FLUSH_DEBOUNCE_TIMEOUT_IN_MS];
                        }
                        return [2];
                }
            });
        });
    };
    return FsService;
}());
exports.FsService = FsService;


/***/ }),

/***/ "../workspaces-git-fs/dist/services/FsUnloadManager.js":
/*!*************************************************************!*\
  !*** ../workspaces-git-fs/dist/services/FsUnloadManager.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FsUnloadManager = void 0;
function imperativePromiseHandle() {
    var resolve;
    var reject;
    var promise = new Promise(function (res, rej) {
        resolve = res;
        reject = rej;
    });
    return { promise: promise, resolve: resolve, reject: reject };
}
var FsUnloadManager = (function () {
    function FsUnloadManager(fsCache, readWriteFsUsageCounter, readonlyFsUsageCounter, fsFlushManager) {
        this.fsCache = fsCache;
        this.readWriteFsUsageCounter = readWriteFsUsageCounter;
        this.readonlyFsUsageCounter = readonlyFsUsageCounter;
        this.fsFlushManager = fsFlushManager;
        this.ongoingUnloads = new Map();
    }
    FsUnloadManager.prototype.makeSpaceForOrWaitUnloadOf = function (fsMountPoint) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.fsCache.hasSpaceFor(fsMountPoint)) {
                            this.makeSpaceFor(fsMountPoint);
                        }
                        else {
                            console.debug("No need to make space for ".concat(fsMountPoint, "."));
                        }
                        return [4, ((_a = this.ongoingUnloads.get(fsMountPoint)) === null || _a === void 0 ? void 0 : _a.promise)];
                    case 1:
                        _b.sent();
                        return [2];
                }
            });
        });
    };
    FsUnloadManager.prototype.unloadFsIfMarkedAndNotInUse = function (fsMountPoint) {
        var _this = this;
        var unloadPromiseHandle = this.ongoingUnloads.get(fsMountPoint);
        if (!unloadPromiseHandle) {
            return { didTriggerUnload: false };
        }
        if (this.readWriteFsUsageCounter.isInUse(fsMountPoint) || this.readonlyFsUsageCounter.isInUse(fsMountPoint)) {
            return { didTriggerUnload: false };
        }
        var flushArgs = { executeEvenIfNotScheduled: !this.readWriteFsUsageCounter.isInUse(fsMountPoint) };
        setTimeout(function () { return _this.flushAndUnloadFs(fsMountPoint, unloadPromiseHandle, flushArgs); }, 0);
        return { didTriggerUnload: true };
    };
    FsUnloadManager.prototype.makeSpaceFor = function (fsMountPoint) {
        var _this = this;
        var fsMountPointToUnload = this.fsCache.getLastRecentlyUsed();
        if (this.ongoingUnloads.has(fsMountPointToUnload)) {
            return;
        }
        console.debug("Making space for ".concat(fsMountPoint, " by unloading ").concat(fsMountPointToUnload, "."));
        var _a = imperativePromiseHandle(), promise = _a.promise, resolve = _a.resolve, reject = _a.reject;
        var unloadPromiseHandle = {
            promise: promise.finally(function () { return _this.ongoingUnloads.delete(fsMountPointToUnload); }),
            resolve: resolve,
            reject: reject,
        };
        this.ongoingUnloads.set(fsMountPointToUnload, unloadPromiseHandle);
        this.unloadFsIfMarkedAndNotInUse(fsMountPointToUnload);
    };
    FsUnloadManager.prototype.flushAndUnloadFs = function (fsMountPoint, unloadPromiseHandle, flushArgs) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.fsFlushManager.expediteFlush(this.fsCache, fsMountPoint, flushArgs)];
                    case 1:
                        _a.sent();
                        this.fsCache.unloadFs(fsMountPoint);
                        unloadPromiseHandle.resolve();
                        return [2];
                }
            });
        });
    };
    return FsUnloadManager;
}());
exports.FsUnloadManager = FsUnloadManager;


/***/ }),

/***/ "../workspaces-git-fs/dist/services/FsUsageCounter.js":
/*!************************************************************!*\
  !*** ../workspaces-git-fs/dist/services/FsUsageCounter.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FsUsageCounter = void 0;
var FsUsageCounter = (function () {
    function FsUsageCounter() {
        this.counter = new Map();
    }
    FsUsageCounter.prototype.isInUse = function (fsMountPoint) {
        return this.counter.has(fsMountPoint);
    };
    FsUsageCounter.prototype.addUsage = function (fsMountPoint) {
        var _a;
        console.log("Adding to usage counter ".concat(fsMountPoint));
        this.counter.set(fsMountPoint, ((_a = this.counter.get(fsMountPoint)) !== null && _a !== void 0 ? _a : 0) + 1);
    };
    FsUsageCounter.prototype.releaseUsage = function (fsMountPoint) {
        var currentCount = this.counter.get(fsMountPoint);
        if (!currentCount) {
            throw new Error("Catastrophic error releasing usage of ".concat(fsMountPoint, ". No ack counterpart."));
        }
        console.log("Subtracting from usage counter ".concat(fsMountPoint));
        var nextCount = currentCount - 1;
        if (nextCount < 0) {
            throw new Error("Catastrophic error releasing usage of ".concat(fsMountPoint, ". Negative usage count."));
        }
        else if (nextCount === 0) {
            this.counter.delete(fsMountPoint);
        }
        else {
            this.counter.set(fsMountPoint, nextCount);
        }
        return { usagesLeft: nextCount };
    };
    return FsUsageCounter;
}());
exports.FsUsageCounter = FsUsageCounter;


/***/ }),

/***/ "../workspaces-git-fs/dist/services/GitService.js":
/*!********************************************************!*\
  !*** ../workspaces-git-fs/dist/services/GitService.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GitService = void 0;
var isomorphic_git_1 = __importStar(__webpack_require__(/*! isomorphic-git */ "../../node_modules/.pnpm/isomorphic-git@1.11.1/node_modules/isomorphic-git/index.js"));
var web_1 = __importDefault(__webpack_require__(/*! isomorphic-git/http/web */ "../../node_modules/.pnpm/isomorphic-git@1.11.1/node_modules/isomorphic-git/http/web/index.js"));
var GitConstants_1 = __webpack_require__(/*! ../constants/GitConstants */ "../workspaces-git-fs/dist/constants/GitConstants.js");
var GitService = (function () {
    function GitService(corsProxy) {
        this.corsProxy = corsProxy;
    }
    GitService.prototype.listServerRefs = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _b = (_a = isomorphic_git_1.default).listServerRefs;
                        _c = {
                            http: web_1.default
                        };
                        return [4, this.corsProxy];
                    case 1: return [2, _b.apply(_a, [(_c.corsProxy = _d.sent(),
                                _c.onAuth = function () { return args.authInfo; },
                                _c.url = args.url,
                                _c.symrefs = true,
                                _c.protocolVersion = 1,
                                _c)])];
                }
            });
        });
    };
    GitService.prototype.clone = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        console.time("GitService#clone");
                        _b = (_a = isomorphic_git_1.default).clone;
                        _c = {
                            fs: args.fs,
                            http: web_1.default
                        };
                        return [4, this.corsProxy];
                    case 1: return [4, _b.apply(_a, [(_c.corsProxy = _d.sent(),
                                _c.dir = args.dir,
                                _c.url = args.repositoryUrl.href,
                                _c.singleBranch = true,
                                _c.noTags = true,
                                _c.depth = 1,
                                _c.ref = args.sourceBranch,
                                _c.onAuth = function () { return args.authInfo; },
                                _c)])];
                    case 2:
                        _d.sent();
                        if (!args.gitConfig) return [3, 4];
                        return [4, this.setupGitConfig(args.fs, args.dir, args.gitConfig)];
                    case 3:
                        _d.sent();
                        _d.label = 4;
                    case 4:
                        console.timeEnd("GitService#clone");
                        return [2];
                }
            });
        });
    };
    GitService.prototype.branch = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, isomorphic_git_1.default.branch({
                            fs: args.fs,
                            dir: args.dir,
                            ref: args.name,
                            checkout: args.checkout,
                        })];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    GitService.prototype.addRemote = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, isomorphic_git_1.default.addRemote({
                            fs: args.fs,
                            dir: args.dir,
                            remote: args.name,
                            url: args.url,
                            force: args.force,
                        })];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    GitService.prototype.deleteRemote = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, isomorphic_git_1.default.deleteRemote({
                            fs: args.fs,
                            dir: args.dir,
                            remote: args.name,
                        })];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    GitService.prototype.fetch = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _b = (_a = isomorphic_git_1.default).fetch;
                        _c = {
                            fs: args.fs,
                            http: web_1.default
                        };
                        return [4, this.corsProxy];
                    case 1: return [4, _b.apply(_a, [(_c.corsProxy = _d.sent(),
                                _c.dir = args.dir,
                                _c.remote = args.remote,
                                _c.ref = args.ref,
                                _c.singleBranch = true,
                                _c.depth = 1,
                                _c)])];
                    case 2:
                        _d.sent();
                        return [2];
                }
            });
        });
    };
    GitService.prototype.checkout = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, isomorphic_git_1.default.checkout({
                            fs: args.fs,
                            dir: args.dir,
                            ref: args.ref,
                            remote: args.remote,
                        })];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    GitService.prototype.commit = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!args.author) return [3, 2];
                        return [4, this.setupGitConfig(args.fs, args.dir, args.author)];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [4, isomorphic_git_1.default.commit({
                            fs: args.fs,
                            dir: args.dir,
                            message: args.message,
                            author: {
                                name: args.author.name,
                                email: args.author.email,
                            },
                            ref: args.targetBranch,
                        })];
                    case 3:
                        _a.sent();
                        return [4, isomorphic_git_1.default.writeRef({
                                fs: args.fs,
                                dir: args.dir,
                                ref: "HEAD",
                                force: true,
                                value: args.targetBranch,
                            })];
                    case 4:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    GitService.prototype.pull = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _b = (_a = isomorphic_git_1.default).pull;
                        _c = {
                            fs: args.fs,
                            http: web_1.default
                        };
                        return [4, this.corsProxy];
                    case 1: return [4, _b.apply(_a, [(_c.corsProxy = _d.sent(),
                                _c.dir = args.dir,
                                _c.ref = args.ref,
                                _c.singleBranch = true,
                                _c.author = args.author,
                                _c.onAuth = function () { return args.authInfo; },
                                _c)])];
                    case 2:
                        _d.sent();
                        return [2];
                }
            });
        });
    };
    GitService.prototype.getRemoteRef = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var url, serverRefs, _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4, isomorphic_git_1.default.getConfig({ fs: args.fs, path: "remote.origin.url", dir: args.dir })];
                    case 1:
                        url = _d.sent();
                        _b = (_a = isomorphic_git_1.default).listServerRefs;
                        _c = {
                            http: web_1.default,
                            url: url
                        };
                        return [4, this.corsProxy];
                    case 2: return [4, _b.apply(_a, [(_c.corsProxy = _d.sent(),
                                _c.onAuth = function () { return args.authInfo; },
                                _c)])];
                    case 3:
                        serverRefs = _d.sent();
                        return [2, serverRefs.find(function (serverRef) {
                                return args.remoteRef ? serverRef.ref === args.remoteRef : serverRef.ref === "HEAD";
                            })];
                }
            });
        });
    };
    GitService.prototype.push = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var head, serverRemoteRef, _a, _b;
            var _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4, isomorphic_git_1.default.listRemotes(args)];
                    case 1:
                        if ((_d.sent()).length === 0) {
                            throw new Error("No remote repository found");
                        }
                        return [4, this.resolveRef({
                                fs: args.fs,
                                dir: args.dir,
                                ref: "HEAD",
                            })];
                    case 2:
                        head = _d.sent();
                        return [4, this.getRemoteRef({
                                fs: args.fs,
                                dir: args.dir,
                                remoteRef: args.remoteRef,
                                authInfo: args.authInfo,
                            })];
                    case 3:
                        serverRemoteRef = _d.sent();
                        if ((serverRemoteRef === null || serverRemoteRef === void 0 ? void 0 : serverRemoteRef.oid) && head === serverRemoteRef.oid)
                            return [2];
                        _b = (_a = isomorphic_git_1.default).push;
                        _c = {
                            fs: args.fs,
                            http: web_1.default
                        };
                        return [4, this.corsProxy];
                    case 4: return [4, _b.apply(_a, [(_c.corsProxy = _d.sent(),
                                _c.dir = args.dir,
                                _c.ref = args.ref,
                                _c.remoteRef = args.remoteRef,
                                _c.remote = args.remote,
                                _c.force = args.force,
                                _c.onAuth = function () { return args.authInfo; },
                                _c)])];
                    case 5:
                        _d.sent();
                        return [2];
                }
            });
        });
    };
    GitService.prototype.add = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, isomorphic_git_1.default.add({
                            fs: args.fs,
                            dir: args.dir,
                            filepath: args.relativePath,
                        })];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    GitService.prototype.setupGitConfig = function (fs, dir, config) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, isomorphic_git_1.default.setConfig({
                            fs: fs,
                            dir: dir,
                            path: "user.name",
                            value: config.name,
                        })];
                    case 1:
                        _a.sent();
                        return [4, isomorphic_git_1.default.setConfig({
                                fs: fs,
                                dir: dir,
                                path: "user.email",
                                value: config.email,
                            })];
                    case 2:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    GitService.prototype.init = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, isomorphic_git_1.default.init({
                            fs: args.fs,
                            dir: args.dir,
                            bare: false,
                            defaultBranch: GitConstants_1.GIT_DEFAULT_BRANCH,
                        })];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    GitService.prototype.isIgnored = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, isomorphic_git_1.default.isIgnored({
                        fs: args.fs,
                        dir: args.dir,
                        filepath: args.filepath,
                    })];
            });
        });
    };
    GitService.prototype.rm = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, isomorphic_git_1.default.remove({
                            fs: args.fs,
                            dir: args.dir,
                            filepath: args.relativePath,
                        })];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    GitService.prototype.isModified = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var status;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, isomorphic_git_1.default.status({
                            fs: args.fs,
                            dir: args.dir,
                            filepath: args.relativePath,
                        })];
                    case 1:
                        status = _a.sent();
                        return [2, status !== "unmodified"];
                }
            });
        });
    };
    GitService.prototype.hasLocalChanges = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var files;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.unstagedModifiedFileRelativePaths(args)];
                    case 1:
                        files = _a.sent();
                        return [2, files.length > 0];
                }
            });
        });
    };
    GitService.prototype.unstagedModifiedFileRelativePaths = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var now, pseudoStatusMatrix, _WORKDIR, _STAGE, _FILE, ret;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        now = performance.now();
                        console.time("".concat(now, ": hasLocalChanges"));
                        return [4, isomorphic_git_1.default.walk({
                                fs: args.fs,
                                dir: args.dir,
                                trees: [(0, isomorphic_git_1.WORKDIR)(), (0, isomorphic_git_1.STAGE)()],
                                map: function (filepath, _a) {
                                    var _b = __read(_a, 2), workdir = _b[0], stage = _b[1];
                                    return __awaiter(_this, void 0, void 0, function () {
                                        var _c, workdirType, _d, stageType, _e, stageOid, _f, workdirOid, entry, result;
                                        return __generator(this, function (_g) {
                                            switch (_g.label) {
                                                case 0:
                                                    _c = !stage && workdir;
                                                    if (!_c) return [3, 2];
                                                    return [4, isomorphic_git_1.default.isIgnored({ fs: args.fs, dir: args.dir, filepath: filepath })];
                                                case 1:
                                                    _c = (_g.sent());
                                                    _g.label = 2;
                                                case 2:
                                                    if (_c) {
                                                        return [2, null];
                                                    }
                                                    if (filepath.startsWith(".git")) {
                                                        return [2, null];
                                                    }
                                                    if (args.exclude(filepath))
                                                        return [2];
                                                    _d = workdir;
                                                    if (!_d) return [3, 4];
                                                    return [4, workdir.type()];
                                                case 3:
                                                    _d = (_g.sent());
                                                    _g.label = 4;
                                                case 4:
                                                    workdirType = _d;
                                                    if (workdirType === "tree" || workdirType === "special")
                                                        return [2];
                                                    _e = stage;
                                                    if (!_e) return [3, 6];
                                                    return [4, stage.type()];
                                                case 5:
                                                    _e = (_g.sent());
                                                    _g.label = 6;
                                                case 6:
                                                    stageType = _e;
                                                    if (stageType === "commit")
                                                        return [2, null];
                                                    if (stageType === "tree" || stageType === "special")
                                                        return [2];
                                                    if (!stage) return [3, 8];
                                                    return [4, stage.oid()];
                                                case 7:
                                                    _f = _g.sent();
                                                    return [3, 9];
                                                case 8:
                                                    _f = undefined;
                                                    _g.label = 9;
                                                case 9:
                                                    stageOid = _f;
                                                    if (!(workdir && !stage)) return [3, 10];
                                                    workdirOid = "42";
                                                    return [3, 12];
                                                case 10:
                                                    if (!workdir) return [3, 12];
                                                    return [4, workdir.oid()];
                                                case 11:
                                                    workdirOid = _g.sent();
                                                    _g.label = 12;
                                                case 12:
                                                    entry = [undefined, undefined, workdirOid, stageOid];
                                                    result = entry.map(function (value) { return entry.indexOf(value); });
                                                    result.shift();
                                                    return [2, __spreadArray([filepath], __read(result), false)];
                                            }
                                        });
                                    });
                                },
                            })];
                    case 1:
                        pseudoStatusMatrix = _a.sent();
                        _WORKDIR = 2;
                        _STAGE = 3;
                        _FILE = 0;
                        ret = pseudoStatusMatrix.filter(function (row) { return row[_WORKDIR] !== row[_STAGE]; }).map(function (row) { return row[_FILE]; });
                        console.timeEnd("".concat(now, ": hasLocalChanges"));
                        return [2, ret];
                }
            });
        });
    };
    GitService.prototype.resolveRef = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, isomorphic_git_1.default.resolveRef({
                        fs: args.fs,
                        dir: args.dir,
                        ref: args.ref,
                    })];
            });
        });
    };
    return GitService;
}());
exports.GitService = GitService;


/***/ }),

/***/ "../workspaces-git-fs/dist/services/StorageService.js":
/*!************************************************************!*\
  !*** ../workspaces-git-fs/dist/services/StorageService.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StorageService = exports.StorageFile = void 0;
var path_1 = __webpack_require__(/*! path */ "../../node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js");
var WorkspaceFileRelativePathParser_1 = __webpack_require__(/*! ../relativePath/WorkspaceFileRelativePathParser */ "../workspaces-git-fs/dist/relativePath/WorkspaceFileRelativePathParser.js");
var StorageFile = (function () {
    function StorageFile(args) {
        this.args = args;
    }
    Object.defineProperty(StorageFile.prototype, "path", {
        get: function () {
            return this.args.path;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(StorageFile.prototype, "getFileContents", {
        get: function () {
            return this.args.getFileContents;
        },
        enumerable: false,
        configurable: true
    });
    return StorageFile;
}());
exports.StorageFile = StorageFile;
var StorageService = (function () {
    function StorageService() {
    }
    StorageService.prototype.createOrOverwriteFile = function (fs, file) {
        return __awaiter(this, void 0, void 0, function () {
            var contents, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, file.getFileContents()];
                    case 1:
                        contents = _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 7]);
                        return [4, fs.promises.writeFile(file.path, contents)];
                    case 3:
                        _a.sent();
                        return [3, 7];
                    case 4:
                        err_1 = _a.sent();
                        return [4, this.mkdirDeep(fs, (0, path_1.dirname)(file.path))];
                    case 5:
                        _a.sent();
                        return [4, fs.promises.writeFile(file.path, contents)];
                    case 6:
                        _a.sent();
                        return [3, 7];
                    case 7: return [2];
                }
            });
        });
    };
    StorageService.prototype.updateFile = function (fs, path, getFileContents) {
        return __awaiter(this, void 0, void 0, function () {
            var content;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.exists(fs, path)];
                    case 1:
                        if (!(_a.sent())) {
                            throw new Error("File ".concat(path, " does not exist"));
                        }
                        return [4, getFileContents()];
                    case 2:
                        content = _a.sent();
                        return [4, fs.promises.writeFile(path, content)];
                    case 3:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    StorageService.prototype.deleteFile = function (fs, path) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, fs.promises.unlink(path)];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    StorageService.prototype.renameFile = function (fs, file, newFileName) {
        return __awaiter(this, void 0, void 0, function () {
            var extension, newPath, newFile;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.exists(fs, file.path)];
                    case 1:
                        if (!(_a.sent())) {
                            throw new Error("File ".concat(file.path, " does not exist"));
                        }
                        if ((0, path_1.basename)(file.path) === newFileName) {
                            return [2, file];
                        }
                        extension = (0, WorkspaceFileRelativePathParser_1.extractExtension)(file.path);
                        newPath = (0, path_1.join)((0, path_1.dirname)(file.path), "".concat(newFileName).concat(extension ? "." + extension : ""));
                        return [4, this.exists(fs, newPath)];
                    case 2:
                        if (_a.sent()) {
                            throw new Error("File ".concat(newPath, " already exists"));
                        }
                        newFile = new StorageFile({
                            path: newPath,
                            getFileContents: function () { return _this.getFileContent(fs, newPath); },
                        });
                        return [4, fs.promises.rename(file.path, newFile.path)];
                    case 3:
                        _a.sent();
                        return [2, newFile];
                }
            });
        });
    };
    StorageService.prototype.moveFile = function (fs, file, newDirPath) {
        return __awaiter(this, void 0, void 0, function () {
            var newPath, fileToMove;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.exists(fs, file.path)];
                    case 1:
                        if (!(_a.sent())) {
                            throw new Error("File ".concat(file.path, " does not exist"));
                        }
                        return [4, this.mkdirDeep(fs, newDirPath)];
                    case 2:
                        _a.sent();
                        newPath = (0, path_1.join)(newDirPath, (0, path_1.basename)(file.path));
                        fileToMove = new StorageFile({
                            getFileContents: file.getFileContents,
                            path: newPath,
                        });
                        return [4, this.createOrOverwriteFile(fs, fileToMove)];
                    case 3:
                        _a.sent();
                        return [4, this.deleteFile(fs, file.path)];
                    case 4:
                        _a.sent();
                        return [2, new StorageFile({
                                getFileContents: function () { return _this.getFileContent(fs, newPath); },
                                path: newPath,
                            })];
                }
            });
        });
    };
    StorageService.prototype.moveFiles = function (fs, files, newDirPath) {
        return __awaiter(this, void 0, void 0, function () {
            var paths, files_1, files_1_1, fileToMove, movedFile, e_1_1;
            var e_1, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        paths = new Map();
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        files_1 = __values(files), files_1_1 = files_1.next();
                        _b.label = 2;
                    case 2:
                        if (!!files_1_1.done) return [3, 5];
                        fileToMove = files_1_1.value;
                        return [4, this.moveFile(fs, fileToMove, newDirPath)];
                    case 3:
                        movedFile = _b.sent();
                        paths.set(fileToMove.path, movedFile.path);
                        _b.label = 4;
                    case 4:
                        files_1_1 = files_1.next();
                        return [3, 2];
                    case 5: return [3, 8];
                    case 6:
                        e_1_1 = _b.sent();
                        e_1 = { error: e_1_1 };
                        return [3, 8];
                    case 7:
                        try {
                            if (files_1_1 && !files_1_1.done && (_a = files_1.return)) _a.call(files_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7];
                    case 8: return [2, paths];
                }
            });
        });
    };
    StorageService.prototype.getFileContent = function (fs, path) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.exists(fs, path)];
                    case 1:
                        if (!(_a.sent())) {
                            throw new Error("File '".concat(path, "' doesn't exist"));
                        }
                        return [4, fs.promises.readFile(path)];
                    case 2: return [2, (_a.sent())];
                }
            });
        });
    };
    StorageService.prototype.getFile = function (fs, path) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.exists(fs, path)];
                    case 1:
                        if (!(_a.sent())) {
                            return [2];
                        }
                        return [2, new StorageFile({
                                path: path,
                                getFileContents: function () { return fs.promises.readFile(path); },
                            })];
                }
            });
        });
    };
    StorageService.prototype.mkdirDeep = function (fs, dirPath, _selfCall) {
        if (_selfCall === void 0) { _selfCall = false; }
        return __awaiter(this, void 0, void 0, function () {
            var err_2, parent_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 6]);
                        return [4, fs.promises.mkdir(dirPath)];
                    case 1:
                        _a.sent();
                        return [2];
                    case 2:
                        err_2 = _a.sent();
                        if (err_2 === null) {
                            return [2];
                        }
                        if (err_2.code === "EEXIST") {
                            return [2];
                        }
                        if (_selfCall) {
                            throw err_2;
                        }
                        if (!(err_2.code === "ENOENT")) return [3, 5];
                        parent_1 = (0, path_1.dirname)(dirPath);
                        if (parent_1 === "." || parent_1 === "/" || parent_1 === dirPath) {
                            throw err_2;
                        }
                        return [4, this.mkdirDeep(fs, parent_1)];
                    case 3:
                        _a.sent();
                        return [4, this.mkdirDeep(fs, dirPath, true)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [3, 6];
                    case 6: return [2];
                }
            });
        });
    };
    StorageService.prototype.exists = function (fs, path) {
        return __awaiter(this, void 0, void 0, function () {
            var err_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4, fs.promises.stat(path)];
                    case 1:
                        _a.sent();
                        return [2, true];
                    case 2:
                        err_3 = _a.sent();
                        if (err_3.code === "ENOENT" || err_3.code === "ENOTDIR") {
                            return [2, false];
                        }
                        else {
                            console.log("Unexpected error when trying to check if file exists", err_3);
                            throw err_3;
                        }
                        return [3, 3];
                    case 3: return [2];
                }
            });
        });
    };
    StorageService.prototype.walk = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var files;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, Promise.all(__spreadArray([], __read(args.schema.entries()), false).flatMap(function (_a) {
                            var _b = __read(_a, 2), absolutePath = _b[0], _c = _b[1], ino = _c.ino, mode = _c.mode;
                            return __awaiter(_this, void 0, void 0, function () {
                                var relativePath, visit;
                                return __generator(this, function (_d) {
                                    switch (_d.label) {
                                        case 0:
                                            if (FS.isDir(mode)) {
                                                return [2, []];
                                            }
                                            if (args.shouldExcludeAbsolutePath(absolutePath)) {
                                                return [2, []];
                                            }
                                            relativePath = (0, path_1.relative)(args.baseAbsolutePath, absolutePath);
                                            return [4, args.onVisit({ absolutePath: absolutePath, relativePath: relativePath })];
                                        case 1:
                                            visit = _d.sent();
                                            return [2, visit ? [visit] : []];
                                    }
                                });
                            });
                        }))];
                    case 1:
                        files = _a.sent();
                        return [2, files.reduce(function (res, acc) { return (acc ? res.concat(acc) : res); }, [])];
                }
            });
        });
    };
    return StorageService;
}());
exports.StorageService = StorageService;


/***/ }),

/***/ "../workspaces-git-fs/dist/services/Subscribable.js":
/*!**********************************************************!*\
  !*** ../workspaces-git-fs/dist/services/Subscribable.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Subscribable = void 0;
var Subscribable = (function () {
    function Subscribable(args) {
        this.args = args;
        this.subscriptions = new Set();
    }
    Subscribable.prototype.subscribe = function (subscription) {
        this.subscriptions.add(subscription);
        return subscription;
    };
    Subscribable.prototype.unsubscribe = function (subscription) {
        this.subscriptions.delete(subscription);
    };
    Subscribable.prototype._notifySubscribers = function () {
        var newValue = this.args.newValueSupplier();
        this.subscriptions.forEach(function (subscription) {
            subscription(newValue);
        });
    };
    return Subscribable;
}());
exports.Subscribable = Subscribable;


/***/ }),

/***/ "../workspaces-git-fs/dist/services/WorkspaceDescriptorFsService.js":
/*!**************************************************************************!*\
  !*** ../workspaces-git-fs/dist/services/WorkspaceDescriptorFsService.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceDescriptorFsService = void 0;
var FsService_1 = __webpack_require__(/*! ./FsService */ "../workspaces-git-fs/dist/services/FsService.js");
var WorkspaceDescriptorFsService = (function () {
    function WorkspaceDescriptorFsService(fsFlushManager, fsService) {
        if (fsService === void 0) { fsService = new FsService_1.FsService({ name: "Descriptors" }, fsFlushManager); }
        this.fsFlushManager = fsFlushManager;
        this.fsService = fsService;
    }
    WorkspaceDescriptorFsService.prototype.withReadWriteInMemoryFs = function (callback) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.fsService.withReadWriteInMemoryFs(this.getMountPoint(), callback)];
            });
        });
    };
    WorkspaceDescriptorFsService.prototype.withReadonlyInMemoryFs = function (callback) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.fsService.withReadonlyInMemoryFs(this.getMountPoint(), callback)];
            });
        });
    };
    WorkspaceDescriptorFsService.prototype.getMountPoint = function () {
        return "fs_v1__workspaces";
    };
    return WorkspaceDescriptorFsService;
}());
exports.WorkspaceDescriptorFsService = WorkspaceDescriptorFsService;


/***/ }),

/***/ "../workspaces-git-fs/dist/services/WorkspaceDescriptorService.js":
/*!************************************************************************!*\
  !*** ../workspaces-git-fs/dist/services/WorkspaceDescriptorService.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceDescriptorService = void 0;
var WorkspaceDescriptor_1 = __webpack_require__(/*! ../worker/api/WorkspaceDescriptor */ "../workspaces-git-fs/dist/worker/api/WorkspaceDescriptor.js");
var uuid_1 = __webpack_require__(/*! uuid */ "../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/index.js");
var StorageService_1 = __webpack_require__(/*! ./StorageService */ "../workspaces-git-fs/dist/services/StorageService.js");
var EncoderDecoder_1 = __webpack_require__(/*! ../encoderdecoder/EncoderDecoder */ "../workspaces-git-fs/dist/encoderdecoder/EncoderDecoder.js");
var WorkspaceOrigin_1 = __webpack_require__(/*! ../worker/api/WorkspaceOrigin */ "../workspaces-git-fs/dist/worker/api/WorkspaceOrigin.js");
var GitConstants_1 = __webpack_require__(/*! ../constants/GitConstants */ "../workspaces-git-fs/dist/constants/GitConstants.js");
var path_1 = __webpack_require__(/*! path */ "../../node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js");
var FsService_1 = __webpack_require__(/*! ./FsService */ "../workspaces-git-fs/dist/services/FsService.js");
var WorkspacesBroadcastEvents_1 = __webpack_require__(/*! ../worker/api/WorkspacesBroadcastEvents */ "../workspaces-git-fs/dist/worker/api/WorkspacesBroadcastEvents.js");
var WorkspaceDescriptorService = (function () {
    function WorkspaceDescriptorService(descriptorFsService, storageService) {
        this.descriptorFsService = descriptorFsService;
        this.storageService = storageService;
    }
    WorkspaceDescriptorService.prototype.listAll = function (fs, schema) {
        return __awaiter(this, void 0, void 0, function () {
            var workspaceDescriptorsFilePaths;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.storageService.walk({
                            schema: schema,
                            baseAbsolutePath: this.getAbsolutePath(""),
                            shouldExcludeAbsolutePath: function () { return false; },
                            onVisit: function (_a) {
                                var absolutePath = _a.absolutePath;
                                return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_b) {
                                    return [2, absolutePath];
                                }); });
                            },
                        })];
                    case 1:
                        workspaceDescriptorsFilePaths = _a.sent();
                        return [2, Promise.all(workspaceDescriptorsFilePaths.map(function (p) { return __awaiter(_this, void 0, void 0, function () {
                                var content;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4, this.storageService.getFileContent(fs, p)];
                                        case 1:
                                            content = _a.sent();
                                            return [2, JSON.parse(EncoderDecoder_1.decoder.decode(content))];
                                    }
                                });
                            }); }))];
                }
            });
        });
    };
    WorkspaceDescriptorService.prototype.bumpLastUpdatedDate = function (fs, workspaceId) {
        return __awaiter(this, void 0, void 0, function () {
            var file, _a, _b;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this.toStorageFile;
                        _b = [{}];
                        return [4, this.get(fs, workspaceId)];
                    case 1:
                        file = _a.apply(this, [__assign.apply(void 0, [__assign.apply(void 0, _b.concat([(_c.sent())])), { lastUpdatedDateISO: new Date().toISOString() }])]);
                        return [4, this.storageService.updateFile(fs, file.path, file.getFileContents)];
                    case 2:
                        _c.sent();
                        new FsService_1.Broadcaster().broadcast({
                            channel: workspaceId,
                            message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2, ({ type: "WS_UPDATE_DESCRIPTOR" })];
                            }); }); },
                        });
                        return [2];
                }
            });
        });
    };
    WorkspaceDescriptorService.prototype.get = function (fs, workspaceId) {
        return __awaiter(this, void 0, void 0, function () {
            var workspaceDescriptorFile, _a, _b, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4, this.storageService.getFile(fs, this.getAbsolutePath(workspaceId))];
                    case 1:
                        workspaceDescriptorFile = _e.sent();
                        if (!workspaceDescriptorFile) {
                            throw new Error("Workspace not found (".concat(workspaceId, ")"));
                        }
                        _b = (_a = JSON).parse;
                        _d = (_c = EncoderDecoder_1.decoder).decode;
                        return [4, workspaceDescriptorFile.getFileContents()];
                    case 2: return [2, _b.apply(_a, [_d.apply(_c, [_e.sent()])])];
                }
            });
        });
    };
    WorkspaceDescriptorService.prototype.create = function (args) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var workspace;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        workspace = {
                            workspaceId: this.newWorkspaceId(),
                            name: ((_a = args.preferredName) === null || _a === void 0 ? void 0 : _a.trim()) || WorkspaceDescriptor_1.NEW_WORKSPACE_DEFAULT_NAME,
                            origin: args.origin,
                            createdDateISO: new Date().toISOString(),
                            lastUpdatedDateISO: new Date().toISOString(),
                            gitAuthSessionId: args.gitAuthSessionId,
                        };
                        return [4, this.storageService.createOrOverwriteFile(args.fs, this.toStorageFile(workspace))];
                    case 1:
                        _b.sent();
                        return [2, workspace];
                }
            });
        });
    };
    WorkspaceDescriptorService.prototype.delete = function (fs, workspaceId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.storageService.deleteFile(fs, this.getAbsolutePath(workspaceId))];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    WorkspaceDescriptorService.prototype.rename = function (fs, workspaceId, newName) {
        return __awaiter(this, void 0, void 0, function () {
            var file, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this.toStorageFile;
                        _b = [{}];
                        return [4, this.get(fs, workspaceId)];
                    case 1:
                        file = _a.apply(this, [__assign.apply(void 0, [__assign.apply(void 0, _b.concat([(_c.sent())])), { name: newName }])]);
                        return [4, this.storageService.updateFile(fs, file.path, file.getFileContents)];
                    case 2:
                        _c.sent();
                        return [2];
                }
            });
        });
    };
    WorkspaceDescriptorService.prototype.turnIntoGist = function (fs, workspaceId, gistUrl, branch) {
        return __awaiter(this, void 0, void 0, function () {
            var file, _a, _b;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this.toStorageFile;
                        _b = [{}];
                        return [4, this.get(fs, workspaceId)];
                    case 1:
                        file = _a.apply(this, [__assign.apply(void 0, [__assign.apply(void 0, _b.concat([(_c.sent())])), { origin: {
                                        kind: WorkspaceOrigin_1.WorkspaceKind.GITHUB_GIST,
                                        url: gistUrl.toString(),
                                        branch: branch,
                                    } }])]);
                        return [4, this.storageService.updateFile(fs, file.path, file.getFileContents)];
                    case 2:
                        _c.sent();
                        new FsService_1.Broadcaster().broadcast({
                            channel: workspaceId,
                            message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2, ({ type: "WS_UPDATE_DESCRIPTOR" })];
                            }); }); },
                        });
                        new FsService_1.Broadcaster().broadcast({
                            channel: WorkspacesBroadcastEvents_1.WORKSPACES_BROADCAST_CHANNEL,
                            message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2, ({ type: "WSS_UPDATE", workspaceId: workspaceId })];
                            }); }); },
                        });
                        return [2];
                }
            });
        });
    };
    WorkspaceDescriptorService.prototype.turnIntoSnippet = function (fs, workspaceId, snippetUrl, branch) {
        return __awaiter(this, void 0, void 0, function () {
            var file, _a, _b;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this.toStorageFile;
                        _b = [{}];
                        return [4, this.get(fs, workspaceId)];
                    case 1:
                        file = _a.apply(this, [__assign.apply(void 0, [__assign.apply(void 0, _b.concat([(_c.sent())])), { origin: {
                                        kind: WorkspaceOrigin_1.WorkspaceKind.BITBUCKET_SNIPPET,
                                        url: snippetUrl.toString(),
                                        branch: branch,
                                    } }])]);
                        return [4, this.storageService.updateFile(fs, file.path, file.getFileContents)];
                    case 2:
                        _c.sent();
                        new FsService_1.Broadcaster().broadcast({
                            channel: workspaceId,
                            message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2, ({ type: "WS_UPDATE_DESCRIPTOR" })];
                            }); }); },
                        });
                        new FsService_1.Broadcaster().broadcast({
                            channel: WorkspacesBroadcastEvents_1.WORKSPACES_BROADCAST_CHANNEL,
                            message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2, ({ type: "WSS_UPDATE", workspaceId: workspaceId })];
                            }); }); },
                        });
                        return [2];
                }
            });
        });
    };
    WorkspaceDescriptorService.prototype.turnIntoGit = function (fs, workspaceId, url, branch) {
        return __awaiter(this, void 0, void 0, function () {
            var file, _a, _b;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this.toStorageFile;
                        _b = [{}];
                        return [4, this.get(fs, workspaceId)];
                    case 1:
                        file = _a.apply(this, [__assign.apply(void 0, [__assign.apply(void 0, _b.concat([(_c.sent())])), { origin: {
                                        kind: WorkspaceOrigin_1.WorkspaceKind.GIT,
                                        url: url.toString(),
                                        branch: branch !== null && branch !== void 0 ? branch : GitConstants_1.GIT_DEFAULT_BRANCH,
                                    } }])]);
                        return [4, this.storageService.updateFile(fs, file.path, file.getFileContents)];
                    case 2:
                        _c.sent();
                        new FsService_1.Broadcaster().broadcast({
                            channel: workspaceId,
                            message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2, ({ type: "WS_UPDATE_DESCRIPTOR" })];
                            }); }); },
                        });
                        new FsService_1.Broadcaster().broadcast({
                            channel: WorkspacesBroadcastEvents_1.WORKSPACES_BROADCAST_CHANNEL,
                            message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2, ({ type: "WSS_UPDATE", workspaceId: workspaceId })];
                            }); }); },
                        });
                        return [2];
                }
            });
        });
    };
    WorkspaceDescriptorService.prototype.changeGitAuthSessionId = function (fs, workspaceId, gitAuthSessionId) {
        return __awaiter(this, void 0, void 0, function () {
            var file, _a, _b;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this.toStorageFile;
                        _b = [{}];
                        return [4, this.get(fs, workspaceId)];
                    case 1:
                        file = _a.apply(this, [__assign.apply(void 0, [__assign.apply(void 0, _b.concat([(_c.sent())])), { gitAuthSessionId: gitAuthSessionId }])]);
                        return [4, this.storageService.updateFile(fs, file.path, file.getFileContents)];
                    case 2:
                        _c.sent();
                        new FsService_1.Broadcaster().broadcast({
                            channel: workspaceId,
                            message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2, ({ type: "WS_UPDATE_DESCRIPTOR" })];
                            }); }); },
                        });
                        new FsService_1.Broadcaster().broadcast({
                            channel: WorkspacesBroadcastEvents_1.WORKSPACES_BROADCAST_CHANNEL,
                            message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2, ({ type: "WSS_UPDATE", workspaceId: workspaceId })];
                            }); }); },
                        });
                        return [2];
                }
            });
        });
    };
    WorkspaceDescriptorService.prototype.turnIntoLocal = function (fs, workspaceId) {
        return __awaiter(this, void 0, void 0, function () {
            var file, _a, _b;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this.toStorageFile;
                        _b = [{}];
                        return [4, this.get(fs, workspaceId)];
                    case 1:
                        file = _a.apply(this, [__assign.apply(void 0, [__assign.apply(void 0, _b.concat([(_c.sent())])), { origin: {
                                        kind: WorkspaceOrigin_1.WorkspaceKind.LOCAL,
                                        branch: GitConstants_1.GIT_DEFAULT_BRANCH,
                                    } }])]);
                        return [4, this.storageService.updateFile(fs, file.path, file.getFileContents)];
                    case 2:
                        _c.sent();
                        new FsService_1.Broadcaster().broadcast({
                            channel: workspaceId,
                            message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2, ({ type: "WS_UPDATE_DESCRIPTOR" })];
                            }); }); },
                        });
                        new FsService_1.Broadcaster().broadcast({
                            channel: WorkspacesBroadcastEvents_1.WORKSPACES_BROADCAST_CHANNEL,
                            message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2, ({ type: "WSS_UPDATE", workspaceId: workspaceId })];
                            }); }); },
                        });
                        return [2];
                }
            });
        });
    };
    WorkspaceDescriptorService.prototype.getAbsolutePath = function (relativePath) {
        return (0, path_1.join)("/", this.descriptorFsService.getMountPoint(), relativePath !== null && relativePath !== void 0 ? relativePath : "");
    };
    WorkspaceDescriptorService.prototype.toStorageFile = function (descriptor) {
        return new StorageService_1.StorageFile({
            path: this.getAbsolutePath(descriptor.workspaceId),
            getFileContents: function () { return Promise.resolve(EncoderDecoder_1.encoder.encode(JSON.stringify(descriptor))); },
        });
    };
    WorkspaceDescriptorService.prototype.newWorkspaceId = function () {
        return (0, uuid_1.v4)();
    };
    return WorkspaceDescriptorService;
}());
exports.WorkspaceDescriptorService = WorkspaceDescriptorService;


/***/ }),

/***/ "../workspaces-git-fs/dist/services/WorkspaceFsService.js":
/*!****************************************************************!*\
  !*** ../workspaces-git-fs/dist/services/WorkspaceFsService.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceFsService = void 0;
var FsService_1 = __webpack_require__(/*! ./FsService */ "../workspaces-git-fs/dist/services/FsService.js");
var FsCache_1 = __webpack_require__(/*! ./FsCache */ "../workspaces-git-fs/dist/services/FsCache.js");
var WorkspaceFsService = (function () {
    function WorkspaceFsService(fsFlushManager, fsService) {
        if (fsService === void 0) { fsService = new FsService_1.FsService({ name: "Workspaces" }, fsFlushManager); }
        this.fsFlushManager = fsFlushManager;
        this.fsService = fsService;
    }
    WorkspaceFsService.prototype.withReadWriteInMemoryFs = function (workspaceId, callback) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.fsService.withReadWriteInMemoryFs(this.getFsMountPoint(workspaceId), callback)];
            });
        });
    };
    WorkspaceFsService.prototype.withReadonlyInMemoryFs = function (workspaceId, callback) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.fsService.withReadonlyInMemoryFs(this.getFsMountPoint(workspaceId), callback)];
            });
        });
    };
    WorkspaceFsService.prototype.withReadonlyFsSchema = function (workspaceId, callback) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.fsService.withReadonlyFsSchema(this.getFsMountPoint(workspaceId), callback)];
            });
        });
    };
    WorkspaceFsService.prototype.getFsMountPoint = function (workspaceId) {
        return "fs_v1__".concat(workspaceId);
    };
    WorkspaceFsService.prototype.getFsSchemaMountPoint = function (workspaceId) {
        return (0, FsCache_1.fsSchemaDir)(this.getFsMountPoint(workspaceId));
    };
    return WorkspaceFsService;
}());
exports.WorkspaceFsService = WorkspaceFsService;


/***/ }),

/***/ "../workspaces-git-fs/dist/services/WorkspaceService.js":
/*!**************************************************************!*\
  !*** ../workspaces-git-fs/dist/services/WorkspaceService.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceService = void 0;
var EncoderDecoder_1 = __webpack_require__(/*! ../encoderdecoder/EncoderDecoder */ "../workspaces-git-fs/dist/encoderdecoder/EncoderDecoder.js");
var jszip_1 = __importDefault(__webpack_require__(/*! jszip */ "../../node_modules/.pnpm/jszip@3.7.1/node_modules/jszip/dist/jszip.min.js"));
var StorageService_1 = __webpack_require__(/*! ./StorageService */ "../workspaces-git-fs/dist/services/StorageService.js");
var path_1 = __webpack_require__(/*! path */ "../../node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js");
var minimatch_1 = __webpack_require__(/*! minimatch */ "../../node_modules/.pnpm/minimatch@3.0.5/node_modules/minimatch/minimatch.js");
var WorkspacesBroadcastEvents_1 = __webpack_require__(/*! ../worker/api/WorkspacesBroadcastEvents */ "../workspaces-git-fs/dist/worker/api/WorkspacesBroadcastEvents.js");
var WorkspaceFileRelativePathParser_1 = __webpack_require__(/*! ../relativePath/WorkspaceFileRelativePathParser */ "../workspaces-git-fs/dist/relativePath/WorkspaceFileRelativePathParser.js");
var WorkspaceService = (function () {
    function WorkspaceService(storageService, descriptorsFsService, workspaceDescriptorService, fsService) {
        this.storageService = storageService;
        this.descriptorsFsService = descriptorsFsService;
        this.workspaceDescriptorService = workspaceDescriptorService;
        this.fsService = fsService;
    }
    WorkspaceService.prototype.create = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var workspace, e_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                            var fs = _a.fs;
                            return _this.workspaceDescriptorService.create({
                                fs: fs,
                                origin: args.origin,
                                preferredName: args.preferredName,
                                gitAuthSessionId: args.gitAuthSessionId,
                            });
                        })];
                    case 1:
                        workspace = _a.sent();
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 6]);
                        return [4, this.fsService.withReadWriteInMemoryFs(workspace.workspaceId, function (_a) {
                                var fs = _a.fs, schema = _a.schema, broadcaster = _a.broadcaster;
                                return __awaiter(_this, void 0, void 0, function () {
                                    var files;
                                    var _this = this;
                                    return __generator(this, function (_b) {
                                        switch (_b.label) {
                                            case 0: return [4, args.storeFiles(fs, schema, workspace)];
                                            case 1:
                                                files = _b.sent();
                                                broadcaster.broadcast({
                                                    channel: WorkspacesBroadcastEvents_1.WORKSPACES_BROADCAST_CHANNEL,
                                                    message: function () { return __awaiter(_this, void 0, void 0, function () {
                                                        return __generator(this, function (_a) {
                                                            return [2, ({
                                                                    type: "WSS_ADD_WORKSPACE",
                                                                    workspaceId: workspace.workspaceId,
                                                                })];
                                                        });
                                                    }); },
                                                });
                                                broadcaster.broadcast({
                                                    channel: workspace.workspaceId,
                                                    message: function () { return __awaiter(_this, void 0, void 0, function () {
                                                        return __generator(this, function (_a) {
                                                            return [2, ({
                                                                    type: "WS_ADD",
                                                                    workspaceId: workspace.workspaceId,
                                                                })];
                                                        });
                                                    }); },
                                                });
                                                return [2, { workspace: workspace, files: files }];
                                        }
                                    });
                                });
                            })];
                    case 3: return [2, _a.sent()];
                    case 4:
                        e_1 = _a.sent();
                        return [4, this.delete(workspace.workspaceId)];
                    case 5:
                        _a.sent();
                        throw e_1;
                    case 6: return [2];
                }
            });
        });
    };
    WorkspaceService.prototype.getFilteredWorkspaceFileDescriptors = function (schema, workspaceId, globPattern) {
        return __awaiter(this, void 0, void 0, function () {
            var matcher, gitDirAbsolutePath;
            var _this = this;
            return __generator(this, function (_a) {
                matcher = globPattern ? new minimatch_1.Minimatch(globPattern, { dot: true }) : undefined;
                gitDirAbsolutePath = this.getAbsolutePath({ workspaceId: workspaceId, relativePath: ".git" });
                return [2, this.storageService.walk({
                        schema: schema,
                        baseAbsolutePath: this.getAbsolutePath({ workspaceId: workspaceId }),
                        shouldExcludeAbsolutePath: function (absolutePath) { return absolutePath.startsWith(gitDirAbsolutePath); },
                        onVisit: function (_a) {
                            var relativePath = _a.relativePath;
                            return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_b) {
                                    if (matcher && !matcher.match((0, path_1.basename)(relativePath))) {
                                        return [2, undefined];
                                    }
                                    else {
                                        return [2, { workspaceId: workspaceId, relativePath: relativePath }];
                                    }
                                    return [2];
                                });
                            });
                        },
                    })];
            });
        });
    };
    WorkspaceService.prototype.delete = function (workspaceId) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                            var fs = _a.fs, broadcaster = _a.broadcaster;
                            return __awaiter(_this, void 0, void 0, function () {
                                var _this = this;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0: return [4, this.workspaceDescriptorService.delete(fs, workspaceId)];
                                        case 1:
                                            _b.sent();
                                            indexedDB.deleteDatabase(this.fsService.getFsMountPoint(workspaceId));
                                            indexedDB.deleteDatabase(this.fsService.getFsSchemaMountPoint(workspaceId));
                                            broadcaster.broadcast({
                                                channel: WorkspacesBroadcastEvents_1.WORKSPACES_BROADCAST_CHANNEL,
                                                message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                                    return [2, ({ type: "WSS_DELETE_WORKSPACE", workspaceId: workspaceId })];
                                                }); }); },
                                            });
                                            broadcaster.broadcast({
                                                channel: workspaceId,
                                                message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                                    return [2, ({ type: "WS_DELETE", workspaceId: workspaceId })];
                                                }); }); },
                                            });
                                            return [2];
                                    }
                                });
                            });
                        })];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    WorkspaceService.prototype.rename = function (workspaceId, newName) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                            var fs = _a.fs, broadcaster = _a.broadcaster;
                            return __awaiter(_this, void 0, void 0, function () {
                                var _this = this;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0: return [4, this.workspaceDescriptorService.rename(fs, workspaceId, newName)];
                                        case 1:
                                            _b.sent();
                                            return [4, this.workspaceDescriptorService.bumpLastUpdatedDate(fs, workspaceId)];
                                        case 2:
                                            _b.sent();
                                            broadcaster.broadcast({
                                                channel: WorkspacesBroadcastEvents_1.WORKSPACES_BROADCAST_CHANNEL,
                                                message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                                    return [2, ({ type: "WSS_RENAME_WORKSPACE", workspaceId: workspaceId })];
                                                }); }); },
                                            });
                                            broadcaster.broadcast({
                                                channel: workspaceId,
                                                message: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                                    return [2, ({ type: "WS_RENAME", workspaceId: workspaceId })];
                                                }); }); },
                                            });
                                            return [2];
                                    }
                                });
                            });
                        })];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    WorkspaceService.prototype.prepareZip = function (fs, schema, workspaceId, onlyExtensions) {
        return __awaiter(this, void 0, void 0, function () {
            var wwfds, filesToZip, zip, filesToZip_1, filesToZip_1_1, file;
            var e_2, _a;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4, this.getFilteredWorkspaceFileDescriptors(schema, workspaceId)];
                    case 1:
                        wwfds = _b.sent();
                        return [4, Promise.all(wwfds
                                .filter(function (wwfd) { return !onlyExtensions || onlyExtensions.includes((0, WorkspaceFileRelativePathParser_1.extractExtension)(wwfd.relativePath)); })
                                .map(function (wwfd) { return __awaiter(_this, void 0, void 0, function () {
                                var _a;
                                return __generator(this, function (_b) {
                                    switch (_b.label) {
                                        case 0:
                                            _a = {
                                                relativePath: wwfd.relativePath
                                            };
                                            return [4, this.storageService.getFileContent(fs, this.getAbsolutePath(wwfd))];
                                        case 1: return [2, (_a.content = _b.sent(),
                                                _a)];
                                    }
                                });
                            }); }))];
                    case 2:
                        filesToZip = _b.sent();
                        zip = new jszip_1.default();
                        try {
                            for (filesToZip_1 = __values(filesToZip), filesToZip_1_1 = filesToZip_1.next(); !filesToZip_1_1.done; filesToZip_1_1 = filesToZip_1.next()) {
                                file = filesToZip_1_1.value;
                                zip.file(file.relativePath, file.content);
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (filesToZip_1_1 && !filesToZip_1_1.done && (_a = filesToZip_1.return)) _a.call(filesToZip_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        return [2, zip.generateAsync({ type: "blob" })];
                }
            });
        });
    };
    WorkspaceService.prototype.createOrOverwriteFile = function (fs, file, broadcaster) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.storageService.createOrOverwriteFile(fs, this.toStorageFile(file, function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                            return [2, file.content];
                        }); }); }))];
                    case 1:
                        _a.sent();
                        return [4, this.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                                var fs = _a.fs;
                                return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_b) {
                                        switch (_b.label) {
                                            case 0: return [4, this.workspaceDescriptorService.bumpLastUpdatedDate(fs, file.workspaceId)];
                                            case 1:
                                                _b.sent();
                                                return [2];
                                        }
                                    });
                                });
                            })];
                    case 2:
                        _a.sent();
                        broadcaster.broadcast({
                            channel: file.workspaceId,
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WS_ADD_FILE",
                                            relativePath: file.relativePath,
                                        })];
                                });
                            }); },
                        });
                        broadcaster.broadcast({
                            channel: this.getUniqueFileIdentifier(file),
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WSF_ADD",
                                            relativePath: file.relativePath,
                                        })];
                                });
                            }); },
                        });
                        broadcaster.broadcast({
                            channel: WorkspacesBroadcastEvents_1.WORKSPACES_FILES_BROADCAST_CHANNEL,
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WSSFS_ADD",
                                            workspaceId: file.workspaceId,
                                            relativePath: file.relativePath,
                                        })];
                                });
                            }); },
                        });
                        return [2];
                }
            });
        });
    };
    WorkspaceService.prototype.getFile = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var absolutePath, storageFile;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        absolutePath = this.getAbsolutePath(args);
                        return [4, this.storageService.getFile(args.fs, absolutePath)];
                    case 1:
                        storageFile = _a.sent();
                        if (!storageFile) {
                            return [2];
                        }
                        return [2, this.toWorkspaceFile(args.workspaceId, storageFile)];
                }
            });
        });
    };
    WorkspaceService.prototype.updateFile = function (fs, wwfd, getNewContents, broadcaster) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.storageService.updateFile(fs, this.getAbsolutePath(wwfd), function () {
                            return getNewContents().then(function (c) { return EncoderDecoder_1.encoder.encode(c); });
                        })];
                    case 1:
                        _a.sent();
                        return [4, this.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                                var fs = _a.fs;
                                return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_b) {
                                        switch (_b.label) {
                                            case 0: return [4, this.workspaceDescriptorService.bumpLastUpdatedDate(fs, wwfd.workspaceId)];
                                            case 1:
                                                _b.sent();
                                                return [2];
                                        }
                                    });
                                });
                            })];
                    case 2:
                        _a.sent();
                        broadcaster.broadcast({
                            channel: this.getUniqueFileIdentifier(wwfd),
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WSF_UPDATE",
                                            relativePath: wwfd.relativePath,
                                        })];
                                });
                            }); },
                        });
                        broadcaster.broadcast({
                            channel: wwfd.workspaceId,
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WS_UPDATE_FILE",
                                            relativePath: wwfd.relativePath,
                                        })];
                                });
                            }); },
                        });
                        broadcaster.broadcast({
                            channel: WorkspacesBroadcastEvents_1.WORKSPACES_FILES_BROADCAST_CHANNEL,
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WSSFS_UPDATE",
                                            workspaceId: wwfd.workspaceId,
                                            relativePath: wwfd.relativePath,
                                        })];
                                });
                            }); },
                        });
                        return [2];
                }
            });
        });
    };
    WorkspaceService.prototype.deleteFile = function (fs, wwfd, broadcaster) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.storageService.deleteFile(fs, this.toExistingStorageFile(fs, wwfd).path)];
                    case 1:
                        _a.sent();
                        return [4, this.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                                var fs = _a.fs;
                                return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_b) {
                                        switch (_b.label) {
                                            case 0: return [4, this.workspaceDescriptorService.bumpLastUpdatedDate(fs, wwfd.workspaceId)];
                                            case 1:
                                                _b.sent();
                                                return [2];
                                        }
                                    });
                                });
                            })];
                    case 2:
                        _a.sent();
                        broadcaster.broadcast({
                            channel: this.getUniqueFileIdentifier(wwfd),
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WSF_DELETE",
                                            relativePath: wwfd.relativePath,
                                        })];
                                });
                            }); },
                        });
                        broadcaster.broadcast({
                            channel: wwfd.workspaceId,
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WS_DELETE_FILE",
                                            relativePath: wwfd.relativePath,
                                        })];
                                });
                            }); },
                        });
                        broadcaster.broadcast({
                            channel: WorkspacesBroadcastEvents_1.WORKSPACES_FILES_BROADCAST_CHANNEL,
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WSSFS_DELETE",
                                            workspaceId: wwfd.workspaceId,
                                            relativePath: wwfd.relativePath,
                                        })];
                                });
                            }); },
                        });
                        return [2];
                }
            });
        });
    };
    WorkspaceService.prototype.renameFile = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var renamedStorageFile, renamedWorkspaceFile;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.storageService.renameFile(args.fs, this.toExistingStorageFile(args.fs, args.wwfd), args.newFileNameWithoutExtension)];
                    case 1:
                        renamedStorageFile = _a.sent();
                        return [4, this.toWorkspaceFile(args.wwfd.workspaceId, renamedStorageFile)];
                    case 2:
                        renamedWorkspaceFile = _a.sent();
                        return [4, this.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                                var fs = _a.fs;
                                return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_b) {
                                        switch (_b.label) {
                                            case 0: return [4, this.workspaceDescriptorService.bumpLastUpdatedDate(fs, args.wwfd.workspaceId)];
                                            case 1:
                                                _b.sent();
                                                return [2];
                                        }
                                    });
                                });
                            })];
                    case 3:
                        _a.sent();
                        args.broadcaster.broadcast({
                            channel: this.getUniqueFileIdentifier(args.wwfd),
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WSF_RENAME",
                                            oldRelativePath: args.wwfd.relativePath,
                                            newRelativePath: renamedWorkspaceFile.relativePath,
                                        })];
                                });
                            }); },
                        });
                        args.broadcaster.broadcast({
                            channel: this.getUniqueFileIdentifier(renamedWorkspaceFile),
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WSF_ADD",
                                            relativePath: renamedWorkspaceFile.relativePath,
                                        })];
                                });
                            }); },
                        });
                        args.broadcaster.broadcast({
                            channel: args.wwfd.workspaceId,
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WS_RENAME_FILE",
                                            oldRelativePath: args.wwfd.relativePath,
                                            newRelativePath: renamedWorkspaceFile.relativePath,
                                        })];
                                });
                            }); },
                        });
                        args.broadcaster.broadcast({
                            channel: WorkspacesBroadcastEvents_1.WORKSPACES_FILES_BROADCAST_CHANNEL,
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WSSFS_RENAME",
                                            workspaceId: args.wwfd.workspaceId,
                                            oldRelativePath: args.wwfd.relativePath,
                                            newRelativePath: renamedWorkspaceFile.relativePath,
                                        })];
                                });
                            }); },
                        });
                        args.broadcaster.broadcast({
                            channel: WorkspacesBroadcastEvents_1.WORKSPACES_FILES_BROADCAST_CHANNEL,
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WSSFS_ADD",
                                            workspaceId: args.wwfd.workspaceId,
                                            relativePath: renamedWorkspaceFile.relativePath,
                                        })];
                                });
                            }); },
                        });
                        return [2, renamedWorkspaceFile];
                }
            });
        });
    };
    WorkspaceService.prototype.moveFile = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var movedStorageFile, movedWorkspaceFile;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.storageService.moveFile(args.fs, this.toExistingStorageFile(args.fs, args.wwfd), this.getAbsolutePath({ workspaceId: args.wwfd.workspaceId, relativePath: args.newDirPath }))];
                    case 1:
                        movedStorageFile = _a.sent();
                        return [4, this.toWorkspaceFile(args.wwfd.workspaceId, movedStorageFile)];
                    case 2:
                        movedWorkspaceFile = _a.sent();
                        return [4, this.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                                var fs = _a.fs;
                                return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_b) {
                                        switch (_b.label) {
                                            case 0: return [4, this.workspaceDescriptorService.bumpLastUpdatedDate(fs, args.wwfd.workspaceId)];
                                            case 1:
                                                _b.sent();
                                                return [2];
                                        }
                                    });
                                });
                            })];
                    case 3:
                        _a.sent();
                        args.broadcaster.broadcast({
                            channel: this.getUniqueFileIdentifier(args.wwfd),
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WSF_MOVE",
                                            oldRelativePath: args.wwfd.relativePath,
                                            newRelativePath: movedWorkspaceFile.relativePath,
                                        })];
                                });
                            }); },
                        });
                        args.broadcaster.broadcast({
                            channel: this.getUniqueFileIdentifier(movedWorkspaceFile),
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WSF_ADD",
                                            relativePath: movedWorkspaceFile.relativePath,
                                        })];
                                });
                            }); },
                        });
                        args.broadcaster.broadcast({
                            channel: args.wwfd.workspaceId,
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WS_MOVE_FILE",
                                            oldRelativePath: args.wwfd.relativePath,
                                            newRelativePath: movedWorkspaceFile.relativePath,
                                        })];
                                });
                            }); },
                        });
                        args.broadcaster.broadcast({
                            channel: WorkspacesBroadcastEvents_1.WORKSPACES_FILES_BROADCAST_CHANNEL,
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WSSFS_MOVE",
                                            workspaceId: args.wwfd.workspaceId,
                                            oldRelativePath: args.wwfd.relativePath,
                                            newRelativePath: movedWorkspaceFile.relativePath,
                                        })];
                                });
                            }); },
                        });
                        args.broadcaster.broadcast({
                            channel: WorkspacesBroadcastEvents_1.WORKSPACES_FILES_BROADCAST_CHANNEL,
                            message: function () { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    return [2, ({
                                            type: "WSSFS_ADD",
                                            workspaceId: args.wwfd.workspaceId,
                                            relativePath: movedWorkspaceFile.relativePath,
                                        })];
                                });
                            }); },
                        });
                        return [2, movedWorkspaceFile];
                }
            });
        });
    };
    WorkspaceService.prototype.existsFile = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.storageService.exists(args.fs, this.getAbsolutePath(args))];
            });
        });
    };
    WorkspaceService.prototype.getAbsolutePath = function (args) {
        var _a;
        return (0, path_1.join)("/", this.fsService.getFsMountPoint(args.workspaceId), (_a = args.relativePath) !== null && _a !== void 0 ? _a : "");
    };
    WorkspaceService.prototype.toWorkspaceFile = function (workspaceId, storageFile) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = {
                            workspaceId: workspaceId
                        };
                        return [4, storageFile.getFileContents()];
                    case 1: return [2, (_a.content = _b.sent(),
                            _a.relativePath = (0, path_1.relative)(this.getAbsolutePath({ workspaceId: workspaceId }), storageFile.path),
                            _a)];
                }
            });
        });
    };
    WorkspaceService.prototype.toStorageFile = function (wwfd, getFileContents) {
        return new StorageService_1.StorageFile({
            path: this.getAbsolutePath(wwfd),
            getFileContents: getFileContents,
        });
    };
    WorkspaceService.prototype.toExistingStorageFile = function (fs, wwfd) {
        var _this = this;
        return this.toStorageFile(wwfd, function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2, this.storageService.getFileContent(fs, this.getAbsolutePath(wwfd))];
        }); }); });
    };
    WorkspaceService.prototype.getUniqueFileIdentifier = function (args) {
        return "".concat(args.workspaceId, "__").concat(this.getAbsolutePath(args));
    };
    return WorkspaceService;
}());
exports.WorkspaceService = WorkspaceService;


/***/ }),

/***/ "../workspaces-git-fs/dist/worker/WorkspacesWorkerApiImpl.js":
/*!*******************************************************************!*\
  !*** ../workspaces-git-fs/dist/worker/WorkspacesWorkerApiImpl.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspacesWorkerApiImpl = void 0;
var api_1 = __webpack_require__(/*! @kie-tools-core/workspace/dist/api */ "../workspace/dist/api/index.js");
var path_1 = __webpack_require__(/*! path */ "../../node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js");
var GitConstants_1 = __webpack_require__(/*! ../constants/GitConstants */ "../workspaces-git-fs/dist/constants/GitConstants.js");
var EncoderDecoder_1 = __webpack_require__(/*! ../encoderdecoder/EncoderDecoder */ "../workspaces-git-fs/dist/encoderdecoder/EncoderDecoder.js");
var StorageService_1 = __webpack_require__(/*! ../services/StorageService */ "../workspaces-git-fs/dist/services/StorageService.js");
var WorkspaceOrigin_1 = __webpack_require__(/*! ./api/WorkspaceOrigin */ "../workspaces-git-fs/dist/worker/api/WorkspaceOrigin.js");
var WorkspacesWorkerApiImpl = (function () {
    function WorkspacesWorkerApiImpl(args) {
        this.args = args;
        this.MAX_NEW_FILE_INDEX_ATTEMPTS = 10;
        this.NEW_FILE_DEFAULT_NAME = "Untitled";
        this.GIT_DEFAULT_USER = {
            name: this.args.appName,
            email: "",
        };
    }
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_changeGitAuthSessionId = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                        var fs = _a.fs;
                        return _this.args.services.descriptorService.changeGitAuthSessionId(fs, args.workspaceId, args.gitAuthSessionId);
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_initGistOnExistingWorkspace = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                        var fs = _a.fs;
                        return _this.args.services.descriptorService.turnIntoGist(fs, args.workspaceId, new URL(args.remoteUrl), args.branch);
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_initSnippetOnExistingWorkspace = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                        var fs = _a.fs;
                        return _this.args.services.descriptorService.turnIntoSnippet(fs, args.workspaceId, new URL(args.remoteUrl), args.branch);
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_initGitOnExistingWorkspace = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                        var fs = _a.fs;
                        return _this.args.services.descriptorService.turnIntoGit(fs, args.workspaceId, new URL(args.remoteUrl), args.branch);
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_initLocalOnExistingWorkspace = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                        var fs = _a.fs;
                        return _this.args.services.descriptorService.turnIntoLocal(fs, args.workspaceId);
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_getWorkspace = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.descriptorsFsService.withReadonlyInMemoryFs(function (_a) {
                        var fs = _a.fs;
                        return _this.args.services.descriptorService.get(fs, args.workspaceId);
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_listAllWorkspaces = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.descriptorsFsService.withReadonlyInMemoryFs(function (_a) {
                        var fs = _a.fs, schema = _a.schema;
                        return _this.args.services.descriptorService.listAll(fs, schema);
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_resourceContentGet = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadonlyInMemoryFs(args.workspaceId, function (_a) {
                        var fs = _a.fs;
                        return __awaiter(_this, void 0, void 0, function () {
                            var file;
                            var _b;
                            return __generator(this, function (_c) {
                                switch (_c.label) {
                                    case 0: return [4, this.args.services.workspaceService.getFile({
                                            fs: fs,
                                            workspaceId: args.workspaceId,
                                            relativePath: args.relativePath,
                                        })];
                                    case 1:
                                        file = _c.sent();
                                        if (!file) {
                                            throw new Error("File '".concat(args.relativePath, "' not found in Workspace ").concat(args.workspaceId));
                                        }
                                        try {
                                            if (((_b = args.opts) === null || _b === void 0 ? void 0 : _b.type) === "binary") {
                                                return [2, new api_1.ResourceContent(args.relativePath, file.content ? Buffer.from(file.content).toString("base64") : "", api_1.ContentType.BINARY)];
                                            }
                                            return [2, new api_1.ResourceContent(args.relativePath, EncoderDecoder_1.decoder.decode(file.content), api_1.ContentType.TEXT)];
                                        }
                                        catch (e) {
                                            console.error(e);
                                            throw e;
                                        }
                                        return [2];
                                }
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_resourceContentList = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadonlyFsSchema(args.workspaceId, function (_a) {
                        var schema = _a.schema;
                        return __awaiter(_this, void 0, void 0, function () {
                            var files;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0: return [4, this.args.services.workspaceService.getFilteredWorkspaceFileDescriptors(schema, args.workspaceId, args.globPattern)];
                                    case 1:
                                        files = _b.sent();
                                        return [2, new api_1.ResourcesList(args.globPattern, files.map(function (file) { return file.relativePath; }))];
                                }
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_addEmptyFile = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.kieSandboxWorkspacesStorage_addFile(__assign(__assign({}, args), { name: this.NEW_FILE_DEFAULT_NAME, content: "" }))];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_addFile = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.workspaceId, function (_a) {
                        var fs = _a.fs, broadcaster = _a.broadcaster;
                        return __awaiter(_this, void 0, void 0, function () {
                            var i, index, fileName, relativePath, newFile;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        i = 0;
                                        _b.label = 1;
                                    case 1:
                                        if (!(i < this.MAX_NEW_FILE_INDEX_ATTEMPTS)) return [3, 5];
                                        index = i === 0 ? "" : "-".concat(i);
                                        fileName = "".concat(args.name).concat(index, ".").concat(args.extension);
                                        relativePath = (0, path_1.join)(args.destinationDirRelativePath, fileName);
                                        return [4, this.args.services.workspaceService.existsFile({ fs: fs, workspaceId: args.workspaceId, relativePath: relativePath })];
                                    case 2:
                                        if (_b.sent()) {
                                            return [3, 4];
                                        }
                                        newFile = {
                                            workspaceId: args.workspaceId,
                                            content: EncoderDecoder_1.encoder.encode(args.content),
                                            relativePath: relativePath,
                                        };
                                        return [4, this.args.services.workspaceService.createOrOverwriteFile(fs, newFile, broadcaster)];
                                    case 3:
                                        _b.sent();
                                        return [2, newFile];
                                    case 4:
                                        i++;
                                        return [3, 1];
                                    case 5: throw new Error("Max attempts of new empty file exceeded.");
                                }
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_deleteFile = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.wwfd.workspaceId, function (_a) {
                        var fs = _a.fs, broadcaster = _a.broadcaster;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0: return [4, this.args.services.workspaceService.deleteFile(fs, args.wwfd, broadcaster)];
                                    case 1:
                                        _b.sent();
                                        return [2];
                                }
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_moveFile = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.wwfd.workspaceId, function (_a) {
                        var fs = _a.fs, broadcaster = _a.broadcaster;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                return [2, this.args.services.workspaceService.moveFile({
                                        fs: fs,
                                        wwfd: args.wwfd,
                                        newDirPath: args.newDirPath,
                                        broadcaster: broadcaster,
                                    })];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_deleteWorkspace = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.args.services.workspaceService.delete(args.workspaceId)];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_existsFile = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadonlyFsSchema(args.workspaceId, function (_a) {
                        var schema = _a.schema;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                return [2, !!schema.get(this.args.services.workspaceService.getAbsolutePath(args))];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_getFile = function (args) {
        var _this = this;
        return this.args.services.workspaceFsService.withReadonlyFsSchema(args.workspaceId, function (_a) {
            var schema = _a.schema;
            return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_b) {
                    return [2, (schema.get(this.args.services.workspaceService.getAbsolutePath(args)) && {
                            workspaceId: args.workspaceId,
                            relativePath: args.relativePath,
                        })];
                });
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_getFileContent = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadonlyInMemoryFs(args.workspaceId, function (_a) {
                        var fs = _a.fs;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                return [2, this.args.services.storageService.getFileContent(fs, this.args.services.workspaceService.getAbsolutePath(args))];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_getFiles = function (args) {
        var _this = this;
        return this.args.services.workspaceFsService.withReadonlyFsSchema(args.workspaceId, function (_a) {
            var schema = _a.schema;
            return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_b) {
                    return [2, this.args.services.workspaceService.getFilteredWorkspaceFileDescriptors(schema, args.workspaceId, args.globPattern)];
                });
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_getUniqueFileIdentifier = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceService.getUniqueFileIdentifier(args)];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_prepareZip = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadonlyInMemoryFs(args.workspaceId, function (_a) {
                        var fs = _a.fs, schema = _a.schema;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                return [2, this.args.services.workspaceService.prepareZip(fs, schema, args.workspaceId, args.onlyExtensions)];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_renameFile = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.wwfd.workspaceId, function (_a) {
                        var fs = _a.fs, broadcaster = _a.broadcaster;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                return [2, this.args.services.workspaceService.renameFile({
                                        fs: fs,
                                        wwfd: args.wwfd,
                                        newFileNameWithoutExtension: args.newFileNameWithoutExtension,
                                        broadcaster: broadcaster,
                                    })];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_renameWorkspace = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.args.services.workspaceService.rename(args.workspaceId, args.newName)];
                    case 1:
                        _a.sent();
                        return [2];
                }
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_updateFile = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.wwfd.workspaceId, function (_a) {
                        var fs = _a.fs, broadcaster = _a.broadcaster;
                        return __awaiter(_this, void 0, void 0, function () {
                            var _this = this;
                            return __generator(this, function (_b) {
                                return [2, this.args.services.workspaceService.updateFile(fs, args.wwfd, function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                        return [2, args.newContent];
                                    }); }); }, broadcaster)];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_addRemote = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.workspaceId, function (_a) {
                        var fs = _a.fs, broadcaster = _a.broadcaster;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                return [2, this.args.services.gitService.addRemote(__assign({ fs: fs, dir: this.args.services.workspaceService.getAbsolutePath({ workspaceId: args.workspaceId }) }, args))];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_deleteRemote = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.workspaceId, function (_a) {
                        var fs = _a.fs, broadcaster = _a.broadcaster;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                return [2, this.args.services.gitService.deleteRemote(__assign({ fs: fs, dir: this.args.services.workspaceService.getAbsolutePath({ workspaceId: args.workspaceId }) }, args))];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_branch = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.workspaceId, function (_a) {
                        var fs = _a.fs, broadcaster = _a.broadcaster;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                return [2, this.args.services.gitService.branch(__assign({ fs: fs, dir: this.args.services.workspaceService.getAbsolutePath({ workspaceId: args.workspaceId }) }, args))];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_checkout = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.workspaceId, function (_a) {
                        var fs = _a.fs, broadcaster = _a.broadcaster;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                return [2, this.args.services.gitService.checkout(__assign({ fs: fs, dir: this.args.services.workspaceService.getAbsolutePath({ workspaceId: args.workspaceId }) }, args))];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_getGitServerRefs = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.args.services.gitService.listServerRefs(args)];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_clone = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.createWorkspace({
                        preferredName: new URL(args.origin.url).pathname.substring(1),
                        origin: args.origin,
                        gitAuthSessionId: args.gitAuthSessionId,
                        storeFiles: function (fs, schema, workspace) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4, this.args.services.gitService.clone({
                                            fs: fs,
                                            dir: this.args.services.workspaceService.getAbsolutePath({ workspaceId: workspace.workspaceId }),
                                            repositoryUrl: new URL(args.origin.url),
                                            gitConfig: args.gitConfig,
                                            authInfo: args.authInfo,
                                            sourceBranch: args.origin.branch,
                                        })];
                                    case 1:
                                        _a.sent();
                                        return [2, this.args.services.workspaceService.getFilteredWorkspaceFileDescriptors(schema, workspace.workspaceId)];
                                }
                            });
                        }); },
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_getUnstagedModifiedFileRelativePaths = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var workspaceRootDirPath;
            var _this = this;
            return __generator(this, function (_a) {
                workspaceRootDirPath = this.args.services.workspaceService.getAbsolutePath({ workspaceId: args.workspaceId });
                return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.workspaceId, function (_a) {
                        var fs = _a.fs;
                        return __awaiter(_this, void 0, void 0, function () {
                            var _this = this;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0: return [4, this.args.services.gitService.unstagedModifiedFileRelativePaths({
                                            fs: fs,
                                            dir: workspaceRootDirPath,
                                            exclude: function (filepath) { return !_this.args.fileFilter.isEditable(filepath); },
                                        })];
                                    case 1: return [2, _b.sent()];
                                }
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_commit = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var descriptor, workspaceRootDirPath, defaultCommitMessage, fileRelativePaths;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.args.services.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                            var fs = _a.fs;
                            return _this.args.services.descriptorService.get(fs, args.workspaceId);
                        })];
                    case 1:
                        descriptor = _a.sent();
                        workspaceRootDirPath = this.args.services.workspaceService.getAbsolutePath({ workspaceId: args.workspaceId });
                        defaultCommitMessage = "Changes from ".concat(this.args.appName);
                        return [4, this.kieSandboxWorkspacesGit_getUnstagedModifiedFileRelativePaths({
                                workspaceId: args.workspaceId,
                            })];
                    case 2:
                        fileRelativePaths = _a.sent();
                        if (fileRelativePaths.length === 0) {
                            console.debug("Nothing to commit.");
                            return [2];
                        }
                        return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.workspaceId, function (_a) {
                                var fs = _a.fs, broadcaster = _a.broadcaster;
                                return __awaiter(_this, void 0, void 0, function () {
                                    var _this = this;
                                    var _b, _c, _d, _e, _f;
                                    return __generator(this, function (_g) {
                                        switch (_g.label) {
                                            case 0: return [4, Promise.all(fileRelativePaths.map(function (relativePath) { return __awaiter(_this, void 0, void 0, function () {
                                                    return __generator(this, function (_a) {
                                                        switch (_a.label) {
                                                            case 0: return [4, this.args.services.workspaceService.existsFile({
                                                                    fs: fs,
                                                                    workspaceId: args.workspaceId,
                                                                    relativePath: relativePath,
                                                                })];
                                                            case 1:
                                                                if (!_a.sent()) return [3, 3];
                                                                return [4, this.args.services.gitService.add({
                                                                        fs: fs,
                                                                        dir: workspaceRootDirPath,
                                                                        relativePath: relativePath,
                                                                    })];
                                                            case 2:
                                                                _a.sent();
                                                                return [3, 5];
                                                            case 3: return [4, this.args.services.gitService.rm({
                                                                    fs: fs,
                                                                    dir: workspaceRootDirPath,
                                                                    relativePath: relativePath,
                                                                })];
                                                            case 4:
                                                                _a.sent();
                                                                _a.label = 5;
                                                            case 5: return [2];
                                                        }
                                                    });
                                                }); }))];
                                            case 1:
                                                _g.sent();
                                                return [4, this.args.services.gitService.commit({
                                                        fs: fs,
                                                        dir: workspaceRootDirPath,
                                                        targetBranch: descriptor.origin.branch,
                                                        message: (_b = args.commitMessage) !== null && _b !== void 0 ? _b : defaultCommitMessage,
                                                        author: {
                                                            name: (_d = (_c = args.gitConfig) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : this.GIT_DEFAULT_USER.name,
                                                            email: (_f = (_e = args.gitConfig) === null || _e === void 0 ? void 0 : _e.email) !== null && _f !== void 0 ? _f : this.GIT_DEFAULT_USER.email,
                                                        },
                                                    })];
                                            case 2:
                                                _g.sent();
                                                broadcaster.broadcast({
                                                    channel: args.workspaceId,
                                                    message: function () { return __awaiter(_this, void 0, void 0, function () {
                                                        return __generator(this, function (_a) {
                                                            return [2, ({
                                                                    type: "WS_CREATE_SAVE_POINT",
                                                                    workspaceId: args.workspaceId,
                                                                })];
                                                        });
                                                    }); },
                                                });
                                                return [2];
                                        }
                                    });
                                });
                            })];
                }
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_fetch = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.workspaceId, function (_a) {
                        var fs = _a.fs, broadcaster = _a.broadcaster;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                return [2, this.args.services.gitService.fetch(__assign({ fs: fs, dir: this.args.services.workspaceService.getAbsolutePath({ workspaceId: args.workspaceId }) }, args))];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_init = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.createWorkspace({
                        preferredName: args.preferredName,
                        origin: { kind: WorkspaceOrigin_1.WorkspaceKind.LOCAL, branch: GitConstants_1.GIT_DEFAULT_BRANCH },
                        gitAuthSessionId: args.gitAuthSessionId,
                        storeFiles: function (fs, schema, workspace) { return __awaiter(_this, void 0, void 0, function () {
                            var files, workspaceRootDirAbsolutePath, ignoredPaths;
                            var _this = this;
                            var _a, _b, _c, _d;
                            return __generator(this, function (_e) {
                                switch (_e.label) {
                                    case 0:
                                        files = args.localFiles
                                            .filter(function (file) { return !file.path.startsWith(".git/"); })
                                            .map(function (localFile) {
                                            return new StorageService_1.StorageFile({
                                                path: _this.args.services.workspaceService.getAbsolutePath({
                                                    workspaceId: workspace.workspaceId,
                                                    relativePath: localFile.path,
                                                }),
                                                getFileContents: function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                                    return [2, localFile.fileContents];
                                                }); }); },
                                            });
                                        });
                                        return [4, Promise.all(files.map(function (f) { return __awaiter(_this, void 0, void 0, function () {
                                                return __generator(this, function (_a) {
                                                    switch (_a.label) {
                                                        case 0: return [4, this.args.services.storageService.createOrOverwriteFile(fs, f)];
                                                        case 1:
                                                            _a.sent();
                                                            return [2];
                                                    }
                                                });
                                            }); }))];
                                    case 1:
                                        _e.sent();
                                        workspaceRootDirAbsolutePath = this.args.services.workspaceService.getAbsolutePath({
                                            workspaceId: workspace.workspaceId,
                                        });
                                        return [4, this.args.services.storageService.walk({
                                                schema: schema,
                                                shouldExcludeAbsolutePath: function () { return false; },
                                                baseAbsolutePath: workspaceRootDirAbsolutePath,
                                                onVisit: function (_a) {
                                                    var absolutePath = _a.absolutePath, relativePath = _a.relativePath;
                                                    return __awaiter(_this, void 0, void 0, function () {
                                                        var isIgnored;
                                                        return __generator(this, function (_b) {
                                                            switch (_b.label) {
                                                                case 0: return [4, this.args.services.gitService.isIgnored({
                                                                        fs: fs,
                                                                        dir: workspaceRootDirAbsolutePath,
                                                                        filepath: relativePath,
                                                                    })];
                                                                case 1:
                                                                    isIgnored = _b.sent();
                                                                    return [2, isIgnored ? absolutePath : undefined];
                                                            }
                                                        });
                                                    });
                                                },
                                            })];
                                    case 2:
                                        ignoredPaths = _e.sent();
                                        return [4, Promise.all(ignoredPaths.map(function (path) { return __awaiter(_this, void 0, void 0, function () {
                                                return __generator(this, function (_a) {
                                                    switch (_a.label) {
                                                        case 0: return [4, this.args.services.storageService.deleteFile(fs, path)];
                                                        case 1:
                                                            _a.sent();
                                                            return [2];
                                                    }
                                                });
                                            }); }))];
                                    case 3:
                                        _e.sent();
                                        return [4, this.args.services.gitService.init({
                                                fs: fs,
                                                dir: workspaceRootDirAbsolutePath,
                                            })];
                                    case 4:
                                        _e.sent();
                                        return [4, this.args.services.gitService.add({
                                                fs: fs,
                                                dir: workspaceRootDirAbsolutePath,
                                                relativePath: ".",
                                            })];
                                    case 5:
                                        _e.sent();
                                        return [4, this.args.services.gitService.commit({
                                                fs: fs,
                                                dir: workspaceRootDirAbsolutePath,
                                                message: "Initial commit from ".concat(this.args.appName),
                                                targetBranch: GitConstants_1.GIT_DEFAULT_BRANCH,
                                                author: {
                                                    name: (_b = (_a = args.gitConfig) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : this.GIT_DEFAULT_USER.name,
                                                    email: (_d = (_c = args.gitConfig) === null || _c === void 0 ? void 0 : _c.email) !== null && _d !== void 0 ? _d : this.GIT_DEFAULT_USER.email,
                                                },
                                            })];
                                    case 6:
                                        _e.sent();
                                        return [2, this.args.services.workspaceService.getFilteredWorkspaceFileDescriptors(schema, workspace.workspaceId)];
                                }
                            });
                        }); },
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_pull = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var workspace;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.args.services.descriptorsFsService.withReadWriteInMemoryFs(function (_a) {
                            var fs = _a.fs;
                            return _this.args.services.descriptorService.get(fs, args.workspaceId);
                        })];
                    case 1:
                        workspace = _a.sent();
                        return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.workspaceId, function (_a) {
                                var fs = _a.fs, broadcaster = _a.broadcaster;
                                return __awaiter(_this, void 0, void 0, function () {
                                    var _this = this;
                                    var _b, _c, _d, _e;
                                    return __generator(this, function (_f) {
                                        switch (_f.label) {
                                            case 0: return [4, this.args.services.gitService.pull({
                                                    fs: fs,
                                                    dir: this.args.services.workspaceService.getAbsolutePath({ workspaceId: args.workspaceId }),
                                                    ref: workspace.origin.branch,
                                                    author: {
                                                        name: (_c = (_b = args.gitConfig) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : this.GIT_DEFAULT_USER.name,
                                                        email: (_e = (_d = args.gitConfig) === null || _d === void 0 ? void 0 : _d.email) !== null && _e !== void 0 ? _e : this.GIT_DEFAULT_USER.email,
                                                    },
                                                    authInfo: args.authInfo,
                                                })];
                                            case 1:
                                                _f.sent();
                                                broadcaster.broadcast({
                                                    channel: args.workspaceId,
                                                    message: function () { return __awaiter(_this, void 0, void 0, function () {
                                                        return __generator(this, function (_a) {
                                                            return [2, ({
                                                                    type: "WS_PULL",
                                                                    workspaceId: args.workspaceId,
                                                                })];
                                                        });
                                                    }); },
                                                });
                                                return [2];
                                        }
                                    });
                                });
                            })];
                }
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_push = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.workspaceId, function (_a) {
                        var fs = _a.fs, broadcaster = _a.broadcaster;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                return [2, this.args.services.gitService.push(__assign({ fs: fs, dir: this.args.services.workspaceService.getAbsolutePath({ workspaceId: args.workspaceId }) }, args))];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_resolveRef = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadonlyInMemoryFs(args.workspaceId, function (_a) {
                        var fs = _a.fs;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                return [2, this.args.services.gitService.resolveRef({
                                        fs: fs,
                                        dir: this.args.services.workspaceService.getAbsolutePath({ workspaceId: args.workspaceId }),
                                        ref: args.ref,
                                    })];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_isModified = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.workspaceId, function (_a) {
                        var fs = _a.fs;
                        return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_b) {
                                return [2, this.args.services.gitService.isModified({
                                        fs: fs,
                                        dir: this.args.services.workspaceService.getAbsolutePath({ workspaceId: args.workspaceId }),
                                        relativePath: args.relativePath,
                                    })];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesGit_hasLocalChanges = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2, this.args.services.workspaceFsService.withReadWriteInMemoryFs(args.workspaceId, function (_a) {
                        var fs = _a.fs;
                        return __awaiter(_this, void 0, void 0, function () {
                            var _this = this;
                            return __generator(this, function (_b) {
                                return [2, this.args.services.gitService.hasLocalChanges({
                                        fs: fs,
                                        dir: this.args.services.workspaceService.getAbsolutePath({ workspaceId: args.workspaceId }),
                                        exclude: function (filepath) { return !_this.args.fileFilter.isEditable(filepath); },
                                    })];
                            });
                        });
                    })];
            });
        });
    };
    WorkspacesWorkerApiImpl.prototype.kieSandboxWorkspacesStorage_flushes = function () {
        return { defaultValue: [] };
    };
    WorkspacesWorkerApiImpl.prototype.createWorkspace = function (args) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, workspace, files, filteredFiles, suggestedFirstFile;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4, this.args.services.workspaceService.create({
                            storeFiles: args.storeFiles,
                            origin: args.origin,
                            preferredName: args.preferredName,
                            gitAuthSessionId: args.gitAuthSessionId,
                        })];
                    case 1:
                        _a = _b.sent(), workspace = _a.workspace, files = _a.files;
                        if (files.length <= 0) {
                            return [2, { workspace: workspace, suggestedFirstFile: undefined }];
                        }
                        filteredFiles = files.filter(function (file) { return _this.args.fileFilter.isModel(file.relativePath); });
                        if (!filteredFiles.length) {
                            filteredFiles = files.filter(function (file) { return _this.args.fileFilter.isEditable(file.relativePath); });
                        }
                        if (!filteredFiles.length) {
                            filteredFiles = files.filter(function (file) { return _this.args.fileFilter.isSupported(file.relativePath); });
                        }
                        filteredFiles.sort(function (a, b) { return a.relativePath.localeCompare(b.relativePath); });
                        suggestedFirstFile = filteredFiles.length ? filteredFiles[0] : undefined;
                        return [2, {
                                workspace: workspace,
                                suggestedFirstFile: suggestedFirstFile,
                            }];
                }
            });
        });
    };
    return WorkspacesWorkerApiImpl;
}());
exports.WorkspacesWorkerApiImpl = WorkspacesWorkerApiImpl;


/***/ }),

/***/ "../workspaces-git-fs/dist/worker/api/WorkspaceDescriptor.js":
/*!*******************************************************************!*\
  !*** ../workspaces-git-fs/dist/worker/api/WorkspaceDescriptor.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NEW_WORKSPACE_DEFAULT_NAME = void 0;
exports.NEW_WORKSPACE_DEFAULT_NAME = "Untitled Folder";


/***/ }),

/***/ "../workspaces-git-fs/dist/worker/api/WorkspaceOrigin.js":
/*!***************************************************************!*\
  !*** ../workspaces-git-fs/dist/worker/api/WorkspaceOrigin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isGistLikeWorkspaceKind = exports.isGitBasedWorkspaceKind = exports.WorkspaceKind = void 0;
var WorkspaceKind;
(function (WorkspaceKind) {
    WorkspaceKind["GITHUB_GIST"] = "GITHUB_GIST";
    WorkspaceKind["GIT"] = "GIT";
    WorkspaceKind["LOCAL"] = "LOCAL";
    WorkspaceKind["BITBUCKET_SNIPPET"] = "BITBUCKET_SNIPPET";
})(WorkspaceKind = exports.WorkspaceKind || (exports.WorkspaceKind = {}));
var gitBasedTypeKeys = [WorkspaceKind.GIT, WorkspaceKind.BITBUCKET_SNIPPET, WorkspaceKind.GITHUB_GIST];
var isGitBasedWorkspaceKind = function (maybeGitBasedType) {
    return gitBasedTypeKeys.some(function (k) { return k === maybeGitBasedType; });
};
exports.isGitBasedWorkspaceKind = isGitBasedWorkspaceKind;
var gistLikeTypeKeys = [WorkspaceKind.GITHUB_GIST, WorkspaceKind.BITBUCKET_SNIPPET];
var isGistLikeWorkspaceKind = function (maybeGistLikeType) {
    return gistLikeTypeKeys.some(function (k) { return k === maybeGistLikeType; });
};
exports.isGistLikeWorkspaceKind = isGistLikeWorkspaceKind;


/***/ }),

/***/ "../workspaces-git-fs/dist/worker/api/WorkspacesBroadcastEvents.js":
/*!*************************************************************************!*\
  !*** ../workspaces-git-fs/dist/worker/api/WorkspacesBroadcastEvents.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WORKSPACES_FILES_BROADCAST_CHANNEL = exports.WORKSPACES_BROADCAST_CHANNEL = void 0;
exports.WORKSPACES_BROADCAST_CHANNEL = "workspaces";
exports.WORKSPACES_FILES_BROADCAST_CHANNEL = "workspaces_files";


/***/ }),

/***/ "../workspaces-git-fs/dist/worker/createWorkspaceServices.js":
/*!*******************************************************************!*\
  !*** ../workspaces-git-fs/dist/worker/createWorkspaceServices.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createWorkspaceServices = void 0;
var FsFlushManager_1 = __webpack_require__(/*! ../services/FsFlushManager */ "../workspaces-git-fs/dist/services/FsFlushManager.js");
var GitService_1 = __webpack_require__(/*! ../services/GitService */ "../workspaces-git-fs/dist/services/GitService.js");
var StorageService_1 = __webpack_require__(/*! ../services/StorageService */ "../workspaces-git-fs/dist/services/StorageService.js");
var WorkspaceDescriptorFsService_1 = __webpack_require__(/*! ../services/WorkspaceDescriptorFsService */ "../workspaces-git-fs/dist/services/WorkspaceDescriptorFsService.js");
var WorkspaceDescriptorService_1 = __webpack_require__(/*! ../services/WorkspaceDescriptorService */ "../workspaces-git-fs/dist/services/WorkspaceDescriptorService.js");
var WorkspaceFsService_1 = __webpack_require__(/*! ../services/WorkspaceFsService */ "../workspaces-git-fs/dist/services/WorkspaceFsService.js");
var WorkspaceService_1 = __webpack_require__(/*! ../services/WorkspaceService */ "../workspaces-git-fs/dist/services/WorkspaceService.js");
function createWorkspaceServices(args) {
    var fsFlushManager = new FsFlushManager_1.FsFlushManager();
    var storageService = new StorageService_1.StorageService();
    var workspaceFsService = new WorkspaceFsService_1.WorkspaceFsService(fsFlushManager);
    var descriptorsFsService = new WorkspaceDescriptorFsService_1.WorkspaceDescriptorFsService(fsFlushManager);
    var descriptorService = new WorkspaceDescriptorService_1.WorkspaceDescriptorService(descriptorsFsService, storageService);
    var gitService = new GitService_1.GitService(args.gitCorsProxyUrl);
    var workspaceService = new WorkspaceService_1.WorkspaceService(storageService, descriptorsFsService, descriptorService, workspaceFsService);
    return {
        fsFlushManager: fsFlushManager,
        storageService: storageService,
        workspaceFsService: workspaceFsService,
        descriptorsFsService: descriptorsFsService,
        descriptorService: descriptorService,
        workspaceService: workspaceService,
        gitService: gitService,
    };
}
exports.createWorkspaceServices = createWorkspaceServices;


/***/ }),

/***/ "../workspaces-git-fs/dist/worker/setupWorkerConnection.js":
/*!*****************************************************************!*\
  !*** ../workspaces-git-fs/dist/worker/setupWorkerConnection.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setupWorkerConnection = void 0;
var common_1 = __webpack_require__(/*! @kie-tools-core/envelope-bus/dist/common */ "../envelope-bus/dist/common/index.js");
function setupWorkerConnection(args) {
    var bus = new common_1.EnvelopeBusMessageManager(function (m) {
        return args.port.postMessage(m);
    });
    args.port.addEventListener("message", function (message) { return bus.server.receive(message.data, args.apiImpl); });
    args.port.start();
    bus.clientApi.notifications.kieToolsWorkspacesWorker_ready.send();
    var flushManagerSubscription = args.fsFlushManager.subscribable.subscribe(function (flushes) {
        bus.shared.kieSandboxWorkspacesStorage_flushes.set(flushes);
    });
    var keepalive = setInterval(function () {
        var ping = "ping";
        bus.clientApi.requests.kieToolsWorkspacesWorker_ping().then(function (pong) { return (ping = pong); });
        setTimeout(function () {
            if (ping !== "pong") {
                console.log("Disconnecting from Workspaces Shared Worker");
                args.port.close();
                args.fsFlushManager.subscribable.unsubscribe(flushManagerSubscription);
                clearInterval(keepalive);
            }
            else {
                console.debug("Connection is still alive.");
            }
        }, 200);
    }, 60000);
}
exports.setupWorkerConnection = setupWorkerConnection;


/***/ }),

/***/ "./src/AppConstants.ts":
/*!*****************************!*\
  !*** ./src/AppConstants.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "APP_NAME": () => (/* binding */ APP_NAME)
/* harmony export */ });
const APP_NAME = "Serverless Logic Web Tools";


/***/ }),

/***/ "./src/env/EnvConstants.ts":
/*!*********************************!*\
  !*** ./src/env/EnvConstants.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ENV_FILE_PATH": () => (/* binding */ ENV_FILE_PATH)
/* harmony export */ });
const ENV_FILE_PATH = "env.json";


/***/ }),

/***/ "./src/envelopeLocator/EditorEnvelopeLocatorFactory.ts":
/*!*************************************************************!*\
  !*** ./src/envelopeLocator/EditorEnvelopeLocatorFactory.ts ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditorEnvelopeLocatorFactory": () => (/* binding */ EditorEnvelopeLocatorFactory)
/* harmony export */ });
/* harmony import */ var _kie_tools_core_editor_dist_api_EditorEnvelopeLocator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @kie-tools-core/editor/dist/api/EditorEnvelopeLocator */ "../editor/dist/api/EditorEnvelopeLocator.js");
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extension */ "./src/extension/index.ts");


class EditorEnvelopeLocatorFactory {
    create(args) {
        return new _kie_tools_core_editor_dist_api_EditorEnvelopeLocator__WEBPACK_IMPORTED_MODULE_0__.EditorEnvelopeLocator(args.targetOrigin, [
            new _kie_tools_core_editor_dist_api_EditorEnvelopeLocator__WEBPACK_IMPORTED_MODULE_0__.EnvelopeMapping({
                type: "swf",
                filePathGlob: _extension__WEBPACK_IMPORTED_MODULE_1__.GLOB_PATTERN.sw,
                resourcesPathPrefix: ".",
                envelopeContent: { type: _kie_tools_core_editor_dist_api_EditorEnvelopeLocator__WEBPACK_IMPORTED_MODULE_0__.EnvelopeContentType.PATH, path: "serverless-workflow-combined-editor-envelope.html" },
            }),
            new _kie_tools_core_editor_dist_api_EditorEnvelopeLocator__WEBPACK_IMPORTED_MODULE_0__.EnvelopeMapping({
                type: "dash",
                filePathGlob: _extension__WEBPACK_IMPORTED_MODULE_1__.GLOB_PATTERN.dash,
                resourcesPathPrefix: "",
                envelopeContent: { type: _kie_tools_core_editor_dist_api_EditorEnvelopeLocator__WEBPACK_IMPORTED_MODULE_0__.EnvelopeContentType.PATH, path: "dashbuilder-editor-envelope.html" },
            }),
            new _kie_tools_core_editor_dist_api_EditorEnvelopeLocator__WEBPACK_IMPORTED_MODULE_0__.EnvelopeMapping({
                type: "text",
                filePathGlob: _extension__WEBPACK_IMPORTED_MODULE_1__.GLOB_PATTERN.all,
                resourcesPathPrefix: "",
                envelopeContent: { type: _kie_tools_core_editor_dist_api_EditorEnvelopeLocator__WEBPACK_IMPORTED_MODULE_0__.EnvelopeContentType.PATH, path: "text-editor-envelope.html" },
            }),
        ]);
    }
}


/***/ }),

/***/ "./src/extension/index.ts":
/*!********************************!*\
  !*** ./src/extension/index.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FileTypes": () => (/* binding */ FileTypes),
/* harmony export */   "GLOB_PATTERN": () => (/* binding */ GLOB_PATTERN),
/* harmony export */   "isDashbuilder": () => (/* binding */ isDashbuilder),
/* harmony export */   "isEditable": () => (/* binding */ isEditable),
/* harmony export */   "isJson": () => (/* binding */ isJson),
/* harmony export */   "isModel": () => (/* binding */ isModel),
/* harmony export */   "isServerlessDecision": () => (/* binding */ isServerlessDecision),
/* harmony export */   "isServerlessWorkflow": () => (/* binding */ isServerlessWorkflow),
/* harmony export */   "isServerlessWorkflowJson": () => (/* binding */ isServerlessWorkflowJson),
/* harmony export */   "isServerlessWorkflowYaml": () => (/* binding */ isServerlessWorkflowYaml),
/* harmony export */   "isSpec": () => (/* binding */ isSpec),
/* harmony export */   "isSupportedByVirtualServiceRegistry": () => (/* binding */ isSupportedByVirtualServiceRegistry),
/* harmony export */   "isYaml": () => (/* binding */ isYaml),
/* harmony export */   "splitFiles": () => (/* binding */ splitFiles),
/* harmony export */   "supportedFileExtensionArray": () => (/* binding */ supportedFileExtensionArray)
/* harmony export */ });
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ "../../node_modules/.pnpm/path-browserify@1.0.1/node_modules/path-browserify/index.js");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _project__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../project */ "./src/project/index.ts");


const EDIT_NON_MODEL_ALLOW_LIST = [_project__WEBPACK_IMPORTED_MODULE_1__.PROJECT_FILES.applicationProperties];
const REGEX = {
    supported: /(\.sw\.json|\.sw\.yaml|\.sw\.yml|\.yard\.json|\.yard\.yaml|\.yard\.yml|\.dash\.yml|\.dash\.yaml)$/i,
    sw: /^.*\.sw\.(json|yml|yaml)$/i,
    swJson: /^.*\.sw\.json$/i,
    swYaml: /^.*\.sw\.(yml|yaml)$/i,
    yard: /^.*\.yard\.(json|yml|yaml)$/i,
    dash: /^.*\.dash\.(yml|yaml)$/i,
    json: /^.*\.json$/i,
    yaml: /^.*\.(yml|yaml)$/i,
    spec: /^.*(\.spec|\.specs|spec|specs)\.(json|yml|yaml)$/i,
};
const GLOB_PATTERN = {
    all: "**/*",
    allExceptDockerfiles: "**/!(Dockerfile|.dockerignore)",
    sw: "**/*.sw.+(json|yml|yaml)",
    yard: "**/*.yard.+(json|yml|yaml)",
    dash: "**/*.dash.+(yml|yaml)",
    spec: "**/+(*.spec?(s)|spec?(s)).+(yml|yaml|json)",
    sw_spec: "**/+(*.sw|*.spec?(s)|spec?(s)).+(yml|yaml|json)",
};
var FileTypes;
(function (FileTypes) {
    FileTypes["SW_JSON"] = "sw.json";
    FileTypes["SW_YML"] = "sw.yml";
    FileTypes["SW_YAML"] = "sw.yaml";
    FileTypes["YARD_JSON"] = "yard.json";
    FileTypes["YARD_YML"] = "yard.yml";
    FileTypes["YARD_YAML"] = "yard.yaml";
    FileTypes["DASH_YAML"] = "dash.yaml";
    FileTypes["DASH_YML"] = "dash.yml";
})(FileTypes || (FileTypes = {}));
const supportedFileExtensionArray = [
    FileTypes.SW_JSON,
    FileTypes.SW_YML,
    FileTypes.SW_YAML,
    FileTypes.YARD_JSON,
    FileTypes.YARD_YML,
    FileTypes.YARD_YAML,
    FileTypes.DASH_YAML,
    FileTypes.DASH_YML,
];
function isServerlessWorkflow(path) {
    return REGEX.sw.test(path);
}
function isServerlessWorkflowJson(path) {
    return REGEX.swJson.test(path);
}
function isServerlessWorkflowYaml(path) {
    return REGEX.swYaml.test(path);
}
function isServerlessDecision(path) {
    return REGEX.yard.test(path);
}
function isDashbuilder(path) {
    return REGEX.dash.test(path);
}
function isModel(path) {
    return isServerlessWorkflow(path) || isServerlessDecision(path) || isDashbuilder(path);
}
function isEditable(path) {
    return isModel(path) || EDIT_NON_MODEL_ALLOW_LIST.includes((0,path__WEBPACK_IMPORTED_MODULE_0__.basename)(path));
}
function isSupportedByVirtualServiceRegistry(path) {
    return isServerlessWorkflow(path) || isSpec(path);
}
function isSpec(path) {
    return REGEX.spec.test(path);
}
function isJson(path) {
    return REGEX.json.test(path);
}
function isYaml(path) {
    return REGEX.yaml.test(path);
}
function splitFiles(files) {
    const [editableFiles, readonlyFiles] = files.reduce(([editableFiles, readonlyFiles], f) => isEditable(f.relativePath) ? [[...editableFiles, f], readonlyFiles] : [editableFiles, [...readonlyFiles, f]], [[], []]);
    return { editableFiles, readonlyFiles };
}


/***/ }),

/***/ "./src/project/index.ts":
/*!******************************!*\
  !*** ./src/project/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEFAULT_DOCKER_IGNORE_CONTENT": () => (/* binding */ DEFAULT_DOCKER_IGNORE_CONTENT),
/* harmony export */   "PROJECT_FILES": () => (/* binding */ PROJECT_FILES),
/* harmony export */   "buildProjectPaths": () => (/* binding */ buildProjectPaths),
/* harmony export */   "isProject": () => (/* binding */ isProject),
/* harmony export */   "isSingleModuleProject": () => (/* binding */ isSingleModuleProject)
/* harmony export */ });
const PROJECT_FILES = {
    pomXml: "pom.xml",
    applicationProperties: "application.properties",
    dockerFile: "Dockerfile",
    dockerIgnore: ".dockerignore",
    kogitoYml: "kogito.yml",
    quarkusRunJar: "quarkus-run.jar",
};
function isProject(files) {
    return !!files.some((f) => f.relativePath === PROJECT_FILES.pomXml);
}
function isSingleModuleProject(files) {
    const pomFiles = files.filter((f) => f.name === PROJECT_FILES.pomXml);
    return pomFiles.length === 1 && pomFiles[0].relativeDirPath === "";
}
const buildProjectPaths = (projectFolder) => ({
    folders: {
        root: `${projectFolder}`,
        mainResources: `${projectFolder}/src/main/resources`,
        metaInfResources: `${projectFolder}/src/main/resources/META-INF/resources`,
        kubernetes: `${projectFolder}/target/kubernetes`,
        quarkusApp: `${projectFolder}/target/quarkus-app`,
    },
    files: {
        pomXml: `${projectFolder}/${PROJECT_FILES.pomXml}`,
        kogitoYaml: `${projectFolder}/target/kubernetes/${PROJECT_FILES.kogitoYml}`,
        quarkusRunJar: `${projectFolder}/target/quarkus-app/${PROJECT_FILES.quarkusRunJar}`,
    },
});
const DEFAULT_DOCKER_IGNORE_CONTENT = `
${PROJECT_FILES.dockerFile}
`;


/***/ }),

/***/ "../../node_modules/.pnpm/isomorphic-git@1.11.1/node_modules/isomorphic-git/http/web/index.js":
/*!****************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/isomorphic-git@1.11.1/node_modules/isomorphic-git/http/web/index.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "request": () => (/* binding */ request)
/* harmony export */ });
/**
 * @typedef {Object} GitProgressEvent
 * @property {string} phase
 * @property {number} loaded
 * @property {number} total
 */

/**
 * @callback ProgressCallback
 * @param {GitProgressEvent} progress
 * @returns {void | Promise<void>}
 */

/**
 * @typedef {Object} GitHttpRequest
 * @property {string} url - The URL to request
 * @property {string} [method='GET'] - The HTTP method to use
 * @property {Object<string, string>} [headers={}] - Headers to include in the HTTP request
 * @property {AsyncIterableIterator<Uint8Array>} [body] - An async iterator of Uint8Arrays that make up the body of POST requests
 * @property {ProgressCallback} [onProgress] - Reserved for future use (emitting `GitProgressEvent`s)
 * @property {object} [signal] - Reserved for future use (canceling a request)
 */

/**
 * @typedef {Object} GitHttpResponse
 * @property {string} url - The final URL that was fetched after any redirects
 * @property {string} [method] - The HTTP method that was used
 * @property {Object<string, string>} [headers] - HTTP response headers
 * @property {AsyncIterableIterator<Uint8Array>} [body] - An async iterator of Uint8Arrays that make up the body of the response
 * @property {number} statusCode - The HTTP status code
 * @property {string} statusMessage - The HTTP status message
 */

/**
 * @callback HttpFetch
 * @param {GitHttpRequest} request
 * @returns {Promise<GitHttpResponse>}
 */

/**
 * @typedef {Object} HttpClient
 * @property {HttpFetch} request
 */

// Convert a value to an Async Iterator
// This will be easier with async generator functions.
function fromValue(value) {
  let queue = [value];
  return {
    next() {
      return Promise.resolve({ done: queue.length === 0, value: queue.pop() })
    },
    return() {
      queue = [];
      return {}
    },
    [Symbol.asyncIterator]() {
      return this
    },
  }
}

function getIterator(iterable) {
  if (iterable[Symbol.asyncIterator]) {
    return iterable[Symbol.asyncIterator]()
  }
  if (iterable[Symbol.iterator]) {
    return iterable[Symbol.iterator]()
  }
  if (iterable.next) {
    return iterable
  }
  return fromValue(iterable)
}

// Currently 'for await' upsets my linters.
async function forAwait(iterable, cb) {
  const iter = getIterator(iterable);
  while (true) {
    const { value, done } = await iter.next();
    if (value) await cb(value);
    if (done) break
  }
  if (iter.return) iter.return();
}

async function collect(iterable) {
  let size = 0;
  const buffers = [];
  // This will be easier once `for await ... of` loops are available.
  await forAwait(iterable, value => {
    buffers.push(value);
    size += value.byteLength;
  });
  const result = new Uint8Array(size);
  let nextIndex = 0;
  for (const buffer of buffers) {
    result.set(buffer, nextIndex);
    nextIndex += buffer.byteLength;
  }
  return result
}

// Convert a web ReadableStream (not Node stream!) to an Async Iterator
// adapted from https://jakearchibald.com/2017/async-iterators-and-generators/
function fromStream(stream) {
  // Use native async iteration if it's available.
  if (stream[Symbol.asyncIterator]) return stream
  const reader = stream.getReader();
  return {
    next() {
      return reader.read()
    },
    return() {
      reader.releaseLock();
      return {}
    },
    [Symbol.asyncIterator]() {
      return this
    },
  }
}

/* eslint-env browser */

/**
 * HttpClient
 *
 * @param {GitHttpRequest} request
 * @returns {Promise<GitHttpResponse>}
 */
async function request({
  onProgress,
  url,
  method = 'GET',
  headers = {},
  body,
}) {
  // streaming uploads aren't possible yet in the browser
  if (body) {
    body = await collect(body);
  }
  const res = await fetch(url, { method, headers, body });
  const iter =
    res.body && res.body.getReader
      ? fromStream(res.body)
      : [new Uint8Array(await res.arrayBuffer())];
  // convert Header object to ordinary JSON
  headers = {};
  for (const [key, value] of res.headers.entries()) {
    headers[key] = value;
  }
  return {
    url: res.url,
    method: res.method,
    statusCode: res.status,
    statusMessage: res.statusText,
    body: iter,
    headers: headers,
  }
}

var index = { request };

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);



/***/ }),

/***/ "../../node_modules/.pnpm/isomorphic-git@1.11.1/node_modules/isomorphic-git/index.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/isomorphic-git@1.11.1/node_modules/isomorphic-git/index.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Errors": () => (/* binding */ Errors),
/* harmony export */   "STAGE": () => (/* binding */ STAGE),
/* harmony export */   "TREE": () => (/* binding */ TREE),
/* harmony export */   "WORKDIR": () => (/* binding */ WORKDIR),
/* harmony export */   "add": () => (/* binding */ add),
/* harmony export */   "addNote": () => (/* binding */ addNote),
/* harmony export */   "addRemote": () => (/* binding */ addRemote),
/* harmony export */   "annotatedTag": () => (/* binding */ annotatedTag),
/* harmony export */   "branch": () => (/* binding */ branch),
/* harmony export */   "checkout": () => (/* binding */ checkout),
/* harmony export */   "clone": () => (/* binding */ clone),
/* harmony export */   "commit": () => (/* binding */ commit),
/* harmony export */   "currentBranch": () => (/* binding */ currentBranch),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "deleteBranch": () => (/* binding */ deleteBranch),
/* harmony export */   "deleteRef": () => (/* binding */ deleteRef),
/* harmony export */   "deleteRemote": () => (/* binding */ deleteRemote),
/* harmony export */   "deleteTag": () => (/* binding */ deleteTag),
/* harmony export */   "expandOid": () => (/* binding */ expandOid),
/* harmony export */   "expandRef": () => (/* binding */ expandRef),
/* harmony export */   "fastForward": () => (/* binding */ fastForward),
/* harmony export */   "fetch": () => (/* binding */ fetch),
/* harmony export */   "findMergeBase": () => (/* binding */ findMergeBase),
/* harmony export */   "findRoot": () => (/* binding */ findRoot),
/* harmony export */   "getConfig": () => (/* binding */ getConfig),
/* harmony export */   "getConfigAll": () => (/* binding */ getConfigAll),
/* harmony export */   "getRemoteInfo": () => (/* binding */ getRemoteInfo),
/* harmony export */   "getRemoteInfo2": () => (/* binding */ getRemoteInfo2),
/* harmony export */   "hashBlob": () => (/* binding */ hashBlob),
/* harmony export */   "indexPack": () => (/* binding */ indexPack),
/* harmony export */   "init": () => (/* binding */ init),
/* harmony export */   "isDescendent": () => (/* binding */ isDescendent),
/* harmony export */   "isIgnored": () => (/* binding */ isIgnored),
/* harmony export */   "listBranches": () => (/* binding */ listBranches),
/* harmony export */   "listFiles": () => (/* binding */ listFiles),
/* harmony export */   "listNotes": () => (/* binding */ listNotes),
/* harmony export */   "listRemotes": () => (/* binding */ listRemotes),
/* harmony export */   "listServerRefs": () => (/* binding */ listServerRefs),
/* harmony export */   "listTags": () => (/* binding */ listTags),
/* harmony export */   "log": () => (/* binding */ log),
/* harmony export */   "merge": () => (/* binding */ merge),
/* harmony export */   "packObjects": () => (/* binding */ packObjects),
/* harmony export */   "pull": () => (/* binding */ pull),
/* harmony export */   "push": () => (/* binding */ push),
/* harmony export */   "readBlob": () => (/* binding */ readBlob),
/* harmony export */   "readCommit": () => (/* binding */ readCommit),
/* harmony export */   "readNote": () => (/* binding */ readNote),
/* harmony export */   "readObject": () => (/* binding */ readObject),
/* harmony export */   "readTag": () => (/* binding */ readTag),
/* harmony export */   "readTree": () => (/* binding */ readTree),
/* harmony export */   "remove": () => (/* binding */ remove),
/* harmony export */   "removeNote": () => (/* binding */ removeNote),
/* harmony export */   "renameBranch": () => (/* binding */ renameBranch),
/* harmony export */   "resetIndex": () => (/* binding */ resetIndex),
/* harmony export */   "resolveRef": () => (/* binding */ resolveRef),
/* harmony export */   "setConfig": () => (/* binding */ setConfig),
/* harmony export */   "status": () => (/* binding */ status),
/* harmony export */   "statusMatrix": () => (/* binding */ statusMatrix),
/* harmony export */   "tag": () => (/* binding */ tag),
/* harmony export */   "version": () => (/* binding */ version),
/* harmony export */   "walk": () => (/* binding */ walk),
/* harmony export */   "writeBlob": () => (/* binding */ writeBlob),
/* harmony export */   "writeCommit": () => (/* binding */ writeCommit),
/* harmony export */   "writeObject": () => (/* binding */ writeObject),
/* harmony export */   "writeRef": () => (/* binding */ writeRef),
/* harmony export */   "writeTag": () => (/* binding */ writeTag),
/* harmony export */   "writeTree": () => (/* binding */ writeTree)
/* harmony export */ });
/* harmony import */ var async_lock__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! async-lock */ "../../node_modules/.pnpm/async-lock@1.3.0/node_modules/async-lock/index.js");
/* harmony import */ var sha_js_sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sha.js/sha1.js */ "../../node_modules/.pnpm/sha.js@2.4.11/node_modules/sha.js/sha1.js");
/* harmony import */ var crc_32__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crc-32 */ "../../node_modules/.pnpm/crc-32@1.2.0/node_modules/crc-32/crc32.js");
/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pako */ "../../node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js");
/* harmony import */ var ignore__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ignore */ "../../node_modules/.pnpm/ignore@5.2.0/node_modules/ignore/index.js");
/* harmony import */ var pify__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! pify */ "../../node_modules/.pnpm/pify@4.0.1/node_modules/pify/index.js");
/* harmony import */ var clean_git_ref__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! clean-git-ref */ "../../node_modules/.pnpm/clean-git-ref@2.0.1/node_modules/clean-git-ref/lib/index.js");
/* harmony import */ var diff3__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! diff3 */ "../../node_modules/.pnpm/diff3@0.0.3/node_modules/diff3/diff3.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js")["Buffer"];









/**
 * @typedef {Object} GitProgressEvent
 * @property {string} phase
 * @property {number} loaded
 * @property {number} total
 */

/**
 * @callback ProgressCallback
 * @param {GitProgressEvent} progress
 * @returns {void | Promise<void>}
 */

/**
 * @typedef {Object} GitHttpRequest
 * @property {string} url - The URL to request
 * @property {string} [method='GET'] - The HTTP method to use
 * @property {Object<string, string>} [headers={}] - Headers to include in the HTTP request
 * @property {AsyncIterableIterator<Uint8Array>} [body] - An async iterator of Uint8Arrays that make up the body of POST requests
 * @property {ProgressCallback} [onProgress] - Reserved for future use (emitting `GitProgressEvent`s)
 * @property {object} [signal] - Reserved for future use (canceling a request)
 */

/**
 * @typedef {Object} GitHttpResponse
 * @property {string} url - The final URL that was fetched after any redirects
 * @property {string} [method] - The HTTP method that was used
 * @property {Object<string, string>} [headers] - HTTP response headers
 * @property {AsyncIterableIterator<Uint8Array>} [body] - An async iterator of Uint8Arrays that make up the body of the response
 * @property {number} statusCode - The HTTP status code
 * @property {string} statusMessage - The HTTP status message
 */

/**
 * @callback HttpFetch
 * @param {GitHttpRequest} request
 * @returns {Promise<GitHttpResponse>}
 */

/**
 * @typedef {Object} HttpClient
 * @property {HttpFetch} request
 */

/**
 * A git commit object.
 *
 * @typedef {Object} CommitObject
 * @property {string} message Commit message
 * @property {string} tree SHA-1 object id of corresponding file tree
 * @property {string[]} parent an array of zero or more SHA-1 object ids
 * @property {Object} author
 * @property {string} author.name The author's name
 * @property {string} author.email The author's email
 * @property {number} author.timestamp UTC Unix timestamp in seconds
 * @property {number} author.timezoneOffset Timezone difference from UTC in minutes
 * @property {Object} committer
 * @property {string} committer.name The committer's name
 * @property {string} committer.email The committer's email
 * @property {number} committer.timestamp UTC Unix timestamp in seconds
 * @property {number} committer.timezoneOffset Timezone difference from UTC in minutes
 * @property {string} [gpgsig] PGP signature (if present)
 */

/**
 * An entry from a git tree object. Files are called 'blobs' and directories are called 'trees'.
 *
 * @typedef {Object} TreeEntry
 * @property {string} mode the 6 digit hexadecimal mode
 * @property {string} path the name of the file or directory
 * @property {string} oid the SHA-1 object id of the blob or tree
 * @property {'commit'|'blob'|'tree'} type the type of object
 */

/**
 * A git tree object. Trees represent a directory snapshot.
 *
 * @typedef {TreeEntry[]} TreeObject
 */

/**
 * A git annotated tag object.
 *
 * @typedef {Object} TagObject
 * @property {string} object SHA-1 object id of object being tagged
 * @property {'blob' | 'tree' | 'commit' | 'tag'} type the type of the object being tagged
 * @property {string} tag the tag name
 * @property {Object} tagger
 * @property {string} tagger.name the tagger's name
 * @property {string} tagger.email the tagger's email
 * @property {number} tagger.timestamp UTC Unix timestamp in seconds
 * @property {number} tagger.timezoneOffset timezone difference from UTC in minutes
 * @property {string} message tag message
 * @property {string} [gpgsig] PGP signature (if present)
 */

/**
 * @typedef {Object} ReadCommitResult
 * @property {string} oid - SHA-1 object id of this commit
 * @property {CommitObject} commit - the parsed commit object
 * @property {string} payload - PGP signing payload
 */

/**
 * @typedef {Object} ServerRef - This object has the following schema:
 * @property {string} ref - The name of the ref
 * @property {string} oid - The SHA-1 object id the ref points to
 * @property {string} [target] - The target ref pointed to by a symbolic ref
 * @property {string} [peeled] - If the oid is the SHA-1 object id of an annotated tag, this is the SHA-1 object id that the annotated tag points to
 */

/**
 * @typedef Walker
 * @property {Symbol} Symbol('GitWalkerSymbol')
 */

/**
 * Normalized subset of filesystem `stat` data:
 *
 * @typedef {Object} Stat
 * @property {number} ctimeSeconds
 * @property {number} ctimeNanoseconds
 * @property {number} mtimeSeconds
 * @property {number} mtimeNanoseconds
 * @property {number} dev
 * @property {number} ino
 * @property {number} mode
 * @property {number} uid
 * @property {number} gid
 * @property {number} size
 */

/**
 * The `WalkerEntry` is an interface that abstracts computing many common tree / blob stats.
 *
 * @typedef {Object} WalkerEntry
 * @property {function(): Promise<'tree'|'blob'|'special'|'commit'>} type
 * @property {function(): Promise<number>} mode
 * @property {function(): Promise<string>} oid
 * @property {function(): Promise<Uint8Array|void>} content
 * @property {function(): Promise<Stat>} stat
 */

/**
 * @typedef {Object} CallbackFsClient
 * @property {function} readFile - https://nodejs.org/api/fs.html#fs_fs_readfile_path_options_callback
 * @property {function} writeFile - https://nodejs.org/api/fs.html#fs_fs_writefile_file_data_options_callback
 * @property {function} unlink - https://nodejs.org/api/fs.html#fs_fs_unlink_path_callback
 * @property {function} readdir - https://nodejs.org/api/fs.html#fs_fs_readdir_path_options_callback
 * @property {function} mkdir - https://nodejs.org/api/fs.html#fs_fs_mkdir_path_mode_callback
 * @property {function} rmdir - https://nodejs.org/api/fs.html#fs_fs_rmdir_path_callback
 * @property {function} stat - https://nodejs.org/api/fs.html#fs_fs_stat_path_options_callback
 * @property {function} lstat - https://nodejs.org/api/fs.html#fs_fs_lstat_path_options_callback
 * @property {function} [readlink] - https://nodejs.org/api/fs.html#fs_fs_readlink_path_options_callback
 * @property {function} [symlink] - https://nodejs.org/api/fs.html#fs_fs_symlink_target_path_type_callback
 * @property {function} [chmod] - https://nodejs.org/api/fs.html#fs_fs_chmod_path_mode_callback
 */

/**
 * @typedef {Object} PromiseFsClient
 * @property {Object} promises
 * @property {function} promises.readFile - https://nodejs.org/api/fs.html#fs_fspromises_readfile_path_options
 * @property {function} promises.writeFile - https://nodejs.org/api/fs.html#fs_fspromises_writefile_file_data_options
 * @property {function} promises.unlink - https://nodejs.org/api/fs.html#fs_fspromises_unlink_path
 * @property {function} promises.readdir - https://nodejs.org/api/fs.html#fs_fspromises_readdir_path_options
 * @property {function} promises.mkdir - https://nodejs.org/api/fs.html#fs_fspromises_mkdir_path_options
 * @property {function} promises.rmdir - https://nodejs.org/api/fs.html#fs_fspromises_rmdir_path
 * @property {function} promises.stat - https://nodejs.org/api/fs.html#fs_fspromises_stat_path_options
 * @property {function} promises.lstat - https://nodejs.org/api/fs.html#fs_fspromises_lstat_path_options
 * @property {function} [promises.readlink] - https://nodejs.org/api/fs.html#fs_fspromises_readlink_path_options
 * @property {function} [promises.symlink] - https://nodejs.org/api/fs.html#fs_fspromises_symlink_target_path_type
 * @property {function} [promises.chmod] - https://nodejs.org/api/fs.html#fs_fspromises_chmod_path_mode
 */

/**
 * @typedef {CallbackFsClient | PromiseFsClient} FsClient
 */

/**
 * @callback MessageCallback
 * @param {string} message
 * @returns {void | Promise<void>}
 */

/**
 * @typedef {Object} GitAuth
 * @property {string} [username]
 * @property {string} [password]
 * @property {Object<string, string>} [headers]
 * @property {boolean} [cancel] Tells git to throw a `UserCanceledError` (instead of an `HttpError`).
 */

/**
 * @callback AuthCallback
 * @param {string} url
 * @param {GitAuth} auth Might have some values if the URL itself originally contained a username or password.
 * @returns {GitAuth | void | Promise<GitAuth | void>}
 */

/**
 * @callback AuthFailureCallback
 * @param {string} url
 * @param {GitAuth} auth The credentials that failed
 * @returns {GitAuth | void | Promise<GitAuth | void>}
 */

/**
 * @callback AuthSuccessCallback
 * @param {string} url
 * @param {GitAuth} auth
 * @returns {void | Promise<void>}
 */

/**
 * @typedef {Object} SignParams
 * @property {string} payload - a plaintext message
 * @property {string} secretKey - an 'ASCII armor' encoded PGP key (technically can actually contain _multiple_ keys)
 */

/**
 * @callback SignCallback
 * @param {SignParams} args
 * @return {{signature: string} | Promise<{signature: string}>} - an 'ASCII armor' encoded "detached" signature
 */

/**
 * @callback WalkerMap
 * @param {string} filename
 * @param {WalkerEntry[]} entries
 * @returns {Promise<any>}
 */

/**
 * @callback WalkerReduce
 * @param {any} parent
 * @param {any[]} children
 * @returns {Promise<any>}
 */

/**
 * @callback WalkerIterateCallback
 * @param {WalkerEntry[]} entries
 * @returns {Promise<any[]>}
 */

/**
 * @callback WalkerIterate
 * @param {WalkerIterateCallback} walk
 * @param {IterableIterator<WalkerEntry[]>} children
 * @returns {Promise<any[]>}
 */

/**
 * @typedef {Object} RefUpdateStatus
 * @property {boolean} ok
 * @property {string} error
 */

/**
 * @typedef {Object} PushResult
 * @property {boolean} ok
 * @property {?string} error
 * @property {Object<string, RefUpdateStatus>} refs
 * @property {Object<string, string>} [headers]
 */

/**
 * @typedef {0|1} HeadStatus
 */

/**
 * @typedef {0|1|2} WorkdirStatus
 */

/**
 * @typedef {0|1|2|3} StageStatus
 */

/**
 * @typedef {[string, HeadStatus, WorkdirStatus, StageStatus]} StatusRow
 */

class BaseError extends Error {
  constructor(message) {
    super(message);
    // Setting this here allows TS to infer that all git errors have a `caller` property and
    // that its type is string.
    this.caller = '';
  }

  toJSON() {
    // Error objects aren't normally serializable. So we do something about that.
    return {
      code: this.code,
      data: this.data,
      caller: this.caller,
      message: this.message,
      stack: this.stack,
    }
  }

  fromJSON(json) {
    const e = new BaseError(json.message);
    e.code = json.code;
    e.data = json.data;
    e.caller = json.caller;
    e.stack = json.stack;
    return e
  }

  get isIsomorphicGitError() {
    return true
  }
}

class InternalError extends BaseError {
  /**
   * @param {string} message
   */
  constructor(message) {
    super(
      `An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${message}`
    );
    this.code = this.name = InternalError.code;
    this.data = { message };
  }
}
/** @type {'InternalError'} */
InternalError.code = 'InternalError';

class UnsafeFilepathError extends BaseError {
  /**
   * @param {string} filepath
   */
  constructor(filepath) {
    super(`The filepath "${filepath}" contains unsafe character sequences`);
    this.code = this.name = UnsafeFilepathError.code;
    this.data = { filepath };
  }
}
/** @type {'UnsafeFilepathError'} */
UnsafeFilepathError.code = 'UnsafeFilepathError';

// Modeled after https://github.com/tjfontaine/node-buffercursor
// but with the goal of being much lighter weight.
class BufferCursor {
  constructor(buffer) {
    this.buffer = buffer;
    this._start = 0;
  }

  eof() {
    return this._start >= this.buffer.length
  }

  tell() {
    return this._start
  }

  seek(n) {
    this._start = n;
  }

  slice(n) {
    const r = this.buffer.slice(this._start, this._start + n);
    this._start += n;
    return r
  }

  toString(enc, length) {
    const r = this.buffer.toString(enc, this._start, this._start + length);
    this._start += length;
    return r
  }

  write(value, length, enc) {
    const r = this.buffer.write(value, this._start, length, enc);
    this._start += length;
    return r
  }

  copy(source, start, end) {
    const r = source.copy(this.buffer, this._start, start, end);
    this._start += r;
    return r
  }

  readUInt8() {
    const r = this.buffer.readUInt8(this._start);
    this._start += 1;
    return r
  }

  writeUInt8(value) {
    const r = this.buffer.writeUInt8(value, this._start);
    this._start += 1;
    return r
  }

  readUInt16BE() {
    const r = this.buffer.readUInt16BE(this._start);
    this._start += 2;
    return r
  }

  writeUInt16BE(value) {
    const r = this.buffer.writeUInt16BE(value, this._start);
    this._start += 2;
    return r
  }

  readUInt32BE() {
    const r = this.buffer.readUInt32BE(this._start);
    this._start += 4;
    return r
  }

  writeUInt32BE(value) {
    const r = this.buffer.writeUInt32BE(value, this._start);
    this._start += 4;
    return r
  }
}

function compareStrings(a, b) {
  // https://stackoverflow.com/a/40355107/2168416
  return -(a < b) || +(a > b)
}

function comparePath(a, b) {
  // https://stackoverflow.com/a/40355107/2168416
  return compareStrings(a.path, b.path)
}

/**
 * From https://github.com/git/git/blob/master/Documentation/technical/index-format.txt
 *
 * 32-bit mode, split into (high to low bits)
 *
 *  4-bit object type
 *    valid values in binary are 1000 (regular file), 1010 (symbolic link)
 *    and 1110 (gitlink)
 *
 *  3-bit unused
 *
 *  9-bit unix permission. Only 0755 and 0644 are valid for regular files.
 *  Symbolic links and gitlinks have value 0 in this field.
 */
function normalizeMode(mode) {
  // Note: BrowserFS will use -1 for "unknown"
  // I need to make it non-negative for these bitshifts to work.
  let type = mode > 0 ? mode >> 12 : 0;
  // If it isn't valid, assume it as a "regular file"
  // 0100 = directory
  // 1000 = regular file
  // 1010 = symlink
  // 1110 = gitlink
  if (
    type !== 0b0100 &&
    type !== 0b1000 &&
    type !== 0b1010 &&
    type !== 0b1110
  ) {
    type = 0b1000;
  }
  let permissions = mode & 0o777;
  // Is the file executable? then 755. Else 644.
  if (permissions & 0b001001001) {
    permissions = 0o755;
  } else {
    permissions = 0o644;
  }
  // If it's not a regular file, scrub all permissions
  if (type !== 0b1000) permissions = 0;
  return (type << 12) + permissions
}

const MAX_UINT32 = 2 ** 32;

function SecondsNanoseconds(
  givenSeconds,
  givenNanoseconds,
  milliseconds,
  date
) {
  if (givenSeconds !== undefined && givenNanoseconds !== undefined) {
    return [givenSeconds, givenNanoseconds]
  }
  if (milliseconds === undefined) {
    milliseconds = date.valueOf();
  }
  const seconds = Math.floor(milliseconds / 1000);
  const nanoseconds = (milliseconds - seconds * 1000) * 1000000;
  return [seconds, nanoseconds]
}

function normalizeStats(e) {
  const [ctimeSeconds, ctimeNanoseconds] = SecondsNanoseconds(
    e.ctimeSeconds,
    e.ctimeNanoseconds,
    e.ctimeMs,
    e.ctime
  );
  const [mtimeSeconds, mtimeNanoseconds] = SecondsNanoseconds(
    e.mtimeSeconds,
    e.mtimeNanoseconds,
    e.mtimeMs,
    e.mtime
  );

  return {
    ctimeSeconds: ctimeSeconds % MAX_UINT32,
    ctimeNanoseconds: ctimeNanoseconds % MAX_UINT32,
    mtimeSeconds: mtimeSeconds % MAX_UINT32,
    mtimeNanoseconds: mtimeNanoseconds % MAX_UINT32,
    dev: e.dev % MAX_UINT32,
    ino: e.ino % MAX_UINT32,
    mode: normalizeMode(e.mode % MAX_UINT32),
    uid: e.uid % MAX_UINT32,
    gid: e.gid % MAX_UINT32,
    // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers
    // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat
    size: e.size > -1 ? e.size % MAX_UINT32 : 0,
  }
}

function toHex(buffer) {
  let hex = '';
  for (const byte of new Uint8Array(buffer)) {
    if (byte < 16) hex += '0';
    hex += byte.toString(16);
  }
  return hex
}

/* eslint-env node, browser */

let supportsSubtleSHA1 = null;

async function shasum(buffer) {
  if (supportsSubtleSHA1 === null) {
    supportsSubtleSHA1 = await testSubtleSHA1();
  }
  return supportsSubtleSHA1 ? subtleSHA1(buffer) : shasumSync(buffer)
}

// This is modeled after @dominictarr's "shasum" module,
// but without the 'json-stable-stringify' dependency and
// extra type-casting features.
function shasumSync(buffer) {
  return new sha_js_sha1_js__WEBPACK_IMPORTED_MODULE_1__().update(buffer).digest('hex')
}

async function subtleSHA1(buffer) {
  const hash = await crypto.subtle.digest('SHA-1', buffer);
  return toHex(hash)
}

async function testSubtleSHA1() {
  // I'm using a rather crude method of progressive enhancement, because
  // some browsers that have crypto.subtle.digest don't actually implement SHA-1.
  try {
    const hash = await subtleSHA1(new Uint8Array([]));
    if (hash === 'da39a3ee5e6b4b0d3255bfef95601890afd80709') return true
  } catch (_) {
    // no bother
  }
  return false
}

// Extract 1-bit assume-valid, 1-bit extended flag, 2-bit merge state flag, 12-bit path length flag
function parseCacheEntryFlags(bits) {
  return {
    assumeValid: Boolean(bits & 0b1000000000000000),
    extended: Boolean(bits & 0b0100000000000000),
    stage: (bits & 0b0011000000000000) >> 12,
    nameLength: bits & 0b0000111111111111,
  }
}

function renderCacheEntryFlags(entry) {
  const flags = entry.flags;
  // 1-bit extended flag (must be zero in version 2)
  flags.extended = false;
  // 12-bit name length if the length is less than 0xFFF; otherwise 0xFFF
  // is stored in this field.
  flags.nameLength = Math.min(Buffer.from(entry.path).length, 0xfff);
  return (
    (flags.assumeValid ? 0b1000000000000000 : 0) +
    (flags.extended ? 0b0100000000000000 : 0) +
    ((flags.stage & 0b11) << 12) +
    (flags.nameLength & 0b111111111111)
  )
}

class GitIndex {
  /*::
   _entries: Map<string, CacheEntry>
   _dirty: boolean // Used to determine if index needs to be saved to filesystem
   */
  constructor(entries) {
    this._dirty = false;
    this._entries = entries || new Map();
  }

  static async from(buffer) {
    if (Buffer.isBuffer(buffer)) {
      return GitIndex.fromBuffer(buffer)
    } else if (buffer === null) {
      return new GitIndex(null)
    } else {
      throw new InternalError('invalid type passed to GitIndex.from')
    }
  }

  static async fromBuffer(buffer) {
    // Verify shasum
    const shaComputed = await shasum(buffer.slice(0, -20));
    const shaClaimed = buffer.slice(-20).toString('hex');
    if (shaClaimed !== shaComputed) {
      throw new InternalError(
        `Invalid checksum in GitIndex buffer: expected ${shaClaimed} but saw ${shaComputed}`
      )
    }
    const reader = new BufferCursor(buffer);
    const _entries = new Map();
    const magic = reader.toString('utf8', 4);
    if (magic !== 'DIRC') {
      throw new InternalError(`Inavlid dircache magic file number: ${magic}`)
    }
    const version = reader.readUInt32BE();
    if (version !== 2) {
      throw new InternalError(`Unsupported dircache version: ${version}`)
    }
    const numEntries = reader.readUInt32BE();
    let i = 0;
    while (!reader.eof() && i < numEntries) {
      const entry = {};
      entry.ctimeSeconds = reader.readUInt32BE();
      entry.ctimeNanoseconds = reader.readUInt32BE();
      entry.mtimeSeconds = reader.readUInt32BE();
      entry.mtimeNanoseconds = reader.readUInt32BE();
      entry.dev = reader.readUInt32BE();
      entry.ino = reader.readUInt32BE();
      entry.mode = reader.readUInt32BE();
      entry.uid = reader.readUInt32BE();
      entry.gid = reader.readUInt32BE();
      entry.size = reader.readUInt32BE();
      entry.oid = reader.slice(20).toString('hex');
      const flags = reader.readUInt16BE();
      entry.flags = parseCacheEntryFlags(flags);
      // TODO: handle if (version === 3 && entry.flags.extended)
      const pathlength = buffer.indexOf(0, reader.tell() + 1) - reader.tell();
      if (pathlength < 1) {
        throw new InternalError(`Got a path length of: ${pathlength}`)
      }
      // TODO: handle pathnames larger than 12 bits
      entry.path = reader.toString('utf8', pathlength);

      // Prevent malicious paths like "..\foo"
      if (entry.path.includes('..\\') || entry.path.includes('../')) {
        throw new UnsafeFilepathError(entry.path)
      }

      // The next bit is awkward. We expect 1 to 8 null characters
      // such that the total size of the entry is a multiple of 8 bits.
      // (Hence subtract 12 bytes for the header.)
      let padding = 8 - ((reader.tell() - 12) % 8);
      if (padding === 0) padding = 8;
      while (padding--) {
        const tmp = reader.readUInt8();
        if (tmp !== 0) {
          throw new InternalError(
            `Expected 1-8 null characters but got '${tmp}' after ${entry.path}`
          )
        } else if (reader.eof()) {
          throw new InternalError('Unexpected end of file')
        }
      }
      // end of awkward part
      _entries.set(entry.path, entry);
      i++;
    }
    return new GitIndex(_entries)
  }

  get entries() {
    return [...this._entries.values()].sort(comparePath)
  }

  get entriesMap() {
    return this._entries
  }

  *[Symbol.iterator]() {
    for (const entry of this.entries) {
      yield entry;
    }
  }

  insert({ filepath, stats, oid }) {
    stats = normalizeStats(stats);
    const bfilepath = Buffer.from(filepath);
    const entry = {
      ctimeSeconds: stats.ctimeSeconds,
      ctimeNanoseconds: stats.ctimeNanoseconds,
      mtimeSeconds: stats.mtimeSeconds,
      mtimeNanoseconds: stats.mtimeNanoseconds,
      dev: stats.dev,
      ino: stats.ino,
      // We provide a fallback value for `mode` here because not all fs
      // implementations assign it, but we use it in GitTree.
      // '100644' is for a "regular non-executable file"
      mode: stats.mode || 0o100644,
      uid: stats.uid,
      gid: stats.gid,
      size: stats.size,
      path: filepath,
      oid: oid,
      flags: {
        assumeValid: false,
        extended: false,
        stage: 0,
        nameLength: bfilepath.length < 0xfff ? bfilepath.length : 0xfff,
      },
    };
    this._entries.set(entry.path, entry);
    this._dirty = true;
  }

  delete({ filepath }) {
    if (this._entries.has(filepath)) {
      this._entries.delete(filepath);
    } else {
      for (const key of this._entries.keys()) {
        if (key.startsWith(filepath + '/')) {
          this._entries.delete(key);
        }
      }
    }
    this._dirty = true;
  }

  clear() {
    this._entries.clear();
    this._dirty = true;
  }

  render() {
    return this.entries
      .map(entry => `${entry.mode.toString(8)} ${entry.oid}    ${entry.path}`)
      .join('\n')
  }

  async toObject() {
    const header = Buffer.alloc(12);
    const writer = new BufferCursor(header);
    writer.write('DIRC', 4, 'utf8');
    writer.writeUInt32BE(2);
    writer.writeUInt32BE(this.entries.length);
    const body = Buffer.concat(
      this.entries.map(entry => {
        const bpath = Buffer.from(entry.path);
        // the fixed length + the filename + at least one null char => align by 8
        const length = Math.ceil((62 + bpath.length + 1) / 8) * 8;
        const written = Buffer.alloc(length);
        const writer = new BufferCursor(written);
        const stat = normalizeStats(entry);
        writer.writeUInt32BE(stat.ctimeSeconds);
        writer.writeUInt32BE(stat.ctimeNanoseconds);
        writer.writeUInt32BE(stat.mtimeSeconds);
        writer.writeUInt32BE(stat.mtimeNanoseconds);
        writer.writeUInt32BE(stat.dev);
        writer.writeUInt32BE(stat.ino);
        writer.writeUInt32BE(stat.mode);
        writer.writeUInt32BE(stat.uid);
        writer.writeUInt32BE(stat.gid);
        writer.writeUInt32BE(stat.size);
        writer.write(entry.oid, 20, 'hex');
        writer.writeUInt16BE(renderCacheEntryFlags(entry));
        writer.write(entry.path, bpath.length, 'utf8');
        return written
      })
    );
    const main = Buffer.concat([header, body]);
    const sum = await shasum(main);
    return Buffer.concat([main, Buffer.from(sum, 'hex')])
  }
}

function compareStats(entry, stats) {
  // Comparison based on the description in Paragraph 4 of
  // https://www.kernel.org/pub/software/scm/git/docs/technical/racy-git.txt
  const e = normalizeStats(entry);
  const s = normalizeStats(stats);
  const staleness =
    e.mode !== s.mode ||
    e.mtimeSeconds !== s.mtimeSeconds ||
    e.ctimeSeconds !== s.ctimeSeconds ||
    e.uid !== s.uid ||
    e.gid !== s.gid ||
    e.ino !== s.ino ||
    e.size !== s.size;
  return staleness
}

// import LockManager from 'travix-lock-manager'

// import Lock from '../utils.js'

// const lm = new LockManager()
let lock = null;

const IndexCache = Symbol('IndexCache');

function createCache() {
  return {
    map: new Map(),
    stats: new Map(),
  }
}

async function updateCachedIndexFile(fs, filepath, cache) {
  const stat = await fs.lstat(filepath);
  const rawIndexFile = await fs.read(filepath);
  const index = await GitIndex.from(rawIndexFile);
  // cache the GitIndex object so we don't need to re-read it every time.
  cache.map.set(filepath, index);
  // Save the stat data for the index so we know whether the cached file is stale (modified by an outside process).
  cache.stats.set(filepath, stat);
}

// Determine whether our copy of the index file is stale
async function isIndexStale(fs, filepath, cache) {
  const savedStats = cache.stats.get(filepath);
  if (savedStats === undefined) return true
  const currStats = await fs.lstat(filepath);
  if (savedStats === null) return false
  if (currStats === null) return false
  return compareStats(savedStats, currStats)
}

class GitIndexManager {
  /**
   *
   * @param {object} opts
   * @param {import('../models/FileSystem.js').FileSystem} opts.fs
   * @param {string} opts.gitdir
   * @param {object} opts.cache
   * @param {function(GitIndex): any} closure
   */
  static async acquire({ fs, gitdir, cache }, closure) {
    if (!cache[IndexCache]) cache[IndexCache] = createCache();

    const filepath = `${gitdir}/index`;
    if (lock === null) lock = new async_lock__WEBPACK_IMPORTED_MODULE_0__({ maxPending: Infinity });
    let result;
    await lock.acquire(filepath, async function() {
      // Acquire a file lock while we're reading the index
      // to make sure other processes aren't writing to it
      // simultaneously, which could result in a corrupted index.
      // const fileLock = await Lock(filepath)
      if (await isIndexStale(fs, filepath, cache[IndexCache])) {
        await updateCachedIndexFile(fs, filepath, cache[IndexCache]);
      }
      const index = cache[IndexCache].map.get(filepath);
      result = await closure(index);
      if (index._dirty) {
        // Acquire a file lock while we're writing the index file
        // let fileLock = await Lock(filepath)
        const buffer = await index.toObject();
        await fs.write(filepath, buffer);
        // Update cached stat value
        cache[IndexCache].stats.set(filepath, await fs.lstat(filepath));
        index._dirty = false;
      }
    });
    return result
  }
}

function basename(path) {
  const last = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\'));
  if (last > -1) {
    path = path.slice(last + 1);
  }
  return path
}

function dirname(path) {
  const last = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\'));
  if (last === -1) return '.'
  if (last === 0) return '/'
  return path.slice(0, last)
}

/*::
type Node = {
  type: string,
  fullpath: string,
  basename: string,
  metadata: Object, // mode, oid
  parent?: Node,
  children: Array<Node>
}
*/

function flatFileListToDirectoryStructure(files) {
  const inodes = new Map();
  const mkdir = function(name) {
    if (!inodes.has(name)) {
      const dir = {
        type: 'tree',
        fullpath: name,
        basename: basename(name),
        metadata: {},
        children: [],
      };
      inodes.set(name, dir);
      // This recursively generates any missing parent folders.
      // We do it after we've added the inode to the set so that
      // we don't recurse infinitely trying to create the root '.' dirname.
      dir.parent = mkdir(dirname(name));
      if (dir.parent && dir.parent !== dir) dir.parent.children.push(dir);
    }
    return inodes.get(name)
  };

  const mkfile = function(name, metadata) {
    if (!inodes.has(name)) {
      const file = {
        type: 'blob',
        fullpath: name,
        basename: basename(name),
        metadata: metadata,
        // This recursively generates any missing parent folders.
        parent: mkdir(dirname(name)),
        children: [],
      };
      if (file.parent) file.parent.children.push(file);
      inodes.set(name, file);
    }
    return inodes.get(name)
  };

  mkdir('.');
  for (const file of files) {
    mkfile(file.path, file);
  }
  return inodes
}

/**
 *
 * @param {number} mode
 */
function mode2type(mode) {
  // prettier-ignore
  switch (mode) {
    case 0o040000: return 'tree'
    case 0o100644: return 'blob'
    case 0o100755: return 'blob'
    case 0o120000: return 'blob'
    case 0o160000: return 'commit'
  }
  throw new InternalError(`Unexpected GitTree entry mode: ${mode.toString(8)}`)
}

class GitWalkerIndex {
  constructor({ fs, gitdir, cache }) {
    this.treePromise = GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function(index) {
        return flatFileListToDirectoryStructure(index.entries)
      }
    );
    const walker = this;
    this.ConstructEntry = class StageEntry {
      constructor(fullpath) {
        this._fullpath = fullpath;
        this._type = false;
        this._mode = false;
        this._stat = false;
        this._oid = false;
      }

      async type() {
        return walker.type(this)
      }

      async mode() {
        return walker.mode(this)
      }

      async stat() {
        return walker.stat(this)
      }

      async content() {
        return walker.content(this)
      }

      async oid() {
        return walker.oid(this)
      }
    };
  }

  async readdir(entry) {
    const filepath = entry._fullpath;
    const tree = await this.treePromise;
    const inode = tree.get(filepath);
    if (!inode) return null
    if (inode.type === 'blob') return null
    if (inode.type !== 'tree') {
      throw new Error(`ENOTDIR: not a directory, scandir '${filepath}'`)
    }
    const names = inode.children.map(inode => inode.fullpath);
    names.sort(compareStrings);
    return names
  }

  async type(entry) {
    if (entry._type === false) {
      await entry.stat();
    }
    return entry._type
  }

  async mode(entry) {
    if (entry._mode === false) {
      await entry.stat();
    }
    return entry._mode
  }

  async stat(entry) {
    if (entry._stat === false) {
      const tree = await this.treePromise;
      const inode = tree.get(entry._fullpath);
      if (!inode) {
        throw new Error(
          `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
        )
      }
      const stats = inode.type === 'tree' ? {} : normalizeStats(inode.metadata);
      entry._type = inode.type === 'tree' ? 'tree' : mode2type(stats.mode);
      entry._mode = stats.mode;
      if (inode.type === 'tree') {
        entry._stat = undefined;
      } else {
        entry._stat = stats;
      }
    }
    return entry._stat
  }

  async content(_entry) {
    // Cannot get content for an index entry
  }

  async oid(entry) {
    if (entry._oid === false) {
      const tree = await this.treePromise;
      const inode = tree.get(entry._fullpath);
      entry._oid = inode.metadata.oid;
    }
    return entry._oid
  }
}

// This is part of an elaborate system to facilitate code-splitting / tree-shaking.
// commands/walk.js can depend on only this, and the actual Walker classes exported
// can be opaque - only having a single property (this symbol) that is not enumerable,
// and thus the constructor can be passed as an argument to walk while being "unusable"
// outside of it.
const GitWalkSymbol = Symbol('GitWalkSymbol');

// @ts-check

/**
 * @returns {Walker}
 */
function STAGE() {
  const o = Object.create(null);
  Object.defineProperty(o, GitWalkSymbol, {
    value: function({ fs, gitdir, cache }) {
      return new GitWalkerIndex({ fs, gitdir, cache })
    },
  });
  Object.freeze(o);
  return o
}

// @ts-check

class NotFoundError extends BaseError {
  /**
   * @param {string} what
   */
  constructor(what) {
    super(`Could not find ${what}.`);
    this.code = this.name = NotFoundError.code;
    this.data = { what };
  }
}
/** @type {'NotFoundError'} */
NotFoundError.code = 'NotFoundError';

class ObjectTypeError extends BaseError {
  /**
   * @param {string} oid
   * @param {'blob'|'commit'|'tag'|'tree'} actual
   * @param {'blob'|'commit'|'tag'|'tree'} expected
   * @param {string} [filepath]
   */
  constructor(oid, actual, expected, filepath) {
    super(
      `Object ${oid} ${
        filepath ? `at ${filepath}` : ''
      }was anticipated to be a ${expected} but it is a ${actual}.`
    );
    this.code = this.name = ObjectTypeError.code;
    this.data = { oid, actual, expected, filepath };
  }
}
/** @type {'ObjectTypeError'} */
ObjectTypeError.code = 'ObjectTypeError';

class InvalidOidError extends BaseError {
  /**
   * @param {string} value
   */
  constructor(value) {
    super(`Expected a 40-char hex object id but saw "${value}".`);
    this.code = this.name = InvalidOidError.code;
    this.data = { value };
  }
}
/** @type {'InvalidOidError'} */
InvalidOidError.code = 'InvalidOidError';

class NoRefspecError extends BaseError {
  /**
   * @param {string} remote
   */
  constructor(remote) {
    super(`Could not find a fetch refspec for remote "${remote}". Make sure the config file has an entry like the following:
[remote "${remote}"]
\tfetch = +refs/heads/*:refs/remotes/origin/*
`);
    this.code = this.name = NoRefspecError.code;
    this.data = { remote };
  }
}
/** @type {'NoRefspecError'} */
NoRefspecError.code = 'NoRefspecError';

class GitPackedRefs {
  constructor(text) {
    this.refs = new Map();
    this.parsedConfig = [];
    if (text) {
      let key = null;
      this.parsedConfig = text
        .trim()
        .split('\n')
        .map(line => {
          if (/^\s*#/.test(line)) {
            return { line, comment: true }
          }
          const i = line.indexOf(' ');
          if (line.startsWith('^')) {
            // This is a oid for the commit associated with the annotated tag immediately preceding this line.
            // Trim off the '^'
            const value = line.slice(1);
            // The tagname^{} syntax is based on the output of `git show-ref --tags -d`
            this.refs.set(key + '^{}', value);
            return { line, ref: key, peeled: value }
          } else {
            // This is an oid followed by the ref name
            const value = line.slice(0, i);
            key = line.slice(i + 1);
            this.refs.set(key, value);
            return { line, ref: key, oid: value }
          }
        });
    }
    return this
  }

  static from(text) {
    return new GitPackedRefs(text)
  }

  delete(ref) {
    this.parsedConfig = this.parsedConfig.filter(entry => entry.ref !== ref);
    this.refs.delete(ref);
  }

  toString() {
    return this.parsedConfig.map(({ line }) => line).join('\n') + '\n'
  }
}

class GitRefSpec {
  constructor({ remotePath, localPath, force, matchPrefix }) {
    Object.assign(this, {
      remotePath,
      localPath,
      force,
      matchPrefix,
    });
  }

  static from(refspec) {
    const [
      forceMatch,
      remotePath,
      remoteGlobMatch,
      localPath,
      localGlobMatch,
    ] = refspec.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1);
    const force = forceMatch === '+';
    const remoteIsGlob = remoteGlobMatch === '*';
    const localIsGlob = localGlobMatch === '*';
    // validate
    // TODO: Make this check more nuanced, and depend on whether this is a fetch refspec or a push refspec
    if (remoteIsGlob !== localIsGlob) {
      throw new InternalError('Invalid refspec')
    }
    return new GitRefSpec({
      remotePath,
      localPath,
      force,
      matchPrefix: remoteIsGlob,
    })
    // TODO: We need to run resolveRef on both paths to expand them to their full name.
  }

  translate(remoteBranch) {
    if (this.matchPrefix) {
      if (remoteBranch.startsWith(this.remotePath)) {
        return this.localPath + remoteBranch.replace(this.remotePath, '')
      }
    } else {
      if (remoteBranch === this.remotePath) return this.localPath
    }
    return null
  }

  reverseTranslate(localBranch) {
    if (this.matchPrefix) {
      if (localBranch.startsWith(this.localPath)) {
        return this.remotePath + localBranch.replace(this.localPath, '')
      }
    } else {
      if (localBranch === this.localPath) return this.remotePath
    }
    return null
  }
}

class GitRefSpecSet {
  constructor(rules = []) {
    this.rules = rules;
  }

  static from(refspecs) {
    const rules = [];
    for (const refspec of refspecs) {
      rules.push(GitRefSpec.from(refspec)); // might throw
    }
    return new GitRefSpecSet(rules)
  }

  add(refspec) {
    const rule = GitRefSpec.from(refspec); // might throw
    this.rules.push(rule);
  }

  translate(remoteRefs) {
    const result = [];
    for (const rule of this.rules) {
      for (const remoteRef of remoteRefs) {
        const localRef = rule.translate(remoteRef);
        if (localRef) {
          result.push([remoteRef, localRef]);
        }
      }
    }
    return result
  }

  translateOne(remoteRef) {
    let result = null;
    for (const rule of this.rules) {
      const localRef = rule.translate(remoteRef);
      if (localRef) {
        result = localRef;
      }
    }
    return result
  }

  localNamespaces() {
    return this.rules
      .filter(rule => rule.matchPrefix)
      .map(rule => rule.localPath.replace(/\/$/, ''))
  }
}

function compareRefNames(a, b) {
  // https://stackoverflow.com/a/40355107/2168416
  const _a = a.replace(/\^\{\}$/, '');
  const _b = b.replace(/\^\{\}$/, '');
  const tmp = -(_a < _b) || +(_a > _b);
  if (tmp === 0) {
    return a.endsWith('^{}') ? 1 : -1
  }
  return tmp
}

function normalizePath(path) {
  const normalizedPath = path
      .replace(/\/\.\//g, "/") // Replace '/./' with '/'
      .replace(/\/{2,}/g, "/") // Replace consecutive '/'
      .replace(/^\/\.$/, "/") // if path === '/.' return '/'
      .replace(/^\.\/$/, ".") // if path === './' return '.'
      .replace(/^\.\//, "") // Remove leading './'
      .replace(/\/\.$/, "") // Remove trailing '/.'
      // .replace(/(.+)\/$/, '$1') // Remove trailing '/'
      .replace(/^$/, "."); // if path === '' return '.'
  return (normalizedPath.length > 1 && normalizedPath.endsWith("/")) ? normalizedPath.slice(0, -1) : normalizedPath;
}

// For some reason path.posix.join is undefined in webpack

function join(...parts) {
  return normalizePath(parts.map(normalizePath).join('/'))
}

// This is straight from parse_unit_factor in config.c of canonical git
const num = val => {
  val = val.toLowerCase();
  let n = parseInt(val);
  if (val.endsWith('k')) n *= 1024;
  if (val.endsWith('m')) n *= 1024 * 1024;
  if (val.endsWith('g')) n *= 1024 * 1024 * 1024;
  return n
};

// This is straight from git_parse_maybe_bool_text in config.c of canonical git
const bool = val => {
  val = val.trim().toLowerCase();
  if (val === 'true' || val === 'yes' || val === 'on') return true
  if (val === 'false' || val === 'no' || val === 'off') return false
  throw Error(
    `Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${val}`
  )
};

const schema = {
  core: {
    filemode: bool,
    bare: bool,
    logallrefupdates: bool,
    symlinks: bool,
    ignorecase: bool,
    bigFileThreshold: num,
  },
};

// https://git-scm.com/docs/git-config#_syntax

// section starts with [ and ends with ]
// section is alphanumeric (ASCII) with - and .
// section is case insensitive
// subsection is optionnal
// subsection is specified after section and one or more spaces
// subsection is specified between double quotes
const SECTION_LINE_REGEX = /^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/;
const SECTION_REGEX = /^[A-Za-z0-9-.]+$/;

// variable lines contain a name, and equal sign and then a value
// variable lines can also only contain a name (the implicit value is a boolean true)
// variable name is alphanumeric (ASCII) with -
// variable name starts with an alphabetic character
// variable name is case insensitive
const VARIABLE_LINE_REGEX = /^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/;
const VARIABLE_NAME_REGEX = /^[A-Za-z][A-Za-z-]*$/;

const VARIABLE_VALUE_COMMENT_REGEX = /^(.*?)( *[#;].*)$/;

const extractSectionLine = line => {
  const matches = SECTION_LINE_REGEX.exec(line);
  if (matches != null) {
    const [section, subsection] = matches.slice(1);
    return [section, subsection]
  }
  return null
};

const extractVariableLine = line => {
  const matches = VARIABLE_LINE_REGEX.exec(line);
  if (matches != null) {
    const [name, rawValue = 'true'] = matches.slice(1);
    const valueWithoutComments = removeComments(rawValue);
    const valueWithoutQuotes = removeQuotes(valueWithoutComments);
    return [name, valueWithoutQuotes]
  }
  return null
};

const removeComments = rawValue => {
  const commentMatches = VARIABLE_VALUE_COMMENT_REGEX.exec(rawValue);
  if (commentMatches == null) {
    return rawValue
  }
  const [valueWithoutComment, comment] = commentMatches.slice(1);
  // if odd number of quotes before and after comment => comment is escaped
  if (
    hasOddNumberOfQuotes(valueWithoutComment) &&
    hasOddNumberOfQuotes(comment)
  ) {
    return `${valueWithoutComment}${comment}`
  }
  return valueWithoutComment
};

const hasOddNumberOfQuotes = text => {
  const numberOfQuotes = (text.match(/(?:^|[^\\])"/g) || []).length;
  return numberOfQuotes % 2 !== 0
};

const removeQuotes = text => {
  return text.split('').reduce((newText, c, idx, text) => {
    const isQuote = c === '"' && text[idx - 1] !== '\\';
    const isEscapeForQuote = c === '\\' && text[idx + 1] === '"';
    if (isQuote || isEscapeForQuote) {
      return newText
    }
    return newText + c
  }, '')
};

const lower = text => {
  return text != null ? text.toLowerCase() : null
};

const getPath = (section, subsection, name) => {
  return [lower(section), subsection, lower(name)]
    .filter(a => a != null)
    .join('.')
};

const findLastIndex = (array, callback) => {
  return array.reduce((lastIndex, item, index) => {
    return callback(item) ? index : lastIndex
  }, -1)
};

// Note: there are a LOT of edge cases that aren't covered (e.g. keys in sections that also
// have subsections, [include] directives, etc.
class GitConfig {
  constructor(text) {
    let section = null;
    let subsection = null;
    this.parsedConfig = text.split('\n').map(line => {
      let name = null;
      let value = null;

      const trimmedLine = line.trim();
      const extractedSection = extractSectionLine(trimmedLine);
      const isSection = extractedSection != null;
      if (isSection) {
        ;[section, subsection] = extractedSection;
      } else {
        const extractedVariable = extractVariableLine(trimmedLine);
        const isVariable = extractedVariable != null;
        if (isVariable) {
          ;[name, value] = extractedVariable;
        }
      }

      const path = getPath(section, subsection, name);
      return { line, isSection, section, subsection, name, value, path }
    });
  }

  static from(text) {
    return new GitConfig(text)
  }

  async get(path, getall = false) {
    const allValues = this.parsedConfig
      .filter(config => config.path === path.toLowerCase())
      .map(({ section, name, value }) => {
        const fn = schema[section] && schema[section][name];
        return fn ? fn(value) : value
      });
    return getall ? allValues : allValues.pop()
  }

  async getall(path) {
    return this.get(path, true)
  }

  async getSubsections(section) {
    return this.parsedConfig
      .filter(config => config.section === section && config.isSection)
      .map(config => config.subsection)
  }

  async deleteSection(section, subsection) {
    this.parsedConfig = this.parsedConfig.filter(
      config =>
        !(config.section === section && config.subsection === subsection)
    );
  }

  async append(path, value) {
    return this.set(path, value, true)
  }

  async set(path, value, append = false) {
    const configIndex = findLastIndex(
      this.parsedConfig,
      config => config.path === path.toLowerCase()
    );
    if (value == null) {
      if (configIndex !== -1) {
        this.parsedConfig.splice(configIndex, 1);
      }
    } else {
      if (configIndex !== -1) {
        const config = this.parsedConfig[configIndex];
        const modifiedConfig = Object.assign({}, config, {
          value,
          modified: true,
        });
        if (append) {
          this.parsedConfig.splice(configIndex + 1, 0, modifiedConfig);
        } else {
          this.parsedConfig[configIndex] = modifiedConfig;
        }
      } else {
        const pathSegments = path.split('.');
        const section = pathSegments.shift().toLowerCase();
        const name = pathSegments.pop();
        const subsection = pathSegments.length
          ? pathSegments.join('.').toLowerCase()
          : undefined;
        const sectionPath = subsection ? section + '.' + subsection : section;
        const sectionIndex = this.parsedConfig.findIndex(
          config => config.path === sectionPath
        );
        const newConfig = {
          section,
          subsection,
          name,
          value,
          modified: true,
          path: getPath(section, subsection, name),
        };
        if (SECTION_REGEX.test(section) && VARIABLE_NAME_REGEX.test(name)) {
          if (sectionIndex >= 0) {
            // Reuse existing section
            this.parsedConfig.splice(sectionIndex + 1, 0, newConfig);
          } else {
            // Add a new section
            const newSection = {
              section,
              subsection,
              modified: true,
              path: getPath(section, subsection, null),
            };
            this.parsedConfig.push(newSection, newConfig);
          }
        }
      }
    }
  }

  toString() {
    return this.parsedConfig
      .map(({ line, section, subsection, name, value, modified = false }) => {
        if (!modified) {
          return line
        }
        if (name != null && value != null) {
          return `\t${name} = ${value}`
        }
        if (subsection != null) {
          return `[${section} "${subsection}"]`
        }
        return `[${section}]`
      })
      .join('\n')
  }
}

class GitConfigManager {
  static async get({ fs, gitdir }) {
    // We can improve efficiency later if needed.
    // TODO: read from full list of git config files
    const text = await fs.read(`${gitdir}/config`, { encoding: 'utf8' });
    return GitConfig.from(text)
  }

  static async save({ fs, gitdir, config }) {
    // We can improve efficiency later if needed.
    // TODO: handle saving to the correct global/user/repo location
    await fs.write(`${gitdir}/config`, config.toString(), {
      encoding: 'utf8',
    });
  }
}

// This is a convenience wrapper for reading and writing files in the 'refs' directory.

// @see https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions
const refpaths = ref => [
  `${ref}`,
  `refs/${ref}`,
  `refs/tags/${ref}`,
  `refs/heads/${ref}`,
  `refs/remotes/${ref}`,
  `refs/remotes/${ref}/HEAD`,
];

// @see https://git-scm.com/docs/gitrepository-layout
const GIT_FILES = ['config', 'description', 'index', 'shallow', 'commondir'];

class GitRefManager {
  static async updateRemoteRefs({
    fs,
    gitdir,
    remote,
    refs,
    symrefs,
    tags,
    refspecs = undefined,
    prune = false,
    pruneTags = false,
  }) {
    // Validate input
    for (const value of refs.values()) {
      if (!value.match(/[0-9a-f]{40}/)) {
        throw new InvalidOidError(value)
      }
    }
    const config = await GitConfigManager.get({ fs, gitdir });
    if (!refspecs) {
      refspecs = await config.getall(`remote.${remote}.fetch`);
      if (refspecs.length === 0) {
        throw new NoRefspecError(remote)
      }
      // There's some interesting behavior with HEAD that doesn't follow the refspec.
      refspecs.unshift(`+HEAD:refs/remotes/${remote}/HEAD`);
    }
    const refspec = GitRefSpecSet.from(refspecs);
    const actualRefsToWrite = new Map();
    // Delete all current tags if the pruneTags argument is true.
    if (pruneTags) {
      const tags = await GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: 'refs/tags',
      });
      await GitRefManager.deleteRefs({
        fs,
        gitdir,
        refs: tags.map(tag => `refs/tags/${tag}`),
      });
    }
    // Add all tags if the fetch tags argument is true.
    if (tags) {
      for (const serverRef of refs.keys()) {
        if (serverRef.startsWith('refs/tags') && !serverRef.endsWith('^{}')) {
          // Git's behavior is to only fetch tags that do not conflict with tags already present.
          if (!(await GitRefManager.exists({ fs, gitdir, ref: serverRef }))) {
            // Always use the object id of the tag itself, and not the peeled object id.
            const oid = refs.get(serverRef);
            actualRefsToWrite.set(serverRef, oid);
          }
        }
      }
    }
    // Combine refs and symrefs giving symrefs priority
    const refTranslations = refspec.translate([...refs.keys()]);
    for (const [serverRef, translatedRef] of refTranslations) {
      const value = refs.get(serverRef);
      actualRefsToWrite.set(translatedRef, value);
    }
    const symrefTranslations = refspec.translate([...symrefs.keys()]);
    for (const [serverRef, translatedRef] of symrefTranslations) {
      const value = symrefs.get(serverRef);
      const symtarget = refspec.translateOne(value);
      if (symtarget) {
        actualRefsToWrite.set(translatedRef, `ref: ${symtarget}`);
      }
    }
    // If `prune` argument is true, clear out the existing local refspec roots
    const pruned = [];
    if (prune) {
      for (const filepath of refspec.localNamespaces()) {
        const refs = (
          await GitRefManager.listRefs({
            fs,
            gitdir,
            filepath,
          })
        ).map(file => `${filepath}/${file}`);
        for (const ref of refs) {
          if (!actualRefsToWrite.has(ref)) {
            pruned.push(ref);
          }
        }
      }
      if (pruned.length > 0) {
        await GitRefManager.deleteRefs({ fs, gitdir, refs: pruned });
      }
    }
    // Update files
    // TODO: For large repos with a history of thousands of pull requests
    // (i.e. gitlab-ce) it would be vastly more efficient to write them
    // to .git/packed-refs.
    // The trick is to make sure we a) don't write a packed ref that is
    // already shadowed by a loose ref and b) don't loose any refs already
    // in packed-refs. Doing this efficiently may be difficult. A
    // solution that might work is
    // a) load the current packed-refs file
    // b) add actualRefsToWrite, overriding the existing values if present
    // c) enumerate all the loose refs currently in .git/refs/remotes/${remote}
    // d) overwrite their value with the new value.
    // Examples of refs we need to avoid writing in loose format for efficieny's sake
    // are .git/refs/remotes/origin/refs/remotes/remote_mirror_3059
    // and .git/refs/remotes/origin/refs/merge-requests
    for (const [key, value] of actualRefsToWrite) {
      await fs.write(join(gitdir, key), `${value.trim()}\n`, 'utf8');
    }
    return { pruned }
  }

  // TODO: make this less crude?
  static async writeRef({ fs, gitdir, ref, value }) {
    // Validate input
    if (!value.match(/[0-9a-f]{40}/)) {
      throw new InvalidOidError(value)
    }
    await fs.write(join(gitdir, ref), `${value.trim()}\n`, 'utf8');
  }

  static async writeSymbolicRef({ fs, gitdir, ref, value }) {
    await fs.write(join(gitdir, ref), 'ref: ' + `${value.trim()}\n`, 'utf8');
  }

  static async deleteRef({ fs, gitdir, ref }) {
    return GitRefManager.deleteRefs({ fs, gitdir, refs: [ref] })
  }

  static async deleteRefs({ fs, gitdir, refs }) {
    // Delete regular ref
    await Promise.all(refs.map(ref => fs.rm(join(gitdir, ref))));
    // Delete any packed ref
    let text = await fs.read(`${gitdir}/packed-refs`, { encoding: 'utf8' });
    const packed = GitPackedRefs.from(text);
    const beforeSize = packed.refs.size;
    for (const ref of refs) {
      if (packed.refs.has(ref)) {
        packed.delete(ref);
      }
    }
    if (packed.refs.size < beforeSize) {
      text = packed.toString();
      await fs.write(`${gitdir}/packed-refs`, text, { encoding: 'utf8' });
    }
  }

  /**
   * @param {object} args
   * @param {import('../models/FileSystem.js').FileSystem} args.fs
   * @param {string} args.gitdir
   * @param {string} args.ref
   * @param {number} [args.depth]
   * @returns {Promise<string>}
   */
  static async resolve({ fs, gitdir, ref, depth = undefined }) {
    if (depth !== undefined) {
      depth--;
      if (depth === -1) {
        return ref
      }
    }
    let sha;
    // Is it a ref pointer?
    if (ref.startsWith('ref: ')) {
      ref = ref.slice('ref: '.length);
      return GitRefManager.resolve({ fs, gitdir, ref, depth })
    }
    // Is it a complete and valid SHA?
    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
      return ref
    }
    // We need to alternate between the file system and the packed-refs
    const packedMap = await GitRefManager.packedRefs({ fs, gitdir });
    // Look in all the proper paths, in this order
    const allpaths = refpaths(ref).filter(p => !GIT_FILES.includes(p)); // exclude git system files (#709)

    for (const ref of allpaths) {
      sha =
        (await fs.read(`${gitdir}/${ref}`, { encoding: 'utf8' })) ||
        packedMap.get(ref);
      if (sha) {
        return GitRefManager.resolve({ fs, gitdir, ref: sha.trim(), depth })
      }
    }
    // Do we give up?
    throw new NotFoundError(ref)
  }

  static async exists({ fs, gitdir, ref }) {
    try {
      await GitRefManager.expand({ fs, gitdir, ref });
      return true
    } catch (err) {
      return false
    }
  }

  static async expand({ fs, gitdir, ref }) {
    // Is it a complete and valid SHA?
    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
      return ref
    }
    // We need to alternate between the file system and the packed-refs
    const packedMap = await GitRefManager.packedRefs({ fs, gitdir });
    // Look in all the proper paths, in this order
    const allpaths = refpaths(ref);
    for (const ref of allpaths) {
      if (await fs.exists(`${gitdir}/${ref}`)) return ref
      if (packedMap.has(ref)) return ref
    }
    // Do we give up?
    throw new NotFoundError(ref)
  }

  static async expandAgainstMap({ ref, map }) {
    // Look in all the proper paths, in this order
    const allpaths = refpaths(ref);
    for (const ref of allpaths) {
      if (await map.has(ref)) return ref
    }
    // Do we give up?
    throw new NotFoundError(ref)
  }

  static resolveAgainstMap({ ref, fullref = ref, depth = undefined, map }) {
    if (depth !== undefined) {
      depth--;
      if (depth === -1) {
        return { fullref, oid: ref }
      }
    }
    // Is it a ref pointer?
    if (ref.startsWith('ref: ')) {
      ref = ref.slice('ref: '.length);
      return GitRefManager.resolveAgainstMap({ ref, fullref, depth, map })
    }
    // Is it a complete and valid SHA?
    if (ref.length === 40 && /[0-9a-f]{40}/.test(ref)) {
      return { fullref, oid: ref }
    }
    // Look in all the proper paths, in this order
    const allpaths = refpaths(ref);
    for (const ref of allpaths) {
      const sha = map.get(ref);
      if (sha) {
        return GitRefManager.resolveAgainstMap({
          ref: sha.trim(),
          fullref: ref,
          depth,
          map,
        })
      }
    }
    // Do we give up?
    throw new NotFoundError(ref)
  }

  static async packedRefs({ fs, gitdir }) {
    const text = await fs.read(`${gitdir}/packed-refs`, { encoding: 'utf8' });
    const packed = GitPackedRefs.from(text);
    return packed.refs
  }

  // List all the refs that match the `filepath` prefix
  static async listRefs({ fs, gitdir, filepath }) {
    const packedMap = GitRefManager.packedRefs({ fs, gitdir });
    let files = null;
    try {
      files = await fs.readdirDeep(`${gitdir}/${filepath}`);
      files = files.map(x => x.replace(`${gitdir}/${filepath}/`, ''));
    } catch (err) {
      files = [];
    }

    for (let key of (await packedMap).keys()) {
      // filter by prefix
      if (key.startsWith(filepath)) {
        // remove prefix
        key = key.replace(filepath + '/', '');
        // Don't include duplicates; the loose files have precedence anyway
        if (!files.includes(key)) {
          files.push(key);
        }
      }
    }
    // since we just appended things onto an array, we need to sort them now
    files.sort(compareRefNames);
    return files
  }

  static async listBranches({ fs, gitdir, remote }) {
    if (remote) {
      return GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: `refs/remotes/${remote}`,
      })
    } else {
      return GitRefManager.listRefs({ fs, gitdir, filepath: `refs/heads` })
    }
  }

  static async listTags({ fs, gitdir }) {
    const tags = await GitRefManager.listRefs({
      fs,
      gitdir,
      filepath: `refs/tags`,
    });
    return tags.filter(x => !x.endsWith('^{}'))
  }
}

function compareTreeEntryPath(a, b) {
  // Git sorts tree entries as if there is a trailing slash on directory names.
  return compareStrings(appendSlashIfDir(a), appendSlashIfDir(b))
}

function appendSlashIfDir(entry) {
  return entry.mode === '040000' ? entry.path + '/' : entry.path
}

/**
 *
 * @typedef {Object} TreeEntry
 * @property {string} mode - the 6 digit hexadecimal mode
 * @property {string} path - the name of the file or directory
 * @property {string} oid - the SHA-1 object id of the blob or tree
 * @property {'commit'|'blob'|'tree'} type - the type of object
 */

function mode2type$1(mode) {
  // prettier-ignore
  switch (mode) {
    case '040000': return 'tree'
    case '100644': return 'blob'
    case '100755': return 'blob'
    case '120000': return 'blob'
    case '160000': return 'commit'
  }
  throw new InternalError(`Unexpected GitTree entry mode: ${mode}`)
}

function parseBuffer(buffer) {
  const _entries = [];
  let cursor = 0;
  while (cursor < buffer.length) {
    const space = buffer.indexOf(32, cursor);
    if (space === -1) {
      throw new InternalError(
        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`
      )
    }
    const nullchar = buffer.indexOf(0, cursor);
    if (nullchar === -1) {
      throw new InternalError(
        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`
      )
    }
    let mode = buffer.slice(cursor, space).toString('utf8');
    if (mode === '40000') mode = '040000'; // makes it line up neater in printed output
    const type = mode2type$1(mode);
    const path = buffer.slice(space + 1, nullchar).toString('utf8');

    // Prevent malicious git repos from writing to "..\foo" on clone etc
    if (path.includes('\\') || path.includes('/')) {
      throw new UnsafeFilepathError(path)
    }

    const oid = buffer.slice(nullchar + 1, nullchar + 21).toString('hex');
    cursor = nullchar + 21;
    _entries.push({ mode, path, oid, type });
  }
  return _entries
}

function limitModeToAllowed(mode) {
  if (typeof mode === 'number') {
    mode = mode.toString(8);
  }
  // tree
  if (mode.match(/^0?4.*/)) return '040000' // Directory
  if (mode.match(/^1006.*/)) return '100644' // Regular non-executable file
  if (mode.match(/^1007.*/)) return '100755' // Regular executable file
  if (mode.match(/^120.*/)) return '120000' // Symbolic link
  if (mode.match(/^160.*/)) return '160000' // Commit (git submodule reference)
  throw new InternalError(`Could not understand file mode: ${mode}`)
}

function nudgeIntoShape(entry) {
  if (!entry.oid && entry.sha) {
    entry.oid = entry.sha; // Github
  }
  entry.mode = limitModeToAllowed(entry.mode); // index
  if (!entry.type) {
    entry.type = mode2type$1(entry.mode); // index
  }
  return entry
}

class GitTree {
  constructor(entries) {
    if (Buffer.isBuffer(entries)) {
      this._entries = parseBuffer(entries);
    } else if (Array.isArray(entries)) {
      this._entries = entries.map(nudgeIntoShape);
    } else {
      throw new InternalError('invalid type passed to GitTree constructor')
    }
    // Tree entries are not sorted alphabetically in the usual sense (see `compareTreeEntryPath`)
    // but it is important later on that these be sorted in the same order as they would be returned from readdir.
    this._entries.sort(comparePath);
  }

  static from(tree) {
    return new GitTree(tree)
  }

  render() {
    return this._entries
      .map(entry => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`)
      .join('\n')
  }

  toObject() {
    // Adjust the sort order to match git's
    const entries = [...this._entries];
    entries.sort(compareTreeEntryPath);
    return Buffer.concat(
      entries.map(entry => {
        const mode = Buffer.from(entry.mode.replace(/^0/, ''));
        const space = Buffer.from(' ');
        const path = Buffer.from(entry.path, 'utf8');
        const nullchar = Buffer.from([0]);
        const oid = Buffer.from(entry.oid, 'hex');
        return Buffer.concat([mode, space, path, nullchar, oid])
      })
    )
  }

  /**
   * @returns {TreeEntry[]}
   */
  entries() {
    return this._entries
  }

  *[Symbol.iterator]() {
    for (const entry of this._entries) {
      yield entry;
    }
  }
}

class GitObject {
  static wrap({ type, object }) {
    return Buffer.concat([
      Buffer.from(`${type} ${object.byteLength.toString()}\x00`),
      Buffer.from(object),
    ])
  }

  static unwrap(buffer) {
    const s = buffer.indexOf(32); // first space
    const i = buffer.indexOf(0); // first null value
    const type = buffer.slice(0, s).toString('utf8'); // get type of object
    const length = buffer.slice(s + 1, i).toString('utf8'); // get type of object
    const actualLength = buffer.length - (i + 1);
    // verify length
    if (parseInt(length) !== actualLength) {
      throw new InternalError(
        `Length mismatch: expected ${length} bytes but got ${actualLength} instead.`
      )
    }
    return {
      type,
      object: Buffer.from(buffer.slice(i + 1)),
    }
  }
}

async function readObjectLoose({ fs, gitdir, oid }) {
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  const file = await fs.read(`${gitdir}/${source}`);
  if (!file) {
    return null
  }
  return { object: file, format: 'deflated', source }
}

/**
 * @param {Buffer} delta
 * @param {Buffer} source
 * @returns {Buffer}
 */
function applyDelta(delta, source) {
  const reader = new BufferCursor(delta);
  const sourceSize = readVarIntLE(reader);

  if (sourceSize !== source.byteLength) {
    throw new InternalError(
      `applyDelta expected source buffer to be ${sourceSize} bytes but the provided buffer was ${source.length} bytes`
    )
  }
  const targetSize = readVarIntLE(reader);
  let target;

  const firstOp = readOp(reader, source);
  // Speed optimization - return raw buffer if it's just single simple copy
  if (firstOp.byteLength === targetSize) {
    target = firstOp;
  } else {
    // Otherwise, allocate a fresh buffer and slices
    target = Buffer.alloc(targetSize);
    const writer = new BufferCursor(target);
    writer.copy(firstOp);

    while (!reader.eof()) {
      writer.copy(readOp(reader, source));
    }

    const tell = writer.tell();
    if (targetSize !== tell) {
      throw new InternalError(
        `applyDelta expected target buffer to be ${targetSize} bytes but the resulting buffer was ${tell} bytes`
      )
    }
  }
  return target
}

function readVarIntLE(reader) {
  let result = 0;
  let shift = 0;
  let byte = null;
  do {
    byte = reader.readUInt8();
    result |= (byte & 0b01111111) << shift;
    shift += 7;
  } while (byte & 0b10000000)
  return result
}

function readCompactLE(reader, flags, size) {
  let result = 0;
  let shift = 0;
  while (size--) {
    if (flags & 0b00000001) {
      result |= reader.readUInt8() << shift;
    }
    flags >>= 1;
    shift += 8;
  }
  return result
}

function readOp(reader, source) {
  /** @type {number} */
  const byte = reader.readUInt8();
  const COPY = 0b10000000;
  const OFFS = 0b00001111;
  const SIZE = 0b01110000;
  if (byte & COPY) {
    // copy consists of 4 byte offset, 3 byte size (in LE order)
    const offset = readCompactLE(reader, byte & OFFS, 4);
    let size = readCompactLE(reader, (byte & SIZE) >> 4, 3);
    // Yup. They really did this optimization.
    if (size === 0) size = 0x10000;
    return source.slice(offset, offset + size)
  } else {
    // insert
    return reader.slice(byte)
  }
}

// Convert a value to an Async Iterator
// This will be easier with async generator functions.
function fromValue(value) {
  let queue = [value];
  return {
    next() {
      return Promise.resolve({ done: queue.length === 0, value: queue.pop() })
    },
    return() {
      queue = [];
      return {}
    },
    [Symbol.asyncIterator]() {
      return this
    },
  }
}

function getIterator(iterable) {
  if (iterable[Symbol.asyncIterator]) {
    return iterable[Symbol.asyncIterator]()
  }
  if (iterable[Symbol.iterator]) {
    return iterable[Symbol.iterator]()
  }
  if (iterable.next) {
    return iterable
  }
  return fromValue(iterable)
}

// inspired by 'gartal' but lighter-weight and more battle-tested.
class StreamReader {
  constructor(stream) {
    this.stream = getIterator(stream);
    this.buffer = null;
    this.cursor = 0;
    this.undoCursor = 0;
    this.started = false;
    this._ended = false;
    this._discardedBytes = 0;
  }

  eof() {
    return this._ended && this.cursor === this.buffer.length
  }

  tell() {
    return this._discardedBytes + this.cursor
  }

  async byte() {
    if (this.eof()) return
    if (!this.started) await this._init();
    if (this.cursor === this.buffer.length) {
      await this._loadnext();
      if (this._ended) return
    }
    this._moveCursor(1);
    return this.buffer[this.undoCursor]
  }

  async chunk() {
    if (this.eof()) return
    if (!this.started) await this._init();
    if (this.cursor === this.buffer.length) {
      await this._loadnext();
      if (this._ended) return
    }
    this._moveCursor(this.buffer.length);
    return this.buffer.slice(this.undoCursor, this.cursor)
  }

  async read(n) {
    if (this.eof()) return
    if (!this.started) await this._init();
    if (this.cursor + n > this.buffer.length) {
      this._trim();
      await this._accumulate(n);
    }
    this._moveCursor(n);
    return this.buffer.slice(this.undoCursor, this.cursor)
  }

  async skip(n) {
    if (this.eof()) return
    if (!this.started) await this._init();
    if (this.cursor + n > this.buffer.length) {
      this._trim();
      await this._accumulate(n);
    }
    this._moveCursor(n);
  }

  async undo() {
    this.cursor = this.undoCursor;
  }

  async _next() {
    this.started = true;
    let { done, value } = await this.stream.next();
    if (done) {
      this._ended = true;
    }
    if (value) {
      value = Buffer.from(value);
    }
    return value
  }

  _trim() {
    // Throw away parts of the buffer we don't need anymore
    // assert(this.cursor <= this.buffer.length)
    this.buffer = this.buffer.slice(this.undoCursor);
    this.cursor -= this.undoCursor;
    this._discardedBytes += this.undoCursor;
    this.undoCursor = 0;
  }

  _moveCursor(n) {
    this.undoCursor = this.cursor;
    this.cursor += n;
    if (this.cursor > this.buffer.length) {
      this.cursor = this.buffer.length;
    }
  }

  async _accumulate(n) {
    if (this._ended) return
    // Expand the buffer until we have N bytes of data
    // or we've reached the end of the stream
    const buffers = [this.buffer];
    while (this.cursor + n > lengthBuffers(buffers)) {
      const nextbuffer = await this._next();
      if (this._ended) break
      buffers.push(nextbuffer);
    }
    this.buffer = Buffer.concat(buffers);
  }

  async _loadnext() {
    this._discardedBytes += this.buffer.length;
    this.undoCursor = 0;
    this.cursor = 0;
    this.buffer = await this._next();
  }

  async _init() {
    this.buffer = await this._next();
  }
}

// This helper function helps us postpone concatenating buffers, which
// would create intermediate buffer objects,
function lengthBuffers(buffers) {
  return buffers.reduce((acc, buffer) => acc + buffer.length, 0)
}

// My version of git-list-pack - roughly 15x faster than the original

async function listpack(stream, onData) {
  const reader = new StreamReader(stream);
  let PACK = await reader.read(4);
  PACK = PACK.toString('utf8');
  if (PACK !== 'PACK') {
    throw new InternalError(`Invalid PACK header '${PACK}'`)
  }

  let version = await reader.read(4);
  version = version.readUInt32BE(0);
  if (version !== 2) {
    throw new InternalError(`Invalid packfile version: ${version}`)
  }

  let numObjects = await reader.read(4);
  numObjects = numObjects.readUInt32BE(0);
  // If (for some godforsaken reason) this is an empty packfile, abort now.
  if (numObjects < 1) return

  while (!reader.eof() && numObjects--) {
    const offset = reader.tell();
    const { type, length, ofs, reference } = await parseHeader(reader);
    const inflator = new pako__WEBPACK_IMPORTED_MODULE_3__.Inflate();
    while (!inflator.result) {
      const chunk = await reader.chunk();
      if (!chunk) break
      inflator.push(chunk, false);
      if (inflator.err) {
        throw new InternalError(`Pako error: ${inflator.msg}`)
      }
      if (inflator.result) {
        if (inflator.result.length !== length) {
          throw new InternalError(
            `Inflated object size is different from that stated in packfile.`
          )
        }

        // Backtrack parser to where deflated data ends
        await reader.undo();
        await reader.read(chunk.length - inflator.strm.avail_in);
        const end = reader.tell();
        await onData({
          data: inflator.result,
          type,
          num: numObjects,
          offset,
          end,
          reference,
          ofs,
        });
      }
    }
  }
}

async function parseHeader(reader) {
  // Object type is encoded in bits 654
  let byte = await reader.byte();
  const type = (byte >> 4) & 0b111;
  // The length encoding get complicated.
  // Last four bits of length is encoded in bits 3210
  let length = byte & 0b1111;
  // Whether the next byte is part of the variable-length encoded number
  // is encoded in bit 7
  if (byte & 0b10000000) {
    let shift = 4;
    do {
      byte = await reader.byte();
      length |= (byte & 0b01111111) << shift;
      shift += 7;
    } while (byte & 0b10000000)
  }
  // Handle deltified objects
  let ofs;
  let reference;
  if (type === 6) {
    let shift = 0;
    ofs = 0;
    const bytes = [];
    do {
      byte = await reader.byte();
      ofs |= (byte & 0b01111111) << shift;
      shift += 7;
      bytes.push(byte);
    } while (byte & 0b10000000)
    reference = Buffer.from(bytes);
  }
  if (type === 7) {
    const buf = await reader.read(20);
    reference = buf;
  }
  return { type, length, ofs, reference }
}

/* eslint-env node, browser */

let supportsDecompressionStream = false;

async function inflate(buffer) {
  if (supportsDecompressionStream === null) {
    supportsDecompressionStream = testDecompressionStream();
  }
  return supportsDecompressionStream
    ? browserInflate(buffer)
    : pako__WEBPACK_IMPORTED_MODULE_3__.inflate(buffer)
}

async function browserInflate(buffer) {
  const ds = new DecompressionStream('deflate');
  const d = new Blob([buffer]).stream().pipeThrough(ds);
  return new Uint8Array(await new Response(d).arrayBuffer())
}

function testDecompressionStream() {
  try {
    const ds = new DecompressionStream('deflate');
    if (ds) return true
  } catch (_) {
    // no bother
  }
  return false
}

function decodeVarInt(reader) {
  const bytes = [];
  let byte = 0;
  let multibyte = 0;
  do {
    byte = reader.readUInt8();
    // We keep bits 6543210
    const lastSeven = byte & 0b01111111;
    bytes.push(lastSeven);
    // Whether the next byte is part of the variable-length encoded number
    // is encoded in bit 7
    multibyte = byte & 0b10000000;
  } while (multibyte)
  // Now that all the bytes are in big-endian order,
  // alternate shifting the bits left by 7 and OR-ing the next byte.
  // And... do a weird increment-by-one thing that I don't quite understand.
  return bytes.reduce((a, b) => ((a + 1) << 7) | b, -1)
}

// I'm pretty much copying this one from the git C source code,
// because it makes no sense.
function otherVarIntDecode(reader, startWith) {
  let result = startWith;
  let shift = 4;
  let byte = null;
  do {
    byte = reader.readUInt8();
    result |= (byte & 0b01111111) << shift;
    shift += 7;
  } while (byte & 0b10000000)
  return result
}

class GitPackIndex {
  constructor(stuff) {
    Object.assign(this, stuff);
    this.offsetCache = {};
  }

  static async fromIdx({ idx, getExternalRefDelta }) {
    const reader = new BufferCursor(idx);
    const magic = reader.slice(4).toString('hex');
    // Check for IDX v2 magic number
    if (magic !== 'ff744f63') {
      return // undefined
    }
    const version = reader.readUInt32BE();
    if (version !== 2) {
      throw new InternalError(
        `Unable to read version ${version} packfile IDX. (Only version 2 supported)`
      )
    }
    if (idx.byteLength > 2048 * 1024 * 1024) {
      throw new InternalError(
        `To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.`
      )
    }
    // Skip over fanout table
    reader.seek(reader.tell() + 4 * 255);
    // Get hashes
    const size = reader.readUInt32BE();
    const hashes = [];
    for (let i = 0; i < size; i++) {
      const hash = reader.slice(20).toString('hex');
      hashes[i] = hash;
    }
    reader.seek(reader.tell() + 4 * size);
    // Skip over CRCs
    // Get offsets
    const offsets = new Map();
    for (let i = 0; i < size; i++) {
      offsets.set(hashes[i], reader.readUInt32BE());
    }
    const packfileSha = reader.slice(20).toString('hex');
    return new GitPackIndex({
      hashes,
      crcs: {},
      offsets,
      packfileSha,
      getExternalRefDelta,
    })
  }

  static async fromPack({ pack, getExternalRefDelta, onProgress }) {
    const listpackTypes = {
      1: 'commit',
      2: 'tree',
      3: 'blob',
      4: 'tag',
      6: 'ofs-delta',
      7: 'ref-delta',
    };
    const offsetToObject = {};

    // Older packfiles do NOT use the shasum of the pack itself,
    // so it is recommended to just use whatever bytes are in the trailer.
    // Source: https://github.com/git/git/commit/1190a1acf800acdcfd7569f87ac1560e2d077414
    const packfileSha = pack.slice(-20).toString('hex');

    const hashes = [];
    const crcs = {};
    const offsets = new Map();
    let totalObjectCount = null;
    let lastPercent = null;

    await listpack([pack], async ({ data, type, reference, offset, num }) => {
      if (totalObjectCount === null) totalObjectCount = num;
      const percent = Math.floor(
        ((totalObjectCount - num) * 100) / totalObjectCount
      );
      if (percent !== lastPercent) {
        if (onProgress) {
          await onProgress({
            phase: 'Receiving objects',
            loaded: totalObjectCount - num,
            total: totalObjectCount,
          });
        }
      }
      lastPercent = percent;
      // Change type from a number to a meaningful string
      type = listpackTypes[type];

      if (['commit', 'tree', 'blob', 'tag'].includes(type)) {
        offsetToObject[offset] = {
          type,
          offset,
        };
      } else if (type === 'ofs-delta') {
        offsetToObject[offset] = {
          type,
          offset,
        };
      } else if (type === 'ref-delta') {
        offsetToObject[offset] = {
          type,
          offset,
        };
      }
    });

    // We need to know the lengths of the slices to compute the CRCs.
    const offsetArray = Object.keys(offsetToObject).map(Number);
    for (const [i, start] of offsetArray.entries()) {
      const end =
        i + 1 === offsetArray.length ? pack.byteLength - 20 : offsetArray[i + 1];
      const o = offsetToObject[start];
      const crc = crc_32__WEBPACK_IMPORTED_MODULE_2__.buf(pack.slice(start, end)) >>> 0;
      o.end = end;
      o.crc = crc;
    }

    // We don't have the hashes yet. But we can generate them using the .readSlice function!
    const p = new GitPackIndex({
      pack: Promise.resolve(pack),
      packfileSha,
      crcs,
      hashes,
      offsets,
      getExternalRefDelta,
    });

    // Resolve deltas and compute the oids
    lastPercent = null;
    let count = 0;
    const objectsByDepth = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (let offset in offsetToObject) {
      offset = Number(offset);
      const percent = Math.floor((count++ * 100) / totalObjectCount);
      if (percent !== lastPercent) {
        if (onProgress) {
          await onProgress({
            phase: 'Resolving deltas',
            loaded: count,
            total: totalObjectCount,
          });
        }
      }
      lastPercent = percent;

      const o = offsetToObject[offset];
      if (o.oid) continue
      try {
        p.readDepth = 0;
        p.externalReadDepth = 0;
        const { type, object } = await p.readSlice({ start: offset });
        objectsByDepth[p.readDepth] += 1;
        const oid = await shasum(GitObject.wrap({ type, object }));
        o.oid = oid;
        hashes.push(oid);
        offsets.set(oid, offset);
        crcs[oid] = o.crc;
      } catch (err) {
        continue
      }
    }

    hashes.sort();
    return p
  }

  async toBuffer() {
    const buffers = [];
    const write = (str, encoding) => {
      buffers.push(Buffer.from(str, encoding));
    };
    // Write out IDX v2 magic number
    write('ff744f63', 'hex');
    // Write out version number 2
    write('00000002', 'hex');
    // Write fanout table
    const fanoutBuffer = new BufferCursor(Buffer.alloc(256 * 4));
    for (let i = 0; i < 256; i++) {
      let count = 0;
      for (const hash of this.hashes) {
        if (parseInt(hash.slice(0, 2), 16) <= i) count++;
      }
      fanoutBuffer.writeUInt32BE(count);
    }
    buffers.push(fanoutBuffer.buffer);
    // Write out hashes
    for (const hash of this.hashes) {
      write(hash, 'hex');
    }
    // Write out crcs
    const crcsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));
    for (const hash of this.hashes) {
      crcsBuffer.writeUInt32BE(this.crcs[hash]);
    }
    buffers.push(crcsBuffer.buffer);
    // Write out offsets
    const offsetsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length * 4));
    for (const hash of this.hashes) {
      offsetsBuffer.writeUInt32BE(this.offsets.get(hash));
    }
    buffers.push(offsetsBuffer.buffer);
    // Write out packfile checksum
    write(this.packfileSha, 'hex');
    // Write out shasum
    const totalBuffer = Buffer.concat(buffers);
    const sha = await shasum(totalBuffer);
    const shaBuffer = Buffer.alloc(20);
    shaBuffer.write(sha, 'hex');
    return Buffer.concat([totalBuffer, shaBuffer])
  }

  async load({ pack }) {
    this.pack = pack;
  }

  async unload() {
    this.pack = null;
  }

  async read({ oid }) {
    if (!this.offsets.get(oid)) {
      if (this.getExternalRefDelta) {
        this.externalReadDepth++;
        return this.getExternalRefDelta(oid)
      } else {
        throw new InternalError(`Could not read object ${oid} from packfile`)
      }
    }
    const start = this.offsets.get(oid);
    return this.readSlice({ start })
  }

  async readSlice({ start }) {
    if (this.offsetCache[start]) {
      return Object.assign({}, this.offsetCache[start])
    }
    this.readDepth++;
    const types = {
      0b0010000: 'commit',
      0b0100000: 'tree',
      0b0110000: 'blob',
      0b1000000: 'tag',
      0b1100000: 'ofs_delta',
      0b1110000: 'ref_delta',
    };
    if (!this.pack) {
      throw new InternalError(
        'Tried to read from a GitPackIndex with no packfile loaded into memory'
      )
    }
    const raw = (await this.pack).slice(start);
    const reader = new BufferCursor(raw);
    const byte = reader.readUInt8();
    // Object type is encoded in bits 654
    const btype = byte & 0b1110000;
    let type = types[btype];
    if (type === undefined) {
      throw new InternalError('Unrecognized type: 0b' + btype.toString(2))
    }
    // The length encoding get complicated.
    // Last four bits of length is encoded in bits 3210
    const lastFour = byte & 0b1111;
    let length = lastFour;
    // Whether the next byte is part of the variable-length encoded number
    // is encoded in bit 7
    const multibyte = byte & 0b10000000;
    if (multibyte) {
      length = otherVarIntDecode(reader, lastFour);
    }
    let base = null;
    let object = null;
    // Handle deltified objects
    if (type === 'ofs_delta') {
      const offset = decodeVarInt(reader);
      const baseOffset = start - offset
      ;({ object: base, type } = await this.readSlice({ start: baseOffset }));
    }
    if (type === 'ref_delta') {
      const oid = reader.slice(20).toString('hex')
      ;({ object: base, type } = await this.read({ oid }));
    }
    // Handle undeltified objects
    const buffer = raw.slice(reader.tell());
    object = Buffer.from(await inflate(buffer));
    // Assert that the object length is as expected.
    if (object.byteLength !== length) {
      throw new InternalError(
        `Packfile told us object would have length ${length} but it had length ${object.byteLength}`
      )
    }
    if (base) {
      object = Buffer.from(applyDelta(object, base));
    }
    // Cache the result based on depth.
    if (this.readDepth > 3) {
      // hand tuned for speed / memory usage tradeoff
      this.offsetCache[start] = { type, object };
    }
    return { type, format: 'content', object }
  }
}

const PackfileCache = Symbol('PackfileCache');

async function loadPackIndex({
  fs,
  filename,
  getExternalRefDelta,
  emitter,
  emitterPrefix,
}) {
  const idx = await fs.read(filename);
  return GitPackIndex.fromIdx({ idx, getExternalRefDelta })
}

function readPackIndex({
  fs,
  cache,
  filename,
  getExternalRefDelta,
  emitter,
  emitterPrefix,
}) {
  // Try to get the packfile index from the in-memory cache
  if (!cache[PackfileCache]) cache[PackfileCache] = new Map();
  let p = cache[PackfileCache].get(filename);
  if (!p) {
    p = loadPackIndex({
      fs,
      filename,
      getExternalRefDelta,
      emitter,
      emitterPrefix,
    });
    cache[PackfileCache].set(filename, p);
  }
  return p
}

async function readObjectPacked({
  fs,
  cache,
  gitdir,
  oid,
  format = 'content',
  getExternalRefDelta,
}) {
  // Check to see if it's in a packfile.
  // Iterate through all the .idx files
  let list = await fs.readdir(join(gitdir, 'objects/pack'));
  list = list.filter(x => x.endsWith('.idx'));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta,
    });
    if (p.error) throw new InternalError(p.error)
    // If the packfile DOES have the oid we're looking for...
    if (p.offsets.has(oid)) {
      // Get the resolved git object from the packfile
      if (!p.pack) {
        const packFile = indexFile.replace(/idx$/, 'pack');
        p.pack = fs.read(packFile);
      }
      const result = await p.read({ oid, getExternalRefDelta });
      result.format = 'content';
      result.source = `objects/pack/${filename.replace(/idx$/, 'pack')}`;
      return result
    }
  }
  // Failed to find it
  return null
}

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.oid
 * @param {string} [args.format]
 */
async function _readObject({
  fs,
  cache,
  gitdir,
  oid,
  format = 'content',
}) {
  // Curry the current read method so that the packfile un-deltification
  // process can acquire external ref-deltas.
  const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });

  let result;
  // Empty tree - hard-coded so we can use it as a shorthand.
  // Note: I think the canonical git implementation must do this too because
  // `git cat-file -t 4b825dc642cb6eb9a060e54bf8d69288fbee4904` prints "tree" even in empty repos.
  if (oid === '4b825dc642cb6eb9a060e54bf8d69288fbee4904') {
    result = { format: 'wrapped', object: Buffer.from(`tree 0\x00`) };
  }
  // Look for it in the loose object directory.
  if (!result) {
    result = await readObjectLoose({ fs, gitdir, oid });
  }
  // Check to see if it's in a packfile.
  if (!result) {
    result = await readObjectPacked({
      fs,
      cache,
      gitdir,
      oid,
      getExternalRefDelta,
    });
  }
  // Finally
  if (!result) {
    throw new NotFoundError(oid)
  }

  if (format === 'deflated') {
    return result
  }

  if (result.format === 'deflated') {
    result.object = Buffer.from(await inflate(result.object));
    result.format = 'wrapped';
  }

  if (result.format === 'wrapped') {
    if (format === 'wrapped' && result.format === 'wrapped') {
      return result
    }
    const sha = await shasum(result.object);
    if (sha !== oid) {
      throw new InternalError(
        `SHA check failed! Expected ${oid}, computed ${sha}`
      )
    }
    const { object, type } = GitObject.unwrap(result.object);
    result.type = type;
    result.object = object;
    result.format = 'content';
  }

  if (result.format === 'content') {
    if (format === 'content') return result
    return
  }

  throw new InternalError(`invalid format "${result.format}"`)
}

class AlreadyExistsError extends BaseError {
  /**
   * @param {'note'|'remote'|'tag'|'branch'} noun
   * @param {string} where
   * @param {boolean} canForce
   */
  constructor(noun, where, canForce = true) {
    super(
      `Failed to create ${noun} at ${where} because it already exists.${
        canForce
          ? ` (Hint: use 'force: true' parameter to overwrite existing ${noun}.)`
          : ''
      }`
    );
    this.code = this.name = AlreadyExistsError.code;
    this.data = { noun, where, canForce };
  }
}
/** @type {'AlreadyExistsError'} */
AlreadyExistsError.code = 'AlreadyExistsError';

class AmbiguousError extends BaseError {
  /**
   * @param {'oids'|'refs'} nouns
   * @param {string} short
   * @param {string[]} matches
   */
  constructor(nouns, short, matches) {
    super(
      `Found multiple ${nouns} matching "${short}" (${matches.join(
        ', '
      )}). Use a longer abbreviation length to disambiguate them.`
    );
    this.code = this.name = AmbiguousError.code;
    this.data = { nouns, short, matches };
  }
}
/** @type {'AmbiguousError'} */
AmbiguousError.code = 'AmbiguousError';

class CheckoutConflictError extends BaseError {
  /**
   * @param {string[]} filepaths
   */
  constructor(filepaths) {
    super(
      `Your local changes to the following files would be overwritten by checkout: ${filepaths.join(
        ', '
      )}`
    );
    this.code = this.name = CheckoutConflictError.code;
    this.data = { filepaths };
  }
}
/** @type {'CheckoutConflictError'} */
CheckoutConflictError.code = 'CheckoutConflictError';

class CommitNotFetchedError extends BaseError {
  /**
   * @param {string} ref
   * @param {string} oid
   */
  constructor(ref, oid) {
    super(
      `Failed to checkout "${ref}" because commit ${oid} is not available locally. Do a git fetch to make the branch available locally.`
    );
    this.code = this.name = CommitNotFetchedError.code;
    this.data = { ref, oid };
  }
}
/** @type {'CommitNotFetchedError'} */
CommitNotFetchedError.code = 'CommitNotFetchedError';

class EmptyServerResponseError extends BaseError {
  constructor() {
    super(`Empty response from git server.`);
    this.code = this.name = EmptyServerResponseError.code;
    this.data = {};
  }
}
/** @type {'EmptyServerResponseError'} */
EmptyServerResponseError.code = 'EmptyServerResponseError';

class FastForwardError extends BaseError {
  constructor() {
    super(`A simple fast-forward merge was not possible.`);
    this.code = this.name = FastForwardError.code;
    this.data = {};
  }
}
/** @type {'FastForwardError'} */
FastForwardError.code = 'FastForwardError';

class GitPushError extends BaseError {
  /**
   * @param {string} prettyDetails
   * @param {PushResult} result
   */
  constructor(prettyDetails, result) {
    super(`One or more branches were not updated: ${prettyDetails}`);
    this.code = this.name = GitPushError.code;
    this.data = { prettyDetails, result };
  }
}
/** @type {'GitPushError'} */
GitPushError.code = 'GitPushError';

class HttpError extends BaseError {
  /**
   * @param {number} statusCode
   * @param {string} statusMessage
   * @param {string} response
   */
  constructor(statusCode, statusMessage, response) {
    super(`HTTP Error: ${statusCode} ${statusMessage}`);
    this.code = this.name = HttpError.code;
    this.data = { statusCode, statusMessage, response };
  }
}
/** @type {'HttpError'} */
HttpError.code = 'HttpError';

class InvalidFilepathError extends BaseError {
  /**
   * @param {'leading-slash'|'trailing-slash'} [reason]
   */
  constructor(reason) {
    let message = 'invalid filepath';
    if (reason === 'leading-slash' || reason === 'trailing-slash') {
      message = `"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.`;
    }
    super(message);
    this.code = this.name = InvalidFilepathError.code;
    this.data = { reason };
  }
}
/** @type {'InvalidFilepathError'} */
InvalidFilepathError.code = 'InvalidFilepathError';

class InvalidRefNameError extends BaseError {
  /**
   * @param {string} ref
   * @param {string} suggestion
   * @param {boolean} canForce
   */
  constructor(ref, suggestion) {
    super(
      `"${ref}" would be an invalid git reference. (Hint: a valid alternative would be "${suggestion}".)`
    );
    this.code = this.name = InvalidRefNameError.code;
    this.data = { ref, suggestion };
  }
}
/** @type {'InvalidRefNameError'} */
InvalidRefNameError.code = 'InvalidRefNameError';

class MaxDepthError extends BaseError {
  /**
   * @param {number} depth
   */
  constructor(depth) {
    super(`Maximum search depth of ${depth} exceeded.`);
    this.code = this.name = MaxDepthError.code;
    this.data = { depth };
  }
}
/** @type {'MaxDepthError'} */
MaxDepthError.code = 'MaxDepthError';

class MergeNotSupportedError extends BaseError {
  constructor() {
    super(`Merges with conflicts are not supported yet.`);
    this.code = this.name = MergeNotSupportedError.code;
    this.data = {};
  }
}
/** @type {'MergeNotSupportedError'} */
MergeNotSupportedError.code = 'MergeNotSupportedError';

class MissingNameError extends BaseError {
  /**
   * @param {'author'|'committer'|'tagger'} role
   */
  constructor(role) {
    super(
      `No name was provided for ${role} in the argument or in the .git/config file.`
    );
    this.code = this.name = MissingNameError.code;
    this.data = { role };
  }
}
/** @type {'MissingNameError'} */
MissingNameError.code = 'MissingNameError';

class MissingParameterError extends BaseError {
  /**
   * @param {string} parameter
   */
  constructor(parameter) {
    super(
      `The function requires a "${parameter}" parameter but none was provided.`
    );
    this.code = this.name = MissingParameterError.code;
    this.data = { parameter };
  }
}
/** @type {'MissingParameterError'} */
MissingParameterError.code = 'MissingParameterError';

class ParseError extends BaseError {
  /**
   * @param {string} expected
   * @param {string} actual
   */
  constructor(expected, actual) {
    super(`Expected "${expected}" but received "${actual}".`);
    this.code = this.name = ParseError.code;
    this.data = { expected, actual };
  }
}
/** @type {'ParseError'} */
ParseError.code = 'ParseError';

class PushRejectedError extends BaseError {
  /**
   * @param {'not-fast-forward'|'tag-exists'} reason
   */
  constructor(reason) {
    let message = '';
    if (reason === 'not-fast-forward') {
      message = ' because it was not a simple fast-forward';
    } else if (reason === 'tag-exists') {
      message = ' because tag already exists';
    }
    super(`Push rejected${message}. Use "force: true" to override.`);
    this.code = this.name = PushRejectedError.code;
    this.data = { reason };
  }
}
/** @type {'PushRejectedError'} */
PushRejectedError.code = 'PushRejectedError';

class RemoteCapabilityError extends BaseError {
  /**
   * @param {'shallow'|'deepen-since'|'deepen-not'|'deepen-relative'} capability
   * @param {'depth'|'since'|'exclude'|'relative'} parameter
   */
  constructor(capability, parameter) {
    super(
      `Remote does not support the "${capability}" so the "${parameter}" parameter cannot be used.`
    );
    this.code = this.name = RemoteCapabilityError.code;
    this.data = { capability, parameter };
  }
}
/** @type {'RemoteCapabilityError'} */
RemoteCapabilityError.code = 'RemoteCapabilityError';

class SmartHttpError extends BaseError {
  /**
   * @param {string} preview
   * @param {string} response
   */
  constructor(preview, response) {
    super(
      `Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${preview}`
    );
    this.code = this.name = SmartHttpError.code;
    this.data = { preview, response };
  }
}
/** @type {'SmartHttpError'} */
SmartHttpError.code = 'SmartHttpError';

class UnknownTransportError extends BaseError {
  /**
   * @param {string} url
   * @param {string} transport
   * @param {string} suggestion
   */
  constructor(url, transport, suggestion) {
    super(
      `Git remote "${url}" uses an unrecognized transport protocol: "${transport}"`
    );
    this.code = this.name = UnknownTransportError.code;
    this.data = { url, transport, suggestion };
  }
}
/** @type {'UnknownTransportError'} */
UnknownTransportError.code = 'UnknownTransportError';

class UrlParseError extends BaseError {
  /**
   * @param {string} url
   */
  constructor(url) {
    super(`Cannot parse remote URL: "${url}"`);
    this.code = this.name = UrlParseError.code;
    this.data = { url };
  }
}
/** @type {'UrlParseError'} */
UrlParseError.code = 'UrlParseError';

class UserCanceledError extends BaseError {
  constructor() {
    super(`The operation was canceled.`);
    this.code = this.name = UserCanceledError.code;
    this.data = {};
  }
}
/** @type {'UserCanceledError'} */
UserCanceledError.code = 'UserCanceledError';



var Errors = /*#__PURE__*/Object.freeze({
  __proto__: null,
  AlreadyExistsError: AlreadyExistsError,
  AmbiguousError: AmbiguousError,
  CheckoutConflictError: CheckoutConflictError,
  CommitNotFetchedError: CommitNotFetchedError,
  EmptyServerResponseError: EmptyServerResponseError,
  FastForwardError: FastForwardError,
  GitPushError: GitPushError,
  HttpError: HttpError,
  InternalError: InternalError,
  InvalidFilepathError: InvalidFilepathError,
  InvalidOidError: InvalidOidError,
  InvalidRefNameError: InvalidRefNameError,
  MaxDepthError: MaxDepthError,
  MergeNotSupportedError: MergeNotSupportedError,
  MissingNameError: MissingNameError,
  MissingParameterError: MissingParameterError,
  NoRefspecError: NoRefspecError,
  NotFoundError: NotFoundError,
  ObjectTypeError: ObjectTypeError,
  ParseError: ParseError,
  PushRejectedError: PushRejectedError,
  RemoteCapabilityError: RemoteCapabilityError,
  SmartHttpError: SmartHttpError,
  UnknownTransportError: UnknownTransportError,
  UnsafeFilepathError: UnsafeFilepathError,
  UrlParseError: UrlParseError,
  UserCanceledError: UserCanceledError
});

function formatAuthor({ name, email, timestamp, timezoneOffset }) {
  timezoneOffset = formatTimezoneOffset(timezoneOffset);
  return `${name} <${email}> ${timestamp} ${timezoneOffset}`
}

// The amount of effort that went into crafting these cases to handle
// -0 (just so we don't lose that information when parsing and reconstructing)
// but can also default to +0 was extraordinary.

function formatTimezoneOffset(minutes) {
  const sign = simpleSign(negateExceptForZero(minutes));
  minutes = Math.abs(minutes);
  const hours = Math.floor(minutes / 60);
  minutes -= hours * 60;
  let strHours = String(hours);
  let strMinutes = String(minutes);
  if (strHours.length < 2) strHours = '0' + strHours;
  if (strMinutes.length < 2) strMinutes = '0' + strMinutes;
  return (sign === -1 ? '-' : '+') + strHours + strMinutes
}

function simpleSign(n) {
  return Math.sign(n) || (Object.is(n, -0) ? -1 : 1)
}

function negateExceptForZero(n) {
  return n === 0 ? n : -n
}

function normalizeNewlines(str) {
  // remove all <CR>
  str = str.replace(/\r/g, '');
  // no extra newlines up front
  str = str.replace(/^\n+/, '');
  // and a single newline at the end
  str = str.replace(/\n+$/, '') + '\n';
  return str
}

function parseAuthor(author) {
  const [, name, email, timestamp, offset] = author.match(
    /^(.*) <(.*)> (.*) (.*)$/
  );
  return {
    name: name,
    email: email,
    timestamp: Number(timestamp),
    timezoneOffset: parseTimezoneOffset(offset),
  }
}

// The amount of effort that went into crafting these cases to handle
// -0 (just so we don't lose that information when parsing and reconstructing)
// but can also default to +0 was extraordinary.

function parseTimezoneOffset(offset) {
  let [, sign, hours, minutes] = offset.match(/(\+|-)(\d\d)(\d\d)/);
  minutes = (sign === '+' ? 1 : -1) * (Number(hours) * 60 + Number(minutes));
  return negateExceptForZero$1(minutes)
}

function negateExceptForZero$1(n) {
  return n === 0 ? n : -n
}

class GitAnnotatedTag {
  constructor(tag) {
    if (typeof tag === 'string') {
      this._tag = tag;
    } else if (Buffer.isBuffer(tag)) {
      this._tag = tag.toString('utf8');
    } else if (typeof tag === 'object') {
      this._tag = GitAnnotatedTag.render(tag);
    } else {
      throw new InternalError(
        'invalid type passed to GitAnnotatedTag constructor'
      )
    }
  }

  static from(tag) {
    return new GitAnnotatedTag(tag)
  }

  static render(obj) {
    return `object ${obj.object}
type ${obj.type}
tag ${obj.tag}
tagger ${formatAuthor(obj.tagger)}

${obj.message}
${obj.gpgsig ? obj.gpgsig : ''}`
  }

  justHeaders() {
    return this._tag.slice(0, this._tag.indexOf('\n\n'))
  }

  message() {
    const tag = this.withoutSignature();
    return tag.slice(tag.indexOf('\n\n') + 2)
  }

  parse() {
    return Object.assign(this.headers(), {
      message: this.message(),
      gpgsig: this.gpgsig(),
    })
  }

  render() {
    return this._tag
  }

  headers() {
    const headers = this.justHeaders().split('\n');
    const hs = [];
    for (const h of headers) {
      if (h[0] === ' ') {
        // combine with previous header (without space indent)
        hs[hs.length - 1] += '\n' + h.slice(1);
      } else {
        hs.push(h);
      }
    }
    const obj = {};
    for (const h of hs) {
      const key = h.slice(0, h.indexOf(' '));
      const value = h.slice(h.indexOf(' ') + 1);
      if (Array.isArray(obj[key])) {
        obj[key].push(value);
      } else {
        obj[key] = value;
      }
    }
    if (obj.tagger) {
      obj.tagger = parseAuthor(obj.tagger);
    }
    if (obj.committer) {
      obj.committer = parseAuthor(obj.committer);
    }
    return obj
  }

  withoutSignature() {
    const tag = normalizeNewlines(this._tag);
    if (tag.indexOf('\n-----BEGIN PGP SIGNATURE-----') === -1) return tag
    return tag.slice(0, tag.lastIndexOf('\n-----BEGIN PGP SIGNATURE-----'))
  }

  gpgsig() {
    if (this._tag.indexOf('\n-----BEGIN PGP SIGNATURE-----') === -1) return
    const signature = this._tag.slice(
      this._tag.indexOf('-----BEGIN PGP SIGNATURE-----'),
      this._tag.indexOf('-----END PGP SIGNATURE-----') +
        '-----END PGP SIGNATURE-----'.length
    );
    return normalizeNewlines(signature)
  }

  payload() {
    return this.withoutSignature() + '\n'
  }

  toObject() {
    return Buffer.from(this._tag, 'utf8')
  }

  static async sign(tag, sign, secretKey) {
    const payload = tag.payload();
    let { signature } = await sign({ payload, secretKey });
    // renormalize the line endings to the one true line-ending
    signature = normalizeNewlines(signature);
    const signedTag = payload + signature;
    // return a new tag object
    return GitAnnotatedTag.from(signedTag)
  }
}

function indent(str) {
  return (
    str
      .trim()
      .split('\n')
      .map(x => ' ' + x)
      .join('\n') + '\n'
  )
}

function outdent(str) {
  return str
    .split('\n')
    .map(x => x.replace(/^ /, ''))
    .join('\n')
}

class GitCommit {
  constructor(commit) {
    if (typeof commit === 'string') {
      this._commit = commit;
    } else if (Buffer.isBuffer(commit)) {
      this._commit = commit.toString('utf8');
    } else if (typeof commit === 'object') {
      this._commit = GitCommit.render(commit);
    } else {
      throw new InternalError('invalid type passed to GitCommit constructor')
    }
  }

  static fromPayloadSignature({ payload, signature }) {
    const headers = GitCommit.justHeaders(payload);
    const message = GitCommit.justMessage(payload);
    const commit = normalizeNewlines(
      headers + '\ngpgsig' + indent(signature) + '\n' + message
    );
    return new GitCommit(commit)
  }

  static from(commit) {
    return new GitCommit(commit)
  }

  toObject() {
    return Buffer.from(this._commit, 'utf8')
  }

  // Todo: allow setting the headers and message
  headers() {
    return this.parseHeaders()
  }

  // Todo: allow setting the headers and message
  message() {
    return GitCommit.justMessage(this._commit)
  }

  parse() {
    return Object.assign({ message: this.message() }, this.headers())
  }

  static justMessage(commit) {
    return normalizeNewlines(commit.slice(commit.indexOf('\n\n') + 2))
  }

  static justHeaders(commit) {
    return commit.slice(0, commit.indexOf('\n\n'))
  }

  parseHeaders() {
    const headers = GitCommit.justHeaders(this._commit).split('\n');
    const hs = [];
    for (const h of headers) {
      if (h[0] === ' ') {
        // combine with previous header (without space indent)
        hs[hs.length - 1] += '\n' + h.slice(1);
      } else {
        hs.push(h);
      }
    }
    const obj = {
      parent: [],
    };
    for (const h of hs) {
      const key = h.slice(0, h.indexOf(' '));
      const value = h.slice(h.indexOf(' ') + 1);
      if (Array.isArray(obj[key])) {
        obj[key].push(value);
      } else {
        obj[key] = value;
      }
    }
    if (obj.author) {
      obj.author = parseAuthor(obj.author);
    }
    if (obj.committer) {
      obj.committer = parseAuthor(obj.committer);
    }
    return obj
  }

  static renderHeaders(obj) {
    let headers = '';
    if (obj.tree) {
      headers += `tree ${obj.tree}\n`;
    } else {
      headers += `tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\n`; // the null tree
    }
    if (obj.parent) {
      if (obj.parent.length === undefined) {
        throw new InternalError(`commit 'parent' property should be an array`)
      }
      for (const p of obj.parent) {
        headers += `parent ${p}\n`;
      }
    }
    const author = obj.author;
    headers += `author ${formatAuthor(author)}\n`;
    const committer = obj.committer || obj.author;
    headers += `committer ${formatAuthor(committer)}\n`;
    if (obj.gpgsig) {
      headers += 'gpgsig' + indent(obj.gpgsig);
    }
    return headers
  }

  static render(obj) {
    return GitCommit.renderHeaders(obj) + '\n' + normalizeNewlines(obj.message)
  }

  render() {
    return this._commit
  }

  withoutSignature() {
    const commit = normalizeNewlines(this._commit);
    if (commit.indexOf('\ngpgsig') === -1) return commit
    const headers = commit.slice(0, commit.indexOf('\ngpgsig'));
    const message = commit.slice(
      commit.indexOf('-----END PGP SIGNATURE-----\n') +
        '-----END PGP SIGNATURE-----\n'.length
    );
    return normalizeNewlines(headers + '\n' + message)
  }

  isolateSignature() {
    const signature = this._commit.slice(
      this._commit.indexOf('-----BEGIN PGP SIGNATURE-----'),
      this._commit.indexOf('-----END PGP SIGNATURE-----') +
        '-----END PGP SIGNATURE-----'.length
    );
    return outdent(signature)
  }

  static async sign(commit, sign, secretKey) {
    const payload = commit.withoutSignature();
    const message = GitCommit.justMessage(commit._commit);
    let { signature } = await sign({ payload, secretKey });
    // renormalize the line endings to the one true line-ending
    signature = normalizeNewlines(signature);
    const headers = GitCommit.justHeaders(commit._commit);
    const signedCommit =
      headers + '\n' + 'gpgsig' + indent(signature) + '\n' + message;
    // return a new commit object
    return GitCommit.from(signedCommit)
  }
}

async function resolveTree({ fs, cache, gitdir, oid }) {
  // Empty tree - bypass `readObject`
  if (oid === '4b825dc642cb6eb9a060e54bf8d69288fbee4904') {
    return { tree: GitTree.from([]), oid }
  }
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  // Resolve annotated tag objects to whatever
  if (type === 'tag') {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveTree({ fs, cache, gitdir, oid })
  }
  // Resolve commits to trees
  if (type === 'commit') {
    oid = GitCommit.from(object).parse().tree;
    return resolveTree({ fs, cache, gitdir, oid })
  }
  if (type !== 'tree') {
    throw new ObjectTypeError(oid, type, 'tree')
  }
  return { tree: GitTree.from(object), oid }
}

class GitWalkerRepo {
  constructor({ fs, gitdir, ref, cache }) {
    this.fs = fs;
    this.cache = cache;
    this.gitdir = gitdir;
    this.mapPromise = (async () => {
      const map = new Map();
      let oid;
      try {
        oid = await GitRefManager.resolve({ fs, gitdir, ref });
      } catch (e) {
        if (e instanceof NotFoundError) {
          // Handle fresh branches with no commits
          oid = '4b825dc642cb6eb9a060e54bf8d69288fbee4904';
        }
      }
      const tree = await resolveTree({ fs, cache: this.cache, gitdir, oid });
      tree.type = 'tree';
      tree.mode = '40000';
      map.set('.', tree);
      return map
    })();
    const walker = this;
    this.ConstructEntry = class TreeEntry {
      constructor(fullpath) {
        this._fullpath = fullpath;
        this._type = false;
        this._mode = false;
        this._stat = false;
        this._content = false;
        this._oid = false;
      }

      async type() {
        return walker.type(this)
      }

      async mode() {
        return walker.mode(this)
      }

      async stat() {
        return walker.stat(this)
      }

      async content() {
        return walker.content(this)
      }

      async oid() {
        return walker.oid(this)
      }
    };
  }

  async readdir(entry) {
    const filepath = entry._fullpath;
    const { fs, cache, gitdir } = this;
    const map = await this.mapPromise;
    const obj = map.get(filepath);
    if (!obj) throw new Error(`No obj for ${filepath}`)
    const oid = obj.oid;
    if (!oid) throw new Error(`No oid for obj ${JSON.stringify(obj)}`)
    if (obj.type !== 'tree') {
      // TODO: support submodules (type === 'commit')
      return null
    }
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    if (type !== obj.type) {
      throw new ObjectTypeError(oid, type, obj.type)
    }
    const tree = GitTree.from(object);
    // cache all entries
    for (const entry of tree) {
      map.set(join(filepath, entry.path), entry);
    }
    return tree.entries().map(entry => join(filepath, entry.path))
  }

  async type(entry) {
    if (entry._type === false) {
      const map = await this.mapPromise;
      const { type } = map.get(entry._fullpath);
      entry._type = type;
    }
    return entry._type
  }

  async mode(entry) {
    if (entry._mode === false) {
      const map = await this.mapPromise;
      const { mode } = map.get(entry._fullpath);
      entry._mode = normalizeMode(parseInt(mode, 8));
    }
    return entry._mode
  }

  async stat(_entry) {}

  async content(entry) {
    if (entry._content === false) {
      const map = await this.mapPromise;
      const { fs, cache, gitdir } = this;
      const obj = map.get(entry._fullpath);
      const oid = obj.oid;
      const { type, object } = await _readObject({ fs, cache, gitdir, oid });
      if (type !== 'blob') {
        entry._content = undefined;
      } else {
        entry._content = new Uint8Array(object);
      }
    }
    return entry._content
  }

  async oid(entry) {
    if (entry._oid === false) {
      const map = await this.mapPromise;
      const obj = map.get(entry._fullpath);
      entry._oid = obj.oid;
    }
    return entry._oid
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {string} [args.ref='HEAD']
 * @returns {Walker}
 */
function TREE({ ref = 'HEAD' }) {
  const o = Object.create(null);
  Object.defineProperty(o, GitWalkSymbol, {
    value: function({ fs, gitdir, cache }) {
      return new GitWalkerRepo({ fs, gitdir, ref, cache })
    },
  });
  Object.freeze(o);
  return o
}

// @ts-check

class GitWalkerFs {
  constructor({ fs, dir, gitdir, cache }) {
    this.fs = fs;
    this.cache = cache;
    this.dir = dir;
    this.gitdir = gitdir;
    const walker = this;
    this.ConstructEntry = class WorkdirEntry {
      constructor(fullpath) {
        this._fullpath = fullpath;
        this._type = false;
        this._mode = false;
        this._stat = false;
        this._content = false;
        this._oid = false;
      }

      async type() {
        return walker.type(this)
      }

      async mode() {
        return walker.mode(this)
      }

      async stat() {
        return walker.stat(this)
      }

      async content() {
        return walker.content(this)
      }

      async oid() {
        return walker.oid(this)
      }
    };
  }

  async readdir(entry) {
    const filepath = entry._fullpath;
    const { fs, dir } = this;
    const names = await fs.readdir(join(dir, filepath));
    if (names === null) return null
    return names.map(name => join(filepath, name))
  }

  async type(entry) {
    if (entry._type === false) {
      await entry.stat();
    }
    return entry._type
  }

  async mode(entry) {
    if (entry._mode === false) {
      await entry.stat();
    }
    return entry._mode
  }

  async stat(entry) {
    if (entry._stat === false) {
      const { fs, dir } = this;
      let stat = await fs.lstat(`${dir}/${entry._fullpath}`);
      if (!stat) {
        throw new Error(
          `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
        )
      }
      let type = stat.isDirectory() ? 'tree' : 'blob';
      if (type === 'blob' && !stat.isFile() && !stat.isSymbolicLink()) {
        type = 'special';
      }
      entry._type = type;
      stat = normalizeStats(stat);
      entry._mode = stat.mode;
      // workaround for a BrowserFS edge case
      if (stat.size === -1 && entry._actualSize) {
        stat.size = entry._actualSize;
      }
      entry._stat = stat;
    }
    return entry._stat
  }

  async content(entry) {
    if (entry._content === false) {
      const { fs, dir } = this;
      if ((await entry.type()) === 'tree') {
        entry._content = undefined;
      } else {
        const content = await fs.read(`${dir}/${entry._fullpath}`);
        // workaround for a BrowserFS edge case
        entry._actualSize = content.length;
        if (entry._stat && entry._stat.size === -1) {
          entry._stat.size = entry._actualSize;
        }
        entry._content = new Uint8Array(content);
      }
    }
    return entry._content
  }

  async oid(entry) {
    if (entry._oid === false) {
      const { fs, gitdir, cache } = this;
      let oid;
      // See if we can use the SHA1 hash in the index.
      await GitIndexManager.acquire({ fs, gitdir, cache }, async function(
        index
      ) {
        const stage = index.entriesMap.get(entry._fullpath);
        const stats = await entry.stat();
        if (!stage || compareStats(stats, stage)) {
          const content = await entry.content();
          if (content === undefined) {
            oid = undefined;
          } else {
            oid = await shasum(
              GitObject.wrap({ type: 'blob', object: await entry.content() })
            );
            // Update the stats in the index so we will get a "cache hit" next time
            // 1) if we can (because the oid and mode are the same)
            // 2) and only if we need to (because other stats differ)
            if (
              stage &&
              oid === stage.oid &&
              stats.mode === stage.mode &&
              compareStats(stats, stage)
            ) {
              index.insert({
                filepath: entry._fullpath,
                stats,
                oid: oid,
              });
            }
          }
        } else {
          // Use the index SHA1 rather than compute it
          oid = stage.oid;
        }
      });
      entry._oid = oid;
    }
    return entry._oid
  }
}

// @ts-check

/**
 * @returns {Walker}
 */
function WORKDIR() {
  const o = Object.create(null);
  Object.defineProperty(o, GitWalkSymbol, {
    value: function({ fs, dir, gitdir, cache }) {
      return new GitWalkerFs({ fs, dir, gitdir, cache })
    },
  });
  Object.freeze(o);
  return o
}

// @ts-check

// I'm putting this in a Manager because I reckon it could benefit
// from a LOT of cacheing.
class GitIgnoreManager {
  static async isIgnored({ fs, dir, gitdir = join(dir, '.git'), filepath }) {
    // ALWAYS ignore ".git" folders.
    if (basename(filepath) === '.git') return true
    // '.' is not a valid gitignore entry, so '.' is never ignored
    if (filepath === '.') return false
    // Check and load exclusion rules from project exclude file (.git/info/exclude)
    let excludes = '';
    const excludesFile = join(gitdir, 'info', 'exclude');
    if (await fs.exists(excludesFile)) {
      excludes = await fs.read(excludesFile, 'utf8');
    }
    // Find all the .gitignore files that could affect this file
    const pairs = [
      {
        gitignore: join(dir, '.gitignore'),
        filepath,
      },
    ];
    const pieces = filepath.split('/').filter(Boolean);
    for (let i = 1; i < pieces.length; i++) {
      const folder = pieces.slice(0, i).join('/');
      const file = pieces.slice(i).join('/');
      pairs.push({
        gitignore: join(dir, folder, '.gitignore'),
        filepath: file,
      });
    }
    let ignoredStatus = false;
    for (const p of pairs) {
      let file;
      try {
        file = await fs.read(p.gitignore, 'utf8');
      } catch (err) {
        if (err.code === 'NOENT') continue
      }
      const ign = ignore__WEBPACK_IMPORTED_MODULE_4__().add(excludes);
      ign.add(file);
      // If the parent directory is excluded, we are done.
      // "It is not possible to re-include a file if a parent directory of that file is excluded. Git doesnt list excluded directories for performance reasons, so any patterns on contained files have no effect, no matter where they are defined."
      // source: https://git-scm.com/docs/gitignore
      const parentdir = dirname(p.filepath);
      if (parentdir !== '.' && ign.ignores(parentdir)) return true
      // If the file is currently ignored, test for UNignoring.
      if (ignoredStatus) {
        ignoredStatus = !ign.test(p.filepath).unignored;
      } else {
        ignoredStatus = ign.test(p.filepath).ignored;
      }
    }
    return ignoredStatus
  }
}

/**
 * Removes the directory at the specified filepath recursively. Used internally to replicate the behavior of
 * fs.promises.rm({ recursive: true, force: true }) from Node.js 14 and above when not available. If the provided
 * filepath resolves to a file, it will be removed.
 *
 * @param {import('../models/FileSystem.js').FileSystem} fs
 * @param {string} filepath - The file or directory to remove.
 */
async function rmRecursive(fs, filepath) {
  const entries = await fs.readdir(filepath);
  if (entries == null) {
    await fs.rm(filepath);
  } else if (entries.length) {
    await Promise.all(
      entries.map(entry => {
        const subpath = join(filepath, entry);
        return fs.lstat(subpath).then(stat => {
          if (!stat) return
          return stat.isDirectory() ? rmRecursive(fs, subpath) : fs.rm(subpath)
        })
      })
    ).then(() => fs.rmdir(filepath));
  } else {
    await fs.rmdir(filepath);
  }
}

/**
 * This is just a collection of helper functions really. At least that's how it started.
 */
class FileSystem {
  constructor(fs) {
    if (typeof fs._original_unwrapped_fs !== 'undefined') return fs

    const promises = Object.getOwnPropertyDescriptor(fs, 'promises');
    if (promises && promises.enumerable) {
      this._readFile = fs.promises.readFile.bind(fs.promises);
      this._writeFile = fs.promises.writeFile.bind(fs.promises);
      this._mkdir = fs.promises.mkdir.bind(fs.promises);
      if (fs.promises.rm) {
        this._rm = fs.promises.rm.bind(fs.promises);
      } else if (fs.promises.rmdir.length > 1) {
        this._rm = fs.promises.rmdir.bind(fs.promises);
      } else {
        this._rm = rmRecursive.bind(null, this);
      }
      this._rmdir = fs.promises.rmdir.bind(fs.promises);
      this._unlink = fs.promises.unlink.bind(fs.promises);
      this._stat = fs.promises.stat.bind(fs.promises);
      this._lstat = fs.promises.lstat.bind(fs.promises);
      this._readdir = fs.promises.readdir.bind(fs.promises);
      this._readlink = fs.promises.readlink.bind(fs.promises);
      this._symlink = fs.promises.symlink.bind(fs.promises);
    } else {
      this._readFile = pify__WEBPACK_IMPORTED_MODULE_5__(fs.readFile.bind(fs));
      this._writeFile = pify__WEBPACK_IMPORTED_MODULE_5__(fs.writeFile.bind(fs));
      this._mkdir = pify__WEBPACK_IMPORTED_MODULE_5__(fs.mkdir.bind(fs));
      if (fs.rm) {
        this._rm = pify__WEBPACK_IMPORTED_MODULE_5__(fs.rm.bind(fs));
      } else if (fs.rmdir.length > 2) {
        this._rm = pify__WEBPACK_IMPORTED_MODULE_5__(fs.rmdir.bind(fs));
      } else {
        this._rm = rmRecursive.bind(null, this);
      }
      this._rmdir = pify__WEBPACK_IMPORTED_MODULE_5__(fs.rmdir.bind(fs));
      this._unlink = pify__WEBPACK_IMPORTED_MODULE_5__(fs.unlink.bind(fs));
      this._stat = pify__WEBPACK_IMPORTED_MODULE_5__(fs.stat.bind(fs));
      this._lstat = pify__WEBPACK_IMPORTED_MODULE_5__(fs.lstat.bind(fs));
      this._readdir = pify__WEBPACK_IMPORTED_MODULE_5__(fs.readdir.bind(fs));
      this._readlink = pify__WEBPACK_IMPORTED_MODULE_5__(fs.readlink.bind(fs));
      this._symlink = pify__WEBPACK_IMPORTED_MODULE_5__(fs.symlink.bind(fs));
    }
    this._original_unwrapped_fs = fs;
  }

  /**
   * Return true if a file exists, false if it doesn't exist.
   * Rethrows errors that aren't related to file existance.
   */
  async exists(filepath, options = {}) {
    try {
      await this._stat(filepath);
      return true
    } catch (err) {
      if (err.code === 'ENOENT' || err.code === 'ENOTDIR') {
        return false
      } else {
        console.log('Unhandled error in "FileSystem.exists()" function', err);
        throw err
      }
    }
  }

  /**
   * Return the contents of a file if it exists, otherwise returns null.
   *
   * @param {string} filepath
   * @param {object} [options]
   *
   * @returns {Promise<Buffer|string|null>}
   */
  async read(filepath, options = {}) {
    try {
      let buffer = await this._readFile(filepath, options);
      // Convert plain ArrayBuffers to Buffers
      if (typeof buffer !== 'string') {
        buffer = Buffer.from(buffer);
      }
      return buffer
    } catch (err) {
      return null
    }
  }

  /**
   * Write a file (creating missing directories if need be) without throwing errors.
   *
   * @param {string} filepath
   * @param {Buffer|Uint8Array|string} contents
   * @param {object|string} [options]
   */
  async write(filepath, contents, options = {}) {
    try {
      await this._writeFile(filepath, contents, options);
      return
    } catch (err) {
      // Hmm. Let's try mkdirp and try again.
      await this.mkdir(dirname(filepath));
      await this._writeFile(filepath, contents, options);
    }
  }

  /**
   * Make a directory (or series of nested directories) without throwing an error if it already exists.
   */
  async mkdir(filepath, _selfCall = false) {
    try {
      await this._mkdir(filepath);
      return
    } catch (err) {
      // If err is null then operation succeeded!
      if (err === null) return
      // If the directory already exists, that's OK!
      if (err.code === 'EEXIST') return
      // Avoid infinite loops of failure
      if (_selfCall) throw err
      // If we got a "no such file or directory error" backup and try again.
      if (err.code === 'ENOENT') {
        const parent = dirname(filepath);
        // Check to see if we've gone too far
        if (parent === '.' || parent === '/' || parent === filepath) throw err
        // Infinite recursion, what could go wrong?
        await this.mkdir(parent);
        await this.mkdir(filepath, true);
      }
    }
  }

  /**
   * Delete a file without throwing an error if it is already deleted.
   */
  async rm(filepath) {
    try {
      await this._unlink(filepath);
    } catch (err) {
      if (err.code !== 'ENOENT') throw err
    }
  }

  /**
   * Delete a directory without throwing an error if it is already deleted.
   */
  async rmdir(filepath, opts) {
    try {
      if (opts && opts.recursive) {
        await this._rm(filepath, opts);
      } else {
        await this._rmdir(filepath);
      }
    } catch (err) {
      if (err.code !== 'ENOENT') throw err
    }
  }

  /**
   * Read a directory without throwing an error is the directory doesn't exist
   */
  async readdir(filepath) {
    try {
      const names = await this._readdir(filepath);
      // Ordering is not guaranteed, and system specific (Windows vs Unix)
      // so we must sort them ourselves.
      names.sort(compareStrings);
      return names
    } catch (err) {
      if (err.code === 'ENOTDIR') return null
      return []
    }
  }

  /**
   * Return a flast list of all the files nested inside a directory
   *
   * Based on an elegant concurrent recursive solution from SO
   * https://stackoverflow.com/a/45130990/2168416
   */
  async readdirDeep(dir) {
    const subdirs = await this._readdir(dir);
    const files = await Promise.all(
      subdirs.map(async subdir => {
        const res = dir + '/' + subdir;
        return (await this._stat(res)).isDirectory()
          ? this.readdirDeep(res)
          : res
      })
    );
    return files.reduce((a, f) => a.concat(f), [])
  }

  /**
   * Return the Stats of a file/symlink if it exists, otherwise returns null.
   * Rethrows errors that aren't related to file existance.
   */
  async lstat(filename) {
    try {
      const stats = await this._lstat(filename);
      return stats
    } catch (err) {
      if (err.code === 'ENOENT') {
        return null
      }
      throw err
    }
  }

  /**
   * Reads the contents of a symlink if it exists, otherwise returns null.
   * Rethrows errors that aren't related to file existance.
   */
  async readlink(filename, opts = { encoding: 'buffer' }) {
    // Note: FileSystem.readlink returns a buffer by default
    // so we can dump it into GitObject.write just like any other file.
    try {
      const link = await this._readlink(filename, opts);
      return Buffer.isBuffer(link) ? link : Buffer.from(link)
    } catch (err) {
      if (err.code === 'ENOENT') {
        return null
      }
      throw err
    }
  }

  /**
   * Write the contents of buffer to a symlink.
   */
  async writelink(filename, buffer) {
    return this._symlink(buffer.toString('utf8'), filename)
  }
}

async function writeObjectLoose({ fs, gitdir, object, format, oid }) {
  if (format !== 'deflated') {
    throw new InternalError(
      'GitObjectStoreLoose expects objects to write to be in deflated format'
    )
  }
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  const filepath = `${gitdir}/${source}`;
  // Don't overwrite existing git objects - this helps avoid EPERM errors.
  // Although I don't know how we'd fix corrupted objects then. Perhaps delete them
  // on read?
  if (!(await fs.exists(filepath))) await fs.write(filepath, object);
}

/* eslint-env node, browser */

let supportsCompressionStream = null;

async function deflate(buffer) {
  if (supportsCompressionStream === null) {
    supportsCompressionStream = testCompressionStream();
  }
  return supportsCompressionStream
    ? browserDeflate(buffer)
    : pako__WEBPACK_IMPORTED_MODULE_3__.deflate(buffer)
}

async function browserDeflate(buffer) {
  const cs = new CompressionStream('deflate');
  const c = new Blob([buffer]).stream().pipeThrough(cs);
  return new Uint8Array(await new Response(c).arrayBuffer())
}

function testCompressionStream() {
  try {
    const cs = new CompressionStream('deflate');
    // Test if `Blob.stream` is present. React Native does not have the `stream` method
    new Blob([]).stream();
    if (cs) return true
  } catch (_) {
    // no bother
  }
  return false
}

async function _writeObject({
  fs,
  gitdir,
  type,
  object,
  format = 'content',
  oid = undefined,
  dryRun = false,
}) {
  if (format !== 'deflated') {
    if (format !== 'wrapped') {
      object = GitObject.wrap({ type, object });
    }
    oid = await shasum(object);
    object = Buffer.from(await deflate(object));
  }
  if (!dryRun) {
    await writeObjectLoose({ fs, gitdir, object, format: 'deflated', oid });
  }
  return oid
}

function assertParameter(name, value) {
  if (value === undefined) {
    throw new MissingParameterError(name)
  }
}

function posixifyPathBuffer(buffer) {
  let idx;
  while (~(idx = buffer.indexOf(92))) buffer[idx] = 47;
  return buffer
}

// @ts-check

/**
 * Add a file to the git index (aka staging area)
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.filepath - The path to the file to add to the index
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully once the git index has been updated
 *
 * @example
 * await fs.promises.writeFile('/tutorial/README.md', `# TEST`)
 * await git.add({ fs, dir: '/tutorial', filepath: 'README.md' })
 * console.log('done')
 *
 */
async function add({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  filepath,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('dir', dir);
    assertParameter('gitdir', gitdir);
    assertParameter('filepath', filepath);

    const fs = new FileSystem(_fs);
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      await addToIndex({ dir, gitdir, fs, filepath, index });
    });
  } catch (err) {
    err.caller = 'git.add';
    throw err
  }
}

async function addToIndex({ dir, gitdir, fs, filepath, index }) {
  // TODO: Should ignore UNLESS it's already in the index.
  const ignored = await GitIgnoreManager.isIgnored({
    fs,
    dir,
    gitdir,
    filepath,
  });
  if (ignored) return
  const stats = await fs.lstat(join(dir, filepath));
  if (!stats) throw new NotFoundError(filepath)
  if (stats.isDirectory()) {
    const children = await fs.readdir(join(dir, filepath));
    const promises = children.map(child =>
      addToIndex({ dir, gitdir, fs, filepath: join(filepath, child), index })
    );
    await Promise.all(promises);
  } else {
    const object = stats.isSymbolicLink()
      ? await fs.readlink(join(dir, filepath)).then(posixifyPathBuffer)
      : await fs.read(join(dir, filepath));
    if (object === null) throw new NotFoundError(filepath)
    const oid = await _writeObject({ fs, gitdir, type: 'blob', object });
    index.insert({ filepath, stats, oid });
  }
}

// @ts-check

/**
 *
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {SignCallback} [args.onSign]
 * @param {string} args.gitdir
 * @param {string} args.message
 * @param {Object} args.author
 * @param {string} args.author.name
 * @param {string} args.author.email
 * @param {number} args.author.timestamp
 * @param {number} args.author.timezoneOffset
 * @param {Object} args.committer
 * @param {string} args.committer.name
 * @param {string} args.committer.email
 * @param {number} args.committer.timestamp
 * @param {number} args.committer.timezoneOffset
 * @param {string} [args.signingKey]
 * @param {boolean} [args.dryRun = false]
 * @param {boolean} [args.noUpdateBranch = false]
 * @param {string} [args.ref]
 * @param {string[]} [args.parent]
 * @param {string} [args.tree]
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly created commit.
 */
async function _commit({
  fs,
  cache,
  onSign,
  gitdir,
  message,
  author,
  committer,
  signingKey,
  dryRun = false,
  noUpdateBranch = false,
  ref,
  parent,
  tree,
}) {
  if (!ref) {
    ref = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: 'HEAD',
      depth: 2,
    });
  }

  return GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
    const inodes = flatFileListToDirectoryStructure(index.entries);
    const inode = inodes.get('.');
    if (!tree) {
      tree = await constructTree({ fs, gitdir, inode, dryRun });
    }
    if (!parent) {
      try {
        parent = [
          await GitRefManager.resolve({
            fs,
            gitdir,
            ref,
          }),
        ];
      } catch (err) {
        // Probably an initial commit
        parent = [];
      }
    }
    let comm = GitCommit.from({
      tree,
      parent,
      author,
      committer,
      message,
    });
    if (signingKey) {
      comm = await GitCommit.sign(comm, onSign, signingKey);
    }
    const oid = await _writeObject({
      fs,
      gitdir,
      type: 'commit',
      object: comm.toObject(),
      dryRun,
    });
    if (!noUpdateBranch && !dryRun) {
      // Update branch pointer
      await GitRefManager.writeRef({
        fs,
        gitdir,
        ref,
        value: oid,
      });
    }
    return oid
  })
}

async function constructTree({ fs, gitdir, inode, dryRun }) {
  // use depth first traversal
  const children = inode.children;
  for (const inode of children) {
    if (inode.type === 'tree') {
      inode.metadata.mode = '040000';
      inode.metadata.oid = await constructTree({ fs, gitdir, inode, dryRun });
    }
  }
  const entries = children.map(inode => ({
    mode: inode.metadata.mode,
    path: inode.basename,
    oid: inode.metadata.oid,
    type: inode.type,
  }));
  const tree = GitTree.from(entries);
  const oid = await _writeObject({
    fs,
    gitdir,
    type: 'tree',
    object: tree.toObject(),
    dryRun,
  });
  return oid
}

// @ts-check

async function resolveFilepath({ fs, cache, gitdir, oid, filepath }) {
  // Ensure there are no leading or trailing directory separators.
  // I was going to do this automatically, but then found that the Git Terminal for Windows
  // auto-expands --filepath=/src/utils to --filepath=C:/Users/Will/AppData/Local/Programs/Git/src/utils
  // so I figured it would be wise to promote the behavior in the application layer not just the library layer.
  if (filepath.startsWith('/')) {
    throw new InvalidFilepathError('leading-slash')
  } else if (filepath.endsWith('/')) {
    throw new InvalidFilepathError('trailing-slash')
  }
  const _oid = oid;
  const result = await resolveTree({ fs, cache, gitdir, oid });
  const tree = result.tree;
  if (filepath === '') {
    oid = result.oid;
  } else {
    const pathArray = filepath.split('/');
    oid = await _resolveFilepath({
      fs,
      cache,
      gitdir,
      tree,
      pathArray,
      oid: _oid,
      filepath,
    });
  }
  return oid
}

async function _resolveFilepath({
  fs,
  cache,
  gitdir,
  tree,
  pathArray,
  oid,
  filepath,
}) {
  const name = pathArray.shift();
  for (const entry of tree) {
    if (entry.path === name) {
      if (pathArray.length === 0) {
        return entry.oid
      } else {
        const { type, object } = await _readObject({
          fs,
          cache,
          gitdir,
          oid: entry.oid,
        });
        if (type !== 'tree') {
          throw new ObjectTypeError(oid, type, 'blob', filepath)
        }
        tree = GitTree.from(object);
        return _resolveFilepath({
          fs,
          cache,
          gitdir,
          tree,
          pathArray,
          oid,
          filepath,
        })
      }
    }
  }
  throw new NotFoundError(`file or directory found at "${oid}:${filepath}"`)
}

// @ts-check

/**
 *
 * @typedef {Object} ReadTreeResult - The object returned has the following schema:
 * @property {string} oid - SHA-1 object id of this tree
 * @property {TreeObject} tree - the parsed tree object
 */

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.oid
 * @param {string} [args.filepath]
 *
 * @returns {Promise<ReadTreeResult>}
 */
async function _readTree({
  fs,
  cache,
  gitdir,
  oid,
  filepath = undefined,
}) {
  if (filepath !== undefined) {
    oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });
  }
  const { tree, oid: treeOid } = await resolveTree({ fs, cache, gitdir, oid });
  const result = {
    oid: treeOid,
    tree: tree.entries(),
  };
  return result
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {TreeObject} args.tree
 *
 * @returns {Promise<string>}
 */
async function _writeTree({ fs, gitdir, tree }) {
  // Convert object to buffer
  const object = GitTree.from(tree).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: 'tree',
    object,
    format: 'content',
  });
  return oid
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {SignCallback} [args.onSign]
 * @param {string} args.gitdir
 * @param {string} args.ref
 * @param {string} args.oid
 * @param {string|Uint8Array} args.note
 * @param {boolean} [args.force]
 * @param {Object} args.author
 * @param {string} args.author.name
 * @param {string} args.author.email
 * @param {number} args.author.timestamp
 * @param {number} args.author.timezoneOffset
 * @param {Object} args.committer
 * @param {string} args.committer.name
 * @param {string} args.committer.email
 * @param {number} args.committer.timestamp
 * @param {number} args.committer.timezoneOffset
 * @param {string} [args.signingKey]
 *
 * @returns {Promise<string>}
 */

async function _addNote({
  fs,
  cache,
  onSign,
  gitdir,
  ref,
  oid,
  note,
  force,
  author,
  committer,
  signingKey,
}) {
  // Get the current note commit
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (!(err instanceof NotFoundError)) {
      throw err
    }
  }

  // I'm using the "empty tree" magic number here for brevity
  const result = await _readTree({
    fs,
    cache,
    gitdir,
    oid: parent || '4b825dc642cb6eb9a060e54bf8d69288fbee4904',
  });
  let tree = result.tree;

  // Handle the case where a note already exists
  if (force) {
    tree = tree.filter(entry => entry.path !== oid);
  } else {
    for (const entry of tree) {
      if (entry.path === oid) {
        throw new AlreadyExistsError('note', oid)
      }
    }
  }

  // Create the note blob
  if (typeof note === 'string') {
    note = Buffer.from(note, 'utf8');
  }
  const noteOid = await _writeObject({
    fs,
    gitdir,
    type: 'blob',
    object: note,
    format: 'content',
  });

  // Create the new note tree
  tree.push({ mode: '100644', path: oid, oid: noteOid, type: 'blob' });
  const treeOid = await _writeTree({
    fs,
    gitdir,
    tree,
  });

  // Create the new note commit
  const commitOid = await _commit({
    fs,
    cache,
    onSign,
    gitdir,
    ref,
    tree: treeOid,
    parent: parent && [parent],
    message: `Note added by 'isomorphic-git addNote'\n`,
    author,
    committer,
    signingKey,
  });

  return commitOid
}

// @ts-check

/**
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.path
 *
 * @returns {Promise<any>} Resolves with the config value
 *
 * @example
 * // Read config value
 * let value = await git.getConfig({
 *   dir: '$input((/))',
 *   path: '$input((user.name))'
 * })
 * console.log(value)
 *
 */
async function _getConfig({ fs, gitdir, path }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  return config.get(path)
}

/**
 *
 * @returns {Promise<void | {name: string, email: string, date: Date, timestamp: number, timezoneOffset: number }>}
 */
async function normalizeAuthorObject({ fs, gitdir, author = {} }) {
  let { name, email, timestamp, timezoneOffset } = author;
  name = name || (await _getConfig({ fs, gitdir, path: 'user.name' }));
  email = email || (await _getConfig({ fs, gitdir, path: 'user.email' })) || '';

  if (name === undefined) {
    return undefined
  }

  timestamp = timestamp != null ? timestamp : Math.floor(Date.now() / 1000);
  timezoneOffset =
    timezoneOffset != null
      ? timezoneOffset
      : new Date(timestamp * 1000).getTimezoneOffset();

  return { name, email, timestamp, timezoneOffset }
}

/**
 *
 * @returns {Promise<void | {name: string, email: string, timestamp: number, timezoneOffset: number }>}
 */
async function normalizeCommitterObject({
  fs,
  gitdir,
  author,
  committer,
}) {
  committer = Object.assign({}, committer || author);
  // Match committer's date to author's one, if omitted
  if (author) {
    committer.timestamp = committer.timestamp || author.timestamp;
    committer.timezoneOffset = committer.timezoneOffset || author.timezoneOffset;
  }
  committer = await normalizeAuthorObject({ fs, gitdir, author: committer });
  return committer
}

// @ts-check

/**
 * Add or update an object note
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {SignCallback} [args.onSign] - a PGP signing implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - The notes ref to look under
 * @param {string} args.oid - The SHA-1 object id of the object to add the note to.
 * @param {string|Uint8Array} args.note - The note to add
 * @param {boolean} [args.force] - Over-write note if it already exists.
 * @param {Object} [args.author] - The details about the author.
 * @param {string} [args.author.name] - Default is `user.name` config.
 * @param {string} [args.author.email] - Default is `user.email` config.
 * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {Object} [args.committer = author] - The details about the note committer, in the same format as the author parameter. If not specified, the author details are used.
 * @param {string} [args.committer.name] - Default is `user.name` config.
 * @param {string} [args.committer.email] - Default is `user.email` config.
 * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {string} [args.signingKey] - Sign the note commit using this private PGP key.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the commit object for the added note.
 */

async function addNote({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, '.git'),
  ref = 'refs/notes/commits',
  oid,
  note,
  force,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);
    assertParameter('note', note);
    if (signingKey) {
      assertParameter('onSign', onSign);
    }
    const fs = new FileSystem(_fs);

    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author) throw new MissingNameError('author')

    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer) throw new MissingNameError('committer')

    return await _addNote({
      fs: new FileSystem(fs),
      cache,
      onSign,
      gitdir,
      ref,
      oid,
      note,
      force,
      author,
      committer,
      signingKey,
    })
  } catch (err) {
    err.caller = 'git.addNote';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.remote
 * @param {string} args.url
 * @param {boolean} args.force
 *
 * @returns {Promise<void>}
 *
 */
async function _addRemote({ fs, gitdir, remote, url, force }) {
  if (remote !== clean_git_ref__WEBPACK_IMPORTED_MODULE_6__.clean(remote)) {
    throw new InvalidRefNameError(remote, clean_git_ref__WEBPACK_IMPORTED_MODULE_6__.clean(remote))
  }
  const config = await GitConfigManager.get({ fs, gitdir });
  if (!force) {
    // Check that setting it wouldn't overwrite.
    const remoteNames = await config.getSubsections('remote');
    if (remoteNames.includes(remote)) {
      // Throw an error if it would overwrite an existing remote,
      // but not if it's simply setting the same value again.
      if (url !== (await config.get(`remote.${remote}.url`))) {
        throw new AlreadyExistsError('remote', remote)
      }
    }
  }
  await config.set(`remote.${remote}.url`, url);
  await config.set(
    `remote.${remote}.fetch`,
    `+refs/heads/*:refs/remotes/${remote}/*`
  );
  await GitConfigManager.save({ fs, gitdir, config });
}

// @ts-check

/**
 * Add or update a remote
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.remote - The name of the remote
 * @param {string} args.url - The URL of the remote
 * @param {boolean} [args.force = false] - Instead of throwing an error if a remote named `remote` already exists, overwrite the existing remote.
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.addRemote({
 *   fs,
 *   dir: '/tutorial',
 *   remote: 'upstream',
 *   url: 'https://github.com/isomorphic-git/isomorphic-git'
 * })
 * console.log('done')
 *
 */
async function addRemote({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  remote,
  url,
  force = false,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('remote', remote);
    assertParameter('url', url);
    return await _addRemote({
      fs: new FileSystem(fs),
      gitdir,
      remote,
      url,
      force,
    })
  } catch (err) {
    err.caller = 'git.addRemote';
    throw err
  }
}

// @ts-check

/**
 * Create an annotated tag.
 *
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {SignCallback} [args.onSign]
 * @param {string} args.gitdir
 * @param {string} args.ref
 * @param {string} [args.message = ref]
 * @param {string} [args.object = 'HEAD']
 * @param {object} [args.tagger]
 * @param {string} args.tagger.name
 * @param {string} args.tagger.email
 * @param {number} args.tagger.timestamp
 * @param {number} args.tagger.timezoneOffset
 * @param {string} [args.gpgsig]
 * @param {string} [args.signingKey]
 * @param {boolean} [args.force = false]
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.annotatedTag({
 *   dir: '$input((/))',
 *   ref: '$input((test-tag))',
 *   message: '$input((This commit is awesome))',
 *   tagger: {
 *     name: '$input((Mr. Test))',
 *     email: '$input((mrtest@example.com))'
 *   }
 * })
 * console.log('done')
 *
 */
async function _annotatedTag({
  fs,
  cache,
  onSign,
  gitdir,
  ref,
  tagger,
  message = ref,
  gpgsig,
  object,
  signingKey,
  force = false,
}) {
  ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;

  if (!force && (await GitRefManager.exists({ fs, gitdir, ref }))) {
    throw new AlreadyExistsError('tag', ref)
  }

  // Resolve passed value
  const oid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: object || 'HEAD',
  });

  const { type } = await _readObject({ fs, cache, gitdir, oid });
  let tagObject = GitAnnotatedTag.from({
    object: oid,
    type,
    tag: ref.replace('refs/tags/', ''),
    tagger,
    message,
    gpgsig,
  });
  if (signingKey) {
    tagObject = await GitAnnotatedTag.sign(tagObject, onSign, signingKey);
  }
  const value = await _writeObject({
    fs,
    gitdir,
    type: 'tag',
    object: tagObject.toObject(),
  });

  await GitRefManager.writeRef({ fs, gitdir, ref, value });
}

// @ts-check

/**
 * Create an annotated tag.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {SignCallback} [args.onSign] - a PGP signing implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - What to name the tag
 * @param {string} [args.message = ref] - The tag message to use.
 * @param {string} [args.object = 'HEAD'] - The SHA-1 object id the tag points to. (Will resolve to a SHA-1 object id if value is a ref.) By default, the commit object which is referred by the current `HEAD` is used.
 * @param {object} [args.tagger] - The details about the tagger.
 * @param {string} [args.tagger.name] - Default is `user.name` config.
 * @param {string} [args.tagger.email] - Default is `user.email` config.
 * @param {number} [args.tagger.timestamp=Math.floor(Date.now()/1000)] - Set the tagger timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.tagger.timezoneOffset] - Set the tagger timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {string} [args.gpgsig] - The gpgsig attatched to the tag object. (Mutually exclusive with the `signingKey` option.)
 * @param {string} [args.signingKey] - Sign the tag object using this private PGP key. (Mutually exclusive with the `gpgsig` option.)
 * @param {boolean} [args.force = false] - Instead of throwing an error if a tag named `ref` already exists, overwrite the existing tag. Note that this option does not modify the original tag object itself.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.annotatedTag({
 *   fs,
 *   dir: '/tutorial',
 *   ref: 'test-tag',
 *   message: 'This commit is awesome',
 *   tagger: {
 *     name: 'Mr. Test',
 *     email: 'mrtest@example.com'
 *   }
 * })
 * console.log('done')
 *
 */
async function annotatedTag({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  tagger: _tagger,
  message = ref,
  gpgsig,
  object,
  signingKey,
  force = false,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);
    if (signingKey) {
      assertParameter('onSign', onSign);
    }
    const fs = new FileSystem(_fs);

    // Fill in missing arguments with default values
    const tagger = await normalizeAuthorObject({ fs, gitdir, author: _tagger });
    if (!tagger) throw new MissingNameError('tagger')

    return await _annotatedTag({
      fs,
      cache,
      onSign,
      gitdir,
      ref,
      tagger,
      message,
      gpgsig,
      object,
      signingKey,
      force,
    })
  } catch (err) {
    err.caller = 'git.annotatedTag';
    throw err
  }
}

// @ts-check

/**
 * Create a branch
 *
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.ref
 * @param {boolean} [args.checkout = false]
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.branch({ dir: '$input((/))', ref: '$input((develop))' })
 * console.log('done')
 *
 */
async function _branch({ fs, gitdir, ref, checkout = false }) {
  if (ref !== clean_git_ref__WEBPACK_IMPORTED_MODULE_6__.clean(ref)) {
    throw new InvalidRefNameError(ref, clean_git_ref__WEBPACK_IMPORTED_MODULE_6__.clean(ref))
  }

  const fullref = `refs/heads/${ref}`;

  const exist = await GitRefManager.exists({ fs, gitdir, ref: fullref });
  if (exist) {
    throw new AlreadyExistsError('branch', ref, false)
  }

  // Get current HEAD tree oid
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref: 'HEAD' });
  } catch (e) {
    // Probably an empty repo
  }

  // Create a new ref that points at the current commit
  if (oid) {
    await GitRefManager.writeRef({ fs, gitdir, ref: fullref, value: oid });
  }

  if (checkout) {
    // Update HEAD
    await GitRefManager.writeSymbolicRef({
      fs,
      gitdir,
      ref: 'HEAD',
      value: fullref,
    });
  }
}

// @ts-check

/**
 * Create a branch
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - What to name the branch
 * @param {boolean} [args.checkout = false] - Update `HEAD` to point at the newly created branch
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.branch({ fs, dir: '/tutorial', ref: 'develop' })
 * console.log('done')
 *
 */
async function branch({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  checkout = false,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);
    return await _branch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      checkout,
    })
  } catch (err) {
    err.caller = 'git.branch';
    throw err
  }
}

// https://dev.to/namirsab/comment/2050
function arrayRange(start, end) {
  const length = end - start;
  return Array.from({ length }, (_, i) => start + i)
}

// TODO: Should I just polyfill Array.flat?
const flat =
  typeof Array.prototype.flat === 'undefined'
    ? entries => entries.reduce((acc, x) => acc.concat(x), [])
    : entries => entries.flat();

// This is convenient for computing unions/joins of sorted lists.
class RunningMinimum {
  constructor() {
    // Using a getter for 'value' would just bloat the code.
    // You know better than to set it directly right?
    this.value = null;
  }

  consider(value) {
    if (value === null || value === undefined) return
    if (this.value === null) {
      this.value = value;
    } else if (value < this.value) {
      this.value = value;
    }
  }

  reset() {
    this.value = null;
  }
}

// Take an array of length N of
//   iterators of length Q_n
//     of strings
// and return an iterator of length max(Q_n) for all n
//   of arrays of length N
//     of string|null who all have the same string value
function* unionOfIterators(sets) {
  /* NOTE: We can assume all arrays are sorted.
   * Indexes are sorted because they are defined that way:
   *
   * > Index entries are sorted in ascending order on the name field,
   * > interpreted as a string of unsigned bytes (i.e. memcmp() order, no
   * > localization, no special casing of directory separator '/'). Entries
   * > with the same name are sorted by their stage field.
   *
   * Trees should be sorted because they are created directly from indexes.
   * They definitely should be sorted, or else they wouldn't have a unique SHA1.
   * So that would be very naughty on the part of the tree-creator.
   *
   * Lastly, the working dir entries are sorted because I choose to sort them
   * in my FileSystem.readdir() implementation.
   */

  // Init
  const min = new RunningMinimum();
  let minimum;
  const heads = [];
  const numsets = sets.length;
  for (let i = 0; i < numsets; i++) {
    // Abuse the fact that iterators continue to return 'undefined' for value
    // once they are done
    heads[i] = sets[i].next().value;
    if (heads[i] !== undefined) {
      min.consider(heads[i]);
    }
  }
  if (min.value === null) return
  // Iterate
  while (true) {
    const result = [];
    minimum = min.value;
    min.reset();
    for (let i = 0; i < numsets; i++) {
      if (heads[i] !== undefined && heads[i] === minimum) {
        result[i] = heads[i];
        heads[i] = sets[i].next().value;
      } else {
        // A little hacky, but eh
        result[i] = null;
      }
      if (heads[i] !== undefined) {
        min.consider(heads[i]);
      }
    }
    yield result;
    if (min.value === null) return
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {string} [args.dir]
 * @param {string} [args.gitdir=join(dir,'.git')]
 * @param {Walker[]} args.trees
 * @param {WalkerMap} [args.map]
 * @param {WalkerReduce} [args.reduce]
 * @param {WalkerIterate} [args.iterate]
 *
 * @returns {Promise<any>} The finished tree-walking result
 *
 * @see {WalkerMap}
 *
 */
async function _walk({
  fs,
  cache,
  dir,
  gitdir,
  trees,
  // @ts-ignore
  map = async (_, entry) => entry,
  // The default reducer is a flatmap that filters out undefineds.
  reduce = async (parent, children) => {
    const flatten = flat(children);
    if (parent !== undefined) flatten.unshift(parent);
    return flatten
  },
  // The default iterate function walks all children concurrently
  iterate = (walk, children) => Promise.all([...children].map(walk)),
}) {
  const walkers = trees.map(proxy =>
    proxy[GitWalkSymbol]({ fs, dir, gitdir, cache })
  );

  const root = new Array(walkers.length).fill('.');
  const range = arrayRange(0, walkers.length);
  const unionWalkerFromReaddir = async entries => {
    range.map(i => {
      entries[i] = entries[i] && new walkers[i].ConstructEntry(entries[i]);
    });
    const subdirs = await Promise.all(
      range.map(i => (entries[i] ? walkers[i].readdir(entries[i]) : []))
    );
    // Now process child directories
    const iterators = subdirs
      .map(array => (array === null ? [] : array))
      .map(array => array[Symbol.iterator]());
    return {
      entries,
      children: unionOfIterators(iterators),
    }
  };

  const walk = async root => {
    const { entries, children } = await unionWalkerFromReaddir(root);
    const fullpath = entries.find(entry => entry && entry._fullpath)._fullpath;
    const parent = await map(fullpath, entries);
    if (parent !== null) {
      let walkedChildren = await iterate(walk, children);
      walkedChildren = walkedChildren.filter(x => x !== undefined);
      return reduce(parent, walkedChildren)
    }
  };
  return walk(root)
}

const worthWalking = (filepath, root) => {
  if (filepath === '.' || root == null || root.length === 0 || root === '.') {
    return true
  }
  if (root.length >= filepath.length) {
    return root.startsWith(filepath)
  } else {
    return filepath.startsWith(root)
  }
};

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {ProgressCallback} [args.onProgress]
 * @param {string} args.dir
 * @param {string} args.gitdir
 * @param {string} args.ref
 * @param {string[]} [args.filepaths]
 * @param {string} args.remote
 * @param {boolean} args.noCheckout
 * @param {boolean} [args.noUpdateHead]
 * @param {boolean} [args.dryRun]
 * @param {boolean} [args.force]
 * @param {boolean} [args.track]
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 */
async function _checkout({
  fs,
  cache,
  onProgress,
  dir,
  gitdir,
  remote,
  ref,
  filepaths,
  noCheckout,
  noUpdateHead,
  dryRun,
  force,
  track = true,
}) {
  // Get tree oid
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref });
    // TODO: Figure out what to do if both 'ref' and 'remote' are specified, ref already exists,
    // and is configured to track a different remote.
  } catch (err) {
    if (ref === 'HEAD') throw err
    // If `ref` doesn't exist, create a new remote tracking branch
    // Figure out the commit to checkout
    const remoteRef = `${remote}/${ref}`;
    oid = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: remoteRef,
    });
    if (track) {
      // Set up remote tracking branch
      const config = await GitConfigManager.get({ fs, gitdir });
      await config.set(`branch.${ref}.remote`, remote);
      await config.set(`branch.${ref}.merge`, `refs/heads/${ref}`);
      await GitConfigManager.save({ fs, gitdir, config });
    }
    // Create a new branch that points at that same commit
    await GitRefManager.writeRef({
      fs,
      gitdir,
      ref: `refs/heads/${ref}`,
      value: oid,
    });
  }

  // Update working dir
  if (!noCheckout) {
    let ops;
    // First pass - just analyze files (not directories) and figure out what needs to be done
    try {
      ops = await analyze({
        fs,
        cache,
        onProgress,
        dir,
        gitdir,
        ref,
        force,
        filepaths,
      });
    } catch (err) {
      // Throw a more helpful error message for this common mistake.
      if (err instanceof NotFoundError && err.data.what === oid) {
        throw new CommitNotFetchedError(ref, oid)
      } else {
        throw err
      }
    }

    // Report conflicts
    const conflicts = ops
      .filter(([method]) => method === 'conflict')
      .map(([method, fullpath]) => fullpath);
    if (conflicts.length > 0) {
      throw new CheckoutConflictError(conflicts)
    }

    // Collect errors
    const errors = ops
      .filter(([method]) => method === 'error')
      .map(([method, fullpath]) => fullpath);
    if (errors.length > 0) {
      throw new InternalError(errors.join(', '))
    }

    if (dryRun) {
      // Since the format of 'ops' is in flux, I really would rather folk besides myself not start relying on it
      // return ops
      return
    }

    // Second pass - execute planned changes
    // The cheapest semi-parallel solution without computing a full dependency graph will be
    // to just do ops in 4 dumb phases: delete files, delete dirs, create dirs, write files

    let count = 0;
    const total = ops.length;
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      await Promise.all(
        ops
          .filter(
            ([method]) => method === 'delete' || method === 'delete-index'
          )
          .map(async function([method, fullpath]) {
            const filepath = `${dir}/${fullpath}`;
            if (method === 'delete') {
              await fs.rm(filepath);
            }
            index.delete({ filepath: fullpath });
            if (onProgress) {
              await onProgress({
                phase: 'Updating workdir',
                loaded: ++count,
                total,
              });
            }
          })
      );
    });

    // Note: this is cannot be done naively in parallel
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      for (const [method, fullpath] of ops) {
        if (method === 'rmdir' || method === 'rmdir-index') {
          const filepath = `${dir}/${fullpath}`;
          try {
            if (method === 'rmdir-index') {
              index.delete({ filepath: fullpath });
            }
            await fs.rmdir(filepath);
            if (onProgress) {
              await onProgress({
                phase: 'Updating workdir',
                loaded: ++count,
                total,
              });
            }
          } catch (e) {
            if (e.code === 'ENOTEMPTY') {
              console.log(
                `Did not delete ${fullpath} because directory is not empty`
              );
            } else {
              throw e
            }
          }
        }
      }
    });

    await Promise.all(
      ops
        .filter(([method]) => method === 'mkdir' || method === 'mkdir-index')
        .map(async function([_, fullpath]) {
          const filepath = `${dir}/${fullpath}`;
          await fs.mkdir(filepath);
          if (onProgress) {
            await onProgress({
              phase: 'Updating workdir',
              loaded: ++count,
              total,
            });
          }
        })
    );

    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      await Promise.all(
        ops
          .filter(
            ([method]) =>
              method === 'create' ||
              method === 'create-index' ||
              method === 'update' ||
              method === 'mkdir-index'
          )
          .map(async function([method, fullpath, oid, mode, chmod]) {
            const filepath = `${dir}/${fullpath}`;
            try {
              if (method !== 'create-index' && method !== 'mkdir-index') {
                const { object } = await _readObject({ fs, cache, gitdir, oid });
                if (chmod) {
                  // Note: the mode option of fs.write only works when creating files,
                  // not updating them. Since the `fs` plugin doesn't expose `chmod` this
                  // is our only option.
                  await fs.rm(filepath);
                }
                if (mode === 0o100644) {
                  // regular file
                  await fs.write(filepath, object);
                } else if (mode === 0o100755) {
                  // executable file
                  await fs.write(filepath, object, { mode: 0o777 });
                } else if (mode === 0o120000) {
                  // symlink
                  await fs.writelink(filepath, object);
                } else {
                  throw new InternalError(
                    `Invalid mode 0o${mode.toString(8)} detected in blob ${oid}`
                  )
                }
              }

              const stats = await fs.lstat(filepath);
              // We can't trust the executable bit returned by lstat on Windows,
              // so we need to preserve this value from the TREE.
              // TODO: Figure out how git handles this internally.
              if (mode === 0o100755) {
                stats.mode = 0o755;
              }
              // Submodules are present in the git index but use a unique mode different from trees
              if (method === 'mkdir-index') {
                stats.mode = 0o160000;
              }
              index.insert({
                filepath: fullpath,
                stats,
                oid,
              });
              if (onProgress) {
                await onProgress({
                  phase: 'Updating workdir',
                  loaded: ++count,
                  total,
                });
              }
            } catch (e) {
              console.log(e);
            }
          })
      );
    });
  }

  // Update HEAD
  if (!noUpdateHead) {
    const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
    if (fullRef.startsWith('refs/heads')) {
      await GitRefManager.writeSymbolicRef({
        fs,
        gitdir,
        ref: 'HEAD',
        value: fullRef,
      });
    } else {
      // detached head
      await GitRefManager.writeRef({ fs, gitdir, ref: 'HEAD', value: oid });
    }
  }
}

async function analyze({
  fs,
  cache,
  onProgress,
  dir,
  gitdir,
  ref,
  force,
  filepaths,
}) {
  let count = 0;
  return _walk({
    fs,
    cache,
    dir,
    gitdir,
    trees: [TREE({ ref }), WORKDIR(), STAGE()],
    map: async function(fullpath, [commit, workdir, stage]) {
      if (fullpath === '.') return
      // match against base paths
      if (filepaths && !filepaths.some(base => worthWalking(fullpath, base))) {
        return null
      }
      // Emit progress event
      if (onProgress) {
        await onProgress({ phase: 'Analyzing workdir', loaded: ++count });
      }

      // This is a kind of silly pattern but it worked so well for me in the past
      // and it makes intuitively demonstrating exhaustiveness so *easy*.
      // This checks for the presense and/or absense of each of the 3 entries,
      // converts that to a 3-bit binary representation, and then handles
      // every possible combination (2^3 or 8 cases) with a lookup table.
      const key = [!!stage, !!commit, !!workdir].map(Number).join('');
      switch (key) {
        // Impossible case.
        case '000':
          return
        // Ignore workdir files that are not tracked and not part of the new commit.
        case '001':
          // OK, make an exception for explicitly named files.
          if (force && filepaths && filepaths.includes(fullpath)) {
            return ['delete', fullpath]
          }
          return
        // New entries
        case '010': {
          switch (await commit.type()) {
            case 'tree': {
              return ['mkdir', fullpath]
            }
            case 'blob': {
              return [
                'create',
                fullpath,
                await commit.oid(),
                await commit.mode(),
              ]
            }
            case 'commit': {
              return [
                'mkdir-index',
                fullpath,
                await commit.oid(),
                await commit.mode(),
              ]
            }
            default: {
              return [
                'error',
                `new entry Unhandled type ${await commit.type()}`,
              ]
            }
          }
        }
        // New entries but there is already something in the workdir there.
        case '011': {
          switch (`${await commit.type()}-${await workdir.type()}`) {
            case 'tree-tree': {
              return // noop
            }
            case 'tree-blob':
            case 'blob-tree': {
              return ['conflict', fullpath]
            }
            case 'blob-blob': {
              // Is the incoming file different?
              if ((await commit.oid()) !== (await workdir.oid())) {
                if (force) {
                  return [
                    'update',
                    fullpath,
                    await commit.oid(),
                    await commit.mode(),
                    (await commit.mode()) !== (await workdir.mode()),
                  ]
                } else {
                  return ['conflict', fullpath]
                }
              } else {
                // Is the incoming file a different mode?
                if ((await commit.mode()) !== (await workdir.mode())) {
                  if (force) {
                    return [
                      'update',
                      fullpath,
                      await commit.oid(),
                      await commit.mode(),
                      true,
                    ]
                  } else {
                    return ['conflict', fullpath]
                  }
                } else {
                  return [
                    'create-index',
                    fullpath,
                    await commit.oid(),
                    await commit.mode(),
                  ]
                }
              }
            }
            case 'commit-tree': {
              // TODO: submodule
              // We'll ignore submodule directories for now.
              // Users prefer we not throw an error for lack of submodule support.
              // gitlinks
              return
            }
            case 'commit-blob': {
              // TODO: submodule
              // But... we'll complain if there is a *file* where we would
              // put a submodule if we had submodule support.
              return ['conflict', fullpath]
            }
            default: {
              return ['error', `new entry Unhandled type ${commit.type}`]
            }
          }
        }
        // Something in stage but not in the commit OR the workdir.
        // Note: I verified this behavior against canonical git.
        case '100': {
          return ['delete-index', fullpath]
        }
        // Deleted entries
        // TODO: How to handle if stage type and workdir type mismatch?
        case '101': {
          switch (await stage.type()) {
            case 'tree': {
              return ['rmdir', fullpath]
            }
            case 'blob': {
              // Git checks that the workdir.oid === stage.oid before deleting file
              if ((await stage.oid()) !== (await workdir.oid())) {
                if (force) {
                  return ['delete', fullpath]
                } else {
                  return ['conflict', fullpath]
                }
              } else {
                return ['delete', fullpath]
              }
            }
            case 'commit': {
              return ['rmdir-index', fullpath]
            }
            default: {
              return [
                'error',
                `delete entry Unhandled type ${await stage.type()}`,
              ]
            }
          }
        }
        /* eslint-disable no-fallthrough */
        // File missing from workdir
        case '110':
        // Possibly modified entries
        case '111': {
          /* eslint-enable no-fallthrough */
          switch (`${await stage.type()}-${await commit.type()}`) {
            case 'tree-tree': {
              return
            }
            case 'blob-blob': {
              // If the file hasn't changed, there is no need to do anything.
              // Existing file modifications in the workdir can be be left as is.
              if (
                (await stage.oid()) === (await commit.oid()) &&
                (await stage.mode()) === (await commit.mode()) &&
                !force
              ) {
                return
              }

              // Check for local changes that would be lost
              if (workdir) {
                // Note: canonical git only compares with the stage. But we're smart enough
                // to compare to the stage AND the incoming commit.
                if (
                  (await workdir.oid()) !== (await stage.oid()) &&
                  (await workdir.oid()) !== (await commit.oid())
                ) {
                  if (force) {
                    return [
                      'update',
                      fullpath,
                      await commit.oid(),
                      await commit.mode(),
                      (await commit.mode()) !== (await workdir.mode()),
                    ]
                  } else {
                    return ['conflict', fullpath]
                  }
                }
              } else if (force) {
                return [
                  'update',
                  fullpath,
                  await commit.oid(),
                  await commit.mode(),
                  (await commit.mode()) !== (await stage.mode()),
                ]
              }
              // Has file mode changed?
              if ((await commit.mode()) !== (await stage.mode())) {
                return [
                  'update',
                  fullpath,
                  await commit.oid(),
                  await commit.mode(),
                  true,
                ]
              }
              // TODO: HANDLE SYMLINKS
              // Has the file content changed?
              if ((await commit.oid()) !== (await stage.oid())) {
                return [
                  'update',
                  fullpath,
                  await commit.oid(),
                  await commit.mode(),
                  false,
                ]
              } else {
                return
              }
            }
            case 'tree-blob': {
              return ['update-dir-to-blob', fullpath, await commit.oid()]
            }
            case 'blob-tree': {
              return ['update-blob-to-tree', fullpath]
            }
            case 'commit-commit': {
              return [
                'mkdir-index',
                fullpath,
                await commit.oid(),
                await commit.mode(),
              ]
            }
            default: {
              return [
                'error',
                `update entry Unhandled type ${await stage.type()}-${await commit.type()}`,
              ]
            }
          }
        }
      }
    },
    // Modify the default flat mapping
    reduce: async function(parent, children) {
      children = flat(children);
      if (!parent) {
        return children
      } else if (parent && parent[0] === 'rmdir') {
        children.push(parent);
        return children
      } else {
        children.unshift(parent);
        return children
      }
    },
  })
}

// @ts-check

/**
 * Checkout a branch
 *
 * If the branch already exists it will check out that branch. Otherwise, it will create a new remote tracking branch set to track the remote branch of that name.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {ProgressCallback} [args.onProgress] - optional progress event callback
 * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref = 'HEAD'] - Source to checkout files from
 * @param {string[]} [args.filepaths] - Limit the checkout to the given files and directories
 * @param {string} [args.remote = 'origin'] - Which remote repository to use
 * @param {boolean} [args.noCheckout = false] - If true, will update HEAD but won't update the working directory
 * @param {boolean} [args.noUpdateHead] - If true, will update the working directory but won't update HEAD. Defaults to `false` when `ref` is provided, and `true` if `ref` is not provided.
 * @param {boolean} [args.dryRun = false] - If true, simulates a checkout so you can test whether it would succeed.
 * @param {boolean} [args.force = false] - If true, conflicts will be ignored and files will be overwritten regardless of local changes.
 * @param {boolean} [args.track = true] - If false, will not set the remote branch tracking information. Defaults to true.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * // switch to the main branch
 * await git.checkout({
 *   fs,
 *   dir: '/tutorial',
 *   ref: 'main'
 * })
 * console.log('done')
 *
 * @example
 * // restore the 'docs' and 'src/docs' folders to the way they were, overwriting any changes
 * await git.checkout({
 *   fs,
 *   dir: '/tutorial',
 *   force: true,
 *   filepaths: ['docs', 'src/docs']
 * })
 * console.log('done')
 *
 * @example
 * // restore the 'docs' and 'src/docs' folders to the way they are in the 'develop' branch, overwriting any changes
 * await git.checkout({
 *   fs,
 *   dir: '/tutorial',
 *   ref: 'develop',
 *   noUpdateHead: true,
 *   force: true,
 *   filepaths: ['docs', 'src/docs']
 * })
 * console.log('done')
 */
async function checkout({
  fs,
  onProgress,
  dir,
  gitdir = join(dir, '.git'),
  remote = 'origin',
  ref: _ref,
  filepaths,
  noCheckout = false,
  noUpdateHead = _ref === undefined,
  dryRun = false,
  force = false,
  track = true,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('dir', dir);
    assertParameter('gitdir', gitdir);

    const ref = _ref || 'HEAD';
    return await _checkout({
      fs: new FileSystem(fs),
      cache,
      onProgress,
      dir,
      gitdir,
      remote,
      ref,
      filepaths,
      noCheckout,
      noUpdateHead,
      dryRun,
      force,
      track,
    })
  } catch (err) {
    err.caller = 'git.checkout';
    throw err
  }
}

// @see https://git-scm.com/docs/git-rev-parse.html#_specifying_revisions
const abbreviateRx = new RegExp('^refs/(heads/|tags/|remotes/)?(.*)');

function abbreviateRef(ref) {
  const match = abbreviateRx.exec(ref);
  if (match) {
    if (match[1] === 'remotes/' && ref.endsWith('/HEAD')) {
      return match[2].slice(0, -5)
    } else {
      return match[2]
    }
  }
  return ref
}

// @ts-check

/**
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {boolean} [args.fullname = false] - Return the full path (e.g. "refs/heads/main") instead of the abbreviated form.
 * @param {boolean} [args.test = false] - If the current branch doesn't actually exist (such as right after git init) then return `undefined`.
 *
 * @returns {Promise<string|void>} The name of the current branch or undefined if the HEAD is detached.
 *
 */
async function _currentBranch({
  fs,
  gitdir,
  fullname = false,
  test = false,
}) {
  const ref = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: 'HEAD',
    depth: 2,
  });
  if (test) {
    try {
      await GitRefManager.resolve({ fs, gitdir, ref });
    } catch (_) {
      return
    }
  }
  // Return `undefined` for detached HEAD
  if (!ref.startsWith('refs/')) return
  return fullname ? ref : abbreviateRef(ref)
}

function translateSSHtoHTTP(url) {
  // handle "shorter scp-like syntax"
  url = url.replace(/^git@([^:]+):/, 'https://$1/');
  // handle proper SSH URLs
  url = url.replace(/^ssh:\/\//, 'https://');
  return url
}

function calculateBasicAuthHeader({ username = '', password = '' }) {
  return `Basic ${Buffer.from(`${username}:${password}`).toString('base64')}`
}

// Currently 'for await' upsets my linters.
async function forAwait(iterable, cb) {
  const iter = getIterator(iterable);
  while (true) {
    const { value, done } = await iter.next();
    if (value) await cb(value);
    if (done) break
  }
  if (iter.return) iter.return();
}

async function collect(iterable) {
  let size = 0;
  const buffers = [];
  // This will be easier once `for await ... of` loops are available.
  await forAwait(iterable, value => {
    buffers.push(value);
    size += value.byteLength;
  });
  const result = new Uint8Array(size);
  let nextIndex = 0;
  for (const buffer of buffers) {
    result.set(buffer, nextIndex);
    nextIndex += buffer.byteLength;
  }
  return result
}

function extractAuthFromUrl(url) {
  // For whatever reason, the `fetch` API does not convert credentials embedded in the URL
  // into Basic Authentication headers automatically. Instead it throws an error!
  // So we must manually parse the URL, rip out the user:password portion if it is present
  // and compute the Authorization header.
  // Note: I tried using new URL(url) but that throws a security exception in Edge. :rolleyes:
  let userpass = url.match(/^https?:\/\/([^/]+)@/);
  // No credentials, return the url unmodified and an empty auth object
  if (userpass == null) return { url, auth: {} }
  userpass = userpass[1];
  const [username, password] = userpass.split(':');
  // Remove credentials from URL
  url = url.replace(`${userpass}@`, '');
  // Has credentials, return the fetch-safe URL and the parsed credentials
  return { url, auth: { username, password } }
}

function padHex(b, n) {
  const s = n.toString(16);
  return '0'.repeat(b - s.length) + s
}

/**
pkt-line Format
---------------

Much (but not all) of the payload is described around pkt-lines.

A pkt-line is a variable length binary string.  The first four bytes
of the line, the pkt-len, indicates the total length of the line,
in hexadecimal.  The pkt-len includes the 4 bytes used to contain
the length's hexadecimal representation.

A pkt-line MAY contain binary data, so implementors MUST ensure
pkt-line parsing/formatting routines are 8-bit clean.

A non-binary line SHOULD BE terminated by an LF, which if present
MUST be included in the total length. Receivers MUST treat pkt-lines
with non-binary data the same whether or not they contain the trailing
LF (stripping the LF if present, and not complaining when it is
missing).

The maximum length of a pkt-line's data component is 65516 bytes.
Implementations MUST NOT send pkt-line whose length exceeds 65520
(65516 bytes of payload + 4 bytes of length data).

Implementations SHOULD NOT send an empty pkt-line ("0004").

A pkt-line with a length field of 0 ("0000"), called a flush-pkt,
is a special case and MUST be handled differently than an empty
pkt-line ("0004").

----
  pkt-line     =  data-pkt / flush-pkt

  data-pkt     =  pkt-len pkt-payload
  pkt-len      =  4*(HEXDIG)
  pkt-payload  =  (pkt-len - 4)*(OCTET)

  flush-pkt    = "0000"
----

Examples (as C-style strings):

----
  pkt-line          actual value
  ---------------------------------
  "0006a\n"         "a\n"
  "0005a"           "a"
  "000bfoobar\n"    "foobar\n"
  "0004"            ""
----
*/

// I'm really using this more as a namespace.
// There's not a lot of "state" in a pkt-line

class GitPktLine {
  static flush() {
    return Buffer.from('0000', 'utf8')
  }

  static delim() {
    return Buffer.from('0001', 'utf8')
  }

  static encode(line) {
    if (typeof line === 'string') {
      line = Buffer.from(line);
    }
    const length = line.length + 4;
    const hexlength = padHex(4, length);
    return Buffer.concat([Buffer.from(hexlength, 'utf8'), line])
  }

  static streamReader(stream) {
    const reader = new StreamReader(stream);
    return async function read() {
      try {
        let length = await reader.read(4);
        if (length == null) return true
        length = parseInt(length.toString('utf8'), 16);
        if (length === 0) return null
        if (length === 1) return null // delim packets
        const buffer = await reader.read(length - 4);
        if (buffer == null) return true
        return buffer
      } catch (err) {
        console.log('error', err);
        return true
      }
    }
  }
}

// @ts-check

/**
 * @param {function} read
 */
async function parseCapabilitiesV2(read) {
  /** @type {Object<string, string | true>} */
  const capabilities2 = {};

  let line;
  while (true) {
    line = await read();
    if (line === true) break
    if (line === null) continue
    line = line.toString('utf8').replace(/\n$/, '');
    const i = line.indexOf('=');
    if (i > -1) {
      const key = line.slice(0, i);
      const value = line.slice(i + 1);
      capabilities2[key] = value;
    } else {
      capabilities2[line] = true;
    }
  }
  return { protocolVersion: 2, capabilities2 }
}

async function parseRefsAdResponse(stream, { service }) {
  const capabilities = new Set();
  const refs = new Map();
  const symrefs = new Map();

  // There is probably a better way to do this, but for now
  // let's just throw the result parser inline here.
  const read = GitPktLine.streamReader(stream);
  let lineOne = await read();
  // skip past any flushes
  while (lineOne === null) lineOne = await read();

  if (lineOne === true) throw new EmptyServerResponseError()

  // Handle protocol v2 responses (Bitbucket Server doesn't include a `# service=` line)
  if (lineOne.includes('version 2')) {
    return parseCapabilitiesV2(read)
  }

  // Clients MUST ignore an LF at the end of the line.
  if (lineOne.toString('utf8').replace(/\n$/, '') !== `# service=${service}`) {
    throw new ParseError(`# service=${service}\\n`, lineOne.toString('utf8'))
  }
  let lineTwo = await read();
  // skip past any flushes
  while (lineTwo === null) lineTwo = await read();
  // In the edge case of a brand new repo, zero refs (and zero capabilities)
  // are returned.
  if (lineTwo === true) return { capabilities, refs, symrefs }
  lineTwo = lineTwo.toString('utf8');

  // Handle protocol v2 responses
  if (lineTwo.includes('version 2')) {
    return parseCapabilitiesV2(read)
  }

  const [firstRef, capabilitiesLine] = splitAndAssert(lineTwo, '\x00', '\\x00');
  capabilitiesLine.split(' ').map(x => capabilities.add(x));
  const [ref, name] = splitAndAssert(firstRef, ' ', ' ');
  refs.set(name, ref);
  while (true) {
    const line = await read();
    if (line === true) break
    if (line !== null) {
      const [ref, name] = splitAndAssert(line.toString('utf8'), ' ', ' ');
      refs.set(name, ref);
    }
  }
  // Symrefs are thrown into the "capabilities" unfortunately.
  for (const cap of capabilities) {
    if (cap.startsWith('symref=')) {
      const m = cap.match(/symref=([^:]+):(.*)/);
      if (m.length === 3) {
        symrefs.set(m[1], m[2]);
      }
    }
  }
  return { protocolVersion: 1, capabilities, refs, symrefs }
}

function splitAndAssert(line, sep, expected) {
  const split = line.trim().split(sep);
  if (split.length !== 2) {
    throw new ParseError(
      `Two strings separated by '${expected}'`,
      line.toString('utf8')
    )
  }
  return split
}

// Try to accomodate known CORS proxy implementations:
// - https://jcubic.pl/proxy.php?  <-- uses query string
// - https://cors.isomorphic-git.org  <-- uses path
const corsProxify = (corsProxy, url) =>
  corsProxy.endsWith('?')
    ? `${corsProxy}${url}`
    : `${corsProxy}/${url.replace(/^https?:\/\//, '')}`;

const updateHeaders = (headers, auth) => {
  // Update the basic auth header
  if (auth.username || auth.password) {
    headers.Authorization = calculateBasicAuthHeader(auth);
  }
  // but any manually provided headers take precedence
  if (auth.headers) {
    Object.assign(headers, auth.headers);
  }
};

/**
 * @param {GitHttpResponse} res
 *
 * @returns {{ preview: string, response: string, data: Buffer }}
 */
const stringifyBody = async res => {
  try {
    // Some services provide a meaningful error message in the body of 403s like "token lacks the scopes necessary to perform this action"
    const data = Buffer.from(await collect(res.body));
    const response = data.toString('utf8');
    const preview =
      response.length < 256 ? response : response.slice(0, 256) + '...';
    return { preview, response, data }
  } catch (e) {
    return {}
  }
};

class GitRemoteHTTP {
  static async capabilities() {
    return ['discover', 'connect']
  }

  /**
   * @param {Object} args
   * @param {HttpClient} args.http
   * @param {ProgressCallback} [args.onProgress]
   * @param {AuthCallback} [args.onAuth]
   * @param {AuthFailureCallback} [args.onAuthFailure]
   * @param {AuthSuccessCallback} [args.onAuthSuccess]
   * @param {string} [args.corsProxy]
   * @param {string} args.service
   * @param {string} args.url
   * @param {Object<string, string>} args.headers
   * @param {1 | 2} args.protocolVersion - Git Protocol Version
   */
  static async discover({
    http,
    onProgress,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service,
    url: _origUrl,
    headers,
    protocolVersion,
  }) {
    let { url, auth } = extractAuthFromUrl(_origUrl);
    const proxifiedURL = corsProxy ? corsProxify(corsProxy, url) : url;
    if (auth.username || auth.password) {
      headers.Authorization = calculateBasicAuthHeader(auth);
    }
    if (protocolVersion === 2) {
      headers['Git-Protocol'] = 'version=2';
    }

    let res;
    let tryAgain;
    let providedAuthBefore = false;
    do {
      res = await http.request({
        onProgress,
        method: 'GET',
        url: `${proxifiedURL}/info/refs?service=${service}`,
        headers,
      });

      // the default loop behavior
      tryAgain = false;

      // 401 is the "correct" response for access denied. 203 is Non-Authoritative Information and comes from Azure DevOps, which
      // apparently doesn't realize this is a git request and is returning the HTML for the "Azure DevOps Services | Sign In" page.
      if (res.statusCode === 401 || res.statusCode === 203) {
        // On subsequent 401s, call `onAuthFailure` instead of `onAuth`.
        // This is so that naive `onAuth` callbacks that return a fixed value don't create an infinite loop of retrying.
        const getAuth = providedAuthBefore ? onAuthFailure : onAuth;
        if (getAuth) {
          // Acquire credentials and try again
          // TODO: read `useHttpPath` value from git config and pass along?
          auth = await getAuth(url, {
            ...auth,
            headers: { ...headers },
          });
          if (auth && auth.cancel) {
            throw new UserCanceledError()
          } else if (auth) {
            updateHeaders(headers, auth);
            providedAuthBefore = true;
            tryAgain = true;
          }
        }
      } else if (
        res.statusCode === 200 &&
        providedAuthBefore &&
        onAuthSuccess
      ) {
        await onAuthSuccess(url, auth);
      }
    } while (tryAgain)

    if (res.statusCode !== 200) {
      const { response } = await stringifyBody(res);
      throw new HttpError(res.statusCode, res.statusMessage, response)
    }
    // Git "smart" HTTP servers should respond with the correct Content-Type header.
    if (
      res.headers['content-type'] === `application/x-${service}-advertisement`
    ) {
      const remoteHTTP = await parseRefsAdResponse(res.body, { service });
      remoteHTTP.auth = auth;
      return remoteHTTP
    } else {
      // If they don't send the correct content-type header, that's a good indicator it is either a "dumb" HTTP
      // server, or the user specified an incorrect remote URL and the response is actually an HTML page.
      // In this case, we save the response as plain text so we can generate a better error message if needed.
      const { preview, response, data } = await stringifyBody(res);
      // For backwards compatibility, try to parse it anyway.
      // TODO: maybe just throw instead of trying?
      try {
        const remoteHTTP = await parseRefsAdResponse([data], { service });
        remoteHTTP.auth = auth;
        return remoteHTTP
      } catch (e) {
        throw new SmartHttpError(preview, response)
      }
    }
  }

  /**
   * @param {Object} args
   * @param {HttpClient} args.http
   * @param {ProgressCallback} [args.onProgress]
   * @param {string} [args.corsProxy]
   * @param {string} args.service
   * @param {string} args.url
   * @param {Object<string, string>} [args.headers]
   * @param {any} args.body
   * @param {any} args.auth
   */
  static async connect({
    http,
    onProgress,
    corsProxy,
    service,
    url,
    auth,
    body,
    headers,
  }) {
    // We already have the "correct" auth value at this point, but
    // we need to strip out the username/password from the URL yet again.
    const urlAuth = extractAuthFromUrl(url);
    if (urlAuth) url = urlAuth.url;

    if (corsProxy) url = corsProxify(corsProxy, url);

    headers['content-type'] = `application/x-${service}-request`;
    headers.accept = `application/x-${service}-result`;
    updateHeaders(headers, auth);

    const res = await http.request({
      onProgress,
      method: 'POST',
      url: `${url}/${service}`,
      body,
      headers,
    });
    if (res.statusCode !== 200) {
      const { response } = stringifyBody(res);
      throw new HttpError(res.statusCode, res.statusMessage, response)
    }
    return res
  }
}

function parseRemoteUrl({ url }) {
  // the stupid "shorter scp-like syntax"
  if (url.startsWith('git@')) {
    return {
      transport: 'ssh',
      address: url,
    }
  }
  const matches = url.match(/(\w+)(:\/\/|::)(.*)/);
  if (matches === null) return
  /*
   * When git encounters a URL of the form <transport>://<address>, where <transport> is
   * a protocol that it cannot handle natively, it automatically invokes git remote-<transport>
   * with the full URL as the second argument.
   *
   * @see https://git-scm.com/docs/git-remote-helpers
   */
  if (matches[2] === '://') {
    return {
      transport: matches[1],
      address: matches[0],
    }
  }
  /*
   * A URL of the form <transport>::<address> explicitly instructs git to invoke
   * git remote-<transport> with <address> as the second argument.
   *
   * @see https://git-scm.com/docs/git-remote-helpers
   */
  if (matches[2] === '::') {
    return {
      transport: matches[1],
      address: matches[3],
    }
  }
}

class GitRemoteManager {
  static getRemoteHelperFor({ url }) {
    // TODO: clean up the remoteHelper API and move into PluginCore
    const remoteHelpers = new Map();
    remoteHelpers.set('http', GitRemoteHTTP);
    remoteHelpers.set('https', GitRemoteHTTP);

    const parts = parseRemoteUrl({ url });
    if (!parts) {
      throw new UrlParseError(url)
    }
    if (remoteHelpers.has(parts.transport)) {
      return remoteHelpers.get(parts.transport)
    }
    throw new UnknownTransportError(
      url,
      parts.transport,
      parts.transport === 'ssh' ? translateSSHtoHTTP(url) : undefined
    )
  }
}

let lock$1 = null;

class GitShallowManager {
  static async read({ fs, gitdir }) {
    if (lock$1 === null) lock$1 = new async_lock__WEBPACK_IMPORTED_MODULE_0__();
    const filepath = join(gitdir, 'shallow');
    const oids = new Set();
    await lock$1.acquire(filepath, async function() {
      const text = await fs.read(filepath, { encoding: 'utf8' });
      if (text === null) return oids // no file
      if (text.trim() === '') return oids // empty file
      text
        .trim()
        .split('\n')
        .map(oid => oids.add(oid));
    });
    return oids
  }

  static async write({ fs, gitdir, oids }) {
    if (lock$1 === null) lock$1 = new async_lock__WEBPACK_IMPORTED_MODULE_0__();
    const filepath = join(gitdir, 'shallow');
    if (oids.size > 0) {
      const text = [...oids].join('\n') + '\n';
      await lock$1.acquire(filepath, async function() {
        await fs.write(filepath, text, {
          encoding: 'utf8',
        });
      });
    } else {
      // No shallows
      await lock$1.acquire(filepath, async function() {
        await fs.rm(filepath);
      });
    }
  }
}

async function hasObjectLoose({ fs, gitdir, oid }) {
  const source = `objects/${oid.slice(0, 2)}/${oid.slice(2)}`;
  return fs.exists(`${gitdir}/${source}`)
}

async function hasObjectPacked({
  fs,
  cache,
  gitdir,
  oid,
  getExternalRefDelta,
}) {
  // Check to see if it's in a packfile.
  // Iterate through all the .idx files
  let list = await fs.readdir(join(gitdir, 'objects/pack'));
  list = list.filter(x => x.endsWith('.idx'));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta,
    });
    if (p.error) throw new InternalError(p.error)
    // If the packfile DOES have the oid we're looking for...
    if (p.offsets.has(oid)) {
      return true
    }
  }
  // Failed to find it
  return false
}

async function hasObject({
  fs,
  cache,
  gitdir,
  oid,
  format = 'content',
}) {
  // Curry the current read method so that the packfile un-deltification
  // process can acquire external ref-deltas.
  const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });

  // Look for it in the loose object directory.
  let result = await hasObjectLoose({ fs, gitdir, oid });
  // Check to see if it's in a packfile.
  if (!result) {
    result = await hasObjectPacked({
      fs,
      cache,
      gitdir,
      oid,
      getExternalRefDelta,
    });
  }
  // Finally
  return result
}

// TODO: make a function that just returns obCount. then emptyPackfile = () => sizePack(pack) === 0
function emptyPackfile(pack) {
  const pheader = '5041434b';
  const version = '00000002';
  const obCount = '00000000';
  const header = pheader + version + obCount;
  return pack.slice(0, 12).toString('hex') === header
}

function filterCapabilities(server, client) {
  const serverNames = server.map(cap => cap.split('=', 1)[0]);
  return client.filter(cap => {
    const name = cap.split('=', 1)[0];
    return serverNames.includes(name)
  })
}

const pkg = {
  name: 'isomorphic-git',
  version: '1.11.1',
  agent: 'git/isomorphic-git@1.11.1',
};

class FIFO {
  constructor() {
    this._queue = [];
  }

  write(chunk) {
    if (this._ended) {
      throw Error('You cannot write to a FIFO that has already been ended!')
    }
    if (this._waiting) {
      const resolve = this._waiting;
      this._waiting = null;
      resolve({ value: chunk });
    } else {
      this._queue.push(chunk);
    }
  }

  end() {
    this._ended = true;
    if (this._waiting) {
      const resolve = this._waiting;
      this._waiting = null;
      resolve({ done: true });
    }
  }

  destroy(err) {
    this._ended = true;
    this.error = err;
  }

  async next() {
    if (this._queue.length > 0) {
      return { value: this._queue.shift() }
    }
    if (this._ended) {
      return { done: true }
    }
    if (this._waiting) {
      throw Error(
        'You cannot call read until the previous call to read has returned!'
      )
    }
    return new Promise(resolve => {
      this._waiting = resolve;
    })
  }
}

// Note: progress messages are designed to be written directly to the terminal,
// so they are often sent with just a carriage return to overwrite the last line of output.
// But there are also messages delimited with newlines.
// I also include CRLF just in case.
function findSplit(str) {
  const r = str.indexOf('\r');
  const n = str.indexOf('\n');
  if (r === -1 && n === -1) return -1
  if (r === -1) return n + 1 // \n
  if (n === -1) return r + 1 // \r
  if (n === r + 1) return n + 1 // \r\n
  return Math.min(r, n) + 1 // \r or \n
}

function splitLines(input) {
  const output = new FIFO();
  let tmp = ''
  ;(async () => {
    await forAwait(input, chunk => {
      chunk = chunk.toString('utf8');
      tmp += chunk;
      while (true) {
        const i = findSplit(tmp);
        if (i === -1) break
        output.write(tmp.slice(0, i));
        tmp = tmp.slice(i);
      }
    });
    if (tmp.length > 0) {
      output.write(tmp);
    }
    output.end();
  })();
  return output
}

/*
If 'side-band' or 'side-band-64k' capabilities have been specified by
the client, the server will send the packfile data multiplexed.

Each packet starting with the packet-line length of the amount of data
that follows, followed by a single byte specifying the sideband the
following data is coming in on.

In 'side-band' mode, it will send up to 999 data bytes plus 1 control
code, for a total of up to 1000 bytes in a pkt-line.  In 'side-band-64k'
mode it will send up to 65519 data bytes plus 1 control code, for a
total of up to 65520 bytes in a pkt-line.

The sideband byte will be a '1', '2' or a '3'. Sideband '1' will contain
packfile data, sideband '2' will be used for progress information that the
client will generally print to stderr and sideband '3' is used for error
information.

If no 'side-band' capability was specified, the server will stream the
entire packfile without multiplexing.
*/

class GitSideBand {
  static demux(input) {
    const read = GitPktLine.streamReader(input);
    // And now for the ridiculous side-band or side-band-64k protocol
    const packetlines = new FIFO();
    const packfile = new FIFO();
    const progress = new FIFO();
    // TODO: Use a proper through stream?
    const nextBit = async function() {
      const line = await read();
      // Skip over flush packets
      if (line === null) return nextBit()
      // A made up convention to signal there's no more to read.
      if (line === true) {
        packetlines.end();
        progress.end();
        packfile.end();
        return
      }
      // Examine first byte to determine which output "stream" to use
      switch (line[0]) {
        case 1: {
          // pack data
          packfile.write(line.slice(1));
          break
        }
        case 2: {
          // progress message
          progress.write(line.slice(1));
          break
        }
        case 3: {
          // fatal error message just before stream aborts
          const error = line.slice(1);
          progress.write(error);
          packfile.destroy(new Error(error.toString('utf8')));
          return
        }
        default: {
          // Not part of the side-band-64k protocol
          packetlines.write(line.slice(0));
        }
      }
      // Careful not to blow up the stack.
      // I think Promises in a tail-call position should be OK.
      nextBit();
    };
    nextBit();
    return {
      packetlines,
      packfile,
      progress,
    }
  }
  // static mux ({
  //   protocol, // 'side-band' or 'side-band-64k'
  //   packetlines,
  //   packfile,
  //   progress,
  //   error
  // }) {
  //   const MAX_PACKET_LENGTH = protocol === 'side-band-64k' ? 999 : 65519
  //   let output = new PassThrough()
  //   packetlines.on('data', data => {
  //     if (data === null) {
  //       output.write(GitPktLine.flush())
  //     } else {
  //       output.write(GitPktLine.encode(data))
  //     }
  //   })
  //   let packfileWasEmpty = true
  //   let packfileEnded = false
  //   let progressEnded = false
  //   let errorEnded = false
  //   let goodbye = Buffer.concat([
  //     GitPktLine.encode(Buffer.from('010A', 'hex')),
  //     GitPktLine.flush()
  //   ])
  //   packfile
  //     .on('data', data => {
  //       packfileWasEmpty = false
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('01', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       packfileEnded = true
  //       if (!packfileWasEmpty) output.write(goodbye)
  //       if (progressEnded && errorEnded) output.end()
  //     })
  //   progress
  //     .on('data', data => {
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('02', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       progressEnded = true
  //       if (packfileEnded && errorEnded) output.end()
  //     })
  //   error
  //     .on('data', data => {
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('03', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       errorEnded = true
  //       if (progressEnded && packfileEnded) output.end()
  //     })
  //   return output
  // }
}

async function parseUploadPackResponse(stream) {
  const { packetlines, packfile, progress } = GitSideBand.demux(stream);
  const shallows = [];
  const unshallows = [];
  const acks = [];
  let nak = false;
  let done = false;
  return new Promise((resolve, reject) => {
    // Parse the response
    forAwait(packetlines, data => {
      const line = data.toString('utf8').trim();
      if (line.startsWith('shallow')) {
        const oid = line.slice(-41).trim();
        if (oid.length !== 40) {
          reject(new InvalidOidError(oid));
        }
        shallows.push(oid);
      } else if (line.startsWith('unshallow')) {
        const oid = line.slice(-41).trim();
        if (oid.length !== 40) {
          reject(new InvalidOidError(oid));
        }
        unshallows.push(oid);
      } else if (line.startsWith('ACK')) {
        const [, oid, status] = line.split(' ');
        acks.push({ oid, status });
        if (!status) done = true;
      } else if (line.startsWith('NAK')) {
        nak = true;
        done = true;
      }
      if (done) {
        resolve({ shallows, unshallows, acks, nak, packfile, progress });
      }
    });
  })
}

function writeUploadPackRequest({
  capabilities = [],
  wants = [],
  haves = [],
  shallows = [],
  depth = null,
  since = null,
  exclude = [],
}) {
  const packstream = [];
  wants = [...new Set(wants)]; // remove duplicates
  let firstLineCapabilities = ` ${capabilities.join(' ')}`;
  for (const oid of wants) {
    packstream.push(GitPktLine.encode(`want ${oid}${firstLineCapabilities}\n`));
    firstLineCapabilities = '';
  }
  for (const oid of shallows) {
    packstream.push(GitPktLine.encode(`shallow ${oid}\n`));
  }
  if (depth !== null) {
    packstream.push(GitPktLine.encode(`deepen ${depth}\n`));
  }
  if (since !== null) {
    packstream.push(
      GitPktLine.encode(`deepen-since ${Math.floor(since.valueOf() / 1000)}\n`)
    );
  }
  for (const oid of exclude) {
    packstream.push(GitPktLine.encode(`deepen-not ${oid}\n`));
  }
  packstream.push(GitPktLine.flush());
  for (const oid of haves) {
    packstream.push(GitPktLine.encode(`have ${oid}\n`));
  }
  packstream.push(GitPktLine.encode(`done\n`));
  return packstream
}

// @ts-check

/**
 *
 * @typedef {object} FetchResult - The object returned has the following schema:
 * @property {string | null} defaultBranch - The branch that is cloned if no branch is specified
 * @property {string | null} fetchHead - The SHA-1 object id of the fetched head commit
 * @property {string | null} fetchHeadDescription - a textual description of the branch that was fetched
 * @property {Object<string, string>} [headers] - The HTTP response headers returned by the git server
 * @property {string[]} [pruned] - A list of branches that were pruned, if you provided the `prune` parameter
 *
 */

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {HttpClient} args.http
 * @param {ProgressCallback} [args.onProgress]
 * @param {MessageCallback} [args.onMessage]
 * @param {AuthCallback} [args.onAuth]
 * @param {AuthFailureCallback} [args.onAuthFailure]
 * @param {AuthSuccessCallback} [args.onAuthSuccess]
 * @param {string} args.gitdir
 * @param {string|void} [args.url]
 * @param {string} [args.corsProxy]
 * @param {string} [args.ref]
 * @param {string} [args.remoteRef]
 * @param {string} [args.remote]
 * @param {boolean} [args.singleBranch = false]
 * @param {boolean} [args.tags = false]
 * @param {number} [args.depth]
 * @param {Date} [args.since]
 * @param {string[]} [args.exclude = []]
 * @param {boolean} [args.relative = false]
 * @param {Object<string, string>} [args.headers]
 * @param {boolean} [args.prune]
 * @param {boolean} [args.pruneTags]
 *
 * @returns {Promise<FetchResult>}
 * @see FetchResult
 */
async function _fetch({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  gitdir,
  ref: _ref,
  remoteRef: _remoteRef,
  remote: _remote,
  url: _url,
  corsProxy,
  depth = null,
  since = null,
  exclude = [],
  relative = false,
  tags = false,
  singleBranch = false,
  headers = {},
  prune = false,
  pruneTags = false,
}) {
  const ref = _ref || (await _currentBranch({ fs, gitdir, test: true }));
  const config = await GitConfigManager.get({ fs, gitdir });
  // Figure out what remote to use.
  const remote =
    _remote || (ref && (await config.get(`branch.${ref}.remote`))) || 'origin';
  // Lookup the URL for the given remote.
  const url = _url || (await config.get(`remote.${remote}.url`));
  if (typeof url === 'undefined') {
    throw new MissingParameterError('remote OR url')
  }
  // Figure out what remote ref to use.
  const remoteRef =
    _remoteRef ||
    (ref && (await config.get(`branch.${ref}.merge`))) ||
    _ref ||
    'HEAD';

  if (corsProxy === undefined) {
    corsProxy = await config.get('http.corsProxy');
  }

  const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });
  const remoteHTTP = await GitRemoteHTTP.discover({
    http,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service: 'git-upload-pack',
    url,
    headers,
    protocolVersion: 1,
  });
  const auth = remoteHTTP.auth; // hack to get new credentials from CredentialManager API
  const remoteRefs = remoteHTTP.refs;
  // For the special case of an empty repository with no refs, return null.
  if (remoteRefs.size === 0) {
    return {
      defaultBranch: null,
      fetchHead: null,
      fetchHeadDescription: null,
    }
  }
  // Check that the remote supports the requested features
  if (depth !== null && !remoteHTTP.capabilities.has('shallow')) {
    throw new RemoteCapabilityError('shallow', 'depth')
  }
  if (since !== null && !remoteHTTP.capabilities.has('deepen-since')) {
    throw new RemoteCapabilityError('deepen-since', 'since')
  }
  if (exclude.length > 0 && !remoteHTTP.capabilities.has('deepen-not')) {
    throw new RemoteCapabilityError('deepen-not', 'exclude')
  }
  if (relative === true && !remoteHTTP.capabilities.has('deepen-relative')) {
    throw new RemoteCapabilityError('deepen-relative', 'relative')
  }
  // Figure out the SHA for the requested ref
  const { oid, fullref } = GitRefManager.resolveAgainstMap({
    ref: remoteRef,
    map: remoteRefs,
  });
  // Filter out refs we want to ignore: only keep ref we're cloning, HEAD, branches, and tags (if we're keeping them)
  for (const remoteRef of remoteRefs.keys()) {
    if (
      remoteRef === fullref ||
      remoteRef === 'HEAD' ||
      remoteRef.startsWith('refs/heads/') ||
      (tags && remoteRef.startsWith('refs/tags/'))
    ) {
      continue
    }
    remoteRefs.delete(remoteRef);
  }
  // Assemble the application/x-git-upload-pack-request
  const capabilities = filterCapabilities(
    [...remoteHTTP.capabilities],
    [
      'multi_ack_detailed',
      'no-done',
      'side-band-64k',
      // Note: I removed 'thin-pack' option since our code doesn't "fatten" packfiles,
      // which is necessary for compatibility with git. It was the cause of mysterious
      // 'fatal: pack has [x] unresolved deltas' errors that plagued us for some time.
      // isomorphic-git is perfectly happy with thin packfiles in .git/objects/pack but
      // canonical git it turns out is NOT.
      'ofs-delta',
      `agent=${pkg.agent}`,
    ]
  );
  if (relative) capabilities.push('deepen-relative');
  // Start figuring out which oids from the remote we want to request
  const wants = singleBranch ? [oid] : remoteRefs.values();
  // Come up with a reasonable list of oids to tell the remote we already have
  // (preferably oids that are close ancestors of the branch heads we're fetching)
  const haveRefs = singleBranch
    ? [ref]
    : await GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: `refs`,
      });
  let haves = [];
  for (let ref of haveRefs) {
    try {
      ref = await GitRefManager.expand({ fs, gitdir, ref });
      const oid = await GitRefManager.resolve({ fs, gitdir, ref });
      if (await hasObject({ fs, cache, gitdir, oid })) {
        haves.push(oid);
      }
    } catch (err) {}
  }
  haves = [...new Set(haves)];
  const oids = await GitShallowManager.read({ fs, gitdir });
  const shallows = remoteHTTP.capabilities.has('shallow') ? [...oids] : [];
  const packstream = writeUploadPackRequest({
    capabilities,
    wants,
    haves,
    shallows,
    depth,
    since,
    exclude,
  });
  // CodeCommit will hang up if we don't send a Content-Length header
  // so we can't stream the body.
  const packbuffer = Buffer.from(await collect(packstream));
  const raw = await GitRemoteHTTP.connect({
    http,
    onProgress,
    corsProxy,
    service: 'git-upload-pack',
    url,
    auth,
    body: [packbuffer],
    headers,
  });
  const response = await parseUploadPackResponse(raw.body);
  if (raw.headers) {
    response.headers = raw.headers;
  }
  // Apply all the 'shallow' and 'unshallow' commands
  for (const oid of response.shallows) {
    if (!oids.has(oid)) {
      // this is in a try/catch mostly because my old test fixtures are missing objects
      try {
        // server says it's shallow, but do we have the parents?
        const { object } = await _readObject({ fs, cache, gitdir, oid });
        const commit = new GitCommit(object);
        const hasParents = await Promise.all(
          commit
            .headers()
            .parent.map(oid => hasObject({ fs, cache, gitdir, oid }))
        );
        const haveAllParents =
          hasParents.length === 0 || hasParents.every(has => has);
        if (!haveAllParents) {
          oids.add(oid);
        }
      } catch (err) {
        oids.add(oid);
      }
    }
  }
  for (const oid of response.unshallows) {
    oids.delete(oid);
  }
  await GitShallowManager.write({ fs, gitdir, oids });
  // Update local remote refs
  if (singleBranch) {
    const refs = new Map([[fullref, oid]]);
    // But wait, maybe it was a symref, like 'HEAD'!
    // We need to save all the refs in the symref chain (sigh).
    const symrefs = new Map();
    let bail = 10;
    let key = fullref;
    while (bail--) {
      const value = remoteHTTP.symrefs.get(key);
      if (value === undefined) break
      symrefs.set(key, value);
      key = value;
    }
    // final value must not be a symref but a real ref
    const realRef = remoteRefs.get(key);
    // There may be no ref at all if we've fetched a specific commit hash
    if (realRef) {
      refs.set(key, realRef);
    }
    const { pruned } = await GitRefManager.updateRemoteRefs({
      fs,
      gitdir,
      remote,
      refs,
      symrefs,
      tags,
      prune,
    });
    if (prune) {
      response.pruned = pruned;
    }
  } else {
    const { pruned } = await GitRefManager.updateRemoteRefs({
      fs,
      gitdir,
      remote,
      refs: remoteRefs,
      symrefs: remoteHTTP.symrefs,
      tags,
      prune,
      pruneTags,
    });
    if (prune) {
      response.pruned = pruned;
    }
  }
  // We need this value later for the `clone` command.
  response.HEAD = remoteHTTP.symrefs.get('HEAD');
  // AWS CodeCommit doesn't list HEAD as a symref, but we can reverse engineer it
  // Find the SHA of the branch called HEAD
  if (response.HEAD === undefined) {
    const { oid } = GitRefManager.resolveAgainstMap({
      ref: 'HEAD',
      map: remoteRefs,
    });
    // Use the name of the first branch that's not called HEAD that has
    // the same SHA as the branch called HEAD.
    for (const [key, value] of remoteRefs.entries()) {
      if (key !== 'HEAD' && value === oid) {
        response.HEAD = key;
        break
      }
    }
  }
  const noun = fullref.startsWith('refs/tags') ? 'tag' : 'branch';
  response.FETCH_HEAD = {
    oid,
    description: `${noun} '${abbreviateRef(fullref)}' of ${url}`,
  };

  if (onProgress || onMessage) {
    const lines = splitLines(response.progress);
    forAwait(lines, async line => {
      if (onMessage) await onMessage(line);
      if (onProgress) {
        const matches = line.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);
        if (matches) {
          await onProgress({
            phase: matches[1].trim(),
            loaded: parseInt(matches[2], 10),
            total: parseInt(matches[3], 10),
          });
        }
      }
    });
  }
  const packfile = Buffer.from(await collect(response.packfile));
  const packfileSha = packfile.slice(-20).toString('hex');
  const res = {
    defaultBranch: response.HEAD,
    fetchHead: response.FETCH_HEAD.oid,
    fetchHeadDescription: response.FETCH_HEAD.description,
  };
  if (response.headers) {
    res.headers = response.headers;
  }
  if (prune) {
    res.pruned = response.pruned;
  }
  // This is a quick fix for the empty .git/objects/pack/pack-.pack file error,
  // which due to the way `git-list-pack` works causes the program to hang when it tries to read it.
  // TODO: Longer term, we should actually:
  // a) NOT concatenate the entire packfile into memory (line 78),
  // b) compute the SHA of the stream except for the last 20 bytes, using the same library used in push.js, and
  // c) compare the computed SHA with the last 20 bytes of the stream before saving to disk, and throwing a "packfile got corrupted during download" error if the SHA doesn't match.
  if (packfileSha !== '' && !emptyPackfile(packfile)) {
    res.packfile = `objects/pack/pack-${packfileSha}.pack`;
    const fullpath = join(gitdir, res.packfile);
    await fs.write(fullpath, packfile);
    const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });
    const idx = await GitPackIndex.fromPack({
      pack: packfile,
      getExternalRefDelta,
      onProgress,
    });
    await fs.write(fullpath.replace(/\.pack$/, '.idx'), await idx.toBuffer());
  }
  return res
}

// @ts-check

/**
 * Initialize a new repository
 *
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} [args.dir]
 * @param {string} [args.gitdir]
 * @param {boolean} [args.bare = false]
 * @param {string} [args.defaultBranch = 'master']
 * @returns {Promise<void>}
 */
async function _init({
  fs,
  bare = false,
  dir,
  gitdir = bare ? dir : join(dir, '.git'),
  defaultBranch = 'master',
}) {
  // Don't overwrite an existing config
  if (await fs.exists(gitdir + '/config')) return

  let folders = [
    'hooks',
    'info',
    'objects/info',
    'objects/pack',
    'refs/heads',
    'refs/tags',
  ];
  folders = folders.map(dir => gitdir + '/' + dir);
  for (const folder of folders) {
    await fs.mkdir(folder);
  }

  await fs.write(
    gitdir + '/config',
    '[core]\n' +
      '\trepositoryformatversion = 0\n' +
      '\tfilemode = false\n' +
      `\tbare = ${bare}\n` +
      (bare ? '' : '\tlogallrefupdates = true\n') +
      '\tsymlinks = false\n' +
      '\tignorecase = true\n'
  );
  await fs.write(gitdir + '/HEAD', `ref: refs/heads/${defaultBranch}\n`);
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {HttpClient} args.http
 * @param {ProgressCallback} [args.onProgress]
 * @param {MessageCallback} [args.onMessage]
 * @param {AuthCallback} [args.onAuth]
 * @param {AuthFailureCallback} [args.onAuthFailure]
 * @param {AuthSuccessCallback} [args.onAuthSuccess]
 * @param {string} [args.dir]
 * @param {string} args.gitdir
 * @param {string} args.url
 * @param {string} args.corsProxy
 * @param {string} args.ref
 * @param {boolean} args.singleBranch
 * @param {boolean} args.noCheckout
 * @param {boolean} args.noTags
 * @param {string} args.remote
 * @param {number} args.depth
 * @param {Date} args.since
 * @param {string[]} args.exclude
 * @param {boolean} args.relative
 * @param {Object<string, string>} args.headers
 *
 * @returns {Promise<void>} Resolves successfully when clone completes
 *
 */
async function _clone({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir,
  url,
  corsProxy,
  ref,
  remote,
  depth,
  since,
  exclude,
  relative,
  singleBranch,
  noCheckout,
  noTags,
  headers,
}) {
  try {
    await _init({ fs, gitdir });
    await _addRemote({ fs, gitdir, remote, url, force: false });
    if (corsProxy) {
      const config = await GitConfigManager.get({ fs, gitdir });
      await config.set(`http.corsProxy`, corsProxy);
      await GitConfigManager.save({ fs, gitdir, config });
    }
    const { defaultBranch, fetchHead } = await _fetch({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remote,
      corsProxy,
      depth,
      since,
      exclude,
      relative,
      singleBranch,
      headers,
      tags: !noTags,
    });
    if (fetchHead === null) return
    ref = ref || defaultBranch;
    ref = ref.replace('refs/heads/', '');
    // Checkout that branch
    await _checkout({
      fs,
      cache,
      onProgress,
      dir,
      gitdir,
      ref,
      remote,
      noCheckout,
    });
  } catch (err) {
    // Remove partial local repository, see #1283
    // Ignore any error as we are already failing.
    // The catch is necessary so the original error is not masked.
    await fs
      .rmdir(gitdir, { recursive: true, maxRetries: 10 })
      .catch(() => undefined);
    throw err
  }
}

// @ts-check

/**
 * Clone a repository
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {HttpClient} args.http - an HTTP client
 * @param {ProgressCallback} [args.onProgress] - optional progress event callback
 * @param {MessageCallback} [args.onMessage] - optional message event callback
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.url - The URL of the remote repository
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Value is stored in the git config file for that repo.
 * @param {string} [args.ref] - Which branch to checkout. By default this is the designated "main branch" of the repository.
 * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.
 * @param {boolean} [args.noCheckout = false] - If true, clone will only fetch the repo, not check out a branch. Skipping checkout can save a lot of time normally spent writing files to disk.
 * @param {boolean} [args.noTags = false] - By default clone will fetch all tags. `noTags` disables that behavior.
 * @param {string} [args.remote = 'origin'] - What to name the remote that is created.
 * @param {number} [args.depth] - Integer. Determines how much of the git repository's history to retrieve
 * @param {Date} [args.since] - Only fetch commits created after the given date. Mutually exclusive with `depth`.
 * @param {string[]} [args.exclude = []] - A list of branches or tags. Instructs the remote server not to send us any commits reachable from these refs.
 * @param {boolean} [args.relative = false] - Changes the meaning of `depth` to be measured from the current shallow depth rather than from the branch tip.
 * @param {Object<string, string>} [args.headers = {}] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully when clone completes
 *
 * @example
 * await git.clone({
 *   fs,
 *   http,
 *   dir: '/tutorial',
 *   corsProxy: 'https://cors.isomorphic-git.org',
 *   url: 'https://github.com/isomorphic-git/isomorphic-git',
 *   singleBranch: true,
 *   depth: 1
 * })
 * console.log('done')
 *
 */
async function clone({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, '.git'),
  url,
  corsProxy = undefined,
  ref = undefined,
  remote = 'origin',
  depth = undefined,
  since = undefined,
  exclude = [],
  relative = false,
  singleBranch = false,
  noCheckout = false,
  noTags = false,
  headers = {},
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('http', http);
    assertParameter('gitdir', gitdir);
    if (!noCheckout) {
      assertParameter('dir', dir);
    }
    assertParameter('url', url);

    return await _clone({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      url,
      corsProxy,
      ref,
      remote,
      depth,
      since,
      exclude,
      relative,
      singleBranch,
      noCheckout,
      noTags,
      headers,
    })
  } catch (err) {
    err.caller = 'git.clone';
    throw err
  }
}

// @ts-check

/**
 * Create a new commit
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {SignCallback} [args.onSign] - a PGP signing implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.message - The commit message to use.
 * @param {Object} [args.author] - The details about the author.
 * @param {string} [args.author.name] - Default is `user.name` config.
 * @param {string} [args.author.email] - Default is `user.email` config.
 * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {Object} [args.committer = author] - The details about the commit committer, in the same format as the author parameter. If not specified, the author details are used.
 * @param {string} [args.committer.name] - Default is `user.name` config.
 * @param {string} [args.committer.email] - Default is `user.email` config.
 * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {string} [args.signingKey] - Sign the tag object using this private PGP key.
 * @param {boolean} [args.dryRun = false] - If true, simulates making a commit so you can test whether it would succeed. Implies `noUpdateBranch`.
 * @param {boolean} [args.noUpdateBranch = false] - If true, does not update the branch pointer after creating the commit.
 * @param {string} [args.ref] - The fully expanded name of the branch to commit to. Default is the current branch pointed to by HEAD. (TODO: fix it so it can expand branch names without throwing if the branch doesn't exist yet.)
 * @param {string[]} [args.parent] - The SHA-1 object ids of the commits to use as parents. If not specified, the commit pointed to by `ref` is used.
 * @param {string} [args.tree] - The SHA-1 object id of the tree to use. If not specified, a new tree object is created from the current git index.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly created commit.
 *
 * @example
 * let sha = await git.commit({
 *   fs,
 *   dir: '/tutorial',
 *   author: {
 *     name: 'Mr. Test',
 *     email: 'mrtest@example.com',
 *   },
 *   message: 'Added the a.txt file'
 * })
 * console.log(sha)
 *
 */
async function commit({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, '.git'),
  message,
  author: _author,
  committer: _committer,
  signingKey,
  dryRun = false,
  noUpdateBranch = false,
  ref,
  parent,
  tree,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('message', message);
    if (signingKey) {
      assertParameter('onSign', onSign);
    }
    const fs = new FileSystem(_fs);

    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author) throw new MissingNameError('author')

    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer) throw new MissingNameError('committer')

    return await _commit({
      fs,
      cache,
      onSign,
      gitdir,
      message,
      author,
      committer,
      signingKey,
      dryRun,
      noUpdateBranch,
      ref,
      parent,
      tree,
    })
  } catch (err) {
    err.caller = 'git.commit';
    throw err
  }
}

// @ts-check

/**
 * Get the name of the branch currently pointed to by .git/HEAD
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {boolean} [args.fullname = false] - Return the full path (e.g. "refs/heads/main") instead of the abbreviated form.
 * @param {boolean} [args.test = false] - If the current branch doesn't actually exist (such as right after git init) then return `undefined`.
 *
 * @returns {Promise<string|void>} The name of the current branch or undefined if the HEAD is detached.
 *
 * @example
 * // Get the current branch name
 * let branch = await git.currentBranch({
 *   fs,
 *   dir: '/tutorial',
 *   fullname: false
 * })
 * console.log(branch)
 *
 */
async function currentBranch({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  fullname = false,
  test = false,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    return await _currentBranch({
      fs: new FileSystem(fs),
      gitdir,
      fullname,
      test,
    })
  } catch (err) {
    err.caller = 'git.currentBranch';
    throw err
  }
}

// @ts-check

/**
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.ref
 *
 * @returns {Promise<void>}
 */
async function _deleteBranch({ fs, gitdir, ref }) {
  const exist = await GitRefManager.exists({ fs, gitdir, ref });
  if (!exist) {
    throw new NotFoundError(ref)
  }

  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
  const currentRef = await _currentBranch({ fs, gitdir, fullname: true });
  if (fullRef === currentRef) {
    // detach HEAD
    const value = await GitRefManager.resolve({ fs, gitdir, ref: fullRef });
    await GitRefManager.writeRef({ fs, gitdir, ref: 'HEAD', value });
  }

  // Delete a specified branch
  await GitRefManager.deleteRef({ fs, gitdir, ref: fullRef });
}

// @ts-check

/**
 * Delete a local branch
 *
 * > Note: This only deletes loose branches - it should be fixed in the future to delete packed branches as well.
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - The branch to delete
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.deleteBranch({ fs, dir: '/tutorial', ref: 'local-branch' })
 * console.log('done')
 *
 */
async function deleteBranch({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('ref', ref);
    return await _deleteBranch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
    })
  } catch (err) {
    err.caller = 'git.deleteBranch';
    throw err
  }
}

// @ts-check

/**
 * Delete a local ref
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - The ref to delete
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.deleteRef({ fs, dir: '/tutorial', ref: 'refs/tags/test-tag' })
 * console.log('done')
 *
 */
async function deleteRef({ fs, dir, gitdir = join(dir, '.git'), ref }) {
  try {
    assertParameter('fs', fs);
    assertParameter('ref', ref);
    await GitRefManager.deleteRef({ fs: new FileSystem(fs), gitdir, ref });
  } catch (err) {
    err.caller = 'git.deleteRef';
    throw err
  }
}

// @ts-check

/**
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.remote
 *
 * @returns {Promise<void>}
 */
async function _deleteRemote({ fs, gitdir, remote }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  await config.deleteSection('remote', remote);
  await GitConfigManager.save({ fs, gitdir, config });
}

// @ts-check

/**
 * Removes the local config entry for a given remote
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.remote - The name of the remote to delete
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.deleteRemote({ fs, dir: '/tutorial', remote: 'upstream' })
 * console.log('done')
 *
 */
async function deleteRemote({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  remote,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('remote', remote);
    return await _deleteRemote({
      fs: new FileSystem(fs),
      gitdir,
      remote,
    })
  } catch (err) {
    err.caller = 'git.deleteRemote';
    throw err
  }
}

// @ts-check

/**
 * Delete a local tag ref
 *
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.ref - The tag to delete
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.deleteTag({ dir: '$input((/))', ref: '$input((test-tag))' })
 * console.log('done')
 *
 */
async function _deleteTag({ fs, gitdir, ref }) {
  ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;
  await GitRefManager.deleteRef({ fs, gitdir, ref });
}

// @ts-check

/**
 * Delete a local tag ref
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - The tag to delete
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.deleteTag({ fs, dir: '/tutorial', ref: 'test-tag' })
 * console.log('done')
 *
 */
async function deleteTag({ fs, dir, gitdir = join(dir, '.git'), ref }) {
  try {
    assertParameter('fs', fs);
    assertParameter('ref', ref);
    return await _deleteTag({
      fs: new FileSystem(fs),
      gitdir,
      ref,
    })
  } catch (err) {
    err.caller = 'git.deleteTag';
    throw err
  }
}

async function expandOidLoose({ fs, gitdir, oid: short }) {
  const prefix = short.slice(0, 2);
  const objectsSuffixes = await fs.readdir(`${gitdir}/objects/${prefix}`);
  return objectsSuffixes
    .map(suffix => `${prefix}${suffix}`)
    .filter(_oid => _oid.startsWith(short))
}

async function expandOidPacked({
  fs,
  cache,
  gitdir,
  oid: short,
  getExternalRefDelta,
}) {
  // Iterate through all the .pack files
  const results = [];
  let list = await fs.readdir(join(gitdir, 'objects/pack'));
  list = list.filter(x => x.endsWith('.idx'));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta,
    });
    if (p.error) throw new InternalError(p.error)
    // Search through the list of oids in the packfile
    for (const oid of p.offsets.keys()) {
      if (oid.startsWith(short)) results.push(oid);
    }
  }
  return results
}

async function _expandOid({ fs, cache, gitdir, oid: short }) {
  // Curry the current read method so that the packfile un-deltification
  // process can acquire external ref-deltas.
  const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });

  const results1 = await expandOidLoose({ fs, gitdir, oid: short });
  const results2 = await expandOidPacked({
    fs,
    cache,
    gitdir,
    oid: short,
    getExternalRefDelta,
  });
  const results = results1.concat(results2);

  if (results.length === 1) {
    return results[0]
  }
  if (results.length > 1) {
    throw new AmbiguousError('oids', short, results)
  }
  throw new NotFoundError(`an object matching "${short}"`)
}

// @ts-check

/**
 * Expand and resolve a short oid into a full oid
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.oid - The shortened oid prefix to expand (like "0414d2a")
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<string>} Resolves successfully with the full oid (like "0414d2a286d7bbc7a4a326a61c1f9f888a8ab87f")
 *
 * @example
 * let oid = await git.expandOid({ fs, dir: '/tutorial', oid: '0414d2a'})
 * console.log(oid)
 *
 */
async function expandOid({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oid,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);
    return await _expandOid({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
    })
  } catch (err) {
    err.caller = 'git.expandOid';
    throw err
  }
}

// @ts-check

/**
 * Expand an abbreviated ref to its full name
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - The ref to expand (like "v1.0.0")
 *
 * @returns {Promise<string>} Resolves successfully with a full ref name ("refs/tags/v1.0.0")
 *
 * @example
 * let fullRef = await git.expandRef({ fs, dir: '/tutorial', ref: 'main'})
 * console.log(fullRef)
 *
 */
async function expandRef({ fs, dir, gitdir = join(dir, '.git'), ref }) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);
    return await GitRefManager.expand({
      fs: new FileSystem(fs),
      gitdir,
      ref,
    })
  } catch (err) {
    err.caller = 'git.expandRef';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string[]} args.oids
 *
 */
async function _findMergeBase({ fs, cache, gitdir, oids }) {
  // Note: right now, the tests are geared so that the output should match that of
  // `git merge-base --all --octopus`
  // because without the --octopus flag, git's output seems to depend on the ORDER of the oids,
  // and computing virtual merge bases is just too much for me to fathom right now.

  // If we start N independent walkers, one at each of the given `oids`, and walk backwards
  // through ancestors, eventually we'll discover a commit where each one of these N walkers
  // has passed through. So we just need to keep track of which walkers have visited each commit
  // until we find a commit that N distinct walkers has visited.
  const visits = {};
  const passes = oids.length;
  let heads = oids.map((oid, index) => ({ index, oid }));
  while (heads.length) {
    // Count how many times we've passed each commit
    const result = new Set();
    for (const { oid, index } of heads) {
      if (!visits[oid]) visits[oid] = new Set();
      visits[oid].add(index);
      if (visits[oid].size === passes) {
        result.add(oid);
      }
    }
    if (result.size > 0) {
      return [...result]
    }
    // We haven't found a common ancestor yet
    const newheads = new Map();
    for (const { oid, index } of heads) {
      try {
        const { object } = await _readObject({ fs, cache, gitdir, oid });
        const commit = GitCommit.from(object);
        const { parent } = commit.parseHeaders();
        for (const oid of parent) {
          if (!visits[oid] || !visits[oid].has(index)) {
            newheads.set(oid + ':' + index, { oid, index });
          }
        }
      } catch (err) {
        // do nothing
      }
    }
    heads = Array.from(newheads.values());
  }
  return []
}

const LINEBREAKS = /^.*(\r?\n|$)/gm;

function mergeFile({
  ourContent,
  baseContent,
  theirContent,
  ourName = 'ours',
  baseName = 'base',
  theirName = 'theirs',
  format = 'diff',
  markerSize = 7,
}) {
  const ours = ourContent.match(LINEBREAKS);
  const base = baseContent.match(LINEBREAKS);
  const theirs = theirContent.match(LINEBREAKS);

  // Here we let the diff3 library do the heavy lifting.
  const result = diff3__WEBPACK_IMPORTED_MODULE_7__(ours, base, theirs);

  // Here we note whether there are conflicts and format the results
  let mergedText = '';
  let cleanMerge = true;
  for (const item of result) {
    if (item.ok) {
      mergedText += item.ok.join('');
    }
    if (item.conflict) {
      cleanMerge = false;
      mergedText += `${'<'.repeat(markerSize)} ${ourName}\n`;
      mergedText += item.conflict.a.join('');
      if (format === 'diff3') {
        mergedText += `${'|'.repeat(markerSize)} ${baseName}\n`;
        mergedText += item.conflict.o.join('');
      }
      mergedText += `${'='.repeat(markerSize)}\n`;
      mergedText += item.conflict.b.join('');
      mergedText += `${'>'.repeat(markerSize)} ${theirName}\n`;
    }
  }
  return { cleanMerge, mergedText }
}

// @ts-check

/**
 * Create a merged tree
 *
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ourOid - The SHA-1 object id of our tree
 * @param {string} args.baseOid - The SHA-1 object id of the base tree
 * @param {string} args.theirOid - The SHA-1 object id of their tree
 * @param {string} [args.ourName='ours'] - The name to use in conflicted files for our hunks
 * @param {string} [args.baseName='base'] - The name to use in conflicted files (in diff3 format) for the base hunks
 * @param {string} [args.theirName='theirs'] - The name to use in conflicted files for their hunks
 * @param {boolean} [args.dryRun=false]
 *
 * @returns {Promise<string>} - The SHA-1 object id of the merged tree
 *
 */
async function mergeTree({
  fs,
  cache,
  dir,
  gitdir = join(dir, '.git'),
  ourOid,
  baseOid,
  theirOid,
  ourName = 'ours',
  baseName = 'base',
  theirName = 'theirs',
  dryRun = false,
}) {
  const ourTree = TREE({ ref: ourOid });
  const baseTree = TREE({ ref: baseOid });
  const theirTree = TREE({ ref: theirOid });

  const results = await _walk({
    fs,
    cache,
    dir,
    gitdir,
    trees: [ourTree, baseTree, theirTree],
    map: async function(filepath, [ours, base, theirs]) {
      const path = basename(filepath);
      // What we did, what they did
      const ourChange = await modified(ours, base);
      const theirChange = await modified(theirs, base);
      switch (`${ourChange}-${theirChange}`) {
        case 'false-false': {
          return {
            mode: await base.mode(),
            path,
            oid: await base.oid(),
            type: await base.type(),
          }
        }
        case 'false-true': {
          return theirs
            ? {
                mode: await theirs.mode(),
                path,
                oid: await theirs.oid(),
                type: await theirs.type(),
              }
            : undefined
        }
        case 'true-false': {
          return ours
            ? {
                mode: await ours.mode(),
                path,
                oid: await ours.oid(),
                type: await ours.type(),
              }
            : undefined
        }
        case 'true-true': {
          // Modifications
          if (
            ours &&
            base &&
            theirs &&
            (await ours.type()) === 'blob' &&
            (await base.type()) === 'blob' &&
            (await theirs.type()) === 'blob'
          ) {
            return mergeBlobs({
              fs,
              gitdir,
              path,
              ours,
              base,
              theirs,
              ourName,
              baseName,
              theirName,
            })
          }
          // all other types of conflicts fail
          throw new MergeNotSupportedError()
        }
      }
    },
    /**
     * @param {TreeEntry} [parent]
     * @param {Array<TreeEntry>} children
     */
    reduce: async (parent, children) => {
      const entries = children.filter(Boolean); // remove undefineds

      // if the parent was deleted, the children have to go
      if (!parent) return

      // automatically delete directories if they have been emptied
      if (parent && parent.type === 'tree' && entries.length === 0) return

      if (entries.length > 0) {
        const tree = new GitTree(entries);
        const object = tree.toObject();
        const oid = await _writeObject({
          fs,
          gitdir,
          type: 'tree',
          object,
          dryRun,
        });
        parent.oid = oid;
      }
      return parent
    },
  });
  return results.oid
}

/**
 *
 * @param {WalkerEntry} entry
 * @param {WalkerEntry} base
 *
 */
async function modified(entry, base) {
  if (!entry && !base) return false
  if (entry && !base) return true
  if (!entry && base) return true
  if ((await entry.type()) === 'tree' && (await base.type()) === 'tree') {
    return false
  }
  if (
    (await entry.type()) === (await base.type()) &&
    (await entry.mode()) === (await base.mode()) &&
    (await entry.oid()) === (await base.oid())
  ) {
    return false
  }
  return true
}

/**
 *
 * @param {Object} args
 * @param {import('../models/FileSystem').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.path
 * @param {WalkerEntry} args.ours
 * @param {WalkerEntry} args.base
 * @param {WalkerEntry} args.theirs
 * @param {string} [args.ourName]
 * @param {string} [args.baseName]
 * @param {string} [args.theirName]
 * @param {string} [args.format]
 * @param {number} [args.markerSize]
 * @param {boolean} [args.dryRun = false]
 *
 */
async function mergeBlobs({
  fs,
  gitdir,
  path,
  ours,
  base,
  theirs,
  ourName,
  theirName,
  baseName,
  format,
  markerSize,
  dryRun,
}) {
  const type = 'blob';
  // Compute the new mode.
  // Since there are ONLY two valid blob modes ('100755' and '100644') it boils down to this
  const mode =
    (await base.mode()) === (await ours.mode())
      ? await theirs.mode()
      : await ours.mode();
  // The trivial case: nothing to merge except maybe mode
  if ((await ours.oid()) === (await theirs.oid())) {
    return { mode, path, oid: await ours.oid(), type }
  }
  // if only one side made oid changes, return that side's oid
  if ((await ours.oid()) === (await base.oid())) {
    return { mode, path, oid: await theirs.oid(), type }
  }
  if ((await theirs.oid()) === (await base.oid())) {
    return { mode, path, oid: await ours.oid(), type }
  }
  // if both sides made changes do a merge
  const { mergedText, cleanMerge } = mergeFile({
    ourContent: Buffer.from(await ours.content()).toString('utf8'),
    baseContent: Buffer.from(await base.content()).toString('utf8'),
    theirContent: Buffer.from(await theirs.content()).toString('utf8'),
    ourName,
    theirName,
    baseName,
    format,
    markerSize,
  });
  if (!cleanMerge) {
    // all other types of conflicts fail
    throw new MergeNotSupportedError()
  }
  const oid = await _writeObject({
    fs,
    gitdir,
    type: 'blob',
    object: Buffer.from(mergedText, 'utf8'),
    dryRun,
  });
  return { mode, path, oid, type }
}

// @ts-check

// import diff3 from 'node-diff3'
/**
 *
 * @typedef {Object} MergeResult - Returns an object with a schema like this:
 * @property {string} [oid] - The SHA-1 object id that is now at the head of the branch. Absent only if `dryRun` was specified and `mergeCommit` is true.
 * @property {boolean} [alreadyMerged] - True if the branch was already merged so no changes were made
 * @property {boolean} [fastForward] - True if it was a fast-forward merge
 * @property {boolean} [mergeCommit] - True if merge resulted in a merge commit
 * @property {string} [tree] - The SHA-1 object id of the tree resulting from a merge commit
 *
 */

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {string} args.gitdir
 * @param {string} [args.ours]
 * @param {string} args.theirs
 * @param {boolean} args.fastForwardOnly
 * @param {boolean} args.dryRun
 * @param {boolean} args.noUpdateBranch
 * @param {string} [args.message]
 * @param {Object} args.author
 * @param {string} args.author.name
 * @param {string} args.author.email
 * @param {number} args.author.timestamp
 * @param {number} args.author.timezoneOffset
 * @param {Object} args.committer
 * @param {string} args.committer.name
 * @param {string} args.committer.email
 * @param {number} args.committer.timestamp
 * @param {number} args.committer.timezoneOffset
 * @param {string} [args.signingKey]
 * @param {SignCallback} [args.onSign] - a PGP signing implementation
 *
 * @returns {Promise<MergeResult>} Resolves to a description of the merge operation
 *
 */
async function _merge({
  fs,
  cache,
  gitdir,
  ours,
  theirs,
  fastForwardOnly = false,
  dryRun = false,
  noUpdateBranch = false,
  message,
  author,
  committer,
  signingKey,
  onSign,
}) {
  if (ours === undefined) {
    ours = await _currentBranch({ fs, gitdir, fullname: true });
  }
  ours = await GitRefManager.expand({
    fs,
    gitdir,
    ref: ours,
  });
  theirs = await GitRefManager.expand({
    fs,
    gitdir,
    ref: theirs,
  });
  const ourOid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: ours,
  });
  const theirOid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: theirs,
  });
  // find most recent common ancestor of ref a and ref b
  const baseOids = await _findMergeBase({
    fs,
    cache,
    gitdir,
    oids: [ourOid, theirOid],
  });
  if (baseOids.length !== 1) {
    throw new MergeNotSupportedError()
  }
  const baseOid = baseOids[0];
  // handle fast-forward case
  if (baseOid === theirOid) {
    return {
      oid: ourOid,
      alreadyMerged: true,
    }
  }
  if (baseOid === ourOid) {
    if (!dryRun && !noUpdateBranch) {
      await GitRefManager.writeRef({ fs, gitdir, ref: ours, value: theirOid });
    }
    return {
      oid: theirOid,
      fastForward: true,
    }
  } else {
    // not a simple fast-forward
    if (fastForwardOnly) {
      throw new FastForwardError()
    }
    // try a fancier merge
    const tree = await mergeTree({
      fs,
      cache,
      gitdir,
      ourOid,
      theirOid,
      baseOid,
      ourName: ours,
      baseName: 'base',
      theirName: theirs,
      dryRun,
    });
    if (!message) {
      message = `Merge branch '${abbreviateRef(theirs)}' into ${abbreviateRef(
        ours
      )}`;
    }
    const oid = await _commit({
      fs,
      cache,
      gitdir,
      message,
      ref: ours,
      tree,
      parent: [ourOid, theirOid],
      author,
      committer,
      signingKey,
      onSign,
      dryRun,
      noUpdateBranch,
    });
    return {
      oid,
      tree,
      mergeCommit: true,
    }
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {HttpClient} args.http
 * @param {ProgressCallback} [args.onProgress]
 * @param {MessageCallback} [args.onMessage]
 * @param {AuthCallback} [args.onAuth]
 * @param {AuthFailureCallback} [args.onAuthFailure]
 * @param {AuthSuccessCallback} [args.onAuthSuccess]
 * @param {string} args.dir
 * @param {string} args.gitdir
 * @param {string} args.ref
 * @param {string} [args.url]
 * @param {string} [args.remote]
 * @param {string} [args.remoteRef]
 * @param {string} [args.corsProxy]
 * @param {boolean} args.singleBranch
 * @param {boolean} args.fastForwardOnly
 * @param {Object<string, string>} [args.headers]
 * @param {Object} args.author
 * @param {string} args.author.name
 * @param {string} args.author.email
 * @param {number} args.author.timestamp
 * @param {number} args.author.timezoneOffset
 * @param {Object} args.committer
 * @param {string} args.committer.name
 * @param {string} args.committer.email
 * @param {number} args.committer.timestamp
 * @param {number} args.committer.timezoneOffset
 * @param {string} [args.signingKey]
 *
 * @returns {Promise<void>} Resolves successfully when pull operation completes
 *
 */
async function _pull({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir,
  ref,
  url,
  remote,
  remoteRef,
  fastForwardOnly,
  corsProxy,
  singleBranch,
  headers,
  author,
  committer,
  signingKey,
}) {
  try {
    // If ref is undefined, use 'HEAD'
    if (!ref) {
      const head = await _currentBranch({ fs, gitdir });
      // TODO: use a better error.
      if (!head) {
        throw new MissingParameterError('ref')
      }
      ref = head;
    }

    const { fetchHead, fetchHeadDescription } = await _fetch({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      corsProxy,
      ref,
      url,
      remote,
      remoteRef,
      singleBranch,
      headers,
    });
    // Merge the remote tracking branch into the local one.
    await _merge({
      fs,
      cache,
      gitdir,
      ours: ref,
      theirs: fetchHead,
      fastForwardOnly,
      message: `Merge ${fetchHeadDescription}`,
      author,
      committer,
      signingKey,
      dryRun: false,
      noUpdateBranch: false,
    });
    await _checkout({
      fs,
      cache,
      onProgress,
      dir,
      gitdir,
      ref,
      remote,
      noCheckout: false,
    });
  } catch (err) {
    err.caller = 'git.pull';
    throw err
  }
}

// @ts-check

/**
 * Like `pull`, but hard-coded with `fastForward: true` so there is no need for an `author` parameter.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {HttpClient} args.http - an HTTP client
 * @param {ProgressCallback} [args.onProgress] - optional progress event callback
 * @param {MessageCallback} [args.onMessage] - optional message event callback
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - Which branch to merge into. By default this is the currently checked out branch.
 * @param {string} [args.url] - (Added in 1.1.0) The URL of the remote repository. The default is the value set in the git config for that remote.
 * @param {string} [args.remote] - (Added in 1.1.0) If URL is not specified, determines which remote to use.
 * @param {string} [args.remoteRef] - (Added in 1.1.0) The name of the branch on the remote to fetch. By default this is the configured remote tracking branch.
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.
 * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.
 * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully when pull operation completes
 *
 * @example
 * await git.fastForward({
 *   fs,
 *   http,
 *   dir: '/tutorial',
 *   ref: 'main',
 *   singleBranch: true
 * })
 * console.log('done')
 *
 */
async function fastForward({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  url,
  remote,
  remoteRef,
  corsProxy,
  singleBranch,
  headers = {},
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('http', http);
    assertParameter('gitdir', gitdir);

    const thisWillNotBeUsed = {
      name: '',
      email: '',
      timestamp: Date.now(),
      timezoneOffset: 0,
    };

    return await _pull({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      ref,
      url,
      remote,
      remoteRef,
      fastForwardOnly: true,
      corsProxy,
      singleBranch,
      headers,
      author: thisWillNotBeUsed,
      committer: thisWillNotBeUsed,
    })
  } catch (err) {
    err.caller = 'git.fastForward';
    throw err
  }
}

// @ts-check

/**
 *
 * @typedef {object} FetchResult - The object returned has the following schema:
 * @property {string | null} defaultBranch - The branch that is cloned if no branch is specified
 * @property {string | null} fetchHead - The SHA-1 object id of the fetched head commit
 * @property {string | null} fetchHeadDescription - a textual description of the branch that was fetched
 * @property {Object<string, string>} [headers] - The HTTP response headers returned by the git server
 * @property {string[]} [pruned] - A list of branches that were pruned, if you provided the `prune` parameter
 *
 */

/**
 * Fetch commits from a remote repository
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {HttpClient} args.http - an HTTP client
 * @param {ProgressCallback} [args.onProgress] - optional progress event callback
 * @param {MessageCallback} [args.onMessage] - optional message event callback
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.url] - The URL of the remote repository. The default is the value set in the git config for that remote.
 * @param {string} [args.remote] - If URL is not specified, determines which remote to use.
 * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.
 * @param {string} [args.ref] - Which branch to fetch if `singleBranch` is true. By default this is the current branch or the remote's default branch.
 * @param {string} [args.remoteRef] - The name of the branch on the remote to fetch if `singleBranch` is true. By default this is the configured remote tracking branch.
 * @param {boolean} [args.tags = false] - Also fetch tags
 * @param {number} [args.depth] - Integer. Determines how much of the git repository's history to retrieve
 * @param {boolean} [args.relative = false] - Changes the meaning of `depth` to be measured from the current shallow depth rather than from the branch tip.
 * @param {Date} [args.since] - Only fetch commits created after the given date. Mutually exclusive with `depth`.
 * @param {string[]} [args.exclude = []] - A list of branches or tags. Instructs the remote server not to send us any commits reachable from these refs.
 * @param {boolean} [args.prune] - Delete local remote-tracking branches that are not present on the remote
 * @param {boolean} [args.pruneTags] - Prune local tags that dont exist on the remote, and force-update those tags that differ
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.
 * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<FetchResult>} Resolves successfully when fetch completes
 * @see FetchResult
 *
 * @example
 * let result = await git.fetch({
 *   fs,
 *   http,
 *   dir: '/tutorial',
 *   corsProxy: 'https://cors.isomorphic-git.org',
 *   url: 'https://github.com/isomorphic-git/isomorphic-git',
 *   ref: 'main',
 *   depth: 1,
 *   singleBranch: true,
 *   tags: false
 * })
 * console.log(result)
 *
 */
async function fetch({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  remote,
  remoteRef,
  url,
  corsProxy,
  depth = null,
  since = null,
  exclude = [],
  relative = false,
  tags = false,
  singleBranch = false,
  headers = {},
  prune = false,
  pruneTags = false,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('http', http);
    assertParameter('gitdir', gitdir);

    return await _fetch({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remote,
      remoteRef,
      url,
      corsProxy,
      depth,
      since,
      exclude,
      relative,
      tags,
      singleBranch,
      headers,
      prune,
      pruneTags,
    })
  } catch (err) {
    err.caller = 'git.fetch';
    throw err
  }
}

// @ts-check

/**
 * Find the merge base for a set of commits
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string[]} args.oids - Which commits
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 */
async function findMergeBase({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oids,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oids', oids);

    return await _findMergeBase({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oids,
    })
  } catch (err) {
    err.caller = 'git.findMergeBase';
    throw err
  }
}

// @ts-check

/**
 * Find the root git directory
 *
 * Starting at `filepath`, walks upward until it finds a directory that contains a subdirectory called '.git'.
 *
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.filepath
 *
 * @returns {Promise<string>} Resolves successfully with a root git directory path
 */
async function _findRoot({ fs, filepath }) {
  if (await fs.exists(join(filepath, '.git'))) {
    return filepath
  } else {
    const parent = dirname(filepath);
    if (parent === filepath) {
      throw new NotFoundError(`git root for ${filepath}`)
    }
    return _findRoot({ fs, filepath: parent })
  }
}

// @ts-check

/**
 * Find the root git directory
 *
 * Starting at `filepath`, walks upward until it finds a directory that contains a subdirectory called '.git'.
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} args.filepath - The file directory to start searching in.
 *
 * @returns {Promise<string>} Resolves successfully with a root git directory path
 * @throws {NotFoundError}
 *
 * @example
 * let gitroot = await git.findRoot({
 *   fs,
 *   filepath: '/tutorial/src/utils'
 * })
 * console.log(gitroot)
 *
 */
async function findRoot({ fs, filepath }) {
  try {
    assertParameter('fs', fs);
    assertParameter('filepath', filepath);

    return await _findRoot({ fs: new FileSystem(fs), filepath })
  } catch (err) {
    err.caller = 'git.findRoot';
    throw err
  }
}

// @ts-check

/**
 * Read an entry from the git config files.
 *
 * *Caveats:*
 * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.
 * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.path - The key of the git config entry
 *
 * @returns {Promise<any>} Resolves with the config value
 *
 * @example
 * // Read config value
 * let value = await git.getConfig({
 *   fs,
 *   dir: '/tutorial',
 *   path: 'remote.origin.url'
 * })
 * console.log(value)
 *
 */
async function getConfig({ fs, dir, gitdir = join(dir, '.git'), path }) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('path', path);

    return await _getConfig({
      fs: new FileSystem(fs),
      gitdir,
      path,
    })
  } catch (err) {
    err.caller = 'git.getConfig';
    throw err
  }
}

// @ts-check

/**
 * @param {Object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.path
 *
 * @returns {Promise<Array<any>>} Resolves with an array of the config value
 *
 */
async function _getConfigAll({ fs, gitdir, path }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  return config.getall(path)
}

// @ts-check

/**
 * Read a multi-valued entry from the git config files.
 *
 * *Caveats:*
 * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.
 * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.path - The key of the git config entry
 *
 * @returns {Promise<Array<any>>} Resolves with the config value
 *
 */
async function getConfigAll({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  path,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('path', path);

    return await _getConfigAll({
      fs: new FileSystem(fs),
      gitdir,
      path,
    })
  } catch (err) {
    err.caller = 'git.getConfigAll';
    throw err
  }
}

// @ts-check

/**
 *
 * @typedef {Object} GetRemoteInfoResult - The object returned has the following schema:
 * @property {string[]} capabilities - The list of capabilities returned by the server (part of the Git protocol)
 * @property {Object} [refs]
 * @property {string} [HEAD] - The default branch of the remote
 * @property {Object<string, string>} [refs.heads] - The branches on the remote
 * @property {Object<string, string>} [refs.pull] - The special branches representing pull requests (non-standard)
 * @property {Object<string, string>} [refs.tags] - The tags on the remote
 *
 */

/**
 * List a remote servers branches, tags, and capabilities.
 *
 * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.
 * It just communicates to a remote git server, using the first step of the `git-upload-pack` handshake, but stopping short of fetching the packfile.
 *
 * @param {object} args
 * @param {HttpClient} args.http - an HTTP client
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.
 * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.
 * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 *
 * @returns {Promise<GetRemoteInfoResult>} Resolves successfully with an object listing the branches, tags, and capabilities of the remote.
 * @see GetRemoteInfoResult
 *
 * @example
 * let info = await git.getRemoteInfo({
 *   http,
 *   url:
 *     "https://cors.isomorphic-git.org/github.com/isomorphic-git/isomorphic-git.git"
 * });
 * console.log(info);
 *
 */
async function getRemoteInfo({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
}) {
  try {
    assertParameter('http', http);
    assertParameter('url', url);

    const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });
    const remote = await GitRemoteHTTP.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? 'git-receive-pack' : 'git-upload-pack',
      url,
      headers,
      protocolVersion: 1,
    });

    // Note: remote.capabilities, remote.refs, and remote.symrefs are Set and Map objects,
    // but one of the objectives of the public API is to always return JSON-compatible objects
    // so we must JSONify them.
    const result = {
      capabilities: [...remote.capabilities],
    };
    // Convert the flat list into an object tree, because I figure 99% of the time
    // that will be easier to use.
    for (const [ref, oid] of remote.refs) {
      const parts = ref.split('/');
      const last = parts.pop();
      let o = result;
      for (const part of parts) {
        o[part] = o[part] || {};
        o = o[part];
      }
      o[last] = oid;
    }
    // Merge symrefs on top of refs to more closely match actual git repo layouts
    for (const [symref, ref] of remote.symrefs) {
      const parts = symref.split('/');
      const last = parts.pop();
      let o = result;
      for (const part of parts) {
        o[part] = o[part] || {};
        o = o[part];
      }
      o[last] = ref;
    }
    return result
  } catch (err) {
    err.caller = 'git.getRemoteInfo';
    throw err
  }
}

// @ts-check

/**
 * @param {any} remote
 * @param {string} prefix
 * @param {boolean} symrefs
 * @param {boolean} peelTags
 * @returns {ServerRef[]}
 */
function formatInfoRefs(remote, prefix, symrefs, peelTags) {
  const refs = [];
  for (const [key, value] of remote.refs) {
    if (prefix && !key.startsWith(prefix)) continue

    if (key.endsWith('^{}')) {
      if (peelTags) {
        const _key = key.replace('^{}', '');
        // Peeled tags are almost always listed immediately after the original tag
        const last = refs[refs.length - 1];
        const r = last.ref === _key ? last : refs.find(x => x.ref === _key);
        if (r === undefined) {
          throw new Error('I did not expect this to happen')
        }
        r.peeled = value;
      }
      continue
    }
    /** @type ServerRef */
    const ref = { ref: key, oid: value };
    if (symrefs) {
      if (remote.symrefs.has(key)) {
        ref.target = remote.symrefs.get(key);
      }
    }
    refs.push(ref);
  }
  return refs
}

// @ts-check

/**
 * @typedef {Object} GetRemoteInfo2Result - This object has the following schema:
 * @property {1 | 2} protocolVersion - Git protocol version the server supports
 * @property {Object<string, string | true>} capabilities - An object of capabilities represented as keys and values
 * @property {ServerRef[]} [refs] - Server refs (they get returned by protocol version 1 whether you want them or not)
 */

/**
 * List a remote server's capabilities.
 *
 * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.
 * It just communicates to a remote git server, determining what protocol version, commands, and features it supports.
 *
 * > The successor to [`getRemoteInfo`](./getRemoteInfo.md), this command supports Git Wire Protocol Version 2.
 * > Therefore its return type is more complicated as either:
 * >
 * > - v1 capabilities (and refs) or
 * > - v2 capabilities (and no refs)
 * >
 * > are returned.
 * > If you just care about refs, use [`listServerRefs`](./listServerRefs.md)
 *
 * @param {object} args
 * @param {HttpClient} args.http - an HTTP client
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.
 * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.
 * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 * @param {1 | 2} [args.protocolVersion = 2] - Which version of the Git Protocol to use.
 *
 * @returns {Promise<GetRemoteInfo2Result>} Resolves successfully with an object listing the capabilities of the remote.
 * @see GetRemoteInfo2Result
 * @see ServerRef
 *
 * @example
 * let info = await git.getRemoteInfo2({
 *   http,
 *   corsProxy: "https://cors.isomorphic-git.org",
 *   url: "https://github.com/isomorphic-git/isomorphic-git.git"
 * });
 * console.log(info);
 *
 */
async function getRemoteInfo2({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
  protocolVersion = 2,
}) {
  try {
    assertParameter('http', http);
    assertParameter('url', url);

    const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });
    const remote = await GitRemoteHTTP.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? 'git-receive-pack' : 'git-upload-pack',
      url,
      headers,
      protocolVersion,
    });

    if (remote.protocolVersion === 2) {
      /** @type GetRemoteInfo2Result */
      return {
        protocolVersion: remote.protocolVersion,
        capabilities: remote.capabilities2,
      }
    }

    // Note: remote.capabilities, remote.refs, and remote.symrefs are Set and Map objects,
    // but one of the objectives of the public API is to always return JSON-compatible objects
    // so we must JSONify them.
    /** @type Object<string, true> */
    const capabilities = {};
    for (const cap of remote.capabilities) {
      const [key, value] = cap.split('=');
      if (value) {
        capabilities[key] = value;
      } else {
        capabilities[key] = true;
      }
    }
    /** @type GetRemoteInfo2Result */
    return {
      protocolVersion: 1,
      capabilities,
      refs: formatInfoRefs(remote, undefined, true, true),
    }
  } catch (err) {
    err.caller = 'git.getRemoteInfo2';
    throw err
  }
}

async function hashObject({
  type,
  object,
  format = 'content',
  oid = undefined,
}) {
  if (format !== 'deflated') {
    if (format !== 'wrapped') {
      object = GitObject.wrap({ type, object });
    }
    oid = await shasum(object);
  }
  return { oid, object }
}

// @ts-check

/**
 *
 * @typedef {object} HashBlobResult - The object returned has the following schema:
 * @property {string} oid - The SHA-1 object id
 * @property {'blob'} type - The type of the object
 * @property {Uint8Array} object - The wrapped git object (the thing that is hashed)
 * @property {'wrapped'} format - The format of the object
 *
 */

/**
 * Compute what the SHA-1 object id of a file would be
 *
 * @param {object} args
 * @param {Uint8Array|string} args.object - The object to write. If `object` is a String then it will be converted to a Uint8Array using UTF-8 encoding.
 *
 * @returns {Promise<HashBlobResult>} Resolves successfully with the SHA-1 object id and the wrapped object Uint8Array.
 * @see HashBlobResult
 *
 * @example
 * let { oid, type, object, format } = await git.hashBlob({
 *   object: 'Hello world!',
 * })
 *
 * console.log('oid', oid)
 * console.log('type', type)
 * console.log('object', object)
 * console.log('format', format)
 *
 */
async function hashBlob({ object }) {
  try {
    assertParameter('object', object);

    // Convert object to buffer
    if (typeof object === 'string') {
      object = Buffer.from(object, 'utf8');
    } else {
      object = Buffer.from(object);
    }

    const type = 'blob';
    const { oid, object: _object } = await hashObject({
      type: 'blob',
      format: 'content',
      object,
    });
    return { oid, type, object: new Uint8Array(_object), format: 'wrapped' }
  } catch (err) {
    err.caller = 'git.hashBlob';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {ProgressCallback} [args.onProgress]
 * @param {string} args.dir
 * @param {string} args.gitdir
 * @param {string} args.filepath
 *
 * @returns {Promise<{oids: string[]}>}
 */
async function _indexPack({
  fs,
  cache,
  onProgress,
  dir,
  gitdir,
  filepath,
}) {
  try {
    filepath = join(dir, filepath);
    const pack = await fs.read(filepath);
    const getExternalRefDelta = oid => _readObject({ fs, cache, gitdir, oid });
    const idx = await GitPackIndex.fromPack({
      pack,
      getExternalRefDelta,
      onProgress,
    });
    await fs.write(filepath.replace(/\.pack$/, '.idx'), await idx.toBuffer());
    return {
      oids: [...idx.hashes],
    }
  } catch (err) {
    err.caller = 'git.indexPack';
    throw err
  }
}

// @ts-check

/**
 * Create the .idx file for a given .pack file
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {ProgressCallback} [args.onProgress] - optional progress event callback
 * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.filepath - The path to the .pack file to index
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<{oids: string[]}>} Resolves with a list of the SHA-1 object ids contained in the packfile
 *
 * @example
 * let packfiles = await fs.promises.readdir('/tutorial/.git/objects/pack')
 * packfiles = packfiles.filter(name => name.endsWith('.pack'))
 * console.log('packfiles', packfiles)
 *
 * const { oids } = await git.indexPack({
 *   fs,
 *   dir: '/tutorial',
 *   filepath: `.git/objects/pack/${packfiles[0]}`,
 *   async onProgress (evt) {
 *     console.log(`${evt.phase}: ${evt.loaded} / ${evt.total}`)
 *   }
 * })
 * console.log(oids)
 *
 */
async function indexPack({
  fs,
  onProgress,
  dir,
  gitdir = join(dir, '.git'),
  filepath,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('dir', dir);
    assertParameter('gitdir', dir);
    assertParameter('filepath', filepath);

    return await _indexPack({
      fs: new FileSystem(fs),
      cache,
      onProgress,
      dir,
      gitdir,
      filepath,
    })
  } catch (err) {
    err.caller = 'git.indexPack';
    throw err
  }
}

// @ts-check

/**
 * Initialize a new repository
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {boolean} [args.bare = false] - Initialize a bare repository
 * @param {string} [args.defaultBranch = 'master'] - The name of the default branch (might be changed to a required argument in 2.0.0)
 * @returns {Promise<void>}  Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.init({ fs, dir: '/tutorial' })
 * console.log('done')
 *
 */
async function init({
  fs,
  bare = false,
  dir,
  gitdir = bare ? dir : join(dir, '.git'),
  defaultBranch = 'master',
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    if (!bare) {
      assertParameter('dir', dir);
    }

    return await _init({
      fs: new FileSystem(fs),
      bare,
      dir,
      gitdir,
      defaultBranch,
    })
  } catch (err) {
    err.caller = 'git.init';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.oid
 * @param {string} args.ancestor
 * @param {number} args.depth - Maximum depth to search before giving up. -1 means no maximum depth.
 *
 * @returns {Promise<boolean>}
 */
async function _isDescendent({
  fs,
  cache,
  gitdir,
  oid,
  ancestor,
  depth,
}) {
  const shallows = await GitShallowManager.read({ fs, gitdir });
  if (!oid) {
    throw new MissingParameterError('oid')
  }
  if (!ancestor) {
    throw new MissingParameterError('ancestor')
  }
  // If you don't like this behavior, add your own check.
  // Edge cases are hard to define a perfect solution.
  if (oid === ancestor) return false
  // We do not use recursion here, because that would lead to depth-first traversal,
  // and we want to maintain a breadth-first traversal to avoid hitting shallow clone depth cutoffs.
  const queue = [oid];
  const visited = new Set();
  let searchdepth = 0;
  while (queue.length) {
    if (searchdepth++ === depth) {
      throw new MaxDepthError(depth)
    }
    const oid = queue.shift();
    const { type, object } = await _readObject({
      fs,
      cache,
      gitdir,
      oid,
    });
    if (type !== 'commit') {
      throw new ObjectTypeError(oid, type, 'commit')
    }
    const commit = GitCommit.from(object).parse();
    // Are any of the parents the sought-after ancestor?
    for (const parent of commit.parent) {
      if (parent === ancestor) return true
    }
    // If not, add them to heads (unless we know this is a shallow commit)
    if (!shallows.has(oid)) {
      for (const parent of commit.parent) {
        if (!visited.has(parent)) {
          queue.push(parent);
          visited.add(parent);
        }
      }
    }
    // Eventually, we'll travel entire tree to the roots where all the parents are empty arrays,
    // or hit the shallow depth and throw an error. Excluding the possibility of grafts, or
    // different branches cloned to different depths, you would hit this error at the same time
    // for all parents, so trying to continue is futile.
  }
  return false
}

// @ts-check

/**
 * Check whether a git commit is descended from another
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.oid - The descendent commit
 * @param {string} args.ancestor - The (proposed) ancestor commit
 * @param {number} [args.depth = -1] - Maximum depth to search before giving up. -1 means no maximum depth.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<boolean>} Resolves to true if `oid` is a descendent of `ancestor`
 *
 * @example
 * let oid = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })
 * let ancestor = await git.resolveRef({ fs, dir: '/tutorial', ref: 'v0.20.0' })
 * console.log(oid, ancestor)
 * await git.isDescendent({ fs, dir: '/tutorial', oid, ancestor, depth: -1 })
 *
 */
async function isDescendent({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oid,
  ancestor,
  depth = -1,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);
    assertParameter('ancestor', ancestor);

    return await _isDescendent({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      ancestor,
      depth,
    })
  } catch (err) {
    err.caller = 'git.isDescendent';
    throw err
  }
}

// @ts-check

/**
 * Test whether a filepath should be ignored (because of .gitignore or .git/exclude)
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.filepath - The filepath to test
 *
 * @returns {Promise<boolean>} Resolves to true if the file should be ignored
 *
 * @example
 * await git.isIgnored({ fs, dir: '/tutorial', filepath: 'docs/add.md' })
 *
 */
async function isIgnored({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  filepath,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('dir', dir);
    assertParameter('gitdir', gitdir);
    assertParameter('filepath', filepath);

    return GitIgnoreManager.isIgnored({
      fs: new FileSystem(fs),
      dir,
      gitdir,
      filepath,
    })
  } catch (err) {
    err.caller = 'git.isIgnored';
    throw err
  }
}

// @ts-check

/**
 * List branches
 *
 * By default it lists local branches. If a 'remote' is specified, it lists the remote's branches. When listing remote branches, the HEAD branch is not filtered out, so it may be included in the list of results.
 *
 * Note that specifying a remote does not actually contact the server and update the list of branches.
 * If you want an up-to-date list, first do a `fetch` to that remote.
 * (Which branch you fetch doesn't matter - the list of branches available on the remote is updated during the fetch handshake.)
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.remote] - Instead of the branches in `refs/heads`, list the branches in `refs/remotes/${remote}`.
 *
 * @returns {Promise<Array<string>>} Resolves successfully with an array of branch names
 *
 * @example
 * let branches = await git.listBranches({ fs, dir: '/tutorial' })
 * console.log(branches)
 * let remoteBranches = await git.listBranches({ fs, dir: '/tutorial', remote: 'origin' })
 * console.log(remoteBranches)
 *
 */
async function listBranches({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  remote,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);

    return GitRefManager.listBranches({
      fs: new FileSystem(fs),
      gitdir,
      remote,
    })
  } catch (err) {
    err.caller = 'git.listBranches';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {string} args.gitdir
 * @param {string} [args.ref]
 *
 * @returns {Promise<Array<string>>}
 */
async function _listFiles({ fs, gitdir, ref, cache }) {
  if (ref) {
    const oid = await GitRefManager.resolve({ gitdir, fs, ref });
    const filenames = [];
    await accumulateFilesFromOid({
      fs,
      cache,
      gitdir,
      oid,
      filenames,
      prefix: '',
    });
    return filenames
  } else {
    return GitIndexManager.acquire({ fs, gitdir, cache }, async function(
      index
    ) {
      return index.entries.map(x => x.path)
    })
  }
}

async function accumulateFilesFromOid({
  fs,
  cache,
  gitdir,
  oid,
  filenames,
  prefix,
}) {
  const { tree } = await _readTree({ fs, cache, gitdir, oid });
  // TODO: Use `walk` to do this. Should be faster.
  for (const entry of tree) {
    if (entry.type === 'tree') {
      await accumulateFilesFromOid({
        fs,
        cache,
        gitdir,
        oid: entry.oid,
        filenames,
        prefix: join(prefix, entry.path),
      });
    } else {
      filenames.push(join(prefix, entry.path));
    }
  }
}

// @ts-check

/**
 * List all the files in the git index or a commit
 *
 * > Note: This function is efficient for listing the files in the staging area, but listing all the files in a commit requires recursively walking through the git object store.
 * > If you do not require a complete list of every file, better performance can be achieved by using [walk](./walk) and ignoring subdirectories you don't care about.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - Return a list of all the files in the commit at `ref` instead of the files currently in the git index (aka staging area)
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<Array<string>>} Resolves successfully with an array of filepaths
 *
 * @example
 * // All the files in the previous commit
 * let files = await git.listFiles({ fs, dir: '/tutorial', ref: 'HEAD' })
 * console.log(files)
 * // All the files in the current staging area
 * files = await git.listFiles({ fs, dir: '/tutorial' })
 * console.log(files)
 *
 */
async function listFiles({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);

    return await _listFiles({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref,
    })
  } catch (err) {
    err.caller = 'git.listFiles';
    throw err
  }
}

// @ts-check

/**
 * List all the object notes
 *
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.ref
 *
 * @returns {Promise<Array<{target: string, note: string}>>}
 */

async function _listNotes({ fs, cache, gitdir, ref }) {
  // Get the current note commit
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (err instanceof NotFoundError) {
      return []
    }
  }

  // Create the current note tree
  const result = await _readTree({
    fs,
    cache,
    gitdir,
    oid: parent,
  });

  // Format the tree entries
  const notes = result.tree.map(entry => ({
    target: entry.path,
    note: entry.oid,
  }));
  return notes
}

// @ts-check

/**
 * List all the object notes
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - The notes ref to look under
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<Array<{target: string, note: string}>>} Resolves successfully with an array of entries containing SHA-1 object ids of the note and the object the note targets
 */

async function listNotes({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref = 'refs/notes/commits',
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);

    return await _listNotes({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref,
    })
  } catch (err) {
    err.caller = 'git.listNotes';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 *
 * @returns {Promise<Array<{remote: string, url: string}>>}
 */
async function _listRemotes({ fs, gitdir }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  const remoteNames = await config.getSubsections('remote');
  const remotes = Promise.all(
    remoteNames.map(async remote => {
      const url = await config.get(`remote.${remote}.url`);
      return { remote, url }
    })
  );
  return remotes
}

// @ts-check

/**
 * List remotes
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 *
 * @returns {Promise<Array<{remote: string, url: string}>>} Resolves successfully with an array of `{remote, url}` objects
 *
 * @example
 * let remotes = await git.listRemotes({ fs, dir: '/tutorial' })
 * console.log(remotes)
 *
 */
async function listRemotes({ fs, dir, gitdir = join(dir, '.git') }) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);

    return await _listRemotes({
      fs: new FileSystem(fs),
      gitdir,
    })
  } catch (err) {
    err.caller = 'git.listRemotes';
    throw err
  }
}

/**
 * @typedef {Object} ServerRef - This object has the following schema:
 * @property {string} ref - The name of the ref
 * @property {string} oid - The SHA-1 object id the ref points to
 * @property {string} [target] - The target ref pointed to by a symbolic ref
 * @property {string} [peeled] - If the oid is the SHA-1 object id of an annotated tag, this is the SHA-1 object id that the annotated tag points to
 */

async function parseListRefsResponse(stream) {
  const read = GitPktLine.streamReader(stream);

  // TODO: when we re-write everything to minimize memory usage,
  // we could make this a generator
  const refs = [];

  let line;
  while (true) {
    line = await read();
    if (line === true) break
    if (line === null) continue
    line = line.toString('utf8').replace(/\n$/, '');
    const [oid, ref, ...attrs] = line.split(' ');
    const r = { ref, oid };
    for (const attr of attrs) {
      const [name, value] = attr.split(':');
      if (name === 'symref-target') {
        r.target = value;
      } else if (name === 'peeled') {
        r.peeled = value;
      }
    }
    refs.push(r);
  }

  return refs
}

/**
 * @param {object} args
 * @param {string} [args.prefix] - Only list refs that start with this prefix
 * @param {boolean} [args.symrefs = false] - Include symbolic ref targets
 * @param {boolean} [args.peelTags = false] - Include peeled tags values
 * @returns {Uint8Array[]}
 */
async function writeListRefsRequest({ prefix, symrefs, peelTags }) {
  const packstream = [];
  // command
  packstream.push(GitPktLine.encode('command=ls-refs\n'));
  // capability-list
  packstream.push(GitPktLine.encode(`agent=${pkg.agent}\n`));
  // [command-args]
  if (peelTags || symrefs || prefix) {
    packstream.push(GitPktLine.delim());
  }
  if (peelTags) packstream.push(GitPktLine.encode('peel'));
  if (symrefs) packstream.push(GitPktLine.encode('symrefs'));
  if (prefix) packstream.push(GitPktLine.encode(`ref-prefix ${prefix}`));
  packstream.push(GitPktLine.flush());
  return packstream
}

// @ts-check

/**
 * Fetch a list of refs (branches, tags, etc) from a server.
 *
 * This is a rare command that doesn't require an `fs`, `dir`, or even `gitdir` argument.
 * It just requires an `http` argument.
 *
 * ### About `protocolVersion`
 *
 * There's a rather fun trade-off between Git Protocol Version 1 and Git Protocol Version 2.
 * Version 2 actually requires 2 HTTP requests instead of 1, making it similar to fetch or push in that regard.
 * However, version 2 supports server-side filtering by prefix, whereas that filtering is done client-side in version 1.
 * Which protocol is most efficient therefore depends on the number of refs on the remote, the latency of the server, and speed of the network connection.
 * For an small repos (or fast Internet connections), the requirement to make two trips to the server makes protocol 2 slower.
 * But for large repos (or slow Internet connections), the decreased payload size of the second request makes up for the additional request.
 *
 * Hard numbers vary by situation, but here's some numbers from my machine:
 *
 * Using isomorphic-git in a browser, with a CORS proxy, listing only the branches (refs/heads) of https://github.com/isomorphic-git/isomorphic-git
 * - Protocol Version 1 took ~300ms and transfered 84 KB.
 * - Protocol Version 2 took ~500ms and transfered 4.1 KB.
 *
 * Using isomorphic-git in a browser, with a CORS proxy, listing only the branches (refs/heads) of https://gitlab.com/gitlab-org/gitlab
 * - Protocol Version 1 took ~4900ms and transfered 9.41 MB.
 * - Protocol Version 2 took ~1280ms and transfered 433 KB.
 *
 * Finally, there is a fun quirk regarding the `symrefs` parameter.
 * Protocol Version 1 will generally only return the `HEAD` symref and not others.
 * Historically, this meant that servers don't use symbolic refs except for `HEAD`, which is used to point at the "default branch".
 * However Protocol Version 2 can return *all* the symbolic refs on the server.
 * So if you are running your own git server, you could take advantage of that I guess.
 *
 * #### TL;DR
 * If you are _not_ taking advantage of `prefix` I would recommend `protocolVersion: 1`.
 * Otherwise, I recommend to use the default which is `protocolVersion: 2`.
 *
 * @param {object} args
 * @param {HttpClient} args.http - an HTTP client
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} args.url - The URL of the remote repository. Will be gotten from gitconfig if absent.
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.
 * @param {boolean} [args.forPush = false] - By default, the command queries the 'fetch' capabilities. If true, it will ask for the 'push' capabilities.
 * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 * @param {1 | 2} [args.protocolVersion = 2] - Which version of the Git Protocol to use.
 * @param {string} [args.prefix] - Only list refs that start with this prefix
 * @param {boolean} [args.symrefs = false] - Include symbolic ref targets
 * @param {boolean} [args.peelTags = false] - Include annotated tag peeled targets
 *
 * @returns {Promise<ServerRef[]>} Resolves successfully with an array of ServerRef objects
 * @see ServerRef
 *
 * @example
 * // List all the branches on a repo
 * let refs = await git.listServerRefs({
 *   http,
 *   corsProxy: "https://cors.isomorphic-git.org",
 *   url: "https://github.com/isomorphic-git/isomorphic-git.git",
 *   prefix: "refs/heads/",
 * });
 * console.log(refs);
 *
 * @example
 * // Get the default branch on a repo
 * let refs = await git.listServerRefs({
 *   http,
 *   corsProxy: "https://cors.isomorphic-git.org",
 *   url: "https://github.com/isomorphic-git/isomorphic-git.git",
 *   prefix: "HEAD",
 *   symrefs: true,
 * });
 * console.log(refs);
 *
 * @example
 * // List all the tags on a repo
 * let refs = await git.listServerRefs({
 *   http,
 *   corsProxy: "https://cors.isomorphic-git.org",
 *   url: "https://github.com/isomorphic-git/isomorphic-git.git",
 *   prefix: "refs/tags/",
 *   peelTags: true,
 * });
 * console.log(refs);
 *
 * @example
 * // List all the pull requests on a repo
 * let refs = await git.listServerRefs({
 *   http,
 *   corsProxy: "https://cors.isomorphic-git.org",
 *   url: "https://github.com/isomorphic-git/isomorphic-git.git",
 *   prefix: "refs/pull/",
 * });
 * console.log(refs);
 *
 */
async function listServerRefs({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
  protocolVersion = 2,
  prefix,
  symrefs,
  peelTags,
}) {
  try {
    assertParameter('http', http);
    assertParameter('url', url);

    const remote = await GitRemoteHTTP.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? 'git-receive-pack' : 'git-upload-pack',
      url,
      headers,
      protocolVersion,
    });

    if (remote.protocolVersion === 1) {
      return formatInfoRefs(remote, prefix, symrefs, peelTags)
    }

    // Protocol Version 2
    const body = await writeListRefsRequest({ prefix, symrefs, peelTags });

    const res = await GitRemoteHTTP.connect({
      http,
      auth: remote.auth,
      headers,
      corsProxy,
      service: forPush ? 'git-receive-pack' : 'git-upload-pack',
      url,
      body,
    });

    return parseListRefsResponse(res.body)
  } catch (err) {
    err.caller = 'git.listServerRefs';
    throw err
  }
}

// @ts-check

/**
 * List tags
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 *
 * @returns {Promise<Array<string>>} Resolves successfully with an array of tag names
 *
 * @example
 * let tags = await git.listTags({ fs, dir: '/tutorial' })
 * console.log(tags)
 *
 */
async function listTags({ fs, dir, gitdir = join(dir, '.git') }) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    return GitRefManager.listTags({ fs: new FileSystem(fs), gitdir })
  } catch (err) {
    err.caller = 'git.listTags';
    throw err
  }
}

async function resolveCommit({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  // Resolve annotated tag objects to whatever
  if (type === 'tag') {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveCommit({ fs, cache, gitdir, oid })
  }
  if (type !== 'commit') {
    throw new ObjectTypeError(oid, type, 'commit')
  }
  return { commit: GitCommit.from(object), oid }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.oid
 *
 * @returns {Promise<ReadCommitResult>} Resolves successfully with a git commit object
 * @see ReadCommitResult
 * @see CommitObject
 *
 */
async function _readCommit({ fs, cache, gitdir, oid }) {
  const { commit, oid: commitOid } = await resolveCommit({
    fs,
    cache,
    gitdir,
    oid,
  });
  const result = {
    oid: commitOid,
    commit: commit.parse(),
    payload: commit.withoutSignature(),
  };
  // @ts-ignore
  return result
}

function compareAge(a, b) {
  return a.committer.timestamp - b.committer.timestamp
}

// @ts-check

// the empty file content object id
const EMPTY_OID = 'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391';

async function resolveFileIdInTree({ fs, cache, gitdir, oid, fileId }) {
  if (fileId === EMPTY_OID) return
  const _oid = oid;
  let filepath;
  const result = await resolveTree({ fs, cache, gitdir, oid });
  const tree = result.tree;
  if (fileId === result.oid) {
    filepath = result.path;
  } else {
    filepath = await _resolveFileId({
      fs,
      cache,
      gitdir,
      tree,
      fileId,
      oid: _oid,
    });
    if (Array.isArray(filepath)) {
      if (filepath.length === 0) filepath = undefined;
      else if (filepath.length === 1) filepath = filepath[0];
    }
  }
  return filepath
}

async function _resolveFileId({
  fs,
  cache,
  gitdir,
  tree,
  fileId,
  oid,
  filepaths = [],
  parentPath = '',
}) {
  const walks = tree.entries().map(function(entry) {
    let result;
    if (entry.oid === fileId) {
      result = join(parentPath, entry.path);
      filepaths.push(result);
    } else if (entry.type === 'tree') {
      result = _readObject({
        fs,
        cache,
        gitdir,
        oid: entry.oid,
      }).then(function({ object }) {
        return _resolveFileId({
          fs,
          cache,
          gitdir,
          tree: GitTree.from(object),
          fileId,
          oid,
          filepaths,
          parentPath: join(parentPath, entry.path),
        })
      });
    }
    return result
  });

  await Promise.all(walks);
  return filepaths
}

// @ts-check

/**
 * Get commit descriptions from the git history
 *
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string=} args.filepath optional get the commit for the filepath only
 * @param {string} args.ref
 * @param {number|void} args.depth
 * @param {boolean=} [args.force=false] do not throw error if filepath is not exist (works only for a single file). defaults to false
 * @param {boolean=} [args.follow=false] Continue listing the history of a file beyond renames (works only for a single file). defaults to false
 * @param {boolean=} args.follow Continue listing the history of a file beyond renames (works only for a single file). defaults to false
 *
 * @returns {Promise<Array<ReadCommitResult>>} Resolves to an array of ReadCommitResult objects
 * @see ReadCommitResult
 * @see CommitObject
 *
 * @example
 * let commits = await git.log({ dir: '$input((/))', depth: $input((5)), ref: '$input((master))' })
 * console.log(commits)
 *
 */
async function _log({
  fs,
  cache,
  gitdir,
  filepath,
  ref,
  depth,
  since,
  force,
  follow,
}) {
  const sinceTimestamp =
    typeof since === 'undefined'
      ? undefined
      : Math.floor(since.valueOf() / 1000);
  // TODO: In the future, we may want to have an API where we return a
  // async iterator that emits commits.
  const commits = [];
  const shallowCommits = await GitShallowManager.read({ fs, gitdir });
  const oid = await GitRefManager.resolve({ fs, gitdir, ref });
  const tips = [await _readCommit({ fs, cache, gitdir, oid })];
  let lastFileOid;
  let lastCommit;
  let isOk;

  function endCommit(commit) {
    if (isOk && filepath) commits.push(commit);
  }

  while (tips.length > 0) {
    const commit = tips.pop();

    // Stop the log if we've hit the age limit
    if (
      sinceTimestamp !== undefined &&
      commit.commit.committer.timestamp <= sinceTimestamp
    ) {
      break
    }

    if (filepath) {
      let vFileOid;
      try {
        vFileOid = await resolveFilepath({
          fs,
          cache,
          gitdir,
          oid: commit.commit.tree,
          filepath,
        });
        if (lastCommit && lastFileOid !== vFileOid) {
          commits.push(lastCommit);
        }
        lastFileOid = vFileOid;
        lastCommit = commit;
        isOk = true;
      } catch (e) {
        if (e instanceof NotFoundError) {
          let found = follow && lastFileOid;
          if (found) {
            found = await resolveFileIdInTree({
              fs,
              cache,
              gitdir,
              oid: commit.commit.tree,
              fileId: lastFileOid,
            });
            if (found) {
              if (Array.isArray(found)) {
                if (lastCommit) {
                  const lastFound = await resolveFileIdInTree({
                    fs,
                    cache,
                    gitdir,
                    oid: lastCommit.commit.tree,
                    fileId: lastFileOid,
                  });
                  if (Array.isArray(lastFound)) {
                    found = found.filter(p => lastFound.indexOf(p) === -1);
                    if (found.length === 1) {
                      found = found[0];
                      filepath = found;
                      if (lastCommit) commits.push(lastCommit);
                    } else {
                      found = false;
                      if (lastCommit) commits.push(lastCommit);
                      break
                    }
                  }
                }
              } else {
                filepath = found;
                if (lastCommit) commits.push(lastCommit);
              }
            }
          }
          if (!found) {
            if (!force && !follow) throw e
            if (isOk && lastFileOid) {
              commits.push(lastCommit);
              // break
            }
          }
          lastCommit = commit;
          isOk = false;
        } else throw e
      }
    } else {
      commits.push(commit);
    }

    // Stop the loop if we have enough commits now.
    if (depth !== undefined && commits.length === depth) {
      endCommit(commit);
      break
    }

    // If this is not a shallow commit...
    if (!shallowCommits.has(commit.oid)) {
      // Add the parents of this commit to the queue
      // Note: for the case of a commit with no parents, it will concat an empty array, having no net effect.
      for (const oid of commit.commit.parent) {
        const commit = await _readCommit({ fs, cache, gitdir, oid });
        if (!tips.map(commit => commit.oid).includes(commit.oid)) {
          tips.push(commit);
        }
      }
    }

    // Stop the loop if there are no more commit parents
    if (tips.length === 0) {
      endCommit(commit);
    }

    // Process tips in order by age
    tips.sort((a, b) => compareAge(a.commit, b.commit));
  }
  return commits
}

// @ts-check

/**
 * Get commit descriptions from the git history
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string=} args.filepath optional get the commit for the filepath only
 * @param {string} [args.ref = 'HEAD'] - The commit to begin walking backwards through the history from
 * @param {number=} [args.depth] - Limit the number of commits returned. No limit by default.
 * @param {Date} [args.since] - Return history newer than the given date. Can be combined with `depth` to get whichever is shorter.
 * @param {boolean=} [args.force=false] do not throw error if filepath is not exist (works only for a single file). defaults to false
 * @param {boolean=} [args.follow=false] Continue listing the history of a file beyond renames (works only for a single file). defaults to false
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<Array<ReadCommitResult>>} Resolves to an array of ReadCommitResult objects
 * @see ReadCommitResult
 * @see CommitObject
 *
 * @example
 * let commits = await git.log({
 *   fs,
 *   dir: '/tutorial',
 *   depth: 5,
 *   ref: 'main'
 * })
 * console.log(commits)
 *
 */
async function log({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  filepath,
  ref = 'HEAD',
  depth,
  since, // Date
  force,
  follow,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);

    return await _log({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      filepath,
      ref,
      depth,
      since,
      force,
      follow,
    })
  } catch (err) {
    err.caller = 'git.log';
    throw err
  }
}

// @ts-check

/**
 *
 * @typedef {Object} MergeResult - Returns an object with a schema like this:
 * @property {string} [oid] - The SHA-1 object id that is now at the head of the branch. Absent only if `dryRun` was specified and `mergeCommit` is true.
 * @property {boolean} [alreadyMerged] - True if the branch was already merged so no changes were made
 * @property {boolean} [fastForward] - True if it was a fast-forward merge
 * @property {boolean} [mergeCommit] - True if merge resulted in a merge commit
 * @property {string} [tree] - The SHA-1 object id of the tree resulting from a merge commit
 *
 */

/**
 * Merge two branches
 *
 * ## Limitations
 *
 * Currently it does not support incomplete merges. That is, if there are merge conflicts it cannot solve
 * with the built in diff3 algorithm it will not modify the working dir, and will throw a [`MergeNotSupportedError`](./errors.md#mergenotsupportedError) error.
 *
 * Currently it will fail if multiple candidate merge bases are found. (It doesn't yet implement the recursive merge strategy.)
 *
 * Currently it does not support selecting alternative merge strategies.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {SignCallback} [args.onSign] - a PGP signing implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ours] - The branch receiving the merge. If undefined, defaults to the current branch.
 * @param {string} args.theirs - The branch to be merged
 * @param {boolean} [args.fastForwardOnly = false] - If true, then non-fast-forward merges will throw an Error instead of performing a merge.
 * @param {boolean} [args.dryRun = false] - If true, simulates a merge so you can test whether it would succeed.
 * @param {boolean} [args.noUpdateBranch = false] - If true, does not update the branch pointer after creating the commit.
 * @param {string} [args.message] - Overrides the default auto-generated merge commit message
 * @param {Object} [args.author] - passed to [commit](commit.md) when creating a merge commit
 * @param {string} [args.author.name] - Default is `user.name` config.
 * @param {string} [args.author.email] - Default is `user.email` config.
 * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {Object} [args.committer] - passed to [commit](commit.md) when creating a merge commit
 * @param {string} [args.committer.name] - Default is `user.name` config.
 * @param {string} [args.committer.email] - Default is `user.email` config.
 * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {string} [args.signingKey] - passed to [commit](commit.md) when creating a merge commit
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<MergeResult>} Resolves to a description of the merge operation
 * @see MergeResult
 *
 * @example
 * let m = await git.merge({
 *   fs,
 *   dir: '/tutorial',
 *   ours: 'main',
 *   theirs: 'remotes/origin/main'
 * })
 * console.log(m)
 *
 */
async function merge({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, '.git'),
  ours,
  theirs,
  fastForwardOnly = false,
  dryRun = false,
  noUpdateBranch = false,
  message,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    if (signingKey) {
      assertParameter('onSign', onSign);
    }
    const fs = new FileSystem(_fs);

    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author && !fastForwardOnly) throw new MissingNameError('author')

    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer && !fastForwardOnly) {
      throw new MissingNameError('committer')
    }

    return await _merge({
      fs,
      cache,
      gitdir,
      ours,
      theirs,
      fastForwardOnly,
      dryRun,
      noUpdateBranch,
      message,
      author,
      committer,
      signingKey,
      onSign,
    })
  } catch (err) {
    err.caller = 'git.merge';
    throw err
  }
}

/**
 * @enum {number}
 */
const types = {
  commit: 0b0010000,
  tree: 0b0100000,
  blob: 0b0110000,
  tag: 0b1000000,
  ofs_delta: 0b1100000,
  ref_delta: 0b1110000,
};

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string[]} args.oids
 */
async function _pack({
  fs,
  cache,
  dir,
  gitdir = join(dir, '.git'),
  oids,
}) {
  const hash = new sha_js_sha1_js__WEBPACK_IMPORTED_MODULE_1__();
  const outputStream = [];
  function write(chunk, enc) {
    const buff = Buffer.from(chunk, enc);
    outputStream.push(buff);
    hash.update(buff);
  }
  async function writeObject({ stype, object }) {
    // Object type is encoded in bits 654
    const type = types[stype];
    // The length encoding gets complicated.
    let length = object.length;
    // Whether the next byte is part of the variable-length encoded number
    // is encoded in bit 7
    let multibyte = length > 0b1111 ? 0b10000000 : 0b0;
    // Last four bits of length is encoded in bits 3210
    const lastFour = length & 0b1111;
    // Discard those bits
    length = length >>> 4;
    // The first byte is then (1-bit multibyte?), (3-bit type), (4-bit least sig 4-bits of length)
    let byte = (multibyte | type | lastFour).toString(16);
    write(byte, 'hex');
    // Now we keep chopping away at length 7-bits at a time until its zero,
    // writing out the bytes in what amounts to little-endian order.
    while (multibyte) {
      multibyte = length > 0b01111111 ? 0b10000000 : 0b0;
      byte = multibyte | (length & 0b01111111);
      write(padHex(2, byte), 'hex');
      length = length >>> 7;
    }
    // Lastly, we can compress and write the object.
    write(Buffer.from(await deflate(object)));
  }
  write('PACK');
  write('00000002', 'hex');
  // Write a 4 byte (32-bit) int
  write(padHex(8, oids.length), 'hex');
  for (const oid of oids) {
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    await writeObject({ write, object, stype: type });
  }
  // Write SHA1 checksum
  const digest = hash.digest();
  outputStream.push(digest);
  return outputStream
}

// @ts-check

/**
 *
 * @typedef {Object} PackObjectsResult The packObjects command returns an object with two properties:
 * @property {string} filename - The suggested filename for the packfile if you want to save it to disk somewhere. It includes the packfile SHA.
 * @property {Uint8Array} [packfile] - The packfile contents. Not present if `write` parameter was true, in which case the packfile was written straight to disk.
 */

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string[]} args.oids
 * @param {boolean} args.write
 *
 * @returns {Promise<PackObjectsResult>}
 * @see PackObjectsResult
 */
async function _packObjects({ fs, cache, gitdir, oids, write }) {
  const buffers = await _pack({ fs, cache, gitdir, oids });
  const packfile = Buffer.from(await collect(buffers));
  const packfileSha = packfile.slice(-20).toString('hex');
  const filename = `pack-${packfileSha}.pack`;
  if (write) {
    await fs.write(join(gitdir, `objects/pack/${filename}`), packfile);
    return { filename }
  }
  return {
    filename,
    packfile: new Uint8Array(packfile),
  }
}

// @ts-check

/**
 *
 * @typedef {Object} PackObjectsResult The packObjects command returns an object with two properties:
 * @property {string} filename - The suggested filename for the packfile if you want to save it to disk somewhere. It includes the packfile SHA.
 * @property {Uint8Array} [packfile] - The packfile contents. Not present if `write` parameter was true, in which case the packfile was written straight to disk.
 */

/**
 * Create a packfile from an array of SHA-1 object ids
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string[]} args.oids - An array of SHA-1 object ids to be included in the packfile
 * @param {boolean} [args.write = false] - Whether to save the packfile to disk or not
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<PackObjectsResult>} Resolves successfully when the packfile is ready with the filename and buffer
 * @see PackObjectsResult
 *
 * @example
 * // Create a packfile containing only an empty tree
 * let { packfile } = await git.packObjects({
 *   fs,
 *   dir: '/tutorial',
 *   oids: ['4b825dc642cb6eb9a060e54bf8d69288fbee4904']
 * })
 * console.log(packfile)
 *
 */
async function packObjects({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oids,
  write = false,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oids', oids);

    return await _packObjects({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oids,
      write,
    })
  } catch (err) {
    err.caller = 'git.packObjects';
    throw err
  }
}

// @ts-check

/**
 * Fetch and merge commits from a remote repository
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {HttpClient} args.http - an HTTP client
 * @param {ProgressCallback} [args.onProgress] - optional progress event callback
 * @param {MessageCallback} [args.onMessage] - optional message event callback
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - Which branch to merge into. By default this is the currently checked out branch.
 * @param {string} [args.url] - (Added in 1.1.0) The URL of the remote repository. The default is the value set in the git config for that remote.
 * @param {string} [args.remote] - (Added in 1.1.0) If URL is not specified, determines which remote to use.
 * @param {string} [args.remoteRef] - (Added in 1.1.0) The name of the branch on the remote to fetch. By default this is the configured remote tracking branch.
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.
 * @param {boolean} [args.singleBranch = false] - Instead of the default behavior of fetching all the branches, only fetch a single branch.
 * @param {boolean} [args.fastForwardOnly = false] - Only perform simple fast-forward merges. (Don't create merge commits.)
 * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 * @param {Object} [args.author] - The details about the author.
 * @param {string} [args.author.name] - Default is `user.name` config.
 * @param {string} [args.author.email] - Default is `user.email` config.
 * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {Object} [args.committer = author] - The details about the commit committer, in the same format as the author parameter. If not specified, the author details are used.
 * @param {string} [args.committer.name] - Default is `user.name` config.
 * @param {string} [args.committer.email] - Default is `user.email` config.
 * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {string} [args.signingKey] - passed to [commit](commit.md) when creating a merge commit
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully when pull operation completes
 *
 * @example
 * await git.pull({
 *   fs,
 *   http,
 *   dir: '/tutorial',
 *   ref: 'main',
 *   singleBranch: true
 * })
 * console.log('done')
 *
 */
async function pull({
  fs: _fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  url,
  remote,
  remoteRef,
  fastForwardOnly = false,
  corsProxy,
  singleBranch,
  headers = {},
  author: _author,
  committer: _committer,
  signingKey,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);

    const fs = new FileSystem(_fs);

    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author) throw new MissingNameError('author')

    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer) throw new MissingNameError('committer')

    return await _pull({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      ref,
      url,
      remote,
      remoteRef,
      fastForwardOnly,
      corsProxy,
      singleBranch,
      headers,
      author,
      committer,
      signingKey,
    })
  } catch (err) {
    err.caller = 'git.pull';
    throw err
  }
}

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} [args.dir]
 * @param {string} args.gitdir
 * @param {Iterable<string>} args.start
 * @param {Iterable<string>} args.finish
 * @returns {Promise<Set<string>>}
 */
async function listCommitsAndTags({
  fs,
  cache,
  dir,
  gitdir = join(dir, '.git'),
  start,
  finish,
}) {
  const shallows = await GitShallowManager.read({ fs, gitdir });
  const startingSet = new Set();
  const finishingSet = new Set();
  for (const ref of start) {
    startingSet.add(await GitRefManager.resolve({ fs, gitdir, ref }));
  }
  for (const ref of finish) {
    // We may not have these refs locally so we must try/catch
    try {
      const oid = await GitRefManager.resolve({ fs, gitdir, ref });
      finishingSet.add(oid);
    } catch (err) {}
  }
  const visited = new Set();
  // Because git commits are named by their hash, there is no
  // way to construct a cycle. Therefore we won't worry about
  // setting a default recursion limit.
  async function walk(oid) {
    visited.add(oid);
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    // Recursively resolve annotated tags
    if (type === 'tag') {
      const tag = GitAnnotatedTag.from(object);
      const commit = tag.headers().object;
      return walk(commit)
    }
    if (type !== 'commit') {
      throw new ObjectTypeError(oid, type, 'commit')
    }
    if (!shallows.has(oid)) {
      const commit = GitCommit.from(object);
      const parents = commit.headers().parent;
      for (oid of parents) {
        if (!finishingSet.has(oid) && !visited.has(oid)) {
          await walk(oid);
        }
      }
    }
  }
  // Let's go walking!
  for (const oid of startingSet) {
    await walk(oid);
  }
  return visited
}

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} [args.dir]
 * @param {string} args.gitdir
 * @param {Iterable<string>} args.oids
 * @returns {Promise<Set<string>>}
 */
async function listObjects({
  fs,
  cache,
  dir,
  gitdir = join(dir, '.git'),
  oids,
}) {
  const visited = new Set();
  // We don't do the purest simplest recursion, because we can
  // avoid reading Blob objects entirely since the Tree objects
  // tell us which oids are Blobs and which are Trees.
  async function walk(oid) {
    if (visited.has(oid)) return
    visited.add(oid);
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    if (type === 'tag') {
      const tag = GitAnnotatedTag.from(object);
      const obj = tag.headers().object;
      await walk(obj);
    } else if (type === 'commit') {
      const commit = GitCommit.from(object);
      const tree = commit.headers().tree;
      await walk(tree);
    } else if (type === 'tree') {
      const tree = GitTree.from(object);
      for (const entry of tree) {
        // add blobs to the set
        // skip over submodules whose type is 'commit'
        if (entry.type === 'blob') {
          visited.add(entry.oid);
        }
        // recurse for trees
        if (entry.type === 'tree') {
          await walk(entry.oid);
        }
      }
    }
  }
  // Let's go walking!
  for (const oid of oids) {
    await walk(oid);
  }
  return visited
}

async function parseReceivePackResponse(packfile) {
  /** @type PushResult */
  const result = {};
  let response = '';
  const read = GitPktLine.streamReader(packfile);
  let line = await read();
  while (line !== true) {
    if (line !== null) response += line.toString('utf8') + '\n';
    line = await read();
  }

  const lines = response.toString('utf8').split('\n');
  // We're expecting "unpack {unpack-result}"
  line = lines.shift();
  if (!line.startsWith('unpack ')) {
    throw new ParseError('unpack ok" or "unpack [error message]', line)
  }
  result.ok = line === 'unpack ok';
  if (!result.ok) {
    result.error = line.slice('unpack '.length);
  }
  result.refs = {};
  for (const line of lines) {
    if (line.trim() === '') continue
    const status = line.slice(0, 2);
    const refAndMessage = line.slice(3);
    let space = refAndMessage.indexOf(' ');
    if (space === -1) space = refAndMessage.length;
    const ref = refAndMessage.slice(0, space);
    const error = refAndMessage.slice(space + 1);
    result.refs[ref] = {
      ok: status === 'ok',
      error,
    };
  }
  return result
}

async function writeReceivePackRequest({
  capabilities = [],
  triplets = [],
}) {
  const packstream = [];
  let capsFirstLine = `\x00 ${capabilities.join(' ')}`;
  for (const trip of triplets) {
    packstream.push(
      GitPktLine.encode(
        `${trip.oldoid} ${trip.oid} ${trip.fullRef}${capsFirstLine}\n`
      )
    );
    capsFirstLine = '';
  }
  packstream.push(GitPktLine.flush());
  return packstream
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {HttpClient} args.http
 * @param {ProgressCallback} [args.onProgress]
 * @param {MessageCallback} [args.onMessage]
 * @param {AuthCallback} [args.onAuth]
 * @param {AuthFailureCallback} [args.onAuthFailure]
 * @param {AuthSuccessCallback} [args.onAuthSuccess]
 * @param {string} args.gitdir
 * @param {string} [args.ref]
 * @param {string} [args.remoteRef]
 * @param {string} [args.remote]
 * @param {boolean} [args.force = false]
 * @param {boolean} [args.delete = false]
 * @param {string} [args.url]
 * @param {string} [args.corsProxy]
 * @param {Object<string, string>} [args.headers]
 *
 * @returns {Promise<PushResult>}
 */
async function _push({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  gitdir,
  ref: _ref,
  remoteRef: _remoteRef,
  remote,
  url: _url,
  force = false,
  delete: _delete = false,
  corsProxy,
  headers = {},
}) {
  const ref = _ref || (await _currentBranch({ fs, gitdir }));
  if (typeof ref === 'undefined') {
    throw new MissingParameterError('ref')
  }
  const config = await GitConfigManager.get({ fs, gitdir });
  // Figure out what remote to use.
  remote =
    remote ||
    (await config.get(`branch.${ref}.pushRemote`)) ||
    (await config.get('remote.pushDefault')) ||
    (await config.get(`branch.${ref}.remote`)) ||
    'origin';
  // Lookup the URL for the given remote.
  const url =
    _url ||
    (await config.get(`remote.${remote}.pushurl`)) ||
    (await config.get(`remote.${remote}.url`));
  if (typeof url === 'undefined') {
    throw new MissingParameterError('remote OR url')
  }
  // Figure out what remote ref to use.
  const remoteRef = _remoteRef || (await config.get(`branch.${ref}.merge`));
  if (typeof url === 'undefined') {
    throw new MissingParameterError('remoteRef')
  }

  if (corsProxy === undefined) {
    corsProxy = await config.get('http.corsProxy');
  }

  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
  const oid = _delete
    ? '0000000000000000000000000000000000000000'
    : await GitRefManager.resolve({ fs, gitdir, ref: fullRef });

  /** @type typeof import("../managers/GitRemoteHTTP").GitRemoteHTTP */
  const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });
  const httpRemote = await GitRemoteHTTP.discover({
    http,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service: 'git-receive-pack',
    url,
    headers,
    protocolVersion: 1,
  });
  const auth = httpRemote.auth; // hack to get new credentials from CredentialManager API
  let fullRemoteRef;
  if (!remoteRef) {
    fullRemoteRef = fullRef;
  } else {
    try {
      fullRemoteRef = await GitRefManager.expandAgainstMap({
        ref: remoteRef,
        map: httpRemote.refs,
      });
    } catch (err) {
      if (err instanceof NotFoundError) {
        // The remote reference doesn't exist yet.
        // If it is fully specified, use that value. Otherwise, treat it as a branch.
        fullRemoteRef = remoteRef.startsWith('refs/')
          ? remoteRef
          : `refs/heads/${remoteRef}`;
      } else {
        throw err
      }
    }
  }
  const oldoid =
    httpRemote.refs.get(fullRemoteRef) ||
    '0000000000000000000000000000000000000000';

  // Remotes can always accept thin-packs UNLESS they specify the 'no-thin' capability
  const thinPack = !httpRemote.capabilities.has('no-thin');

  let objects = new Set();
  if (!_delete) {
    const finish = [...httpRemote.refs.values()];
    let skipObjects = new Set();

    // If remote branch is present, look for a common merge base.
    if (oldoid !== '0000000000000000000000000000000000000000') {
      // trick to speed up common force push scenarios
      const mergebase = await _findMergeBase({
        fs,
        cache,
        gitdir,
        oids: [oid, oldoid],
      });
      for (const oid of mergebase) finish.push(oid);
      if (thinPack) {
        skipObjects = await listObjects({ fs, cache, gitdir, oids: mergebase });
      }
    }

    // If remote does not have the commit, figure out the objects to send
    if (!finish.includes(oid)) {
      const commits = await listCommitsAndTags({
        fs,
        cache,
        gitdir,
        start: [oid],
        finish,
      });
      objects = await listObjects({ fs, cache, gitdir, oids: commits });
    }

    if (thinPack) {
      // If there's a default branch for the remote lets skip those objects too.
      // Since this is an optional optimization, we just catch and continue if there is
      // an error (because we can't find a default branch, or can't find a commit, etc)
      try {
        // Sadly, the discovery phase with 'forPush' doesn't return symrefs, so we have to
        // rely on existing ones.
        const ref = await GitRefManager.resolve({
          fs,
          gitdir,
          ref: `refs/remotes/${remote}/HEAD`,
          depth: 2,
        });
        const { oid } = await GitRefManager.resolveAgainstMap({
          ref: ref.replace(`refs/remotes/${remote}/`, ''),
          fullref: ref,
          map: httpRemote.refs,
        });
        const oids = [oid];
        for (const oid of await listObjects({ fs, cache, gitdir, oids })) {
          skipObjects.add(oid);
        }
      } catch (e) {}

      // Remove objects that we know the remote already has
      for (const oid of skipObjects) {
        objects.delete(oid);
      }
    }

    if (!force) {
      // Is it a tag that already exists?
      if (
        fullRef.startsWith('refs/tags') &&
        oldoid !== '0000000000000000000000000000000000000000'
      ) {
        throw new PushRejectedError('tag-exists')
      }
      // Is it a non-fast-forward commit?
      if (
        oid !== '0000000000000000000000000000000000000000' &&
        oldoid !== '0000000000000000000000000000000000000000' &&
        !(await _isDescendent({
          fs,
          cache,
          gitdir,
          oid,
          ancestor: oldoid,
          depth: -1,
        }))
      ) {
        throw new PushRejectedError('not-fast-forward')
      }
    }
  }
  // We can only safely use capabilities that the server also understands.
  // For instance, AWS CodeCommit aborts a push if you include the `agent`!!!
  const capabilities = filterCapabilities(
    [...httpRemote.capabilities],
    ['report-status', 'side-band-64k', `agent=${pkg.agent}`]
  );
  const packstream1 = await writeReceivePackRequest({
    capabilities,
    triplets: [{ oldoid, oid, fullRef: fullRemoteRef }],
  });
  const packstream2 = _delete
    ? []
    : await _pack({
        fs,
        cache,
        gitdir,
        oids: [...objects],
      });
  const res = await GitRemoteHTTP.connect({
    http,
    onProgress,
    corsProxy,
    service: 'git-receive-pack',
    url,
    auth,
    headers,
    body: [...packstream1, ...packstream2],
  });
  const { packfile, progress } = await GitSideBand.demux(res.body);
  if (onMessage) {
    const lines = splitLines(progress);
    forAwait(lines, async line => {
      await onMessage(line);
    });
  }
  // Parse the response!
  const result = await parseReceivePackResponse(packfile);
  if (res.headers) {
    result.headers = res.headers;
  }

  // Update the local copy of the remote ref
  if (remote && result.ok && result.refs[fullRemoteRef].ok) {
    // TODO: I think this should actually be using a refspec transform rather than assuming 'refs/remotes/{remote}'
    const ref = `refs/remotes/${remote}/${fullRemoteRef.replace(
      'refs/heads',
      ''
    )}`;
    if (_delete) {
      await GitRefManager.deleteRef({ fs, gitdir, ref });
    } else {
      await GitRefManager.writeRef({ fs, gitdir, ref, value: oid });
    }
  }
  if (result.ok && Object.values(result.refs).every(result => result.ok)) {
    return result
  } else {
    const prettyDetails = Object.entries(result.refs)
      .filter(([k, v]) => !v.ok)
      .map(([k, v]) => `\n  - ${k}: ${v.error}`)
      .join('');
    throw new GitPushError(prettyDetails, result)
  }
}

// @ts-check

/**
 * Push a branch or tag
 *
 * The push command returns an object that describes the result of the attempted push operation.
 * *Notes:* If there were no errors, then there will be no `errors` property. There can be a mix of `ok` messages and `errors` messages.
 *
 * | param  | type [= default] | description                                                                                                                                                                                                      |
 * | ------ | ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
 * | ok     | Array\<string\>  | The first item is "unpack" if the overall operation was successful. The remaining items are the names of refs that were updated successfully.                                                                    |
 * | errors | Array\<string\>  | If the overall operation threw and error, the first item will be "unpack {Overall error message}". The remaining items are individual refs that failed to be updated in the format "{ref name} {error message}". |
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {HttpClient} args.http - an HTTP client
 * @param {ProgressCallback} [args.onProgress] - optional progress event callback
 * @param {MessageCallback} [args.onMessage] - optional message event callback
 * @param {AuthCallback} [args.onAuth] - optional auth fill callback
 * @param {AuthFailureCallback} [args.onAuthFailure] - optional auth rejected callback
 * @param {AuthSuccessCallback} [args.onAuthSuccess] - optional auth approved callback
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - Which branch to push. By default this is the currently checked out branch.
 * @param {string} [args.url] - The URL of the remote repository. The default is the value set in the git config for that remote.
 * @param {string} [args.remote] - If URL is not specified, determines which remote to use.
 * @param {string} [args.remoteRef] - The name of the receiving branch on the remote. By default this is the configured remote tracking branch.
 * @param {boolean} [args.force = false] - If true, behaves the same as `git push --force`
 * @param {boolean} [args.delete = false] - If true, delete the remote ref
 * @param {string} [args.corsProxy] - Optional [CORS proxy](https://www.npmjs.com/%40isomorphic-git/cors-proxy). Overrides value in repo config.
 * @param {Object<string, string>} [args.headers] - Additional headers to include in HTTP requests, similar to git's `extraHeader` config
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<PushResult>} Resolves successfully when push completes with a detailed description of the operation from the server.
 * @see PushResult
 * @see RefUpdateStatus
 *
 * @example
 * let pushResult = await git.push({
 *   fs,
 *   http,
 *   dir: '/tutorial',
 *   remote: 'origin',
 *   ref: 'main',
 *   onAuth: () => ({ username: process.env.GITHUB_TOKEN }),
 * })
 * console.log(pushResult)
 *
 */
async function push({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  remoteRef,
  remote = 'origin',
  url,
  force = false,
  delete: _delete = false,
  corsProxy,
  headers = {},
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('http', http);
    assertParameter('gitdir', gitdir);

    return await _push({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remoteRef,
      remote,
      url,
      force,
      delete: _delete,
      corsProxy,
      headers,
    })
  } catch (err) {
    err.caller = 'git.push';
    throw err
  }
}

async function resolveBlob({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  // Resolve annotated tag objects to whatever
  if (type === 'tag') {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveBlob({ fs, cache, gitdir, oid })
  }
  if (type !== 'blob') {
    throw new ObjectTypeError(oid, type, 'blob')
  }
  return { oid, blob: new Uint8Array(object) }
}

// @ts-check

/**
 *
 * @typedef {Object} ReadBlobResult - The object returned has the following schema:
 * @property {string} oid
 * @property {Uint8Array} blob
 *
 */

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.oid
 * @param {string} [args.filepath]
 *
 * @returns {Promise<ReadBlobResult>} Resolves successfully with a blob object description
 * @see ReadBlobResult
 */
async function _readBlob({
  fs,
  cache,
  gitdir,
  oid,
  filepath = undefined,
}) {
  if (filepath !== undefined) {
    oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });
  }
  const blob = await resolveBlob({
    fs,
    cache,
    gitdir,
    oid,
  });
  return blob
}

// @ts-check

/**
 *
 * @typedef {Object} ReadBlobResult - The object returned has the following schema:
 * @property {string} oid
 * @property {Uint8Array} blob
 *
 */

/**
 * Read a blob object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.oid - The SHA-1 object id to get. Annotated tags, commits, and trees are peeled.
 * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the blob object at that filepath.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<ReadBlobResult>} Resolves successfully with a blob object description
 * @see ReadBlobResult
 *
 * @example
 * // Get the contents of 'README.md' in the main branch.
 * let commitOid = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })
 * console.log(commitOid)
 * let { blob } = await git.readBlob({
 *   fs,
 *   dir: '/tutorial',
 *   oid: commitOid,
 *   filepath: 'README.md'
 * })
 * console.log(Buffer.from(blob).toString('utf8'))
 *
 */
async function readBlob({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oid,
  filepath,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);

    return await _readBlob({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      filepath,
    })
  } catch (err) {
    err.caller = 'git.readBlob';
    throw err
  }
}

// @ts-check

/**
 * Read a commit object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.oid - The SHA-1 object id to get. Annotated tags are peeled.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<ReadCommitResult>} Resolves successfully with a git commit object
 * @see ReadCommitResult
 * @see CommitObject
 *
 * @example
 * // Read a commit object
 * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'main' })
 * console.log(sha)
 * let commit = await git.readCommit({ fs, dir: '/tutorial', oid: sha })
 * console.log(commit)
 *
 */
async function readCommit({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oid,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);

    return await _readCommit({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
    })
  } catch (err) {
    err.caller = 'git.readCommit';
    throw err
  }
}

// @ts-check

/**
 * Read the contents of a note
 *
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} [args.ref] - The notes ref to look under
 * @param {string} args.oid
 *
 * @returns {Promise<Uint8Array>} Resolves successfully with note contents as a Buffer.
 */

async function _readNote({
  fs,
  cache,
  gitdir,
  ref = 'refs/notes/commits',
  oid,
}) {
  const parent = await GitRefManager.resolve({ gitdir, fs, ref });
  const { blob } = await _readBlob({
    fs,
    cache,
    gitdir,
    oid: parent,
    filepath: oid,
  });

  return blob
}

// @ts-check

/**
 * Read the contents of a note
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - The notes ref to look under
 * @param {string} args.oid - The SHA-1 object id of the object to get the note for.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<Uint8Array>} Resolves successfully with note contents as a Buffer.
 */

async function readNote({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref = 'refs/notes/commits',
  oid,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);
    assertParameter('oid', oid);

    return await _readNote({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref,
      oid,
    })
  } catch (err) {
    err.caller = 'git.readNote';
    throw err
  }
}

// @ts-check

/**
 *
 * @typedef {Object} DeflatedObject
 * @property {string} oid
 * @property {'deflated'} type
 * @property {'deflated'} format
 * @property {Uint8Array} object
 * @property {string} [source]
 *
 */

/**
 *
 * @typedef {Object} WrappedObject
 * @property {string} oid
 * @property {'wrapped'} type
 * @property {'wrapped'} format
 * @property {Uint8Array} object
 * @property {string} [source]
 *
 */

/**
 *
 * @typedef {Object} RawObject
 * @property {string} oid
 * @property {'blob'|'commit'|'tree'|'tag'} type
 * @property {'content'} format
 * @property {Uint8Array} object
 * @property {string} [source]
 *
 */

/**
 *
 * @typedef {Object} ParsedBlobObject
 * @property {string} oid
 * @property {'blob'} type
 * @property {'parsed'} format
 * @property {string} object
 * @property {string} [source]
 *
 */

/**
 *
 * @typedef {Object} ParsedCommitObject
 * @property {string} oid
 * @property {'commit'} type
 * @property {'parsed'} format
 * @property {CommitObject} object
 * @property {string} [source]
 *
 */

/**
 *
 * @typedef {Object} ParsedTreeObject
 * @property {string} oid
 * @property {'tree'} type
 * @property {'parsed'} format
 * @property {TreeObject} object
 * @property {string} [source]
 *
 */

/**
 *
 * @typedef {Object} ParsedTagObject
 * @property {string} oid
 * @property {'tag'} type
 * @property {'parsed'} format
 * @property {TagObject} object
 * @property {string} [source]
 *
 */

/**
 *
 * @typedef {ParsedBlobObject | ParsedCommitObject | ParsedTreeObject | ParsedTagObject} ParsedObject
 */

/**
 *
 * @typedef {DeflatedObject | WrappedObject | RawObject | ParsedObject } ReadObjectResult
 */

/**
 * Read a git object directly by its SHA-1 object id
 *
 * Regarding `ReadObjectResult`:
 *
 * - `oid` will be the same as the `oid` argument unless the `filepath` argument is provided, in which case it will be the oid of the tree or blob being returned.
 * - `type` of deflated objects is `'deflated'`, and `type` of wrapped objects is `'wrapped'`
 * - `format` is usually, but not always, the format you requested. Packfiles do not store each object individually compressed so if you end up reading the object from a packfile it will be returned in format 'content' even if you requested 'deflated' or 'wrapped'.
 * - `object` will be an actual Object if format is 'parsed' and the object is a commit, tree, or annotated tag. Blobs are still formatted as Buffers unless an encoding is provided in which case they'll be strings. If format is anything other than 'parsed', object will be a Buffer.
 * - `source` is the name of the packfile or loose object file where the object was found.
 *
 * The `format` parameter can have the following values:
 *
 * | param      | description                                                                                                                                                                                               |
 * | ---------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
 * | 'deflated' | Return the raw deflate-compressed buffer for an object if possible. Useful for efficiently shuffling around loose objects when you don't care about the contents and can save time by not inflating them. |
 * | 'wrapped'  | Return the inflated object buffer wrapped in the git object header if possible. This is the raw data used when calculating the SHA-1 object id of a git object.                                           |
 * | 'content'  | Return the object buffer without the git header.                                                                                                                                                          |
 * | 'parsed'   | Returns a parsed representation of the object.                                                                                                                                                            |
 *
 * The result will be in one of the following schemas:
 *
 * ## `'deflated'` format
 *
 * {@link DeflatedObject typedef}
 *
 * ## `'wrapped'` format
 *
 * {@link WrappedObject typedef}
 *
 * ## `'content'` format
 *
 * {@link RawObject typedef}
 *
 * ## `'parsed'` format
 *
 * ### parsed `'blob'` type
 *
 * {@link ParsedBlobObject typedef}
 *
 * ### parsed `'commit'` type
 *
 * {@link ParsedCommitObject typedef}
 * {@link CommitObject typedef}
 *
 * ### parsed `'tree'` type
 *
 * {@link ParsedTreeObject typedef}
 * {@link TreeObject typedef}
 * {@link TreeEntry typedef}
 *
 * ### parsed `'tag'` type
 *
 * {@link ParsedTagObject typedef}
 * {@link TagObject typedef}
 *
 * @deprecated
 * > This command is overly complicated.
 * >
 * > If you know the type of object you are reading, use [`readBlob`](./readBlob.md), [`readCommit`](./readCommit.md), [`readTag`](./readTag.md), or [`readTree`](./readTree.md).
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.oid - The SHA-1 object id to get
 * @param {'deflated' | 'wrapped' | 'content' | 'parsed'} [args.format = 'parsed'] - What format to return the object in. The choices are described in more detail below.
 * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the object at that filepath. To return the root directory of a tree set filepath to `''`
 * @param {string} [args.encoding] - A convenience argument that only affects blobs. Instead of returning `object` as a buffer, it returns a string parsed using the given encoding.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<ReadObjectResult>} Resolves successfully with a git object description
 * @see ReadObjectResult
 *
 * @example
 * // Given a ransom SHA-1 object id, figure out what it is
 * let { type, object } = await git.readObject({
 *   fs,
 *   dir: '/tutorial',
 *   oid: '0698a781a02264a6f37ba3ff41d78067eaf0f075'
 * })
 * switch (type) {
 *   case 'commit': {
 *     console.log(object)
 *     break
 *   }
 *   case 'tree': {
 *     console.log(object)
 *     break
 *   }
 *   case 'blob': {
 *     console.log(object)
 *     break
 *   }
 *   case 'tag': {
 *     console.log(object)
 *     break
 *   }
 * }
 *
 */
async function readObject({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  oid,
  format = 'parsed',
  filepath = undefined,
  encoding = undefined,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);

    const fs = new FileSystem(_fs);
    if (filepath !== undefined) {
      oid = await resolveFilepath({
        fs,
        cache,
        gitdir,
        oid,
        filepath,
      });
    }
    // GitObjectManager does not know how to parse content, so we tweak that parameter before passing it.
    const _format = format === 'parsed' ? 'content' : format;
    const result = await _readObject({
      fs,
      cache,
      gitdir,
      oid,
      format: _format,
    });
    result.oid = oid;
    if (format === 'parsed') {
      result.format = 'parsed';
      switch (result.type) {
        case 'commit':
          result.object = GitCommit.from(result.object).parse();
          break
        case 'tree':
          result.object = GitTree.from(result.object).entries();
          break
        case 'blob':
          // Here we consider returning a raw Buffer as the 'content' format
          // and returning a string as the 'parsed' format
          if (encoding) {
            result.object = result.object.toString(encoding);
          } else {
            result.object = new Uint8Array(result.object);
            result.format = 'content';
          }
          break
        case 'tag':
          result.object = GitAnnotatedTag.from(result.object).parse();
          break
        default:
          throw new ObjectTypeError(
            result.oid,
            result.type,
            'blob|commit|tag|tree'
          )
      }
    } else if (result.format === 'deflated' || result.format === 'wrapped') {
      result.type = result.format;
    }
    return result
  } catch (err) {
    err.caller = 'git.readObject';
    throw err
  }
}

// @ts-check

/**
 *
 * @typedef {Object} ReadTagResult - The object returned has the following schema:
 * @property {string} oid - SHA-1 object id of this tag
 * @property {TagObject} tag - the parsed tag object
 * @property {string} payload - PGP signing payload
 */

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {any} args.cache
 * @param {string} args.gitdir
 * @param {string} args.oid
 *
 * @returns {Promise<ReadTagResult>}
 */
async function _readTag({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({
    fs,
    cache,
    gitdir,
    oid,
    format: 'content',
  });
  if (type !== 'tag') {
    throw new ObjectTypeError(oid, type, 'tag')
  }
  const tag = GitAnnotatedTag.from(object);
  const result = {
    oid,
    tag: tag.parse(),
    payload: tag.payload(),
  };
  // @ts-ignore
  return result
}

/**
 *
 * @typedef {Object} ReadTagResult - The object returned has the following schema:
 * @property {string} oid - SHA-1 object id of this tag
 * @property {TagObject} tag - the parsed tag object
 * @property {string} payload - PGP signing payload
 */

/**
 * Read an annotated tag object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.oid - The SHA-1 object id to get
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<ReadTagResult>} Resolves successfully with a git object description
 * @see ReadTagResult
 * @see TagObject
 *
 */
async function readTag({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oid,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);

    return await _readTag({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
    })
  } catch (err) {
    err.caller = 'git.readTag';
    throw err
  }
}

// @ts-check

/**
 *
 * @typedef {Object} ReadTreeResult - The object returned has the following schema:
 * @property {string} oid - SHA-1 object id of this tree
 * @property {TreeObject} tree - the parsed tree object
 */

/**
 * Read a tree object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.oid - The SHA-1 object id to get. Annotated tags and commits are peeled.
 * @param {string} [args.filepath] - Don't return the object with `oid` itself, but resolve `oid` to a tree and then return the tree object at that filepath.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<ReadTreeResult>} Resolves successfully with a git tree object
 * @see ReadTreeResult
 * @see TreeObject
 * @see TreeEntry
 *
 */
async function readTree({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  oid,
  filepath = undefined,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);

    return await _readTree({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      filepath,
    })
  } catch (err) {
    err.caller = 'git.readTree';
    throw err
  }
}

// @ts-check

/**
 * Remove a file from the git index (aka staging area)
 *
 * Note that this does NOT delete the file in the working directory.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.filepath - The path to the file to remove from the index
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully once the git index has been updated
 *
 * @example
 * await git.remove({ fs, dir: '/tutorial', filepath: 'README.md' })
 * console.log('done')
 *
 */
async function remove({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  filepath,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('filepath', filepath);

    await GitIndexManager.acquire(
      { fs: new FileSystem(_fs), gitdir, cache },
      async function(index) {
        index.delete({ filepath });
      }
    );
  } catch (err) {
    err.caller = 'git.remove';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {object} args.cache
 * @param {SignCallback} [args.onSign]
 * @param {string} [args.dir]
 * @param {string} [args.gitdir=join(dir,'.git')]
 * @param {string} [args.ref]
 * @param {string} args.oid
 * @param {Object} args.author
 * @param {string} args.author.name
 * @param {string} args.author.email
 * @param {number} args.author.timestamp
 * @param {number} args.author.timezoneOffset
 * @param {Object} args.committer
 * @param {string} args.committer.name
 * @param {string} args.committer.email
 * @param {number} args.committer.timestamp
 * @param {number} args.committer.timezoneOffset
 * @param {string} [args.signingKey]
 *
 * @returns {Promise<string>}
 */

async function _removeNote({
  fs,
  cache,
  onSign,
  gitdir,
  ref = 'refs/notes/commits',
  oid,
  author,
  committer,
  signingKey,
}) {
  // Get the current note commit
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (!(err instanceof NotFoundError)) {
      throw err
    }
  }

  // I'm using the "empty tree" magic number here for brevity
  const result = await _readTree({
    fs,
    gitdir,
    oid: parent || '4b825dc642cb6eb9a060e54bf8d69288fbee4904',
  });
  let tree = result.tree;

  // Remove the note blob entry from the tree
  tree = tree.filter(entry => entry.path !== oid);

  // Create the new note tree
  const treeOid = await _writeTree({
    fs,
    gitdir,
    tree,
  });

  // Create the new note commit
  const commitOid = await _commit({
    fs,
    cache,
    onSign,
    gitdir,
    ref,
    tree: treeOid,
    parent: parent && [parent],
    message: `Note removed by 'isomorphic-git removeNote'\n`,
    author,
    committer,
    signingKey,
  });

  return commitOid
}

// @ts-check

/**
 * Remove an object note
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {SignCallback} [args.onSign] - a PGP signing implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref] - The notes ref to look under
 * @param {string} args.oid - The SHA-1 object id of the object to remove the note from.
 * @param {Object} [args.author] - The details about the author.
 * @param {string} [args.author.name] - Default is `user.name` config.
 * @param {string} [args.author.email] - Default is `user.email` config.
 * @param {number} [args.author.timestamp=Math.floor(Date.now()/1000)] - Set the author timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.author.timezoneOffset] - Set the author timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {Object} [args.committer = author] - The details about the note committer, in the same format as the author parameter. If not specified, the author details are used.
 * @param {string} [args.committer.name] - Default is `user.name` config.
 * @param {string} [args.committer.email] - Default is `user.email` config.
 * @param {number} [args.committer.timestamp=Math.floor(Date.now()/1000)] - Set the committer timestamp field. This is the integer number of seconds since the Unix epoch (1970-01-01 00:00:00).
 * @param {number} [args.committer.timezoneOffset] - Set the committer timezone offset field. This is the difference, in minutes, from the current timezone to UTC. Default is `(new Date()).getTimezoneOffset()`.
 * @param {string} [args.signingKey] - Sign the tag object using this private PGP key.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the commit object for the note removal.
 */

async function removeNote({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, '.git'),
  ref = 'refs/notes/commits',
  oid,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('oid', oid);

    const fs = new FileSystem(_fs);

    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author) throw new MissingNameError('author')

    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer,
    });
    if (!committer) throw new MissingNameError('committer')

    return await _removeNote({
      fs,
      cache,
      onSign,
      gitdir,
      ref,
      oid,
      author,
      committer,
      signingKey,
    })
  } catch (err) {
    err.caller = 'git.removeNote';
    throw err
  }
}

// @ts-check

/**
 * Rename a branch
 *
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {string} args.ref - The name of the new branch
 * @param {string} args.oldref - The name of the old branch
 * @param {boolean} [args.checkout = false]
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 */
async function _renameBranch({
  fs,
  gitdir,
  oldref,
  ref,
  checkout = false,
}) {
  if (ref !== clean_git_ref__WEBPACK_IMPORTED_MODULE_6__.clean(ref)) {
    throw new InvalidRefNameError(ref, clean_git_ref__WEBPACK_IMPORTED_MODULE_6__.clean(ref))
  }

  if (oldref !== clean_git_ref__WEBPACK_IMPORTED_MODULE_6__.clean(oldref)) {
    throw new InvalidRefNameError(oldref, clean_git_ref__WEBPACK_IMPORTED_MODULE_6__.clean(oldref))
  }

  const fulloldref = `refs/heads/${oldref}`;
  const fullnewref = `refs/heads/${ref}`;

  const newexist = await GitRefManager.exists({ fs, gitdir, ref: fullnewref });

  if (newexist) {
    throw new AlreadyExistsError('branch', ref, false)
  }

  const value = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: fulloldref,
    depth: 1,
  });

  await GitRefManager.writeRef({ fs, gitdir, ref: fullnewref, value });
  await GitRefManager.deleteRef({ fs, gitdir, ref: fulloldref });

  if (checkout) {
    // Update HEAD
    await GitRefManager.writeSymbolicRef({
      fs,
      gitdir,
      ref: 'HEAD',
      value: fullnewref,
    });
  }
}

// @ts-check

/**
 * Rename a branch
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - What to name the branch
 * @param {string} args.oldref - What the name of the branch was
 * @param {boolean} [args.checkout = false] - Update `HEAD` to point at the newly created branch
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.renameBranch({ fs, dir: '/tutorial', ref: 'main', oldref: 'master' })
 * console.log('done')
 *
 */
async function renameBranch({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  oldref,
  checkout = false,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);
    assertParameter('oldref', oldref);
    return await _renameBranch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      oldref,
      checkout,
    })
  } catch (err) {
    err.caller = 'git.renameBranch';
    throw err
  }
}

async function hashObject$1({ gitdir, type, object }) {
  return shasum(GitObject.wrap({ type, object }))
}

// @ts-check

/**
 * Reset a file in the git index (aka staging area)
 *
 * Note that this does NOT modify the file in the working directory.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.filepath - The path to the file to reset in the index
 * @param {string} [args.ref = 'HEAD'] - A ref to the commit to use
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<void>} Resolves successfully once the git index has been updated
 *
 * @example
 * await git.resetIndex({ fs, dir: '/tutorial', filepath: 'README.md' })
 * console.log('done')
 *
 */
async function resetIndex({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  filepath,
  ref = 'HEAD',
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('filepath', filepath);
    assertParameter('ref', ref);

    const fs = new FileSystem(_fs);
    // Resolve commit
    let oid = await GitRefManager.resolve({ fs, gitdir, ref });
    let workdirOid;
    try {
      // Resolve blob
      oid = await resolveFilepath({
        fs,
        cache,
        gitdir,
        oid,
        filepath,
      });
    } catch (e) {
      // This means we're resetting the file to a "deleted" state
      oid = null;
    }
    // For files that aren't in the workdir use zeros
    let stats = {
      ctime: new Date(0),
      mtime: new Date(0),
      dev: 0,
      ino: 0,
      mode: 0,
      uid: 0,
      gid: 0,
      size: 0,
    };
    // If the file exists in the workdir...
    const object = dir && (await fs.read(join(dir, filepath)));
    if (object) {
      // ... and has the same hash as the desired state...
      workdirOid = await hashObject$1({
        gitdir,
        type: 'blob',
        object,
      });
      if (oid === workdirOid) {
        // ... use the workdir Stats object
        stats = await fs.lstat(join(dir, filepath));
      }
    }
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      index.delete({ filepath });
      if (oid) {
        index.insert({ filepath, stats, oid });
      }
    });
  } catch (err) {
    err.caller = 'git.reset';
    throw err
  }
}

// @ts-check

/**
 * Get the value of a symbolic ref or resolve a ref to its SHA-1 object id
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - The ref to resolve
 * @param {number} [args.depth = undefined] - How many symbolic references to follow before returning
 *
 * @returns {Promise<string>} Resolves successfully with a SHA-1 object id or the value of a symbolic ref
 *
 * @example
 * let currentCommit = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })
 * console.log(currentCommit)
 * let currentBranch = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD', depth: 2 })
 * console.log(currentBranch)
 *
 */
async function resolveRef({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  depth,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);

    const oid = await GitRefManager.resolve({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      depth,
    });
    return oid
  } catch (err) {
    err.caller = 'git.resolveRef';
    throw err
  }
}

// @ts-check

/**
 * Write an entry to the git config files.
 *
 * *Caveats:*
 * - Currently only the local `$GIT_DIR/config` file can be read or written. However support for the global `~/.gitconfig` and system `$(prefix)/etc/gitconfig` will be added in the future.
 * - The current parser does not support the more exotic features of the git-config file format such as `[include]` and `[includeIf]`.
 *
 * @param {Object} args
 * @param {FsClient} args.fs - a file system implementation
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.path - The key of the git config entry
 * @param {string | boolean | number | void} args.value - A value to store at that path. (Use `undefined` as the value to delete a config entry.)
 * @param {boolean} [args.append = false] - If true, will append rather than replace when setting (use with multi-valued config options).
 *
 * @returns {Promise<void>} Resolves successfully when operation completed
 *
 * @example
 * // Write config value
 * await git.setConfig({
 *   fs,
 *   dir: '/tutorial',
 *   path: 'user.name',
 *   value: 'Mr. Test'
 * })
 *
 * // Print out config file
 * let file = await fs.promises.readFile('/tutorial/.git/config', 'utf8')
 * console.log(file)
 *
 * // Delete a config entry
 * await git.setConfig({
 *   fs,
 *   dir: '/tutorial',
 *   path: 'user.name',
 *   value: undefined
 * })
 *
 * // Print out config file
 * file = await fs.promises.readFile('/tutorial/.git/config', 'utf8')
 * console.log(file)
 */
async function setConfig({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  path,
  value,
  append = false,
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('path', path);
    // assertParameter('value', value) // We actually allow 'undefined' as a value to unset/delete

    const fs = new FileSystem(_fs);
    const config = await GitConfigManager.get({ fs, gitdir });
    if (append) {
      await config.append(path, value);
    } else {
      await config.set(path, value);
    }
    await GitConfigManager.save({ fs, gitdir, config });
  } catch (err) {
    err.caller = 'git.setConfig';
    throw err
  }
}

// @ts-check

/**
 * Tell whether a file has been changed
 *
 * The possible resolve values are:
 *
 * | status                | description                                                                           |
 * | --------------------- | ------------------------------------------------------------------------------------- |
 * | `"ignored"`           | file ignored by a .gitignore rule                                                     |
 * | `"unmodified"`        | file unchanged from HEAD commit                                                       |
 * | `"*modified"`         | file has modifications, not yet staged                                                |
 * | `"*deleted"`          | file has been removed, but the removal is not yet staged                              |
 * | `"*added"`            | file is untracked, not yet staged                                                     |
 * | `"absent"`            | file not present in HEAD commit, staging area, or working dir                         |
 * | `"modified"`          | file has modifications, staged                                                        |
 * | `"deleted"`           | file has been removed, staged                                                         |
 * | `"added"`             | previously untracked file, staged                                                     |
 * | `"*unmodified"`       | working dir and HEAD commit match, but index differs                                  |
 * | `"*absent"`           | file not present in working dir or HEAD commit, but present in the index              |
 * | `"*undeleted"`        | file was deleted from the index, but is still in the working dir                      |
 * | `"*undeletemodified"` | file was deleted from the index, but is present with modifications in the working dir |
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.filepath - The path to the file to query
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<'ignored'|'unmodified'|'*modified'|'*deleted'|'*added'|'absent'|'modified'|'deleted'|'added'|'*unmodified'|'*absent'|'*undeleted'|'*undeletemodified'>} Resolves successfully with the file's git status
 *
 * @example
 * let status = await git.status({ fs, dir: '/tutorial', filepath: 'README.md' })
 * console.log(status)
 *
 */
async function status({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  filepath,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('filepath', filepath);

    const fs = new FileSystem(_fs);
    const ignored = await GitIgnoreManager.isIgnored({
      fs,
      gitdir,
      dir,
      filepath,
    });
    if (ignored) {
      return 'ignored'
    }
    const headTree = await getHeadTree({ fs, cache, gitdir });
    const treeOid = await getOidAtPath({
      fs,
      cache,
      gitdir,
      tree: headTree,
      path: filepath,
    });
    const indexEntry = await GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function(index) {
        for (const entry of index) {
          if (entry.path === filepath) return entry
        }
        return null
      }
    );
    const stats = await fs.lstat(join(dir, filepath));

    const H = treeOid !== null; // head
    const I = indexEntry !== null; // index
    const W = stats !== null; // working dir

    const getWorkdirOid = async () => {
      if (I && !compareStats(indexEntry, stats)) {
        return indexEntry.oid
      } else {
        const object = await fs.read(join(dir, filepath));
        const workdirOid = await hashObject$1({
          gitdir,
          type: 'blob',
          object,
        });
        // If the oid in the index === working dir oid but stats differed update cache
        if (I && indexEntry.oid === workdirOid) {
          // and as long as our fs.stats aren't bad.
          // size of -1 happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers
          // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat
          if (stats.size !== -1) {
            // We don't await this so we can return faster for one-off cases.
            GitIndexManager.acquire({ fs, gitdir, cache }, async function(
              index
            ) {
              index.insert({ filepath, stats, oid: workdirOid });
            });
          }
        }
        return workdirOid
      }
    };

    if (!H && !W && !I) return 'absent' // ---
    if (!H && !W && I) return '*absent' // -A-
    if (!H && W && !I) return '*added' // --A
    if (!H && W && I) {
      const workdirOid = await getWorkdirOid();
      // @ts-ignore
      return workdirOid === indexEntry.oid ? 'added' : '*added' // -AA : -AB
    }
    if (H && !W && !I) return 'deleted' // A--
    if (H && !W && I) {
      // @ts-ignore
      return treeOid === indexEntry.oid ? '*deleted' : '*deleted' // AA- : AB-
    }
    if (H && W && !I) {
      const workdirOid = await getWorkdirOid();
      return workdirOid === treeOid ? '*undeleted' : '*undeletemodified' // A-A : A-B
    }
    if (H && W && I) {
      const workdirOid = await getWorkdirOid();
      if (workdirOid === treeOid) {
        // @ts-ignore
        return workdirOid === indexEntry.oid ? 'unmodified' : '*unmodified' // AAA : ABA
      } else {
        // @ts-ignore
        return workdirOid === indexEntry.oid ? 'modified' : '*modified' // ABB : AAB
      }
    }
    /*
    ---
    -A-
    --A
    -AA
    -AB
    A--
    AA-
    AB-
    A-A
    A-B
    AAA
    ABA
    ABB
    AAB
    */
  } catch (err) {
    err.caller = 'git.status';
    throw err
  }
}

async function getOidAtPath({ fs, cache, gitdir, tree, path }) {
  if (typeof path === 'string') path = path.split('/');
  const dirname = path.shift();
  for (const entry of tree) {
    if (entry.path === dirname) {
      if (path.length === 0) {
        return entry.oid
      }
      const { type, object } = await _readObject({
        fs,
        cache,
        gitdir,
        oid: entry.oid,
      });
      if (type === 'tree') {
        const tree = GitTree.from(object);
        return getOidAtPath({ fs, cache, gitdir, tree, path })
      }
      if (type === 'blob') {
        throw new ObjectTypeError(entry.oid, type, 'blob', path.join('/'))
      }
    }
  }
  return null
}

async function getHeadTree({ fs, cache, gitdir }) {
  // Get the tree from the HEAD commit.
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref: 'HEAD' });
  } catch (e) {
    // Handle fresh branches with no commits
    if (e instanceof NotFoundError) {
      return []
    }
  }
  const { tree } = await _readTree({ fs, cache, gitdir, oid });
  return tree
}

// @ts-check

/**
 * Efficiently get the status of multiple files at once.
 *
 * The returned `StatusMatrix` is admittedly not the easiest format to read.
 * However it conveys a large amount of information in dense format that should make it easy to create reports about the current state of the repository;
 * without having to do multiple, time-consuming isomorphic-git calls.
 * My hope is that the speed and flexibility of the function will make up for the learning curve of interpreting the return value.
 *
 * ```js live
 * // get the status of all the files in 'src'
 * let status = await git.statusMatrix({
 *   fs,
 *   dir: '/tutorial',
 *   filter: f => f.startsWith('src/')
 * })
 * console.log(status)
 * ```
 *
 * ```js live
 * // get the status of all the JSON and Markdown files
 * let status = await git.statusMatrix({
 *   fs,
 *   dir: '/tutorial',
 *   filter: f => f.endsWith('.json') || f.endsWith('.md')
 * })
 * console.log(status)
 * ```
 *
 * The result is returned as a 2D array.
 * The outer array represents the files and/or blobs in the repo, in alphabetical order.
 * The inner arrays describe the status of the file:
 * the first value is the filepath, and the next three are integers
 * representing the HEAD status, WORKDIR status, and STAGE status of the entry.
 *
 * ```js
 * // example StatusMatrix
 * [
 *   ["a.txt", 0, 2, 0], // new, untracked
 *   ["b.txt", 0, 2, 2], // added, staged
 *   ["c.txt", 0, 2, 3], // added, staged, with unstaged changes
 *   ["d.txt", 1, 1, 1], // unmodified
 *   ["e.txt", 1, 2, 1], // modified, unstaged
 *   ["f.txt", 1, 2, 2], // modified, staged
 *   ["g.txt", 1, 2, 3], // modified, staged, with unstaged changes
 *   ["h.txt", 1, 0, 1], // deleted, unstaged
 *   ["i.txt", 1, 0, 0], // deleted, staged
 * ]
 * ```
 *
 * - The HEAD status is either absent (0) or present (1).
 * - The WORKDIR status is either absent (0), identical to HEAD (1), or different from HEAD (2).
 * - The STAGE status is either absent (0), identical to HEAD (1), identical to WORKDIR (2), or different from WORKDIR (3).
 *
 * ```ts
 * type Filename      = string
 * type HeadStatus    = 0 | 1
 * type WorkdirStatus = 0 | 1 | 2
 * type StageStatus   = 0 | 1 | 2 | 3
 *
 * type StatusRow     = [Filename, HeadStatus, WorkdirStatus, StageStatus]
 *
 * type StatusMatrix  = StatusRow[]
 * ```
 *
 * > Think of the natural progression of file modifications as being from HEAD (previous) -> WORKDIR (current) -> STAGE (next).
 * > Then HEAD is "version 1", WORKDIR is "version 2", and STAGE is "version 3".
 * > Then, imagine a "version 0" which is before the file was created.
 * > Then the status value in each column corresponds to the oldest version of the file it is identical to.
 * > (For a file to be identical to "version 0" means the file is deleted.)
 *
 * Here are some examples of queries you can answer using the result:
 *
 * #### Q: What files have been deleted?
 * ```js
 * const FILE = 0, WORKDIR = 2
 *
 * const filenames = (await statusMatrix({ dir }))
 *   .filter(row => row[WORKDIR] === 0)
 *   .map(row => row[FILE])
 * ```
 *
 * #### Q: What files have unstaged changes?
 * ```js
 * const FILE = 0, WORKDIR = 2, STAGE = 3
 *
 * const filenames = (await statusMatrix({ dir }))
 *   .filter(row => row[WORKDIR] !== row[STAGE])
 *   .map(row => row[FILE])
 * ```
 *
 * #### Q: What files have been modified since the last commit?
 * ```js
 * const FILE = 0, HEAD = 1, WORKDIR = 2
 *
 * const filenames = (await statusMatrix({ dir }))
 *   .filter(row => row[HEAD] !== row[WORKDIR])
 *   .map(row => row[FILE])
 * ```
 *
 * #### Q: What files will NOT be changed if I commit right now?
 * ```js
 * const FILE = 0, HEAD = 1, STAGE = 3
 *
 * const filenames = (await statusMatrix({ dir }))
 *   .filter(row => row[HEAD] === row[STAGE])
 *   .map(row => row[FILE])
 * ```
 *
 * For reference, here are all possible combinations:
 *
 * | HEAD | WORKDIR | STAGE | `git status --short` equivalent |
 * | ---- | ------- | ----- | ------------------------------- |
 * | 0    | 0       | 0     | ``                              |
 * | 0    | 0       | 3     | `AD`                            |
 * | 0    | 2       | 0     | `??`                            |
 * | 0    | 2       | 2     | `A `                            |
 * | 0    | 2       | 3     | `AM`                            |
 * | 1    | 0       | 0     | `D `                            |
 * | 1    | 0       | 1     | ` D`                            |
 * | 1    | 0       | 3     | `MD`                            |
 * | 1    | 1       | 0     | `D ` + `??`                     |
 * | 1    | 1       | 1     | ``                              |
 * | 1    | 1       | 3     | `MM`                            |
 * | 1    | 2       | 0     | `D ` + `??`                     |
 * | 1    | 2       | 1     | ` M`                            |
 * | 1    | 2       | 2     | `M `                            |
 * | 1    | 2       | 3     | `MM`                            |
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} args.dir - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir, '.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} [args.ref = 'HEAD'] - Optionally specify a different commit to compare against the workdir and stage instead of the HEAD
 * @param {string[]} [args.filepaths = ['.']] - Limit the query to the given files and directories
 * @param {function(string): boolean} [args.filter] - Filter the results to only those whose filepath matches a function.
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<Array<StatusRow>>} Resolves with a status matrix, described below.
 * @see StatusRow
 */
async function statusMatrix({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  ref = 'HEAD',
  filepaths = ['.'],
  filter,
  cache = {},
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);

    const fs = new FileSystem(_fs);
    return await _walk({
      fs,
      cache,
      dir,
      gitdir,
      trees: [TREE({ ref }), WORKDIR(), STAGE()],
      map: async function(filepath, [head, workdir, stage]) {
        // Ignore ignored files, but only if they are not already tracked.
        if (!head && !stage && workdir) {
          if (
            await GitIgnoreManager.isIgnored({
              fs,
              dir,
              filepath,
            })
          ) {
            return null
          }
        }
        // match against base paths
        if (!filepaths.some(base => worthWalking(filepath, base))) {
          return null
        }
        // Late filter against file names
        if (filter) {
          if (!filter(filepath)) return
        }

        // For now, just bail on directories
        const headType = head && (await head.type());
        if (headType === 'tree' || headType === 'special') return
        if (headType === 'commit') return null

        const workdirType = workdir && (await workdir.type());
        if (workdirType === 'tree' || workdirType === 'special') return

        const stageType = stage && (await stage.type());
        if (stageType === 'commit') return null
        if (stageType === 'tree' || stageType === 'special') return

        // Figure out the oids, using the staged oid for the working dir oid if the stats match.
        const headOid = head ? await head.oid() : undefined;
        const stageOid = stage ? await stage.oid() : undefined;
        let workdirOid;
        if (!head && workdir && !stage) {
          // We don't actually NEED the sha. Any sha will do
          // TODO: update this logic to handle N trees instead of just 3.
          workdirOid = '42';
        } else if (workdir) {
          workdirOid = await workdir.oid();
        }
        const entry = [undefined, headOid, workdirOid, stageOid];
        const result = entry.map(value => entry.indexOf(value));
        result.shift(); // remove leading undefined entry
        return [filepath, ...result]
      },
    })
  } catch (err) {
    err.caller = 'git.statusMatrix';
    throw err
  }
}

// @ts-check

/**
 * Create a lightweight tag
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - What to name the tag
 * @param {string} [args.object = 'HEAD'] - What oid the tag refers to. (Will resolve to oid if value is a ref.) By default, the commit object which is referred by the current `HEAD` is used.
 * @param {boolean} [args.force = false] - Instead of throwing an error if a tag named `ref` already exists, overwrite the existing tag.
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.tag({ fs, dir: '/tutorial', ref: 'test-tag' })
 * console.log('done')
 *
 */
async function tag({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  object,
  force = false,
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);

    const fs = new FileSystem(_fs);

    if (ref === undefined) {
      throw new MissingParameterError('ref')
    }

    ref = ref.startsWith('refs/tags/') ? ref : `refs/tags/${ref}`;

    // Resolve passed object
    const value = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: object || 'HEAD',
    });

    if (!force && (await GitRefManager.exists({ fs, gitdir, ref }))) {
      throw new AlreadyExistsError('tag', ref)
    }

    await GitRefManager.writeRef({ fs, gitdir, ref, value });
  } catch (err) {
    err.caller = 'git.tag';
    throw err
  }
}

// @ts-check

/**
 * Return the version number of isomorphic-git
 *
 * I don't know why you might need this. I added it just so I could check that I was getting
 * the correct version of the library and not a cached version.
 *
 * @returns {string} the version string taken from package.json at publication time
 *
 * @example
 * console.log(git.version())
 *
 */
function version() {
  try {
    return pkg.version
  } catch (err) {
    err.caller = 'git.version';
    throw err
  }
}

// @ts-check

/**
 * @callback WalkerMap
 * @param {string} filename
 * @param {Array<WalkerEntry | null>} entries
 * @returns {Promise<any>}
 */

/**
 * @callback WalkerReduce
 * @param {any} parent
 * @param {any[]} children
 * @returns {Promise<any>}
 */

/**
 * @callback WalkerIterateCallback
 * @param {WalkerEntry[]} entries
 * @returns {Promise<any[]>}
 */

/**
 * @callback WalkerIterate
 * @param {WalkerIterateCallback} walk
 * @param {IterableIterator<WalkerEntry[]>} children
 * @returns {Promise<any[]>}
 */

/**
 * A powerful recursive tree-walking utility.
 *
 * The `walk` API simplifies gathering detailed information about a tree or comparing all the filepaths in two or more trees.
 * Trees can be git commits, the working directory, or the or git index (staging area).
 * As long as a file or directory is present in at least one of the trees, it will be traversed.
 * Entries are traversed in alphabetical order.
 *
 * The arguments to `walk` are the `trees` you want to traverse, and 3 optional transform functions:
 *  `map`, `reduce`, and `iterate`.
 *
 * ## `TREE`, `WORKDIR`, and `STAGE`
 *
 * Tree walkers are represented by three separate functions that can be imported:
 *
 * ```js
 * import { TREE, WORKDIR, STAGE } from 'isomorphic-git'
 * ```
 *
 * These functions return opaque handles called `Walker`s.
 * The only thing that `Walker` objects are good for is passing into `walk`.
 * Here are the three `Walker`s passed into `walk` by the `statusMatrix` command for example:
 *
 * ```js
 * let ref = 'HEAD'
 *
 * let trees = [TREE({ ref }), WORKDIR(), STAGE()]
 * ```
 *
 * For the arguments, see the doc pages for [TREE](./TREE.md), [WORKDIR](./WORKDIR.md), and [STAGE](./STAGE.md).
 *
 * `map`, `reduce`, and `iterate` allow you control the recursive walk by pruning and transforming `WalkerEntry`s into the desired result.
 *
 * ## WalkerEntry
 *
 * {@link WalkerEntry typedef}
 *
 * `map` receives an array of `WalkerEntry[]` as its main argument, one `WalkerEntry` for each `Walker` in the `trees` argument.
 * The methods are memoized per `WalkerEntry` so calling them multiple times in a `map` function does not adversely impact performance.
 * By only computing these values if needed, you build can build lean, mean, efficient walking machines.
 *
 * ### WalkerEntry#type()
 *
 * Returns the kind as a string. This is normally either `tree` or `blob`.
 *
 * `TREE`, `STAGE`, and `WORKDIR` walkers all return a string.
 *
 * Possible values:
 *
 * - `'tree'` directory
 * - `'blob'` file
 * - `'special'` used by `WORKDIR` to represent irregular files like sockets and FIFOs
 * - `'commit'` used by `TREE` to represent submodules
 *
 * ```js
 * await entry.type()
 * ```
 *
 * ### WalkerEntry#mode()
 *
 * Returns the file mode as a number. Use this to distinguish between regular files, symlinks, and executable files.
 *
 * `TREE`, `STAGE`, and `WORKDIR` walkers all return a number for all `type`s of entries.
 *
 * It has been normalized to one of the 4 values that are allowed in git commits:
 *
 * - `0o40000` directory
 * - `0o100644` file
 * - `0o100755` file (executable)
 * - `0o120000` symlink
 *
 * Tip: to make modes more readable, you can print them to octal using `.toString(8)`.
 *
 * ```js
 * await entry.mode()
 * ```
 *
 * ### WalkerEntry#oid()
 *
 * Returns the SHA-1 object id for blobs and trees.
 *
 * `TREE` walkers return a string for `blob` and `tree` entries.
 *
 * `STAGE` and `WORKDIR` walkers return a string for `blob` entries and `undefined` for `tree` entries.
 *
 * ```js
 * await entry.oid()
 * ```
 *
 * ### WalkerEntry#content()
 *
 * Returns the file contents as a Buffer.
 *
 * `TREE` and `WORKDIR` walkers return a Buffer for `blob` entries and `undefined` for `tree` entries.
 *
 * `STAGE` walkers always return `undefined` since the file contents are never stored in the stage.
 *
 * ```js
 * await entry.content()
 * ```
 *
 * ### WalkerEntry#stat()
 *
 * Returns a normalized subset of filesystem Stat data.
 *
 * `WORKDIR` walkers return a `Stat` for `blob` and `tree` entries.
 *
 * `STAGE` walkers return a `Stat` for `blob` entries and `undefined` for `tree` entries.
 *
 * `TREE` walkers return `undefined` for all entry types.
 *
 * ```js
 * await entry.stat()
 * ```
 *
 * {@link Stat typedef}
 *
 * ## map(string, Array<WalkerEntry|null>) => Promise<any>
 *
 * {@link WalkerMap typedef}
 *
 * This is the function that is called once per entry BEFORE visiting the children of that node.
 *
 * If you return `null` for a `tree` entry, then none of the children of that `tree` entry will be walked.
 *
 * This is a good place for query logic, such as examining the contents of a file.
 * Ultimately, compare all the entries and return any values you are interested in.
 * If you do not return a value (or return undefined) that entry will be filtered from the results.
 *
 * Example 1: Find all the files containing the word 'foo'.
 * ```js
 * async function map(filepath, [head, workdir]) {
 *   let content = (await workdir.content()).toString('utf8')
 *   if (content.contains('foo')) {
 *     return {
 *       filepath,
 *       content
 *     }
 *   }
 * }
 * ```
 *
 * Example 2: Return the difference between the working directory and the HEAD commit
 * ```js
 * const diff = require('diff-lines')
 * async function map(filepath, [head, workdir]) {
 *   return {
 *     filepath,
 *     oid: await head.oid(),
 *     diff: diff((await head.content()).toString('utf8'), (await workdir.content()).toString('utf8'))
 *   }
 * }
 * ```
 *
 * Example 3:
 * ```js
 * let path = require('path')
 * // Only examine files in the directory `cwd`
 * let cwd = 'src/app'
 * async function map (filepath, [head, workdir, stage]) {
 *   if (
 *     // don't skip the root directory
 *     head.fullpath !== '.' &&
 *     // return true for 'src' and 'src/app'
 *     !cwd.startsWith(filepath) &&
 *     // return true for 'src/app/*'
 *     path.dirname(filepath) !== cwd
 *   ) {
 *     return null
 *   } else {
 *     return filepath
 *   }
 * }
 * ```
 *
 * ## reduce(parent, children)
 *
 * {@link WalkerReduce typedef}
 *
 * This is the function that is called once per entry AFTER visiting the children of that node.
 *
 * Default: `async (parent, children) => parent === undefined ? children.flat() : [parent, children].flat()`
 *
 * The default implementation of this function returns all directories and children in a giant flat array.
 * You can define a different accumulation method though.
 *
 * Example: Return a hierarchical structure
 * ```js
 * async function reduce (parent, children) {
 *   return Object.assign(parent, { children })
 * }
 * ```
 *
 * ## iterate(walk, children)
 *
 * {@link WalkerIterate typedef}
 *
 * {@link WalkerIterateCallback typedef}
 *
 * Default: `(walk, children) => Promise.all([...children].map(walk))`
 *
 * The default implementation recurses all children concurrently using Promise.all.
 * However you could use a custom function to traverse children serially or use a global queue to throttle recursion.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {Walker[]} args.trees - The trees you want to traverse
 * @param {WalkerMap} [args.map] - Transform `WalkerEntry`s into a result form
 * @param {WalkerReduce} [args.reduce] - Control how mapped entries are combined with their parent result
 * @param {WalkerIterate} [args.iterate] - Fine-tune how entries within a tree are iterated over
 * @param {object} [args.cache] - a [cache](cache.md) object
 *
 * @returns {Promise<any>} The finished tree-walking result
 */
async function walk({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  trees,
  map,
  reduce,
  iterate,
  cache = {},
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('trees', trees);

    return await _walk({
      fs: new FileSystem(fs),
      cache,
      dir,
      gitdir,
      trees,
      map,
      reduce,
      iterate,
    })
  } catch (err) {
    err.caller = 'git.walk';
    throw err
  }
}

// @ts-check

/**
 * Write a blob object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {Uint8Array} args.blob - The blob object to write
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object
 *
 * @example
 * // Manually create a blob.
 * let oid = await git.writeBlob({
 *   fs,
 *   dir: '/tutorial',
 *   blob: new Uint8Array([])
 * })
 *
 * console.log('oid', oid) // should be 'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391'
 *
 */
async function writeBlob({ fs, dir, gitdir = join(dir, '.git'), blob }) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('blob', blob);

    return await _writeObject({
      fs: new FileSystem(fs),
      gitdir,
      type: 'blob',
      object: blob,
      format: 'content',
    })
  } catch (err) {
    err.caller = 'git.writeBlob';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {CommitObject} args.commit
 *
 * @returns {Promise<string>}
 * @see CommitObject
 *
 */
async function _writeCommit({ fs, gitdir, commit }) {
  // Convert object to buffer
  const object = GitCommit.from(commit).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: 'commit',
    object,
    format: 'content',
  });
  return oid
}

// @ts-check

/**
 * Write a commit object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {CommitObject} args.commit - The object to write
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object
 * @see CommitObject
 *
 */
async function writeCommit({
  fs,
  dir,
  gitdir = join(dir, '.git'),
  commit,
}) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('commit', commit);

    return await _writeCommit({
      fs: new FileSystem(fs),
      gitdir,
      commit,
    })
  } catch (err) {
    err.caller = 'git.writeCommit';
    throw err
  }
}

// @ts-check

/**
 * Write a git object directly
 *
 * `format` can have the following values:
 *
 * | param      | description                                                                                                                                                      |
 * | ---------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
 * | 'deflated' | Treat `object` as the raw deflate-compressed buffer for an object, meaning can be written to `.git/objects/**` as-is.                                           |
 * | 'wrapped'  | Treat `object` as the inflated object buffer wrapped in the git object header. This is the raw buffer used when calculating the SHA-1 object id of a git object. |
 * | 'content'  | Treat `object` as the object buffer without the git header.                                                                                                      |
 * | 'parsed'   | Treat `object` as a parsed representation of the object.                                                                                                         |
 *
 * If `format` is `'parsed'`, then `object` must match one of the schemas for `CommitObject`, `TreeObject`, `TagObject`, or a `string` (for blobs).
 *
 * {@link CommitObject typedef}
 *
 * {@link TreeObject typedef}
 *
 * {@link TagObject typedef}
 *
 * If `format` is `'content'`, `'wrapped'`, or `'deflated'`, `object` should be a `Uint8Array`.
 *
 * @deprecated
 * > This command is overly complicated.
 * >
 * > If you know the type of object you are writing, use [`writeBlob`](./writeBlob.md), [`writeCommit`](./writeCommit.md), [`writeTag`](./writeTag.md), or [`writeTree`](./writeTree.md).
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string | Uint8Array | CommitObject | TreeObject | TagObject} args.object - The object to write.
 * @param {'blob'|'tree'|'commit'|'tag'} [args.type] - The kind of object to write.
 * @param {'deflated' | 'wrapped' | 'content' | 'parsed'} [args.format = 'parsed'] - What format the object is in. The possible choices are listed below.
 * @param {string} [args.oid] - If `format` is `'deflated'` then this param is required. Otherwise it is calculated.
 * @param {string} [args.encoding] - If `type` is `'blob'` then `object` will be converted to a Uint8Array using `encoding`.
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object.
 *
 * @example
 * // Manually create an annotated tag.
 * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })
 * console.log('commit', sha)
 *
 * let oid = await git.writeObject({
 *   fs,
 *   dir: '/tutorial',
 *   type: 'tag',
 *   object: {
 *     object: sha,
 *     type: 'commit',
 *     tag: 'my-tag',
 *     tagger: {
 *       name: 'your name',
 *       email: 'email@example.com',
 *       timestamp: Math.floor(Date.now()/1000),
 *       timezoneOffset: new Date().getTimezoneOffset()
 *     },
 *     message: 'Optional message'
 *   }
 * })
 *
 * console.log('tag', oid)
 *
 */
async function writeObject({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  type,
  object,
  format = 'parsed',
  oid,
  encoding = undefined,
}) {
  try {
    const fs = new FileSystem(_fs);
    // Convert object to buffer
    if (format === 'parsed') {
      switch (type) {
        case 'commit':
          object = GitCommit.from(object).toObject();
          break
        case 'tree':
          object = GitTree.from(object).toObject();
          break
        case 'blob':
          object = Buffer.from(object, encoding);
          break
        case 'tag':
          object = GitAnnotatedTag.from(object).toObject();
          break
        default:
          throw new ObjectTypeError(oid || '', type, 'blob|commit|tag|tree')
      }
      // GitObjectManager does not know how to serialize content, so we tweak that parameter before passing it.
      format = 'content';
    }
    oid = await _writeObject({
      fs,
      gitdir,
      type,
      object,
      oid,
      format,
    });
    return oid
  } catch (err) {
    err.caller = 'git.writeObject';
    throw err
  }
}

// @ts-check

/**
 * Write a ref which refers to the specified SHA-1 object id, or a symbolic ref which refers to the specified ref.
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {string} args.ref - The name of the ref to write
 * @param {string} args.value - When `symbolic` is false, a ref or an SHA-1 object id. When true, a ref starting with `refs/`.
 * @param {boolean} [args.force = false] - Instead of throwing an error if a ref named `ref` already exists, overwrite the existing ref.
 * @param {boolean} [args.symbolic = false] - Whether the ref is symbolic or not.
 *
 * @returns {Promise<void>} Resolves successfully when filesystem operations are complete
 *
 * @example
 * await git.writeRef({
 *   fs,
 *   dir: '/tutorial',
 *   ref: 'refs/heads/another-branch',
 *   value: 'HEAD'
 * })
 * await git.writeRef({
 *   fs,
 *   dir: '/tutorial',
 *   ref: 'HEAD',
 *   value: 'refs/heads/another-branch',
 *   force: true,
 *   symbolic: true
 * })
 * console.log('done')
 *
 */
async function writeRef({
  fs: _fs,
  dir,
  gitdir = join(dir, '.git'),
  ref,
  value,
  force = false,
  symbolic = false,
}) {
  try {
    assertParameter('fs', _fs);
    assertParameter('gitdir', gitdir);
    assertParameter('ref', ref);
    assertParameter('value', value);

    const fs = new FileSystem(_fs);

    if (ref !== clean_git_ref__WEBPACK_IMPORTED_MODULE_6__.clean(ref)) {
      throw new InvalidRefNameError(ref, clean_git_ref__WEBPACK_IMPORTED_MODULE_6__.clean(ref))
    }

    if (!force && (await GitRefManager.exists({ fs, gitdir, ref }))) {
      throw new AlreadyExistsError('ref', ref)
    }

    if (symbolic) {
      await GitRefManager.writeSymbolicRef({
        fs,
        gitdir,
        ref,
        value,
      });
    } else {
      value = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: value,
      });
      await GitRefManager.writeRef({
        fs,
        gitdir,
        ref,
        value,
      });
    }
  } catch (err) {
    err.caller = 'git.writeRef';
    throw err
  }
}

// @ts-check

/**
 * @param {object} args
 * @param {import('../models/FileSystem.js').FileSystem} args.fs
 * @param {string} args.gitdir
 * @param {TagObject} args.tag
 *
 * @returns {Promise<string>}
 */
async function _writeTag({ fs, gitdir, tag }) {
  // Convert object to buffer
  const object = GitAnnotatedTag.from(tag).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: 'tag',
    object,
    format: 'content',
  });
  return oid
}

// @ts-check

/**
 * Write an annotated tag object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {TagObject} args.tag - The object to write
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object
 * @see TagObject
 *
 * @example
 * // Manually create an annotated tag.
 * let sha = await git.resolveRef({ fs, dir: '/tutorial', ref: 'HEAD' })
 * console.log('commit', sha)
 *
 * let oid = await git.writeTag({
 *   fs,
 *   dir: '/tutorial',
 *   tag: {
 *     object: sha,
 *     type: 'commit',
 *     tag: 'my-tag',
 *     tagger: {
 *       name: 'your name',
 *       email: 'email@example.com',
 *       timestamp: Math.floor(Date.now()/1000),
 *       timezoneOffset: new Date().getTimezoneOffset()
 *     },
 *     message: 'Optional message'
 *   }
 * })
 *
 * console.log('tag', oid)
 *
 */
async function writeTag({ fs, dir, gitdir = join(dir, '.git'), tag }) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('tag', tag);

    return await _writeTag({
      fs: new FileSystem(fs),
      gitdir,
      tag,
    })
  } catch (err) {
    err.caller = 'git.writeTag';
    throw err
  }
}

// @ts-check

/**
 * Write a tree object directly
 *
 * @param {object} args
 * @param {FsClient} args.fs - a file system client
 * @param {string} [args.dir] - The [working tree](dir-vs-gitdir.md) directory path
 * @param {string} [args.gitdir=join(dir,'.git')] - [required] The [git directory](dir-vs-gitdir.md) path
 * @param {TreeObject} args.tree - The object to write
 *
 * @returns {Promise<string>} Resolves successfully with the SHA-1 object id of the newly written object.
 * @see TreeObject
 * @see TreeEntry
 *
 */
async function writeTree({ fs, dir, gitdir = join(dir, '.git'), tree }) {
  try {
    assertParameter('fs', fs);
    assertParameter('gitdir', gitdir);
    assertParameter('tree', tree);

    return await _writeTree({
      fs: new FileSystem(fs),
      gitdir,
      tree,
    })
  } catch (err) {
    err.caller = 'git.writeTree';
    throw err
  }
}

// default export
var index = {
  Errors,
  STAGE,
  TREE,
  WORKDIR,
  add,
  addNote,
  addRemote,
  annotatedTag,
  branch,
  checkout,
  clone,
  commit,
  getConfig,
  getConfigAll,
  setConfig,
  currentBranch,
  deleteBranch,
  deleteRef,
  deleteRemote,
  deleteTag,
  expandOid,
  expandRef,
  fastForward,
  fetch,
  findMergeBase,
  findRoot,
  getRemoteInfo,
  getRemoteInfo2,
  hashBlob,
  indexPack,
  init,
  isDescendent,
  isIgnored,
  listBranches,
  listFiles,
  listNotes,
  listRemotes,
  listServerRefs,
  listTags,
  log,
  merge,
  packObjects,
  pull,
  push,
  readBlob,
  readCommit,
  readNote,
  readObject,
  readTag,
  readTree,
  remove,
  removeNote,
  renameBranch,
  resetIndex,
  resolveRef,
  status,
  statusMatrix,
  tag,
  version,
  walk,
  writeBlob,
  writeCommit,
  writeObject,
  writeRef,
  writeTag,
  writeTree,
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);



/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************************************!*\
  !*** ./src/workspace/worker/sharedWorker.ts ***!
  \**********************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _kie_tools_core_workspaces_git_fs_dist_worker_createWorkspaceServices__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @kie-tools-core/workspaces-git-fs/dist/worker/createWorkspaceServices */ "../workspaces-git-fs/dist/worker/createWorkspaceServices.js");
/* harmony import */ var _kie_tools_core_workspaces_git_fs_dist_worker_WorkspacesWorkerApiImpl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @kie-tools-core/workspaces-git-fs/dist/worker/WorkspacesWorkerApiImpl */ "../workspaces-git-fs/dist/worker/WorkspacesWorkerApiImpl.js");
/* harmony import */ var _kie_tools_core_workspaces_git_fs_dist_worker_WorkspacesWorkerApiImpl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_kie_tools_core_workspaces_git_fs_dist_worker_WorkspacesWorkerApiImpl__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _kie_tools_core_workspaces_git_fs_dist_worker_setupWorkerConnection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @kie-tools-core/workspaces-git-fs/dist/worker/setupWorkerConnection */ "../workspaces-git-fs/dist/worker/setupWorkerConnection.js");
/* harmony import */ var _env_EnvConstants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../env/EnvConstants */ "./src/env/EnvConstants.ts");
/* harmony import */ var _AppConstants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../AppConstants */ "./src/AppConstants.ts");
/* harmony import */ var _extension__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../extension */ "./src/extension/index.ts");
/* harmony import */ var _envelopeLocator_EditorEnvelopeLocatorFactory__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../envelopeLocator/EditorEnvelopeLocatorFactory */ "./src/envelopeLocator/EditorEnvelopeLocatorFactory.ts");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







importScripts("fsMain.js");
function gitCorsProxyUrl() {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const envFilePath = `../../${_env_EnvConstants__WEBPACK_IMPORTED_MODULE_3__.ENV_FILE_PATH}`;
        const env = (yield (yield fetch(envFilePath)).json());
        return (_b = (_a = env.SERVERLESS_LOGIC_WEB_TOOLS_GIT_CORS_PROXY_URL) !== null && _a !== void 0 ? _a : "https://cors.isomorphic-git.org") !== null && _b !== void 0 ? _b : "";
    });
}
const editorEnvelopeLocator = new _envelopeLocator_EditorEnvelopeLocatorFactory__WEBPACK_IMPORTED_MODULE_6__.EditorEnvelopeLocatorFactory().create({ targetOrigin: "" });
const workspaceServices = (0,_kie_tools_core_workspaces_git_fs_dist_worker_createWorkspaceServices__WEBPACK_IMPORTED_MODULE_0__.createWorkspaceServices)({ gitCorsProxyUrl: gitCorsProxyUrl() });
onconnect = (e) => __awaiter(void 0, void 0, void 0, function* () {
    console.log("Connected to Workspaces Shared Worker");
    (0,_kie_tools_core_workspaces_git_fs_dist_worker_setupWorkerConnection__WEBPACK_IMPORTED_MODULE_2__.setupWorkerConnection)({
        fsFlushManager: workspaceServices.fsFlushManager,
        apiImpl: new _kie_tools_core_workspaces_git_fs_dist_worker_WorkspacesWorkerApiImpl__WEBPACK_IMPORTED_MODULE_1__.WorkspacesWorkerApiImpl({
            appName: _AppConstants__WEBPACK_IMPORTED_MODULE_4__.APP_NAME,
            services: workspaceServices,
            fileFilter: {
                isModel: (path) => (0,_extension__WEBPACK_IMPORTED_MODULE_5__.isModel)(path),
                isEditable: (path) => (0,_extension__WEBPACK_IMPORTED_MODULE_5__.isEditable)(path),
                isSupported: (path) => editorEnvelopeLocator.hasMappingFor(path),
            },
        }),
        port: e.ports[0],
    });
});

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ya3NwYWNlL3dvcmtlci9zaGFyZWRXb3JrZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFhO0FBQ2IsbUlBQWlDOzs7Ozs7Ozs7Ozs7QUNEcEI7O0FBRWI7QUFDQTs7QUFFQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQiwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7OztBQzdSYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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TTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0EsU0FBUyxVQUFVOztBQUVuQjtBQUNBOzs7Ozs7Ozs7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxNQUFNOztBQUU1Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxRQUFRO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGtCQUFrQixNQUFNO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixHQUFHO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU0sRUFBRSwrQkFBK0IsRUFBRSxNQUFNO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCLEVBQUUsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxXQUFXLE1BQU07QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxHQUFHOztBQUVoQjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEdBQUcsbUJBQW1CLGFBQWE7QUFDN0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxpQ0FBaUM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsU0FBUztBQUN0QjtBQUNBOztBQUVBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ04sTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNO0FBQ04sSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLElBQUk7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLEVBQUUsRUFBRSxLQUFLO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBOztBQUVBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sNENBQTRDOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwREFBMEQ7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0EsNkJBQTZCLDBCQUEwQjs7O0FBR3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0Q7QUFDaEQ7QUFDQSxNQUFNO0FBQ04sZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDJDQUFJO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSw4QkFBOEIsTUFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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ckI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxNQUFNO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsMkNBQTJDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixFQUFFO0FBQzlCLDRCQUE0QixFQUFFO0FBQzlCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixHQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxJQUFJO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0IsRUFBRSxRQUFRO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUM7UUFDRixJQUFJLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7S0FDakIsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYXN5bmMtbG9ja0AxLjMuMC9ub2RlX21vZHVsZXMvYXN5bmMtbG9jay9pbmRleC5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9hc3luYy1sb2NrQDEuMy4wL25vZGVfbW9kdWxlcy9hc3luYy1sb2NrL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9iYWxhbmNlZC1tYXRjaEAxLjAuMi9ub2RlX21vZHVsZXMvYmFsYW5jZWQtbWF0Y2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYmFzZTY0LWpzQDEuNS4xL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vYnJhY2UtZXhwYW5zaW9uQDEuMS4xMS9ub2RlX21vZHVsZXMvYnJhY2UtZXhwYW5zaW9uL2luZGV4LmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2J1ZmZlckA2LjAuMy9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NsZWFuLWdpdC1yZWZAMi4wLjEvbm9kZV9tb2R1bGVzL2NsZWFuLWdpdC1yZWYvbGliL2luZGV4LmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvbmNhdC1tYXBAMC4wLjEvbm9kZV9tb2R1bGVzL2NvbmNhdC1tYXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vY3JjLTMyQDEuMi4wL25vZGVfbW9kdWxlcy9jcmMtMzIvY3JjMzIuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vZGlmZjNAMC4wLjMvbm9kZV9tb2R1bGVzL2RpZmYzL2RpZmYzLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2RpZmYzQDAuMC4zL25vZGVfbW9kdWxlcy9kaWZmMy9vbnAuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaWVlZTc1NEAxLjIuMS9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pZ25vcmVANS4yLjAvbm9kZV9tb2R1bGVzL2lnbm9yZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9pbmhlcml0c0AyLjAuNC9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9qc3ppcEAzLjcuMS9ub2RlX21vZHVsZXMvanN6aXAvZGlzdC9qc3ppcC5taW4uanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbWluaW1hdGNoQDMuMC41L25vZGVfbW9kdWxlcy9taW5pbWF0Y2gvbWluaW1hdGNoLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2luZGV4LmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9kZWZsYXRlLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL3N0cmluZ3MuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9nemhlYWRlci5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wYWtvQDEuMC4xMS9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3Bha29AMS4wLjExL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mdHJlZXMuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvbWVzc2FnZXMuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcGFrb0AxLjAuMTEvbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvenN0cmVhbS5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9wYXRoLWJyb3dzZXJpZnlAMS4wLjEvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9waWZ5QDQuMC4xL25vZGVfbW9kdWxlcy9waWZ5L2luZGV4LmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3NhZmUtYnVmZmVyQDUuMi4xL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zaGEuanNAMi40LjExL25vZGVfbW9kdWxlcy9zaGEuanMvaGFzaC5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9zaGEuanNAMi40LjExL25vZGVfbW9kdWxlcy9zaGEuanMvc2hhMS5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91dWlkQDguMy4yL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdXVpZEA4LjMuMi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL21kNS5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91dWlkQDguMy4yL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmlsLmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3V1aWRAOC4zLjIvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9wYXJzZS5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91dWlkQDguMy4yL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcmVnZXguanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdXVpZEA4LjMuMi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JuZy5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91dWlkQDguMy4yL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc2hhMS5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91dWlkQDguMy4yL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3V1aWRAOC4zLjIvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92MS5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91dWlkQDguMy4yL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjMuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdXVpZEA4LjMuMi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3YzNS5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91dWlkQDguMy4yL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vdXVpZEA4LjMuMi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y1LmpzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3V1aWRAOC4zLjIvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92YWxpZGF0ZS5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS91dWlkQDguMy4yL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uL2VkaXRvci9zcmMvYXBpL0VkaXRvckVudmVsb3BlTG9jYXRvci50cyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uL2VudmVsb3BlLWJ1cy9zcmMvYXBpL2luZGV4LnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vZW52ZWxvcGUtYnVzL3NyYy9jb21tb24vRW52ZWxvcGVCdXNNZXNzYWdlTWFuYWdlci50cyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uL2VudmVsb3BlLWJ1cy9zcmMvY29tbW9uL2luZGV4LnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlL3NyYy9hcGkvQ29udGVudFR5cGUudHMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi93b3Jrc3BhY2Uvc3JjL2FwaS9SZXNvdXJjZUNvbnRlbnQudHMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi93b3Jrc3BhY2Uvc3JjL2FwaS9SZXNvdXJjZUNvbnRlbnRPcHRpb25zLnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlL3NyYy9hcGkvUmVzb3VyY2VDb250ZW50UmVxdWVzdC50cyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uL3dvcmtzcGFjZS9zcmMvYXBpL1Jlc291cmNlQ29udGVudFNlcnZpY2UudHMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi93b3Jrc3BhY2Uvc3JjL2FwaS9SZXNvdXJjZUxpc3RPcHRpb25zLnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlL3NyYy9hcGkvUmVzb3VyY2VMaXN0UmVxdWVzdC50cyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uL3dvcmtzcGFjZS9zcmMvYXBpL1Jlc291cmNlc0xpc3QudHMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi93b3Jrc3BhY2Uvc3JjL2FwaS9TZWFyY2hUeXBlLnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlL3NyYy9hcGkvV29ya3NwYWNlQ2hhbm5lbEFwaS50cyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uL3dvcmtzcGFjZS9zcmMvYXBpL1dvcmtzcGFjZUVkaXQudHMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi93b3Jrc3BhY2Uvc3JjL2FwaS9pbmRleC50cyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uL3dvcmtzcGFjZXMtZ2l0LWZzL3NyYy9jb25zdGFudHMvR2l0Q29uc3RhbnRzLnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlcy1naXQtZnMvc3JjL2VuY29kZXJkZWNvZGVyL0VuY29kZXJEZWNvZGVyLnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlcy1naXQtZnMvc3JjL3JlbGF0aXZlUGF0aC9Xb3Jrc3BhY2VGaWxlUmVsYXRpdmVQYXRoUGFyc2VyLnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlcy1naXQtZnMvc3JjL3NlcnZpY2VzL0ZzQ2FjaGUudHN4Iiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlcy1naXQtZnMvc3JjL3NlcnZpY2VzL0ZzRmx1c2hNYW5hZ2VyLnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlcy1naXQtZnMvc3JjL3NlcnZpY2VzL0ZzU2VydmljZS50c3giLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi93b3Jrc3BhY2VzLWdpdC1mcy9zcmMvc2VydmljZXMvRnNVbmxvYWRNYW5hZ2VyLnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlcy1naXQtZnMvc3JjL3NlcnZpY2VzL0ZzVXNhZ2VDb3VudGVyLnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlcy1naXQtZnMvc3JjL3NlcnZpY2VzL0dpdFNlcnZpY2UudHN4Iiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlcy1naXQtZnMvc3JjL3NlcnZpY2VzL1N0b3JhZ2VTZXJ2aWNlLnRzeCIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uL3dvcmtzcGFjZXMtZ2l0LWZzL3NyYy9zZXJ2aWNlcy9TdWJzY3JpYmFibGUudHMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi93b3Jrc3BhY2VzLWdpdC1mcy9zcmMvc2VydmljZXMvV29ya3NwYWNlRGVzY3JpcHRvckZzU2VydmljZS50cyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uL3dvcmtzcGFjZXMtZ2l0LWZzL3NyYy9zZXJ2aWNlcy9Xb3Jrc3BhY2VEZXNjcmlwdG9yU2VydmljZS50c3giLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi93b3Jrc3BhY2VzLWdpdC1mcy9zcmMvc2VydmljZXMvV29ya3NwYWNlRnNTZXJ2aWNlLnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlcy1naXQtZnMvc3JjL3NlcnZpY2VzL1dvcmtzcGFjZVNlcnZpY2UudHN4Iiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlcy1naXQtZnMvc3JjL3dvcmtlci9Xb3Jrc3BhY2VzV29ya2VyQXBpSW1wbC50cyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uL3dvcmtzcGFjZXMtZ2l0LWZzL3NyYy93b3JrZXIvYXBpL1dvcmtzcGFjZURlc2NyaXB0b3IudHN4Iiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlcy1naXQtZnMvc3JjL3dvcmtlci9hcGkvV29ya3NwYWNlT3JpZ2luLnRzeCIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzLy4uL3dvcmtzcGFjZXMtZ2l0LWZzL3NyYy93b3JrZXIvYXBpL1dvcmtzcGFjZXNCcm9hZGNhc3RFdmVudHMudHMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi93b3Jrc3BhY2VzLWdpdC1mcy9zcmMvd29ya2VyL2NyZWF0ZVdvcmtzcGFjZVNlcnZpY2VzLnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vd29ya3NwYWNlcy1naXQtZnMvc3JjL3dvcmtlci9zZXR1cFdvcmtlckNvbm5lY3Rpb24udHMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uL3NyYy9BcHBDb25zdGFudHMudHMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uL3NyYy9lbnYvRW52Q29uc3RhbnRzLnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi9zcmMvZW52ZWxvcGVMb2NhdG9yL0VkaXRvckVudmVsb3BlTG9jYXRvckZhY3RvcnkudHMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uL3NyYy9leHRlbnNpb24vaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uL3NyYy9wcm9qZWN0L2luZGV4LnRzIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lzb21vcnBoaWMtZ2l0QDEuMTEuMS9ub2RlX21vZHVsZXMvaXNvbW9ycGhpYy1naXQvaHR0cC93ZWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vaXNvbW9ycGhpYy1naXRAMS4xMS4xL25vZGVfbW9kdWxlcy9pc29tb3JwaGljLWdpdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL0BraWUtdG9vbHMvc2VydmVybGVzcy1sb2dpYy13ZWItdG9vbHMvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9Aa2llLXRvb2xzL3NlcnZlcmxlc3MtbG9naWMtd2ViLXRvb2xzL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vQGtpZS10b29scy9zZXJ2ZXJsZXNzLWxvZ2ljLXdlYi10b29scy8uL3NyYy93b3Jrc3BhY2Uvd29ya2VyL3NoYXJlZFdvcmtlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBBc3luY0xvY2sgPSBmdW5jdGlvbiAob3B0cykge1xuXHRvcHRzID0gb3B0cyB8fCB7fTtcblxuXHR0aGlzLlByb21pc2UgPSBvcHRzLlByb21pc2UgfHwgUHJvbWlzZTtcblxuXHQvLyBmb3JtYXQ6IHtrZXkgOiBbZm4sIGZuXX1cblx0Ly8gcXVldWVzW2tleV0gPSBudWxsIGluZGljYXRlcyBubyBqb2IgcnVubmluZyBmb3Iga2V5XG5cdHRoaXMucXVldWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXHQvLyBsb2NrIGlzIHJlZW50cmFudCBmb3Igc2FtZSBkb21haW5cblx0dGhpcy5kb21haW5SZWVudHJhbnQgPSBvcHRzLmRvbWFpblJlZW50cmFudCB8fCBmYWxzZTtcblx0aWYgKHRoaXMuZG9tYWluUmVlbnRyYW50KSB7XG5cdFx0aWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgcHJvY2Vzcy5kb21haW4gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdCdEb21haW4tcmVlbnRyYW50IGxvY2tzIHJlcXVpcmUgYHByb2Nlc3MuZG9tYWluYCB0byBleGlzdC4gUGxlYXNlIGZsaXAgYG9wdHMuZG9tYWluUmVlbnRyYW50ID0gZmFsc2VgLCAnICtcblx0XHRcdFx0J3VzZSBhIE5vZGVKUyB2ZXJzaW9uIHRoYXQgc3RpbGwgaW1wbGVtZW50cyBEb21haW4sIG9yIGluc3RhbGwgYSBicm93c2VyIHBvbHlmaWxsLicpO1xuXHRcdH1cblx0XHQvLyBkb21haW4gb2YgY3VycmVudCBydW5uaW5nIGZ1bmMge2tleSA6IGZufVxuXHRcdHRoaXMuZG9tYWlucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdH1cblxuXHR0aGlzLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgfHwgQXN5bmNMb2NrLkRFRkFVTFRfVElNRU9VVDtcblx0dGhpcy5tYXhPY2N1cGF0aW9uVGltZSA9IG9wdHMubWF4T2NjdXBhdGlvblRpbWUgfHwgQXN5bmNMb2NrLkRFRkFVTFRfTUFYX09DQ1VQQVRJT05fVElNRTtcblx0aWYgKG9wdHMubWF4UGVuZGluZyA9PT0gSW5maW5pdHkgfHwgKE51bWJlci5pc0ludGVnZXIob3B0cy5tYXhQZW5kaW5nKSAmJiBvcHRzLm1heFBlbmRpbmcgPj0gMCkpIHtcblx0XHR0aGlzLm1heFBlbmRpbmcgPSBvcHRzLm1heFBlbmRpbmc7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5tYXhQZW5kaW5nID0gQXN5bmNMb2NrLkRFRkFVTFRfTUFYX1BFTkRJTkc7XG5cdH1cbn07XG5cbkFzeW5jTG9jay5ERUZBVUxUX1RJTUVPVVQgPSAwOyAvL05ldmVyXG5Bc3luY0xvY2suREVGQVVMVF9NQVhfT0NDVVBBVElPTl9USU1FID0gMDsgLy9OZXZlclxuQXN5bmNMb2NrLkRFRkFVTFRfTUFYX1BFTkRJTkcgPSAxMDAwO1xuXG4vKipcbiAqIEFjcXVpcmUgTG9ja3NcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0ga2V5IFx0cmVzb3VyY2Uga2V5IG9yIGtleXMgdG8gbG9ja1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gXHRhc3luYyBmdW5jdGlvblxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgXHRjYWxsYmFjayBmdW5jdGlvbiwgb3RoZXJ3aXNlIHdpbGwgcmV0dXJuIGEgcHJvbWlzZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgXHRvcHRpb25zXG4gKi9cbkFzeW5jTG9jay5wcm90b3R5cGUuYWNxdWlyZSA9IGZ1bmN0aW9uIChrZXksIGZuLCBjYiwgb3B0cykge1xuXHRpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjcXVpcmVCYXRjaChrZXksIGZuLCBjYiwgb3B0cyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIChmbikgIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSBmdW5jdGlvbiB0byBleGVjdXRlJyk7XG5cdH1cblxuXHQvLyBmYXV4LWRlZmVycmVkIHByb21pc2UgdXNpbmcgbmV3IFByb21pc2UoKSAoYXMgUHJvbWlzZS5kZWZlciBpcyBkZXByZWNhdGVkKVxuXHR2YXIgZGVmZXJyZWRSZXNvbHZlID0gbnVsbDtcblx0dmFyIGRlZmVycmVkUmVqZWN0ID0gbnVsbDtcblx0dmFyIGRlZmVycmVkID0gbnVsbDtcblxuXHRpZiAodHlwZW9mIChjYikgIT09ICdmdW5jdGlvbicpIHtcblx0XHRvcHRzID0gY2I7XG5cdFx0Y2IgPSBudWxsO1xuXG5cdFx0Ly8gd2lsbCByZXR1cm4gYSBwcm9taXNlXG5cdFx0ZGVmZXJyZWQgPSBuZXcgdGhpcy5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0ZGVmZXJyZWRSZXNvbHZlID0gcmVzb2x2ZTtcblx0XHRcdGRlZmVycmVkUmVqZWN0ID0gcmVqZWN0O1xuXHRcdH0pO1xuXHR9XG5cblx0b3B0cyA9IG9wdHMgfHwge307XG5cblx0dmFyIHJlc29sdmVkID0gZmFsc2U7XG5cdHZhciB0aW1lciA9IG51bGw7XG5cdHZhciBvY2N1cGF0aW9uVGltZXIgPSBudWxsO1xuXHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0dmFyIGRvbmUgPSBmdW5jdGlvbiAobG9ja2VkLCBlcnIsIHJldCkge1xuXG5cdFx0aWYgKG9jY3VwYXRpb25UaW1lcikge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KG9jY3VwYXRpb25UaW1lcik7XG5cdFx0XHRvY2N1cGF0aW9uVGltZXIgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChsb2NrZWQpIHtcblx0XHRcdGlmICghIXNlbGYucXVldWVzW2tleV0gJiYgc2VsZi5xdWV1ZXNba2V5XS5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0ZGVsZXRlIHNlbGYucXVldWVzW2tleV07XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2VsZi5kb21haW5SZWVudHJhbnQpIHtcblx0XHRcdFx0ZGVsZXRlIHNlbGYuZG9tYWluc1trZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICghcmVzb2x2ZWQpIHtcblx0XHRcdGlmICghZGVmZXJyZWQpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiAoY2IpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y2IoZXJyLCByZXQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Ly9wcm9taXNlIG1vZGVcblx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdGRlZmVycmVkUmVqZWN0KGVycik7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWRSZXNvbHZlKHJldCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJlc29sdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAobG9ja2VkKSB7XG5cdFx0XHQvL3J1biBuZXh0IGZ1bmNcblx0XHRcdGlmICghIXNlbGYucXVldWVzW2tleV0gJiYgc2VsZi5xdWV1ZXNba2V5XS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdHNlbGYucXVldWVzW2tleV0uc2hpZnQoKSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHR2YXIgZXhlYyA9IGZ1bmN0aW9uIChsb2NrZWQpIHtcblx0XHRpZiAocmVzb2x2ZWQpIHsgLy8gbWF5IGR1ZSB0byB0aW1lZCBvdXRcblx0XHRcdHJldHVybiBkb25lKGxvY2tlZCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRpbWVyKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdFx0dGltZXIgPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChzZWxmLmRvbWFpblJlZW50cmFudCAmJiBsb2NrZWQpIHtcblx0XHRcdHNlbGYuZG9tYWluc1trZXldID0gcHJvY2Vzcy5kb21haW47XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgbW9kZVxuXHRcdGlmIChmbi5sZW5ndGggPT09IDEpIHtcblx0XHRcdHZhciBjYWxsZWQgPSBmYWxzZTtcblx0XHRcdGZuKGZ1bmN0aW9uIChlcnIsIHJldCkge1xuXHRcdFx0XHRpZiAoIWNhbGxlZCkge1xuXHRcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0ZG9uZShsb2NrZWQsIGVyciwgcmV0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gUHJvbWlzZSBtb2RlXG5cdFx0XHRzZWxmLl9wcm9taXNlVHJ5KGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIGZuKCk7XG5cdFx0XHR9KVxuXHRcdFx0LnRoZW4oZnVuY3Rpb24ocmV0KXtcblx0XHRcdFx0ZG9uZShsb2NrZWQsIHVuZGVmaW5lZCwgcmV0KTtcblx0XHRcdH0sIGZ1bmN0aW9uKGVycm9yKXtcblx0XHRcdFx0ZG9uZShsb2NrZWQsIGVycm9yKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoc2VsZi5kb21haW5SZWVudHJhbnQgJiYgISFwcm9jZXNzLmRvbWFpbikge1xuXHRcdGV4ZWMgPSBwcm9jZXNzLmRvbWFpbi5iaW5kKGV4ZWMpO1xuXHR9XG5cblx0aWYgKCFzZWxmLnF1ZXVlc1trZXldKSB7XG5cdFx0c2VsZi5xdWV1ZXNba2V5XSA9IFtdO1xuXHRcdGV4ZWModHJ1ZSk7XG5cdH1cblx0ZWxzZSBpZiAoc2VsZi5kb21haW5SZWVudHJhbnQgJiYgISFwcm9jZXNzLmRvbWFpbiAmJiBwcm9jZXNzLmRvbWFpbiA9PT0gc2VsZi5kb21haW5zW2tleV0pIHtcblx0XHQvLyBJZiBjb2RlIGlzIGluIHRoZSBzYW1lIGRvbWFpbiBvZiBjdXJyZW50IHJ1bm5pbmcgdGFzaywgcnVuIGl0IGRpcmVjdGx5XG5cdFx0Ly8gU2luY2UgbG9jayBpcyByZS1lbnRlcmFibGVcblx0XHRleGVjKGZhbHNlKTtcblx0fVxuXHRlbHNlIGlmIChzZWxmLnF1ZXVlc1trZXldLmxlbmd0aCA+PSBzZWxmLm1heFBlbmRpbmcpIHtcblx0XHRkb25lKGZhbHNlLCBuZXcgRXJyb3IoJ1RvbyBtdWNoIHBlbmRpbmcgdGFza3MnKSk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0dmFyIHRhc2tGbiA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGV4ZWModHJ1ZSk7XG5cdFx0fTtcblx0XHRpZiAob3B0cy5za2lwUXVldWUpIHtcblx0XHRcdHNlbGYucXVldWVzW2tleV0udW5zaGlmdCh0YXNrRm4pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZWxmLnF1ZXVlc1trZXldLnB1c2godGFza0ZuKTtcblx0XHR9XG5cblx0XHR2YXIgdGltZW91dCA9IG9wdHMudGltZW91dCB8fCBzZWxmLnRpbWVvdXQ7XG5cdFx0aWYgKHRpbWVvdXQpIHtcblx0XHRcdHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRpbWVyID0gbnVsbDtcblx0XHRcdFx0ZG9uZShmYWxzZSwgbmV3IEVycm9yKCdhc3luYy1sb2NrIHRpbWVkIG91dCcpKTtcblx0XHRcdH0sIHRpbWVvdXQpO1xuXHRcdH1cblx0fVxuXG5cdHZhciBtYXhPY2N1cGF0aW9uVGltZSA9IG9wdHMubWF4T2NjdXBhdGlvblRpbWUgfHwgc2VsZi5tYXhPY2N1cGF0aW9uVGltZTtcblx0XHRpZiAobWF4T2NjdXBhdGlvblRpbWUpIHtcblx0XHRcdG9jY3VwYXRpb25UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAoISFzZWxmLnF1ZXVlc1trZXldKSB7XG5cdFx0XHRcdFx0ZG9uZShmYWxzZSwgbmV3IEVycm9yKCdNYXhpbXVtIG9jY3VwYXRpb24gdGltZSBpcyBleGNlZWRlZCcpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgbWF4T2NjdXBhdGlvblRpbWUpO1xuXHRcdH1cblxuXHRpZiAoZGVmZXJyZWQpIHtcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH1cbn07XG5cbi8qXG4gKiBCZWxvdyBpcyBob3cgdGhpcyBmdW5jdGlvbiB3b3JrczpcbiAqXG4gKiBFcXVpdmFsZW50IGNvZGU6XG4gKiBzZWxmLmFjcXVpcmUoa2V5MSwgZnVuY3Rpb24oY2Ipe1xuICogICAgIHNlbGYuYWNxdWlyZShrZXkyLCBmdW5jdGlvbihjYil7XG4gKiAgICAgICAgIHNlbGYuYWNxdWlyZShrZXkzLCBmbiwgY2IpO1xuICogICAgIH0sIGNiKTtcbiAqIH0sIGNiKTtcbiAqXG4gKiBFcXVpdmFsZW50IGNvZGU6XG4gKiB2YXIgZm4zID0gZ2V0Rm4oa2V5MywgZm4pO1xuICogdmFyIGZuMiA9IGdldEZuKGtleTIsIGZuMyk7XG4gKiB2YXIgZm4xID0gZ2V0Rm4oa2V5MSwgZm4yKTtcbiAqIGZuMShjYik7XG4gKi9cbkFzeW5jTG9jay5wcm90b3R5cGUuX2FjcXVpcmVCYXRjaCA9IGZ1bmN0aW9uIChrZXlzLCBmbiwgY2IsIG9wdHMpIHtcblx0aWYgKHR5cGVvZiAoY2IpICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0b3B0cyA9IGNiO1xuXHRcdGNiID0gbnVsbDtcblx0fVxuXG5cdHZhciBzZWxmID0gdGhpcztcblx0dmFyIGdldEZuID0gZnVuY3Rpb24gKGtleSwgZm4pIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKGNiKSB7XG5cdFx0XHRzZWxmLmFjcXVpcmUoa2V5LCBmbiwgY2IsIG9wdHMpO1xuXHRcdH07XG5cdH07XG5cblx0dmFyIGZueCA9IGZuO1xuXHRrZXlzLnJldmVyc2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRmbnggPSBnZXRGbihrZXksIGZueCk7XG5cdH0pO1xuXG5cdGlmICh0eXBlb2YgKGNiKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGZueChjYik7XG5cdH1cblx0ZWxzZSB7XG5cdFx0cmV0dXJuIG5ldyB0aGlzLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0Ly8gY2hlY2sgZm9yIHByb21pc2UgbW9kZSBpbiBjYXNlIGtleXMgaXMgZW1wdHkgYXJyYXlcblx0XHRcdGlmIChmbngubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdGZueChmdW5jdGlvbiAoZXJyLCByZXQpIHtcblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJldCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc29sdmUoZm54KCkpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG59O1xuXG4vKlxuICpcdFdoZXRoZXIgdGhlcmUgaXMgYW55IHJ1bm5pbmcgb3IgcGVuZGluZyBhc3luY0Z1bmNcbiAqXG4gKlx0QHBhcmFtIHtTdHJpbmd9IGtleVxuICovXG5Bc3luY0xvY2sucHJvdG90eXBlLmlzQnVzeSA9IGZ1bmN0aW9uIChrZXkpIHtcblx0aWYgKCFrZXkpIHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy5xdWV1ZXMpLmxlbmd0aCA+IDA7XG5cdH1cblx0ZWxzZSB7XG5cdFx0cmV0dXJuICEhdGhpcy5xdWV1ZXNba2V5XTtcblx0fVxufTtcblxuLyoqXG4gKiBQcm9taXNlLnRyeSgpIGltcGxlbWVudGF0aW9uIHRvIGJlY29tZSBpbmRlcGVuZGVudCBvZiBRLXNwZWNpZmljIG1ldGhvZHNcbiAqL1xuQXN5bmNMb2NrLnByb3RvdHlwZS5fcHJvbWlzZVRyeSA9IGZ1bmN0aW9uKGZuKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMuUHJvbWlzZS5yZXNvbHZlKGZuKCkpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIHRoaXMuUHJvbWlzZS5yZWplY3QoZSk7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXN5bmNMb2NrO1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBiYWxhbmNlZDtcbmZ1bmN0aW9uIGJhbGFuY2VkKGEsIGIsIHN0cikge1xuICBpZiAoYSBpbnN0YW5jZW9mIFJlZ0V4cCkgYSA9IG1heWJlTWF0Y2goYSwgc3RyKTtcbiAgaWYgKGIgaW5zdGFuY2VvZiBSZWdFeHApIGIgPSBtYXliZU1hdGNoKGIsIHN0cik7XG5cbiAgdmFyIHIgPSByYW5nZShhLCBiLCBzdHIpO1xuXG4gIHJldHVybiByICYmIHtcbiAgICBzdGFydDogclswXSxcbiAgICBlbmQ6IHJbMV0sXG4gICAgcHJlOiBzdHIuc2xpY2UoMCwgclswXSksXG4gICAgYm9keTogc3RyLnNsaWNlKHJbMF0gKyBhLmxlbmd0aCwgclsxXSksXG4gICAgcG9zdDogc3RyLnNsaWNlKHJbMV0gKyBiLmxlbmd0aClcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWF5YmVNYXRjaChyZWcsIHN0cikge1xuICB2YXIgbSA9IHN0ci5tYXRjaChyZWcpO1xuICByZXR1cm4gbSA/IG1bMF0gOiBudWxsO1xufVxuXG5iYWxhbmNlZC5yYW5nZSA9IHJhbmdlO1xuZnVuY3Rpb24gcmFuZ2UoYSwgYiwgc3RyKSB7XG4gIHZhciBiZWdzLCBiZWcsIGxlZnQsIHJpZ2h0LCByZXN1bHQ7XG4gIHZhciBhaSA9IHN0ci5pbmRleE9mKGEpO1xuICB2YXIgYmkgPSBzdHIuaW5kZXhPZihiLCBhaSArIDEpO1xuICB2YXIgaSA9IGFpO1xuXG4gIGlmIChhaSA+PSAwICYmIGJpID4gMCkge1xuICAgIGlmKGE9PT1iKSB7XG4gICAgICByZXR1cm4gW2FpLCBiaV07XG4gICAgfVxuICAgIGJlZ3MgPSBbXTtcbiAgICBsZWZ0ID0gc3RyLmxlbmd0aDtcblxuICAgIHdoaWxlIChpID49IDAgJiYgIXJlc3VsdCkge1xuICAgICAgaWYgKGkgPT0gYWkpIHtcbiAgICAgICAgYmVncy5wdXNoKGkpO1xuICAgICAgICBhaSA9IHN0ci5pbmRleE9mKGEsIGkgKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAoYmVncy5sZW5ndGggPT0gMSkge1xuICAgICAgICByZXN1bHQgPSBbIGJlZ3MucG9wKCksIGJpIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZWcgPSBiZWdzLnBvcCgpO1xuICAgICAgICBpZiAoYmVnIDwgbGVmdCkge1xuICAgICAgICAgIGxlZnQgPSBiZWc7XG4gICAgICAgICAgcmlnaHQgPSBiaTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJpID0gc3RyLmluZGV4T2YoYiwgaSArIDEpO1xuICAgICAgfVxuXG4gICAgICBpID0gYWkgPCBiaSAmJiBhaSA+PSAwID8gYWkgOiBiaTtcbiAgICB9XG5cbiAgICBpZiAoYmVncy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IFsgbGVmdCwgcmlnaHQgXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCJ2YXIgY29uY2F0TWFwID0gcmVxdWlyZSgnY29uY2F0LW1hcCcpO1xudmFyIGJhbGFuY2VkID0gcmVxdWlyZSgnYmFsYW5jZWQtbWF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBhbmRUb3A7XG5cbnZhciBlc2NTbGFzaCA9ICdcXDBTTEFTSCcrTWF0aC5yYW5kb20oKSsnXFwwJztcbnZhciBlc2NPcGVuID0gJ1xcME9QRU4nK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjQ2xvc2UgPSAnXFwwQ0xPU0UnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjQ29tbWEgPSAnXFwwQ09NTUEnK01hdGgucmFuZG9tKCkrJ1xcMCc7XG52YXIgZXNjUGVyaW9kID0gJ1xcMFBFUklPRCcrTWF0aC5yYW5kb20oKSsnXFwwJztcblxuZnVuY3Rpb24gbnVtZXJpYyhzdHIpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTApID09IHN0clxuICAgID8gcGFyc2VJbnQoc3RyLCAxMClcbiAgICA6IHN0ci5jaGFyQ29kZUF0KDApO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVCcmFjZXMoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoJ1xcXFxcXFxcJykuam9pbihlc2NTbGFzaClcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXHsnKS5qb2luKGVzY09wZW4pXG4gICAgICAgICAgICAuc3BsaXQoJ1xcXFx9Jykuam9pbihlc2NDbG9zZSlcbiAgICAgICAgICAgIC5zcGxpdCgnXFxcXCwnKS5qb2luKGVzY0NvbW1hKVxuICAgICAgICAgICAgLnNwbGl0KCdcXFxcLicpLmpvaW4oZXNjUGVyaW9kKTtcbn1cblxuZnVuY3Rpb24gdW5lc2NhcGVCcmFjZXMoc3RyKSB7XG4gIHJldHVybiBzdHIuc3BsaXQoZXNjU2xhc2gpLmpvaW4oJ1xcXFwnKVxuICAgICAgICAgICAgLnNwbGl0KGVzY09wZW4pLmpvaW4oJ3snKVxuICAgICAgICAgICAgLnNwbGl0KGVzY0Nsb3NlKS5qb2luKCd9JylcbiAgICAgICAgICAgIC5zcGxpdChlc2NDb21tYSkuam9pbignLCcpXG4gICAgICAgICAgICAuc3BsaXQoZXNjUGVyaW9kKS5qb2luKCcuJyk7XG59XG5cblxuLy8gQmFzaWNhbGx5IGp1c3Qgc3RyLnNwbGl0KFwiLFwiKSwgYnV0IGhhbmRsaW5nIGNhc2VzXG4vLyB3aGVyZSB3ZSBoYXZlIG5lc3RlZCBicmFjZWQgc2VjdGlvbnMsIHdoaWNoIHNob3VsZCBiZVxuLy8gdHJlYXRlZCBhcyBpbmRpdmlkdWFsIG1lbWJlcnMsIGxpa2Uge2Ese2IsY30sZH1cbmZ1bmN0aW9uIHBhcnNlQ29tbWFQYXJ0cyhzdHIpIHtcbiAgaWYgKCFzdHIpXG4gICAgcmV0dXJuIFsnJ107XG5cbiAgdmFyIHBhcnRzID0gW107XG4gIHZhciBtID0gYmFsYW5jZWQoJ3snLCAnfScsIHN0cik7XG5cbiAgaWYgKCFtKVxuICAgIHJldHVybiBzdHIuc3BsaXQoJywnKTtcblxuICB2YXIgcHJlID0gbS5wcmU7XG4gIHZhciBib2R5ID0gbS5ib2R5O1xuICB2YXIgcG9zdCA9IG0ucG9zdDtcbiAgdmFyIHAgPSBwcmUuc3BsaXQoJywnKTtcblxuICBwW3AubGVuZ3RoLTFdICs9ICd7JyArIGJvZHkgKyAnfSc7XG4gIHZhciBwb3N0UGFydHMgPSBwYXJzZUNvbW1hUGFydHMocG9zdCk7XG4gIGlmIChwb3N0Lmxlbmd0aCkge1xuICAgIHBbcC5sZW5ndGgtMV0gKz0gcG9zdFBhcnRzLnNoaWZ0KCk7XG4gICAgcC5wdXNoLmFwcGx5KHAsIHBvc3RQYXJ0cyk7XG4gIH1cblxuICBwYXJ0cy5wdXNoLmFwcGx5KHBhcnRzLCBwKTtcblxuICByZXR1cm4gcGFydHM7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFRvcChzdHIpIHtcbiAgaWYgKCFzdHIpXG4gICAgcmV0dXJuIFtdO1xuXG4gIC8vIEkgZG9uJ3Qga25vdyB3aHkgQmFzaCA0LjMgZG9lcyB0aGlzLCBidXQgaXQgZG9lcy5cbiAgLy8gQW55dGhpbmcgc3RhcnRpbmcgd2l0aCB7fSB3aWxsIGhhdmUgdGhlIGZpcnN0IHR3byBieXRlcyBwcmVzZXJ2ZWRcbiAgLy8gYnV0ICpvbmx5KiBhdCB0aGUgdG9wIGxldmVsLCBzbyB7fSxhfWIgd2lsbCBub3QgZXhwYW5kIHRvIGFueXRoaW5nLFxuICAvLyBidXQgYXt9LGJ9YyB3aWxsIGJlIGV4cGFuZGVkIHRvIFthfWMsYWJjXS5cbiAgLy8gT25lIGNvdWxkIGFyZ3VlIHRoYXQgdGhpcyBpcyBhIGJ1ZyBpbiBCYXNoLCBidXQgc2luY2UgdGhlIGdvYWwgb2ZcbiAgLy8gdGhpcyBtb2R1bGUgaXMgdG8gbWF0Y2ggQmFzaCdzIHJ1bGVzLCB3ZSBlc2NhcGUgYSBsZWFkaW5nIHt9XG4gIGlmIChzdHIuc3Vic3RyKDAsIDIpID09PSAne30nKSB7XG4gICAgc3RyID0gJ1xcXFx7XFxcXH0nICsgc3RyLnN1YnN0cigyKTtcbiAgfVxuXG4gIHJldHVybiBleHBhbmQoZXNjYXBlQnJhY2VzKHN0ciksIHRydWUpLm1hcCh1bmVzY2FwZUJyYWNlcyk7XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5KGUpIHtcbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIGVtYnJhY2Uoc3RyKSB7XG4gIHJldHVybiAneycgKyBzdHIgKyAnfSc7XG59XG5mdW5jdGlvbiBpc1BhZGRlZChlbCkge1xuICByZXR1cm4gL14tPzBcXGQvLnRlc3QoZWwpO1xufVxuXG5mdW5jdGlvbiBsdGUoaSwgeSkge1xuICByZXR1cm4gaSA8PSB5O1xufVxuZnVuY3Rpb24gZ3RlKGksIHkpIHtcbiAgcmV0dXJuIGkgPj0geTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kKHN0ciwgaXNUb3ApIHtcbiAgdmFyIGV4cGFuc2lvbnMgPSBbXTtcblxuICB2YXIgbSA9IGJhbGFuY2VkKCd7JywgJ30nLCBzdHIpO1xuICBpZiAoIW0gfHwgL1xcJCQvLnRlc3QobS5wcmUpKSByZXR1cm4gW3N0cl07XG5cbiAgdmFyIGlzTnVtZXJpY1NlcXVlbmNlID0gL14tP1xcZCtcXC5cXC4tP1xcZCsoPzpcXC5cXC4tP1xcZCspPyQvLnRlc3QobS5ib2R5KTtcbiAgdmFyIGlzQWxwaGFTZXF1ZW5jZSA9IC9eW2EtekEtWl1cXC5cXC5bYS16QS1aXSg/OlxcLlxcLi0/XFxkKyk/JC8udGVzdChtLmJvZHkpO1xuICB2YXIgaXNTZXF1ZW5jZSA9IGlzTnVtZXJpY1NlcXVlbmNlIHx8IGlzQWxwaGFTZXF1ZW5jZTtcbiAgdmFyIGlzT3B0aW9ucyA9IG0uYm9keS5pbmRleE9mKCcsJykgPj0gMDtcbiAgaWYgKCFpc1NlcXVlbmNlICYmICFpc09wdGlvbnMpIHtcbiAgICAvLyB7YX0sYn1cbiAgICBpZiAobS5wb3N0Lm1hdGNoKC8sLipcXH0vKSkge1xuICAgICAgc3RyID0gbS5wcmUgKyAneycgKyBtLmJvZHkgKyBlc2NDbG9zZSArIG0ucG9zdDtcbiAgICAgIHJldHVybiBleHBhbmQoc3RyKTtcbiAgICB9XG4gICAgcmV0dXJuIFtzdHJdO1xuICB9XG5cbiAgdmFyIG47XG4gIGlmIChpc1NlcXVlbmNlKSB7XG4gICAgbiA9IG0uYm9keS5zcGxpdCgvXFwuXFwuLyk7XG4gIH0gZWxzZSB7XG4gICAgbiA9IHBhcnNlQ29tbWFQYXJ0cyhtLmJvZHkpO1xuICAgIGlmIChuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8geHt7YSxifX15ID09PiB4e2F9eSB4e2J9eVxuICAgICAgbiA9IGV4cGFuZChuWzBdLCBmYWxzZSkubWFwKGVtYnJhY2UpO1xuICAgICAgaWYgKG4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBwb3N0ID0gbS5wb3N0Lmxlbmd0aFxuICAgICAgICAgID8gZXhwYW5kKG0ucG9zdCwgZmFsc2UpXG4gICAgICAgICAgOiBbJyddO1xuICAgICAgICByZXR1cm4gcG9zdC5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBtLnByZSArIG5bMF0gKyBwO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBhdCB0aGlzIHBvaW50LCBuIGlzIHRoZSBwYXJ0cywgYW5kIHdlIGtub3cgaXQncyBub3QgYSBjb21tYSBzZXRcbiAgLy8gd2l0aCBhIHNpbmdsZSBlbnRyeS5cblxuICAvLyBubyBuZWVkIHRvIGV4cGFuZCBwcmUsIHNpbmNlIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgZnJlZSBvZiBicmFjZS1zZXRzXG4gIHZhciBwcmUgPSBtLnByZTtcbiAgdmFyIHBvc3QgPSBtLnBvc3QubGVuZ3RoXG4gICAgPyBleHBhbmQobS5wb3N0LCBmYWxzZSlcbiAgICA6IFsnJ107XG5cbiAgdmFyIE47XG5cbiAgaWYgKGlzU2VxdWVuY2UpIHtcbiAgICB2YXIgeCA9IG51bWVyaWMoblswXSk7XG4gICAgdmFyIHkgPSBudW1lcmljKG5bMV0pO1xuICAgIHZhciB3aWR0aCA9IE1hdGgubWF4KG5bMF0ubGVuZ3RoLCBuWzFdLmxlbmd0aClcbiAgICB2YXIgaW5jciA9IG4ubGVuZ3RoID09IDNcbiAgICAgID8gTWF0aC5hYnMobnVtZXJpYyhuWzJdKSlcbiAgICAgIDogMTtcbiAgICB2YXIgdGVzdCA9IGx0ZTtcbiAgICB2YXIgcmV2ZXJzZSA9IHkgPCB4O1xuICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICBpbmNyICo9IC0xO1xuICAgICAgdGVzdCA9IGd0ZTtcbiAgICB9XG4gICAgdmFyIHBhZCA9IG4uc29tZShpc1BhZGRlZCk7XG5cbiAgICBOID0gW107XG5cbiAgICBmb3IgKHZhciBpID0geDsgdGVzdChpLCB5KTsgaSArPSBpbmNyKSB7XG4gICAgICB2YXIgYztcbiAgICAgIGlmIChpc0FscGhhU2VxdWVuY2UpIHtcbiAgICAgICAgYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgICAgIGlmIChjID09PSAnXFxcXCcpXG4gICAgICAgICAgYyA9ICcnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYyA9IFN0cmluZyhpKTtcbiAgICAgICAgaWYgKHBhZCkge1xuICAgICAgICAgIHZhciBuZWVkID0gd2lkdGggLSBjLmxlbmd0aDtcbiAgICAgICAgICBpZiAobmVlZCA+IDApIHtcbiAgICAgICAgICAgIHZhciB6ID0gbmV3IEFycmF5KG5lZWQgKyAxKS5qb2luKCcwJyk7XG4gICAgICAgICAgICBpZiAoaSA8IDApXG4gICAgICAgICAgICAgIGMgPSAnLScgKyB6ICsgYy5zbGljZSgxKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYyA9IHogKyBjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgTi5wdXNoKGMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBOID0gY29uY2F0TWFwKG4sIGZ1bmN0aW9uKGVsKSB7IHJldHVybiBleHBhbmQoZWwsIGZhbHNlKSB9KTtcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgTi5sZW5ndGg7IGorKykge1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcG9zdC5sZW5ndGg7IGsrKykge1xuICAgICAgdmFyIGV4cGFuc2lvbiA9IHByZSArIE5bal0gKyBwb3N0W2tdO1xuICAgICAgaWYgKCFpc1RvcCB8fCBpc1NlcXVlbmNlIHx8IGV4cGFuc2lvbilcbiAgICAgICAgZXhwYW5zaW9ucy5wdXNoKGV4cGFuc2lvbik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cGFuc2lvbnM7XG59XG5cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuY29uc3QgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgbGV0IGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICBjb25zdCBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICBsZXQgeCA9IGEubGVuZ3RoXG4gIGxldCB5ID0gYi5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGxldCBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgbGV0IHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGNvbnN0IG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIGNvbnN0IGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIGxldCBzdHIgPSAnJ1xuICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgbGV0IHkgPSBlbmQgLSBzdGFydFxuICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICBsZXQgaW5kZXhTaXplID0gMVxuICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICBsZXQgaVxuICBpZiAoZGlyKSB7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIGNvbnN0IHJlcyA9IFtdXG5cbiAgbGV0IGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIGxldCBjb2RlUG9pbnQgPSBudWxsXG4gICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5jb25zdCBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgbGV0IG91dCA9ICcnXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgbGV0IHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICBsZXQgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGxvID0gZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNFxuXG4gIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIGxhc3QgKiAyICoqIDI0XG5cbiAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3RcblxuICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoXG4gIGxldCBtdWwgPSAxXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICtcbiAgICB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICtcbiAgICB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArXG4gICAgKGxhc3QgPDwgMjQpIC8vIE92ZXJmbG93XG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIC8vIE92ZXJmbG93XG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRMRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyA3XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNl0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDVdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA0XSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgM10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDJdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0XSA9IGhpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gMFxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICBsZXQgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBDVVNUT00gRVJST1JTXG4vLyA9PT09PT09PT09PT09XG5cbi8vIFNpbXBsaWZpZWQgdmVyc2lvbnMgZnJvbSBOb2RlLCBjaGFuZ2VkIGZvciBCdWZmZXItb25seSB1c2FnZVxuY29uc3QgZXJyb3JzID0ge31cbmZ1bmN0aW9uIEUgKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYFxuICAgICAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgICAgIC8vIGZyb20gdGhlIG5hbWUuXG4gICAgICB0aGlzLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG4gICAgICBkZWxldGUgdGhpcy5uYW1lXG4gICAgfVxuXG4gICAgZ2V0IGNvZGUgKCkge1xuICAgICAgcmV0dXJuIHN5bVxuICAgIH1cblxuICAgIHNldCBjb2RlICh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuICBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYFxuICAgIH1cblxuICAgIHJldHVybiAnQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcydcbiAgfSwgUmFuZ2VFcnJvcilcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgZnVuY3Rpb24gKG5hbWUsIGFjdHVhbCkge1xuICAgIHJldHVybiBgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWBcbiAgfSwgVHlwZUVycm9yKVxuRSgnRVJSX09VVF9PRl9SQU5HRScsXG4gIGZ1bmN0aW9uIChzdHIsIHJhbmdlLCBpbnB1dCkge1xuICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLmBcbiAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7XG4gICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKVxuICAgICAgfVxuICAgICAgcmVjZWl2ZWQgKz0gJ24nXG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YFxuICAgIHJldHVybiBtc2dcbiAgfSwgUmFuZ2VFcnJvcilcblxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yICh2YWwpIHtcbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gdmFsLmxlbmd0aFxuICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gJy0nID8gMSA6IDBcbiAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHtcbiAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gXG4gIH1cbiAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gXG59XG5cbi8vIENIRUNLIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRzIChidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBpZiAoYnVmW29mZnNldF0gPT09IHVuZGVmaW5lZCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoICsgMSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRCSSAodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gJ2JpZ2ludCcgPyAnbicgOiAnJ1xuICAgIGxldCByYW5nZVxuICAgIGlmIChieXRlTGVuZ3RoID4gMykge1xuICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4fSR7bn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogYCArXG4gICAgICAgICAgICAgICAgYCR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gXG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgndmFsdWUnLCByYW5nZSwgdmFsdWUpXG4gIH1cbiAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyICh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0Vycm9yICh2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSlcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JywgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKVxuICB9XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUpXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuY29uc3QgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIGxldCBjb2RlUG9pbnRcbiAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIGxldCBjLCBoaSwgbG9cbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxuY29uc3QgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgY29uc3QgaTE2ID0gaSAqIDE2XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG5cbi8vIFJldHVybiBub3QgZnVuY3Rpb24gd2l0aCBFcnJvciBpZiBCaWdJbnQgbm90IHN1cHBvcnRlZFxuZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kIChmbikge1xuICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm5cbn1cblxuZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmlnSW50IG5vdCBzdXBwb3J0ZWQnKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VBbGwoc3RyLCBzZWFyY2gsIHJlcGxhY2VtZW50KSB7XG4gIHNlYXJjaCA9IHNlYXJjaCBpbnN0YW5jZW9mIFJlZ0V4cCA/IHNlYXJjaCA6IG5ldyBSZWdFeHAoZXNjYXBlUmVnRXhwKHNlYXJjaCksICdnJyk7XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHNlYXJjaCwgcmVwbGFjZW1lbnQpO1xufVxuXG52YXIgQ2xlYW5HaXRSZWYgPSB7XG4gIGNsZWFuOiBmdW5jdGlvbiBjbGVhbih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nLCByZWNlaXZlZDogJyArIHZhbHVlKTtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IHJlcGxhY2VBbGwodmFsdWUsICcuLycsICcvJyk7XG4gICAgdmFsdWUgPSByZXBsYWNlQWxsKHZhbHVlLCAnLi4nLCAnLicpO1xuICAgIHZhbHVlID0gcmVwbGFjZUFsbCh2YWx1ZSwgJyAnLCAnLScpO1xuICAgIHZhbHVlID0gcmVwbGFjZUFsbCh2YWx1ZSwgL15bfl46PypcXFxcXFwtXS9nLCAnJyk7XG4gICAgdmFsdWUgPSByZXBsYWNlQWxsKHZhbHVlLCAvW35eOj8qXFxcXF0vZywgJy0nKTtcbiAgICB2YWx1ZSA9IHJlcGxhY2VBbGwodmFsdWUsIC9bfl46PypcXFxcXFwtXSQvZywgJycpO1xuICAgIHZhbHVlID0gcmVwbGFjZUFsbCh2YWx1ZSwgJ0B7JywgJy0nKTtcbiAgICB2YWx1ZSA9IHJlcGxhY2VBbGwodmFsdWUsIC9cXC4kL2csICcnKTtcbiAgICB2YWx1ZSA9IHJlcGxhY2VBbGwodmFsdWUsIC9cXC8kL2csICcnKTtcbiAgICB2YWx1ZSA9IHJlcGxhY2VBbGwodmFsdWUsIC9cXC5sb2NrJC9nLCAnJyk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsZWFuR2l0UmVmOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHhzLCBmbikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB4ID0gZm4oeHNbaV0sIGkpO1xuICAgICAgICBpZiAoaXNBcnJheSh4KSkgcmVzLnB1c2guYXBwbHkocmVzLCB4KTtcbiAgICAgICAgZWxzZSByZXMucHVzaCh4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKiBjcmMzMi5qcyAoQykgMjAxNC1wcmVzZW50IFNoZWV0SlMgLS0gaHR0cDovL3NoZWV0anMuY29tICovXG4vKiB2aW06IHNldCB0cz0yOiAqL1xuLypleHBvcnRlZCBDUkMzMiAqL1xudmFyIENSQzMyO1xuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG5cdC8qanNoaW50IGlnbm9yZTpzdGFydCAqL1xuXHQvKmVzbGludC1kaXNhYmxlICovXG5cdGlmKHR5cGVvZiBET19OT1RfRVhQT1JUX0NSQyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRpZignb2JqZWN0JyA9PT0gdHlwZW9mIGV4cG9ydHMpIHtcblx0XHRcdGZhY3RvcnkoZXhwb3J0cyk7XG5cdFx0fSBlbHNlIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcblx0XHRcdGRlZmluZShmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHZhciBtb2R1bGUgPSB7fTtcblx0XHRcdFx0ZmFjdG9yeShtb2R1bGUpO1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZhY3RvcnkoQ1JDMzIgPSB7fSk7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoQ1JDMzIgPSB7fSk7XG5cdH1cblx0Lyplc2xpbnQtZW5hYmxlICovXG5cdC8qanNoaW50IGlnbm9yZTplbmQgKi9cbn0oZnVuY3Rpb24oQ1JDMzIpIHtcbkNSQzMyLnZlcnNpb24gPSAnMS4yLjAnO1xuLyogc2VlIHBlcmYvY3JjMzJ0YWJsZS5qcyAqL1xuLypnbG9iYWwgSW50MzJBcnJheSAqL1xuZnVuY3Rpb24gc2lnbmVkX2NyY190YWJsZSgpIHtcblx0dmFyIGMgPSAwLCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpO1xuXG5cdGZvcih2YXIgbiA9MDsgbiAhPSAyNTY7ICsrbil7XG5cdFx0YyA9IG47XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0YyA9ICgoYyYxKSA/ICgtMzA2Njc0OTEyIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG5cdFx0dGFibGVbbl0gPSBjO1xuXHR9XG5cblx0cmV0dXJuIHR5cGVvZiBJbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyA/IG5ldyBJbnQzMkFycmF5KHRhYmxlKSA6IHRhYmxlO1xufVxuXG52YXIgVCA9IHNpZ25lZF9jcmNfdGFibGUoKTtcbmZ1bmN0aW9uIGNyYzMyX2JzdHIoYnN0ciwgc2VlZCkge1xuXHR2YXIgQyA9IHNlZWQgXiAtMSwgTCA9IGJzdHIubGVuZ3RoIC0gMTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IEw7KSB7XG5cdFx0QyA9IChDPj4+OCkgXiBUWyhDXmJzdHIuY2hhckNvZGVBdChpKyspKSYweEZGXTtcblx0XHRDID0gKEM+Pj44KSBeIFRbKENeYnN0ci5jaGFyQ29kZUF0KGkrKykpJjB4RkZdO1xuXHR9XG5cdGlmKGkgPT09IEwpIEMgPSAoQz4+PjgpIF4gVFsoQyBeIGJzdHIuY2hhckNvZGVBdChpKSkmMHhGRl07XG5cdHJldHVybiBDIF4gLTE7XG59XG5cbmZ1bmN0aW9uIGNyYzMyX2J1ZihidWYsIHNlZWQpIHtcblx0aWYoYnVmLmxlbmd0aCA+IDEwMDAwKSByZXR1cm4gY3JjMzJfYnVmXzgoYnVmLCBzZWVkKTtcblx0dmFyIEMgPSBzZWVkIF4gLTEsIEwgPSBidWYubGVuZ3RoIC0gMztcblx0Zm9yKHZhciBpID0gMDsgaSA8IEw7KSB7XG5cdFx0QyA9IChDPj4+OCkgXiBUWyhDXmJ1ZltpKytdKSYweEZGXTtcblx0XHRDID0gKEM+Pj44KSBeIFRbKENeYnVmW2krK10pJjB4RkZdO1xuXHRcdEMgPSAoQz4+PjgpIF4gVFsoQ15idWZbaSsrXSkmMHhGRl07XG5cdFx0QyA9IChDPj4+OCkgXiBUWyhDXmJ1ZltpKytdKSYweEZGXTtcblx0fVxuXHR3aGlsZShpIDwgTCszKSBDID0gKEM+Pj44KSBeIFRbKENeYnVmW2krK10pJjB4RkZdO1xuXHRyZXR1cm4gQyBeIC0xO1xufVxuXG5mdW5jdGlvbiBjcmMzMl9idWZfOChidWYsIHNlZWQpIHtcblx0dmFyIEMgPSBzZWVkIF4gLTEsIEwgPSBidWYubGVuZ3RoIC0gNztcblx0Zm9yKHZhciBpID0gMDsgaSA8IEw7KSB7XG5cdFx0QyA9IChDPj4+OCkgXiBUWyhDXmJ1ZltpKytdKSYweEZGXTtcblx0XHRDID0gKEM+Pj44KSBeIFRbKENeYnVmW2krK10pJjB4RkZdO1xuXHRcdEMgPSAoQz4+PjgpIF4gVFsoQ15idWZbaSsrXSkmMHhGRl07XG5cdFx0QyA9IChDPj4+OCkgXiBUWyhDXmJ1ZltpKytdKSYweEZGXTtcblx0XHRDID0gKEM+Pj44KSBeIFRbKENeYnVmW2krK10pJjB4RkZdO1xuXHRcdEMgPSAoQz4+PjgpIF4gVFsoQ15idWZbaSsrXSkmMHhGRl07XG5cdFx0QyA9IChDPj4+OCkgXiBUWyhDXmJ1ZltpKytdKSYweEZGXTtcblx0XHRDID0gKEM+Pj44KSBeIFRbKENeYnVmW2krK10pJjB4RkZdO1xuXHR9XG5cdHdoaWxlKGkgPCBMKzcpIEMgPSAoQz4+PjgpIF4gVFsoQ15idWZbaSsrXSkmMHhGRl07XG5cdHJldHVybiBDIF4gLTE7XG59XG5cbmZ1bmN0aW9uIGNyYzMyX3N0cihzdHIsIHNlZWQpIHtcblx0dmFyIEMgPSBzZWVkIF4gLTE7XG5cdGZvcih2YXIgaSA9IDAsIEw9c3RyLmxlbmd0aCwgYywgZDsgaSA8IEw7KSB7XG5cdFx0YyA9IHN0ci5jaGFyQ29kZUF0KGkrKyk7XG5cdFx0aWYoYyA8IDB4ODApIHtcblx0XHRcdEMgPSAoQz4+PjgpIF4gVFsoQyBeIGMpJjB4RkZdO1xuXHRcdH0gZWxzZSBpZihjIDwgMHg4MDApIHtcblx0XHRcdEMgPSAoQz4+PjgpIF4gVFsoQyBeICgxOTJ8KChjPj42KSYzMSkpKSYweEZGXTtcblx0XHRcdEMgPSAoQz4+PjgpIF4gVFsoQyBeICgxMjh8KGMmNjMpKSkmMHhGRl07XG5cdFx0fSBlbHNlIGlmKGMgPj0gMHhEODAwICYmIGMgPCAweEUwMDApIHtcblx0XHRcdGMgPSAoYyYxMDIzKSs2NDsgZCA9IHN0ci5jaGFyQ29kZUF0KGkrKykmMTAyMztcblx0XHRcdEMgPSAoQz4+PjgpIF4gVFsoQyBeICgyNDB8KChjPj44KSY3KSkpJjB4RkZdO1xuXHRcdFx0QyA9IChDPj4+OCkgXiBUWyhDIF4gKDEyOHwoKGM+PjIpJjYzKSkpJjB4RkZdO1xuXHRcdFx0QyA9IChDPj4+OCkgXiBUWyhDIF4gKDEyOHwoKGQ+PjYpJjE1KXwoKGMmMyk8PDQpKSkmMHhGRl07XG5cdFx0XHRDID0gKEM+Pj44KSBeIFRbKEMgXiAoMTI4fChkJjYzKSkpJjB4RkZdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRDID0gKEM+Pj44KSBeIFRbKEMgXiAoMjI0fCgoYz4+MTIpJjE1KSkpJjB4RkZdO1xuXHRcdFx0QyA9IChDPj4+OCkgXiBUWyhDIF4gKDEyOHwoKGM+PjYpJjYzKSkpJjB4RkZdO1xuXHRcdFx0QyA9IChDPj4+OCkgXiBUWyhDIF4gKDEyOHwoYyY2MykpKSYweEZGXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIEMgXiAtMTtcbn1cbkNSQzMyLnRhYmxlID0gVDtcbi8vICRGbG93SWdub3JlXG5DUkMzMi5ic3RyID0gY3JjMzJfYnN0cjtcbi8vICRGbG93SWdub3JlXG5DUkMzMi5idWYgPSBjcmMzMl9idWY7XG4vLyAkRmxvd0lnbm9yZVxuQ1JDMzIuc3RyID0gY3JjMzJfc3RyO1xufSkpO1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDA2LCAyMDA4IFRvbnkgR2Fybm9jay1Kb25lcyA8dG9ueWdAbHNoaWZ0Lm5ldD5cbi8vIENvcHlyaWdodCAoYykgMjAwNiwgMjAwOCBMU2hpZnQgTHRkLiA8cXVlcnlAbHNoaWZ0Lm5ldD5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuLy8gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbi8vICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbi8vIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4vLyBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuLy8gYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbi8vIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4vLyBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuLy8gRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuLy8gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuLy8gQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuLy8gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuLy8gU09GVFdBUkUuXG5cbnZhciBvbnAgPSByZXF1aXJlKCcuL29ucCcpO1xuXG5mdW5jdGlvbiBsb25nZXN0Q29tbW9uU3Vic2VxdWVuY2UoZmlsZTEsIGZpbGUyKSB7XG4gIHZhciBkaWZmID0gbmV3IG9ucChmaWxlMSwgZmlsZTIpO1xuICBkaWZmLmNvbXBvc2UoKTtcbiAgdmFyIHNlcyA9IGRpZmYuZ2V0c2VzKCk7XG5cbiAgdmFyIHJvb3Q7XG4gIHZhciBwcmV2O1xuICB2YXIgZmlsZTFSZXZJZHggPSBmaWxlMS5sZW5ndGggLSAxLFxuICAgICAgZmlsZTJSZXZJZHggPSBmaWxlMi5sZW5ndGggLSAxO1xuICBmb3IgKHZhciBpID0gc2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAoc2VzW2ldLnQgPT09IGRpZmYuU0VTX0NPTU1PTikge1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgIHByZXYuY2hhaW4gPSB7XG4gICAgICAgICAgICBmaWxlMWluZGV4OiBmaWxlMVJldklkeCxcbiAgICAgICAgICAgIGZpbGUyaW5kZXg6IGZpbGUyUmV2SWR4LFxuICAgICAgICAgICAgY2hhaW46IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHByZXYgPSBwcmV2LmNoYWluO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvb3QgPSB7XG4gICAgICAgICAgICBmaWxlMWluZGV4OiBmaWxlMVJldklkeCxcbiAgICAgICAgICAgIGZpbGUyaW5kZXg6IGZpbGUyUmV2SWR4LFxuICAgICAgICAgICAgY2hhaW46IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHByZXYgPSByb290O1xuICAgICAgICB9XG4gICAgICAgIGZpbGUxUmV2SWR4LS07XG4gICAgICAgIGZpbGUyUmV2SWR4LS07XG4gICAgICB9IGVsc2UgaWYgKHNlc1tpXS50ID09PSBkaWZmLlNFU19ERUxFVEUpIHtcbiAgICAgICAgZmlsZTFSZXZJZHgtLTtcbiAgICAgIH0gZWxzZSBpZiAoc2VzW2ldLnQgPT09IGRpZmYuU0VTX0FERCkge1xuICAgICAgICBmaWxlMlJldklkeC0tO1xuICAgICAgfVxuICB9XG5cbiAgdmFyIHRhaWwgPSB7XG4gICAgZmlsZTFpbmRleDogLTEsXG4gICAgZmlsZTJpbmRleDogLTEsXG4gICAgY2hhaW46IG51bGxcbiAgfTtcblxuICBpZiAoIXByZXYpIHtcbiAgICByZXR1cm4gdGFpbDtcbiAgfVxuXG4gIHByZXYuY2hhaW4gPSB0YWlsO1xuXG4gIHJldHVybiByb290O1xufVxuXG5mdW5jdGlvbiBkaWZmSW5kaWNlcyhmaWxlMSwgZmlsZTIpIHtcbiAgLy8gV2UgYXBwbHkgdGhlIExDUyB0byBnaXZlIGEgc2ltcGxlIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAvLyBvZmZzZXRzIGFuZCBsZW5ndGhzIG9mIG1pc21hdGNoZWQgY2h1bmtzIGluIHRoZSBpbnB1dFxuICAvLyBmaWxlcy4gVGhpcyBpcyB1c2VkIGJ5IGRpZmYzX21lcmdlX2luZGljZXMgYmVsb3cuXG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgdGFpbDEgPSBmaWxlMS5sZW5ndGg7XG4gIHZhciB0YWlsMiA9IGZpbGUyLmxlbmd0aDtcblxuICBmb3IgKHZhciBjYW5kaWRhdGUgPSBsb25nZXN0Q29tbW9uU3Vic2VxdWVuY2UoZmlsZTEsIGZpbGUyKTsgY2FuZGlkYXRlICE9PSBudWxsOyBjYW5kaWRhdGUgPSBjYW5kaWRhdGUuY2hhaW4pIHtcbiAgICB2YXIgbWlzbWF0Y2hMZW5ndGgxID0gdGFpbDEgLSBjYW5kaWRhdGUuZmlsZTFpbmRleCAtIDE7XG4gICAgdmFyIG1pc21hdGNoTGVuZ3RoMiA9IHRhaWwyIC0gY2FuZGlkYXRlLmZpbGUyaW5kZXggLSAxO1xuICAgIHRhaWwxID0gY2FuZGlkYXRlLmZpbGUxaW5kZXg7XG4gICAgdGFpbDIgPSBjYW5kaWRhdGUuZmlsZTJpbmRleDtcblxuICAgIGlmIChtaXNtYXRjaExlbmd0aDEgfHwgbWlzbWF0Y2hMZW5ndGgyKSB7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIGZpbGUxOiBbdGFpbDEgKyAxLCBtaXNtYXRjaExlbmd0aDFdLFxuICAgICAgICBmaWxlMjogW3RhaWwyICsgMSwgbWlzbWF0Y2hMZW5ndGgyXVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmVzdWx0LnJldmVyc2UoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZGlmZjNNZXJnZUluZGljZXMoYSwgbywgYikge1xuICAvLyBHaXZlbiB0aHJlZSBmaWxlcywgQSwgTywgYW5kIEIsIHdoZXJlIGJvdGggQSBhbmQgQiBhcmVcbiAgLy8gaW5kZXBlbmRlbnRseSBkZXJpdmVkIGZyb20gTywgcmV0dXJucyBhIGZhaXJseSBjb21wbGljYXRlZFxuICAvLyBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBtZXJnZSBkZWNpc2lvbnMgaXQncyB0YWtlbi4gVGhlXG4gIC8vIGludGVyZXN0ZWQgcmVhZGVyIG1heSB3aXNoIHRvIGNvbnN1bHRcbiAgLy9cbiAgLy8gU2FuamVldiBLaGFubmEsIEtlc2hhdiBLdW5hbCwgYW5kIEJlbmphbWluIEMuIFBpZXJjZS4gXCJBXG4gIC8vIEZvcm1hbCBJbnZlc3RpZ2F0aW9uIG9mIERpZmYzLlwiIEluIEFydmluZCBhbmQgUHJhc2FkLFxuICAvLyBlZGl0b3JzLCBGb3VuZGF0aW9ucyBvZiBTb2Z0d2FyZSBUZWNobm9sb2d5IGFuZCBUaGVvcmV0aWNhbFxuICAvLyBDb21wdXRlciBTY2llbmNlIChGU1RUQ1MpLCBEZWNlbWJlciAyMDA3LlxuICAvL1xuICAvLyAoaHR0cDovL3d3dy5jaXMudXBlbm4uZWR1L35iY3BpZXJjZS9wYXBlcnMvZGlmZjMtc2hvcnQucGRmKVxuICB2YXIgaTtcblxuICB2YXIgbTEgPSBkaWZmSW5kaWNlcyhvLCBhKTtcbiAgdmFyIG0yID0gZGlmZkluZGljZXMobywgYik7XG5cbiAgdmFyIGh1bmtzID0gW107XG5cbiAgZnVuY3Rpb24gYWRkSHVuayhoLCBzaWRlKSB7XG4gICAgaHVua3MucHVzaChbaC5maWxlMVswXSwgc2lkZSwgaC5maWxlMVsxXSwgaC5maWxlMlswXSwgaC5maWxlMlsxXV0pO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBtMS5sZW5ndGg7IGkrKykge1xuICAgIGFkZEh1bmsobTFbaV0sIDApO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBtMi5sZW5ndGg7IGkrKykge1xuICAgIGFkZEh1bmsobTJbaV0sIDIpO1xuICB9XG4gIGh1bmtzLnNvcnQoZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB4WzBdIC0geVswXVxuICB9KTtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBjb21tb25PZmZzZXQgPSAwO1xuXG4gIGZ1bmN0aW9uIGNvcHlDb21tb24odGFyZ2V0T2Zmc2V0KSB7XG4gICAgaWYgKHRhcmdldE9mZnNldCA+IGNvbW1vbk9mZnNldCkge1xuICAgICAgcmVzdWx0LnB1c2goWzEsIGNvbW1vbk9mZnNldCwgdGFyZ2V0T2Zmc2V0IC0gY29tbW9uT2Zmc2V0XSk7XG4gICAgICBjb21tb25PZmZzZXQgPSB0YXJnZXRPZmZzZXQ7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaHVua0luZGV4ID0gMDsgaHVua0luZGV4IDwgaHVua3MubGVuZ3RoOyBodW5rSW5kZXgrKykge1xuICAgIHZhciBmaXJzdEh1bmtJbmRleCA9IGh1bmtJbmRleDtcbiAgICB2YXIgaHVuayA9IGh1bmtzW2h1bmtJbmRleF07XG4gICAgdmFyIHJlZ2lvbkxocyA9IGh1bmtbMF07XG4gICAgdmFyIHJlZ2lvblJocyA9IHJlZ2lvbkxocyArIGh1bmtbMl07XG4gICAgd2hpbGUgKGh1bmtJbmRleCA8IGh1bmtzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHZhciBtYXliZU92ZXJsYXBwaW5nID0gaHVua3NbaHVua0luZGV4ICsgMV07XG4gICAgICB2YXIgbWF5YmVMaHMgPSBtYXliZU92ZXJsYXBwaW5nWzBdO1xuICAgICAgaWYgKG1heWJlTGhzID4gcmVnaW9uUmhzKSBicmVhaztcbiAgICAgIHJlZ2lvblJocyA9IE1hdGgubWF4KHJlZ2lvblJocywgbWF5YmVMaHMgKyBtYXliZU92ZXJsYXBwaW5nWzJdKTtcbiAgICAgIGh1bmtJbmRleCsrO1xuICAgIH1cblxuICAgIGNvcHlDb21tb24ocmVnaW9uTGhzKTtcbiAgICBpZiAoZmlyc3RIdW5rSW5kZXggPT0gaHVua0luZGV4KSB7XG4gICAgICAvLyBUaGUgXCJvdmVybGFwXCIgd2FzIG9ubHkgb25lIGh1bmsgbG9uZywgbWVhbmluZyB0aGF0XG4gICAgICAvLyB0aGVyZSdzIG5vIGNvbmZsaWN0IGhlcmUuIEVpdGhlciBhIGFuZCBvIHdlcmUgdGhlXG4gICAgICAvLyBzYW1lLCBvciBiIGFuZCBvIHdlcmUgdGhlIHNhbWUuXG4gICAgICBpZiAoaHVua1s0XSA+IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goW2h1bmtbMV0sIGh1bmtbM10sIGh1bmtbNF1dKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQSBwcm9wZXIgY29uZmxpY3QuIERldGVybWluZSB0aGUgZXh0ZW50cyBvZiB0aGVcbiAgICAgIC8vIHJlZ2lvbnMgaW52b2x2ZWQgZnJvbSBhLCBvIGFuZCBiLiBFZmZlY3RpdmVseSBtZXJnZVxuICAgICAgLy8gYWxsIHRoZSBodW5rcyBvbiB0aGUgbGVmdCBpbnRvIG9uZSBnaWFudCBodW5rLCBhbmRcbiAgICAgIC8vIGRvIHRoZSBzYW1lIGZvciB0aGUgcmlnaHQ7IHRoZW4sIGNvcnJlY3QgZm9yIHNrZXdcbiAgICAgIC8vIGluIHRoZSByZWdpb25zIG9mIG8gdGhhdCBlYWNoIHNpZGUgY2hhbmdlZCwgYW5kXG4gICAgICAvLyByZXBvcnQgYXBwcm9wcmlhdGUgc3BhbnMgZm9yIHRoZSB0aHJlZSBzaWRlcy5cbiAgICAgIHZhciByZWdpb25zID0ge1xuICAgICAgICAwOiBbYS5sZW5ndGgsIC0xLCBvLmxlbmd0aCwgLTFdLFxuICAgICAgICAyOiBbYi5sZW5ndGgsIC0xLCBvLmxlbmd0aCwgLTFdXG4gICAgICB9O1xuICAgICAgZm9yIChpID0gZmlyc3RIdW5rSW5kZXg7IGkgPD0gaHVua0luZGV4OyBpKyspIHtcbiAgICAgICAgaHVuayA9IGh1bmtzW2ldO1xuICAgICAgICB2YXIgc2lkZSA9IGh1bmtbMV07XG4gICAgICAgIHZhciByID0gcmVnaW9uc1tzaWRlXTtcbiAgICAgICAgdmFyIG9MaHMgPSBodW5rWzBdO1xuICAgICAgICB2YXIgb1JocyA9IG9MaHMgKyBodW5rWzJdO1xuICAgICAgICB2YXIgYWJMaHMgPSBodW5rWzNdO1xuICAgICAgICB2YXIgYWJSaHMgPSBhYkxocyArIGh1bmtbNF07XG4gICAgICAgIHJbMF0gPSBNYXRoLm1pbihhYkxocywgclswXSk7XG4gICAgICAgIHJbMV0gPSBNYXRoLm1heChhYlJocywgclsxXSk7XG4gICAgICAgIHJbMl0gPSBNYXRoLm1pbihvTGhzLCByWzJdKTtcbiAgICAgICAgclszXSA9IE1hdGgubWF4KG9SaHMsIHJbM10pO1xuICAgICAgfVxuICAgICAgdmFyIGFMaHMgPSByZWdpb25zWzBdWzBdICsgKHJlZ2lvbkxocyAtIHJlZ2lvbnNbMF1bMl0pO1xuICAgICAgdmFyIGFSaHMgPSByZWdpb25zWzBdWzFdICsgKHJlZ2lvblJocyAtIHJlZ2lvbnNbMF1bM10pO1xuICAgICAgdmFyIGJMaHMgPSByZWdpb25zWzJdWzBdICsgKHJlZ2lvbkxocyAtIHJlZ2lvbnNbMl1bMl0pO1xuICAgICAgdmFyIGJSaHMgPSByZWdpb25zWzJdWzFdICsgKHJlZ2lvblJocyAtIHJlZ2lvbnNbMl1bM10pO1xuICAgICAgcmVzdWx0LnB1c2goWy0xLFxuICAgICAgICBhTGhzLCBhUmhzIC0gYUxocyxcbiAgICAgICAgcmVnaW9uTGhzLCByZWdpb25SaHMgLSByZWdpb25MaHMsXG4gICAgICAgIGJMaHMsIGJSaHMgLSBiTGhzXG4gICAgICBdKTtcbiAgICB9XG4gICAgY29tbW9uT2Zmc2V0ID0gcmVnaW9uUmhzO1xuICB9XG5cbiAgY29weUNvbW1vbihvLmxlbmd0aCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGRpZmYzTWVyZ2UoYSwgbywgYikge1xuICAvLyBBcHBsaWVzIHRoZSBvdXRwdXQgb2YgRGlmZi5kaWZmM19tZXJnZV9pbmRpY2VzIHRvIGFjdHVhbGx5XG4gIC8vIGNvbnN0cnVjdCB0aGUgbWVyZ2VkIGZpbGU7IHRoZSByZXR1cm5lZCByZXN1bHQgYWx0ZXJuYXRlc1xuICAvLyBiZXR3ZWVuIFwib2tcIiBhbmQgXCJjb25mbGljdFwiIGJsb2Nrcy5cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBmaWxlcyA9IFthLCBvLCBiXTtcbiAgdmFyIGluZGljZXMgPSBkaWZmM01lcmdlSW5kaWNlcyhhLCBvLCBiKTtcblxuICB2YXIgb2tMaW5lcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGZsdXNoT2soKSB7XG4gICAgaWYgKG9rTGluZXMubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIG9rOiBva0xpbmVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgb2tMaW5lcyA9IFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaE9rKHhzKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCB4cy5sZW5ndGg7IGorKykge1xuICAgICAgb2tMaW5lcy5wdXNoKHhzW2pdKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1RydWVDb25mbGljdChyZWMpIHtcbiAgICBpZiAocmVjWzJdICE9IHJlY1s2XSkgcmV0dXJuIHRydWU7XG4gICAgdmFyIGFvZmYgPSByZWNbMV07XG4gICAgdmFyIGJvZmYgPSByZWNbNV07XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCByZWNbMl07IGorKykge1xuICAgICAgaWYgKGFbaiArIGFvZmZdICE9IGJbaiArIGJvZmZdKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHggPSBpbmRpY2VzW2ldO1xuICAgIHZhciBzaWRlID0geFswXTtcbiAgICBpZiAoc2lkZSA9PSAtMSkge1xuICAgICAgaWYgKCFpc1RydWVDb25mbGljdCh4KSkge1xuICAgICAgICBwdXNoT2soZmlsZXNbMF0uc2xpY2UoeFsxXSwgeFsxXSArIHhbMl0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsdXNoT2soKTtcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgIGNvbmZsaWN0OiB7XG4gICAgICAgICAgICBhOiBhLnNsaWNlKHhbMV0sIHhbMV0gKyB4WzJdKSxcbiAgICAgICAgICAgIGFJbmRleDogeFsxXSxcbiAgICAgICAgICAgIG86IG8uc2xpY2UoeFszXSwgeFszXSArIHhbNF0pLFxuICAgICAgICAgICAgb0luZGV4OiB4WzNdLFxuICAgICAgICAgICAgYjogYi5zbGljZSh4WzVdLCB4WzVdICsgeFs2XSksXG4gICAgICAgICAgICBiSW5kZXg6IHhbNV1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoT2soZmlsZXNbc2lkZV0uc2xpY2UoeFsxXSwgeFsxXSArIHhbMl0pKTtcbiAgICB9XG4gIH1cblxuICBmbHVzaE9rKCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGlmZjNNZXJnZTtcbiIsIi8qXG4gKiBVUkw6IGh0dHBzOi8vZ2l0aHViLmNvbS9jdWJpY2RhaXlhL29ucFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMyBUYXRzdWhpa28gS3VibyA8Y3ViaWNkYWl5YUBnbWFpbC5jb20+XG4gKlxuICogIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqICBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiAgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqICBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqICBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiAgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiAgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiAgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIFRoZSBhbGdvcml0aG0gaW1wbGVtZW50ZWQgaGVyZSBpcyBiYXNlZCBvbiBcIkFuIE8oTlApIFNlcXVlbmNlIENvbXBhcmlzb24gQWxnb3JpdGhtXCJcbiAqIGJ5IGRlc2NyaWJlZCBieSBTdW4gV3UsIFVkaSBNYW5iZXIgYW5kIEdlbmUgTXllcnNcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhXywgYl8pIHtcbiAgICB2YXIgYSAgICAgICAgICA9IGFfLFxuICAgICAgICBiICAgICAgICAgID0gYl8sXG4gICAgICAgIG0gICAgICAgICAgPSBhLmxlbmd0aCxcbiAgICAgICAgbiAgICAgICAgICA9IGIubGVuZ3RoLFxuICAgICAgICByZXZlcnNlICAgID0gZmFsc2UsXG4gICAgICAgIGVkICAgICAgICAgPSBudWxsLFxuICAgICAgICBvZmZzZXQgICAgID0gbSArIDEsXG4gICAgICAgIHBhdGggICAgICAgPSBbXSxcbiAgICAgICAgcGF0aHBvc2kgICA9IFtdLFxuICAgICAgICBzZXMgICAgICAgID0gW10sXG4gICAgICAgIGxjcyAgICAgICAgPSBcIlwiLFxuICAgICAgICBTRVNfREVMRVRFID0gLTEsXG4gICAgICAgIFNFU19DT01NT04gPSAwLFxuICAgICAgICBTRVNfQUREICAgID0gMTtcblxuICAgIHZhciB0bXAxLFxuICAgICAgICB0bXAyO1xuXG4gICAgdmFyIGluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtID49IG4pIHtcbiAgICAgICAgICAgIHRtcDEgICAgPSBhO1xuICAgICAgICAgICAgdG1wMiAgICA9IG07XG4gICAgICAgICAgICBhICAgICAgID0gYjtcbiAgICAgICAgICAgIGIgICAgICAgPSB0bXAxO1xuICAgICAgICAgICAgbSAgICAgICA9IG47XG4gICAgICAgICAgICBuICAgICAgID0gdG1wMjtcbiAgICAgICAgICAgIHJldmVyc2UgPSB0cnVlO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbSArIDE7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIFAgPSBmdW5jdGlvbiAoeCwgeSwgaykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ3gnIDogeCxcbiAgICAgICAgICAgICd5JyA6IHksXG4gICAgICAgICAgICAnaycgOiBrLFxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgc2VzZWxlbSA9IGZ1bmN0aW9uIChlbGVtLCB0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnZWxlbScgOiBlbGVtLFxuICAgICAgICAgICAgJ3QnICAgIDogdCxcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHNuYWtlID0gZnVuY3Rpb24gKGssIHAsIHBwKSB7XG4gICAgICAgIHZhciByLCB4LCB5O1xuICAgICAgICBpZiAocCA+IHBwKSB7XG4gICAgICAgICAgICByID0gcGF0aFtrLTErb2Zmc2V0XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHIgPSBwYXRoW2srMStvZmZzZXRdO1xuICAgICAgICB9XG5cbiAgICAgICAgeSA9IE1hdGgubWF4KHAsIHBwKTtcbiAgICAgICAgeCA9IHkgLSBrO1xuICAgICAgICB3aGlsZSAoeCA8IG0gJiYgeSA8IG4gJiYgYVt4XSA9PT0gYlt5XSkge1xuICAgICAgICAgICAgKyt4O1xuICAgICAgICAgICAgKyt5O1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aFtrK29mZnNldF0gPSBwYXRocG9zaS5sZW5ndGg7XG4gICAgICAgIHBhdGhwb3NpW3BhdGhwb3NpLmxlbmd0aF0gPSBuZXcgUCh4LCB5LCByKTtcbiAgICAgICAgcmV0dXJuIHk7XG4gICAgfTtcblxuICAgIHZhciByZWNvcmRzZXEgPSBmdW5jdGlvbiAoZXBjKSB7XG4gICAgICAgIHZhciB4X2lkeCwgeV9pZHgsIHB4X2lkeCwgcHlfaWR4LCBpO1xuICAgICAgICB4X2lkeCAgPSB5X2lkeCAgPSAxO1xuICAgICAgICBweF9pZHggPSBweV9pZHggPSAwO1xuICAgICAgICBmb3IgKGk9ZXBjLmxlbmd0aC0xO2k+PTA7LS1pKSB7XG4gICAgICAgICAgICB3aGlsZShweF9pZHggPCBlcGNbaV0ueCB8fCBweV9pZHggPCBlcGNbaV0ueSkge1xuICAgICAgICAgICAgICAgIGlmIChlcGNbaV0ueSAtIGVwY1tpXS54ID4gcHlfaWR4IC0gcHhfaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXZlcnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNbc2VzLmxlbmd0aF0gPSBuZXcgc2VzZWxlbShiW3B5X2lkeF0sIFNFU19ERUxFVEUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VzW3Nlcy5sZW5ndGhdID0gbmV3IHNlc2VsZW0oYltweV9pZHhdLCBTRVNfQUREKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICArK3lfaWR4O1xuICAgICAgICAgICAgICAgICAgICArK3B5X2lkeDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVwY1tpXS55IC0gZXBjW2ldLnggPCBweV9pZHggLSBweF9pZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc1tzZXMubGVuZ3RoXSA9IG5ldyBzZXNlbGVtKGFbcHhfaWR4XSwgU0VTX0FERCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNbc2VzLmxlbmd0aF0gPSBuZXcgc2VzZWxlbShhW3B4X2lkeF0sIFNFU19ERUxFVEUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICsreF9pZHg7XG4gICAgICAgICAgICAgICAgICAgICsrcHhfaWR4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlc1tzZXMubGVuZ3RoXSA9IG5ldyBzZXNlbGVtKGFbcHhfaWR4XSwgU0VTX0NPTU1PTik7XG4gICAgICAgICAgICAgICAgICAgIGxjcyArPSBhW3B4X2lkeF07XG4gICAgICAgICAgICAgICAgICAgICsreF9pZHg7XG4gICAgICAgICAgICAgICAgICAgICsreV9pZHg7XG4gICAgICAgICAgICAgICAgICAgICsrcHhfaWR4O1xuICAgICAgICAgICAgICAgICAgICArK3B5X2lkeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaW5pdCgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgU0VTX0RFTEVURSA6IC0xLFxuICAgICAgICBTRVNfQ09NTU9OIDogIDAsXG4gICAgICAgIFNFU19BREQgICAgOiAgMSxcbiAgICAgICAgZWRpdGRpc3RhbmNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGVkO1xuICAgICAgICB9LFxuICAgICAgICBnZXRsY3MgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGNzO1xuICAgICAgICB9LFxuICAgICAgICBnZXRzZXMgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VzO1xuICAgICAgICB9LFxuICAgICAgICBjb21wb3NlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRlbHRhLCBzaXplLCBmcCwgcCwgciwgZXBjLCBpLCBrO1xuICAgICAgICAgICAgZGVsdGEgID0gbiAtIG07XG4gICAgICAgICAgICBzaXplICAgPSBtICsgbiArIDM7XG4gICAgICAgICAgICBmcCAgICAgPSB7fTtcbiAgICAgICAgICAgIGZvciAoaT0wO2k8c2l6ZTsrK2kpIHtcbiAgICAgICAgICAgICAgICBmcFtpXSA9IC0xO1xuICAgICAgICAgICAgICAgIHBhdGhbaV0gPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSAtMTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICArK3A7XG4gICAgICAgICAgICAgICAgZm9yIChrPS1wO2s8PWRlbHRhLTE7KytrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZwW2srb2Zmc2V0XSA9IHNuYWtlKGssIGZwW2stMStvZmZzZXRdKzEsIGZwW2srMStvZmZzZXRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChrPWRlbHRhK3A7az49ZGVsdGErMTstLWspIHtcbiAgICAgICAgICAgICAgICAgICAgZnBbaytvZmZzZXRdID0gc25ha2UoaywgZnBbay0xK29mZnNldF0rMSwgZnBbaysxK29mZnNldF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcFtkZWx0YStvZmZzZXRdID0gc25ha2UoZGVsdGEsIGZwW2RlbHRhLTErb2Zmc2V0XSsxLCBmcFtkZWx0YSsxK29mZnNldF0pO1xuICAgICAgICAgICAgfSB3aGlsZSAoZnBbZGVsdGErb2Zmc2V0XSAhPT0gbik7XG5cbiAgICAgICAgICAgIGVkID0gZGVsdGEgKyAyICogcDtcblxuICAgICAgICAgICAgciA9IHBhdGhbZGVsdGErb2Zmc2V0XTtcblxuICAgICAgICAgICAgZXBjICA9IFtdO1xuICAgICAgICAgICAgd2hpbGUgKHIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZXBjW2VwYy5sZW5ndGhdID0gbmV3IFAocGF0aHBvc2lbcl0ueCwgcGF0aHBvc2lbcl0ueSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgciA9IHBhdGhwb3NpW3JdLms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWNvcmRzZXEoZXBjKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuIiwiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIi8vIEEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIG1ha2UtYXJyYXlcbmZ1bmN0aW9uIG1ha2VBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdWJqZWN0KVxuICAgID8gc3ViamVjdFxuICAgIDogW3N1YmplY3RdXG59XG5cbmNvbnN0IEVNUFRZID0gJydcbmNvbnN0IFNQQUNFID0gJyAnXG5jb25zdCBFU0NBUEUgPSAnXFxcXCdcbmNvbnN0IFJFR0VYX1RFU1RfQkxBTktfTElORSA9IC9eXFxzKyQvXG5jb25zdCBSRUdFWF9SRVBMQUNFX0xFQURJTkdfRVhDQVBFRF9FWENMQU1BVElPTiA9IC9eXFxcXCEvXG5jb25zdCBSRUdFWF9SRVBMQUNFX0xFQURJTkdfRVhDQVBFRF9IQVNIID0gL15cXFxcIy9cbmNvbnN0IFJFR0VYX1NQTElUQUxMX0NSTEYgPSAvXFxyP1xcbi9nXG4vLyAvZm9vLFxuLy8gLi9mb28sXG4vLyAuLi9mb28sXG4vLyAuXG4vLyAuLlxuY29uc3QgUkVHRVhfVEVTVF9JTlZBTElEX1BBVEggPSAvXlxcLipcXC98XlxcLiskL1xuXG5jb25zdCBTTEFTSCA9ICcvJ1xuY29uc3QgS0VZX0lHTk9SRSA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnXG4gID8gU3ltYm9sLmZvcignbm9kZS1pZ25vcmUnKVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICA6ICdub2RlLWlnbm9yZSdcblxuY29uc3QgZGVmaW5lID0gKG9iamVjdCwga2V5LCB2YWx1ZSkgPT5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7dmFsdWV9KVxuXG5jb25zdCBSRUdFWF9SRUdFWFBfUkFOR0UgPSAvKFswLXpdKS0oWzAtel0pL2dcblxuY29uc3QgUkVUVVJOX0ZBTFNFID0gKCkgPT4gZmFsc2VcblxuLy8gU2FuaXRpemUgdGhlIHJhbmdlIG9mIGEgcmVndWxhciBleHByZXNzaW9uXG4vLyBUaGUgY2FzZXMgYXJlIGNvbXBsaWNhdGVkLCBzZWUgdGVzdCBjYXNlcyBmb3IgZGV0YWlsc1xuY29uc3Qgc2FuaXRpemVSYW5nZSA9IHJhbmdlID0+IHJhbmdlLnJlcGxhY2UoXG4gIFJFR0VYX1JFR0VYUF9SQU5HRSxcbiAgKG1hdGNoLCBmcm9tLCB0bykgPT4gZnJvbS5jaGFyQ29kZUF0KDApIDw9IHRvLmNoYXJDb2RlQXQoMClcbiAgICA/IG1hdGNoXG4gICAgLy8gSW52YWxpZCByYW5nZSAob3V0IG9mIG9yZGVyKSB3aGljaCBpcyBvayBmb3IgZ2l0aWdub3JlIHJ1bGVzIGJ1dFxuICAgIC8vICAgZmF0YWwgZm9yIEphdmFTY3JpcHQgcmVndWxhciBleHByZXNzaW9uLCBzbyBlbGltaW5hdGUgaXQuXG4gICAgOiBFTVBUWVxuKVxuXG4vLyBTZWUgZml4dHVyZXMgIzU5XG5jb25zdCBjbGVhblJhbmdlQmFja1NsYXNoID0gc2xhc2hlcyA9PiB7XG4gIGNvbnN0IHtsZW5ndGh9ID0gc2xhc2hlc1xuICByZXR1cm4gc2xhc2hlcy5zbGljZSgwLCBsZW5ndGggLSBsZW5ndGggJSAyKVxufVxuXG4vLyA+IElmIHRoZSBwYXR0ZXJuIGVuZHMgd2l0aCBhIHNsYXNoLFxuLy8gPiBpdCBpcyByZW1vdmVkIGZvciB0aGUgcHVycG9zZSBvZiB0aGUgZm9sbG93aW5nIGRlc2NyaXB0aW9uLFxuLy8gPiBidXQgaXQgd291bGQgb25seSBmaW5kIGEgbWF0Y2ggd2l0aCBhIGRpcmVjdG9yeS5cbi8vID4gSW4gb3RoZXIgd29yZHMsIGZvby8gd2lsbCBtYXRjaCBhIGRpcmVjdG9yeSBmb28gYW5kIHBhdGhzIHVuZGVybmVhdGggaXQsXG4vLyA+IGJ1dCB3aWxsIG5vdCBtYXRjaCBhIHJlZ3VsYXIgZmlsZSBvciBhIHN5bWJvbGljIGxpbmsgZm9vXG4vLyA+ICAodGhpcyBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHdheSBob3cgcGF0aHNwZWMgd29ya3MgaW4gZ2VuZXJhbCBpbiBHaXQpLlxuLy8gJ2Bmb28vYCcgd2lsbCBub3QgbWF0Y2ggcmVndWxhciBmaWxlICdgZm9vYCcgb3Igc3ltYm9saWMgbGluayAnYGZvb2AnXG4vLyAtPiBpZ25vcmUtcnVsZXMgd2lsbCBub3QgZGVhbCB3aXRoIGl0LCBiZWNhdXNlIGl0IGNvc3RzIGV4dHJhIGBmcy5zdGF0YCBjYWxsXG4vLyAgICAgIHlvdSBjb3VsZCB1c2Ugb3B0aW9uIGBtYXJrOiB0cnVlYCB3aXRoIGBnbG9iYFxuXG4vLyAnYGZvby9gJyBzaG91bGQgbm90IGNvbnRpbnVlIHdpdGggdGhlICdgLi5gJ1xuY29uc3QgUkVQTEFDRVJTID0gW1xuXG4gIC8vID4gVHJhaWxpbmcgc3BhY2VzIGFyZSBpZ25vcmVkIHVubGVzcyB0aGV5IGFyZSBxdW90ZWQgd2l0aCBiYWNrc2xhc2ggKFwiXFxcIilcbiAgW1xuICAgIC8vIChhXFwgKSAtPiAoYSApXG4gICAgLy8gKGEgICkgLT4gKGEpXG4gICAgLy8gKGEgXFwgKSAtPiAoYSAgKVxuICAgIC9cXFxcP1xccyskLyxcbiAgICBtYXRjaCA9PiBtYXRjaC5pbmRleE9mKCdcXFxcJykgPT09IDBcbiAgICAgID8gU1BBQ0VcbiAgICAgIDogRU1QVFlcbiAgXSxcblxuICAvLyByZXBsYWNlIChcXCApIHdpdGggJyAnXG4gIFtcbiAgICAvXFxcXFxccy9nLFxuICAgICgpID0+IFNQQUNFXG4gIF0sXG5cbiAgLy8gRXNjYXBlIG1ldGFjaGFyYWN0ZXJzXG4gIC8vIHdoaWNoIGlzIHdyaXR0ZW4gZG93biBieSB1c2VycyBidXQgbWVhbnMgc3BlY2lhbCBmb3IgcmVndWxhciBleHByZXNzaW9ucy5cblxuICAvLyA+IFRoZXJlIGFyZSAxMiBjaGFyYWN0ZXJzIHdpdGggc3BlY2lhbCBtZWFuaW5nczpcbiAgLy8gPiAtIHRoZSBiYWNrc2xhc2ggXFwsXG4gIC8vID4gLSB0aGUgY2FyZXQgXixcbiAgLy8gPiAtIHRoZSBkb2xsYXIgc2lnbiAkLFxuICAvLyA+IC0gdGhlIHBlcmlvZCBvciBkb3QgLixcbiAgLy8gPiAtIHRoZSB2ZXJ0aWNhbCBiYXIgb3IgcGlwZSBzeW1ib2wgfCxcbiAgLy8gPiAtIHRoZSBxdWVzdGlvbiBtYXJrID8sXG4gIC8vID4gLSB0aGUgYXN0ZXJpc2sgb3Igc3RhciAqLFxuICAvLyA+IC0gdGhlIHBsdXMgc2lnbiArLFxuICAvLyA+IC0gdGhlIG9wZW5pbmcgcGFyZW50aGVzaXMgKCxcbiAgLy8gPiAtIHRoZSBjbG9zaW5nIHBhcmVudGhlc2lzICksXG4gIC8vID4gLSBhbmQgdGhlIG9wZW5pbmcgc3F1YXJlIGJyYWNrZXQgWyxcbiAgLy8gPiAtIHRoZSBvcGVuaW5nIGN1cmx5IGJyYWNlIHssXG4gIC8vID4gVGhlc2Ugc3BlY2lhbCBjaGFyYWN0ZXJzIGFyZSBvZnRlbiBjYWxsZWQgXCJtZXRhY2hhcmFjdGVyc1wiLlxuICBbXG4gICAgL1tcXFxcJC58KisoKXteXS9nLFxuICAgIG1hdGNoID0+IGBcXFxcJHttYXRjaH1gXG4gIF0sXG5cbiAgW1xuICAgIC8vID4gYSBxdWVzdGlvbiBtYXJrICg/KSBtYXRjaGVzIGEgc2luZ2xlIGNoYXJhY3RlclxuICAgIC8oPyFcXFxcKVxcPy9nLFxuICAgICgpID0+ICdbXi9dJ1xuICBdLFxuXG4gIC8vIGxlYWRpbmcgc2xhc2hcbiAgW1xuXG4gICAgLy8gPiBBIGxlYWRpbmcgc2xhc2ggbWF0Y2hlcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBwYXRobmFtZS5cbiAgICAvLyA+IEZvciBleGFtcGxlLCBcIi8qLmNcIiBtYXRjaGVzIFwiY2F0LWZpbGUuY1wiIGJ1dCBub3QgXCJtb3ppbGxhLXNoYTEvc2hhMS5jXCIuXG4gICAgLy8gQSBsZWFkaW5nIHNsYXNoIG1hdGNoZXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgcGF0aG5hbWVcbiAgICAvXlxcLy8sXG4gICAgKCkgPT4gJ14nXG4gIF0sXG5cbiAgLy8gcmVwbGFjZSBzcGVjaWFsIG1ldGFjaGFyYWN0ZXIgc2xhc2ggYWZ0ZXIgdGhlIGxlYWRpbmcgc2xhc2hcbiAgW1xuICAgIC9cXC8vZyxcbiAgICAoKSA9PiAnXFxcXC8nXG4gIF0sXG5cbiAgW1xuICAgIC8vID4gQSBsZWFkaW5nIFwiKipcIiBmb2xsb3dlZCBieSBhIHNsYXNoIG1lYW5zIG1hdGNoIGluIGFsbCBkaXJlY3Rvcmllcy5cbiAgICAvLyA+IEZvciBleGFtcGxlLCBcIioqL2Zvb1wiIG1hdGNoZXMgZmlsZSBvciBkaXJlY3RvcnkgXCJmb29cIiBhbnl3aGVyZSxcbiAgICAvLyA+IHRoZSBzYW1lIGFzIHBhdHRlcm4gXCJmb29cIi5cbiAgICAvLyA+IFwiKiovZm9vL2JhclwiIG1hdGNoZXMgZmlsZSBvciBkaXJlY3RvcnkgXCJiYXJcIiBhbnl3aGVyZSB0aGF0IGlzIGRpcmVjdGx5XG4gICAgLy8gPiAgIHVuZGVyIGRpcmVjdG9yeSBcImZvb1wiLlxuICAgIC8vIE5vdGljZSB0aGF0IHRoZSAnKidzIGhhdmUgYmVlbiByZXBsYWNlZCBhcyAnXFxcXConXG4gICAgL15cXF4qXFxcXFxcKlxcXFxcXCpcXFxcXFwvLyxcblxuICAgIC8vICcqKi9mb28nIDwtPiAnZm9vJ1xuICAgICgpID0+ICdeKD86LipcXFxcLyk/J1xuICBdLFxuXG4gIC8vIHN0YXJ0aW5nXG4gIFtcbiAgICAvLyB0aGVyZSB3aWxsIGJlIG5vIGxlYWRpbmcgJy8nXG4gICAgLy8gICAod2hpY2ggaGFzIGJlZW4gcmVwbGFjZWQgYnkgc2VjdGlvbiBcImxlYWRpbmcgc2xhc2hcIilcbiAgICAvLyBJZiBzdGFydHMgd2l0aCAnKionLCBhZGRpbmcgYSAnXicgdG8gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBhbHNvIHdvcmtzXG4gICAgL14oPz1bXl5dKS8sXG4gICAgZnVuY3Rpb24gc3RhcnRpbmdSZXBsYWNlciAoKSB7XG4gICAgICAvLyBJZiBoYXMgYSBzbGFzaCBgL2AgYXQgdGhlIGJlZ2lubmluZyBvciBtaWRkbGVcbiAgICAgIHJldHVybiAhL1xcLyg/ISQpLy50ZXN0KHRoaXMpXG4gICAgICAgIC8vID4gUHJpb3IgdG8gMi4yMi4xXG4gICAgICAgIC8vID4gSWYgdGhlIHBhdHRlcm4gZG9lcyBub3QgY29udGFpbiBhIHNsYXNoIC8sXG4gICAgICAgIC8vID4gICBHaXQgdHJlYXRzIGl0IGFzIGEgc2hlbGwgZ2xvYiBwYXR0ZXJuXG4gICAgICAgIC8vIEFjdHVhbGx5LCBpZiB0aGVyZSBpcyBvbmx5IGEgdHJhaWxpbmcgc2xhc2gsXG4gICAgICAgIC8vICAgZ2l0IGFsc28gdHJlYXRzIGl0IGFzIGEgc2hlbGwgZ2xvYiBwYXR0ZXJuXG5cbiAgICAgICAgLy8gQWZ0ZXIgMi4yMi4xIChjb21wYXRpYmxlIGJ1dCBjbGVhcmVyKVxuICAgICAgICAvLyA+IElmIHRoZXJlIGlzIGEgc2VwYXJhdG9yIGF0IHRoZSBiZWdpbm5pbmcgb3IgbWlkZGxlIChvciBib3RoKVxuICAgICAgICAvLyA+IG9mIHRoZSBwYXR0ZXJuLCB0aGVuIHRoZSBwYXR0ZXJuIGlzIHJlbGF0aXZlIHRvIHRoZSBkaXJlY3RvcnlcbiAgICAgICAgLy8gPiBsZXZlbCBvZiB0aGUgcGFydGljdWxhciAuZ2l0aWdub3JlIGZpbGUgaXRzZWxmLlxuICAgICAgICAvLyA+IE90aGVyd2lzZSB0aGUgcGF0dGVybiBtYXkgYWxzbyBtYXRjaCBhdCBhbnkgbGV2ZWwgYmVsb3dcbiAgICAgICAgLy8gPiB0aGUgLmdpdGlnbm9yZSBsZXZlbC5cbiAgICAgICAgPyAnKD86XnxcXFxcLyknXG5cbiAgICAgICAgLy8gPiBPdGhlcndpc2UsIEdpdCB0cmVhdHMgdGhlIHBhdHRlcm4gYXMgYSBzaGVsbCBnbG9iIHN1aXRhYmxlIGZvclxuICAgICAgICAvLyA+ICAgY29uc3VtcHRpb24gYnkgZm5tYXRjaCgzKVxuICAgICAgICA6ICdeJ1xuICAgIH1cbiAgXSxcblxuICAvLyB0d28gZ2xvYnN0YXJzXG4gIFtcbiAgICAvLyBVc2UgbG9va2FoZWFkIGFzc2VydGlvbnMgc28gdGhhdCB3ZSBjb3VsZCBtYXRjaCBtb3JlIHRoYW4gb25lIGAnLyoqJ2BcbiAgICAvXFxcXFxcL1xcXFxcXCpcXFxcXFwqKD89XFxcXFxcL3wkKS9nLFxuXG4gICAgLy8gWmVybywgb25lIG9yIHNldmVyYWwgZGlyZWN0b3JpZXNcbiAgICAvLyBzaG91bGQgbm90IHVzZSAnKicsIG9yIGl0IHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIG5leHQgcmVwbGFjZXJcblxuICAgIC8vIENoZWNrIGlmIGl0IGlzIG5vdCB0aGUgbGFzdCBgJy8qKidgXG4gICAgKF8sIGluZGV4LCBzdHIpID0+IGluZGV4ICsgNiA8IHN0ci5sZW5ndGhcblxuICAgICAgLy8gY2FzZTogLyoqL1xuICAgICAgLy8gPiBBIHNsYXNoIGZvbGxvd2VkIGJ5IHR3byBjb25zZWN1dGl2ZSBhc3Rlcmlza3MgdGhlbiBhIHNsYXNoIG1hdGNoZXNcbiAgICAgIC8vID4gICB6ZXJvIG9yIG1vcmUgZGlyZWN0b3JpZXMuXG4gICAgICAvLyA+IEZvciBleGFtcGxlLCBcImEvKiovYlwiIG1hdGNoZXMgXCJhL2JcIiwgXCJhL3gvYlwiLCBcImEveC95L2JcIiBhbmQgc28gb24uXG4gICAgICAvLyAnLyoqLydcbiAgICAgID8gJyg/OlxcXFwvW15cXFxcL10rKSonXG5cbiAgICAgIC8vIGNhc2U6IC8qKlxuICAgICAgLy8gPiBBIHRyYWlsaW5nIGBcIi8qKlwiYCBtYXRjaGVzIGV2ZXJ5dGhpbmcgaW5zaWRlLlxuXG4gICAgICAvLyAjMjE6IGV2ZXJ5dGhpbmcgaW5zaWRlIGJ1dCBpdCBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGN1cnJlbnQgZm9sZGVyXG4gICAgICA6ICdcXFxcLy4rJ1xuICBdLFxuXG4gIC8vIGludGVybWVkaWF0ZSB3aWxkY2FyZHNcbiAgW1xuICAgIC8vIE5ldmVyIHJlcGxhY2UgZXNjYXBlZCAnKidcbiAgICAvLyBpZ25vcmUgcnVsZSAnXFwqJyB3aWxsIG1hdGNoIHRoZSBwYXRoICcqJ1xuXG4gICAgLy8gJ2FiYy4qLycgLT4gZ29cbiAgICAvLyAnYWJjLionICAtPiBza2lwIHRoaXMgcnVsZVxuICAgIC8oXnxbXlxcXFxdKylcXFxcXFwqKD89LispL2csXG5cbiAgICAvLyAnKi5qcycgbWF0Y2hlcyAnLmpzJ1xuICAgIC8vICcqLmpzJyBkb2Vzbid0IG1hdGNoICdhYmMnXG4gICAgKF8sIHAxKSA9PiBgJHtwMX1bXlxcXFwvXSpgXG4gIF0sXG5cbiAgW1xuICAgIC8vIHVuZXNjYXBlLCByZXZlcnQgc3RlcCAzIGV4Y2VwdCBmb3IgYmFjayBzbGFzaFxuICAgIC8vIEZvciBleGFtcGxlLCBpZiBhIHVzZXIgZXNjYXBlIGEgJ1xcXFwqJyxcbiAgICAvLyBhZnRlciBzdGVwIDMsIHRoZSByZXN1bHQgd2lsbCBiZSAnXFxcXFxcXFxcXFxcKidcbiAgICAvXFxcXFxcXFxcXFxcKD89WyQufCorKCl7Xl0pL2csXG4gICAgKCkgPT4gRVNDQVBFXG4gIF0sXG5cbiAgW1xuICAgIC8vICdcXFxcXFxcXCcgLT4gJ1xcXFwnXG4gICAgL1xcXFxcXFxcL2csXG4gICAgKCkgPT4gRVNDQVBFXG4gIF0sXG5cbiAgW1xuICAgIC8vID4gVGhlIHJhbmdlIG5vdGF0aW9uLCBlLmcuIFthLXpBLVpdLFxuICAgIC8vID4gY2FuIGJlIHVzZWQgdG8gbWF0Y2ggb25lIG9mIHRoZSBjaGFyYWN0ZXJzIGluIGEgcmFuZ2UuXG5cbiAgICAvLyBgXFxgIGlzIGVzY2FwZWQgYnkgc3RlcCAzXG4gICAgLyhcXFxcKT9cXFsoW15cXF0vXSo/KShcXFxcKikoJHxcXF0pL2csXG4gICAgKG1hdGNoLCBsZWFkRXNjYXBlLCByYW5nZSwgZW5kRXNjYXBlLCBjbG9zZSkgPT4gbGVhZEVzY2FwZSA9PT0gRVNDQVBFXG4gICAgICAvLyAnXFxcXFtiYXJdJyAtPiAnXFxcXFxcXFxbYmFyXFxcXF0nXG4gICAgICA/IGBcXFxcWyR7cmFuZ2V9JHtjbGVhblJhbmdlQmFja1NsYXNoKGVuZEVzY2FwZSl9JHtjbG9zZX1gXG4gICAgICA6IGNsb3NlID09PSAnXSdcbiAgICAgICAgPyBlbmRFc2NhcGUubGVuZ3RoICUgMiA9PT0gMFxuICAgICAgICAgIC8vIEEgbm9ybWFsIGNhc2UsIGFuZCBpdCBpcyBhIHJhbmdlIG5vdGF0aW9uXG4gICAgICAgICAgLy8gJ1tiYXJdJ1xuICAgICAgICAgIC8vICdbYmFyXFxcXFxcXFxdJ1xuICAgICAgICAgID8gYFske3Nhbml0aXplUmFuZ2UocmFuZ2UpfSR7ZW5kRXNjYXBlfV1gXG4gICAgICAgICAgLy8gSW52YWxpZCByYW5nZSBub3RhdG9uXG4gICAgICAgICAgLy8gJ1tiYXJcXFxcXScgLT4gJ1tiYXJcXFxcXFxcXF0nXG4gICAgICAgICAgOiAnW10nXG4gICAgICAgIDogJ1tdJ1xuICBdLFxuXG4gIC8vIGVuZGluZ1xuICBbXG4gICAgLy8gJ2pzJyB3aWxsIG5vdCBtYXRjaCAnanMuJ1xuICAgIC8vICdhYicgd2lsbCBub3QgbWF0Y2ggJ2FiYydcbiAgICAvKD86W14qXSkkLyxcblxuICAgIC8vIFdURiFcbiAgICAvLyBodHRwczovL2dpdC1zY20uY29tL2RvY3MvZ2l0aWdub3JlXG4gICAgLy8gY2hhbmdlcyBpbiBbMi4yMi4xXShodHRwczovL2dpdC1zY20uY29tL2RvY3MvZ2l0aWdub3JlLzIuMjIuMSlcbiAgICAvLyB3aGljaCByZS1maXhlcyAjMjQsICMzOFxuXG4gICAgLy8gPiBJZiB0aGVyZSBpcyBhIHNlcGFyYXRvciBhdCB0aGUgZW5kIG9mIHRoZSBwYXR0ZXJuIHRoZW4gdGhlIHBhdHRlcm5cbiAgICAvLyA+IHdpbGwgb25seSBtYXRjaCBkaXJlY3Rvcmllcywgb3RoZXJ3aXNlIHRoZSBwYXR0ZXJuIGNhbiBtYXRjaCBib3RoXG4gICAgLy8gPiBmaWxlcyBhbmQgZGlyZWN0b3JpZXMuXG5cbiAgICAvLyAnanMqJyB3aWxsIG5vdCBtYXRjaCAnYS5qcydcbiAgICAvLyAnanMvJyB3aWxsIG5vdCBtYXRjaCAnYS5qcydcbiAgICAvLyAnanMnIHdpbGwgbWF0Y2ggJ2EuanMnIGFuZCAnYS5qcy8nXG4gICAgbWF0Y2ggPT4gL1xcLyQvLnRlc3QobWF0Y2gpXG4gICAgICAvLyBmb28vIHdpbGwgbm90IG1hdGNoICdmb28nXG4gICAgICA/IGAke21hdGNofSRgXG4gICAgICAvLyBmb28gbWF0Y2hlcyAnZm9vJyBhbmQgJ2Zvby8nXG4gICAgICA6IGAke21hdGNofSg/PSR8XFxcXC8kKWBcbiAgXSxcblxuICAvLyB0cmFpbGluZyB3aWxkY2FyZFxuICBbXG4gICAgLyhcXF58XFxcXFxcLyk/XFxcXFxcKiQvLFxuICAgIChfLCBwMSkgPT4ge1xuICAgICAgY29uc3QgcHJlZml4ID0gcDFcbiAgICAgICAgLy8gJ1xcXic6XG4gICAgICAgIC8vICcvKicgZG9lcyBub3QgbWF0Y2ggRU1QVFlcbiAgICAgICAgLy8gJy8qJyBkb2VzIG5vdCBtYXRjaCBldmVyeXRoaW5nXG5cbiAgICAgICAgLy8gJ1xcXFxcXC8nOlxuICAgICAgICAvLyAnYWJjLyonIGRvZXMgbm90IG1hdGNoICdhYmMvJ1xuICAgICAgICA/IGAke3AxfVteL10rYFxuXG4gICAgICAgIC8vICdhKicgbWF0Y2hlcyAnYSdcbiAgICAgICAgLy8gJ2EqJyBtYXRjaGVzICdhYSdcbiAgICAgICAgOiAnW14vXSonXG5cbiAgICAgIHJldHVybiBgJHtwcmVmaXh9KD89JHxcXFxcLyQpYFxuICAgIH1cbiAgXSxcbl1cblxuLy8gQSBzaW1wbGUgY2FjaGUsIGJlY2F1c2UgYW4gaWdub3JlIHJ1bGUgb25seSBoYXMgb25seSBvbmUgY2VydGFpbiBtZWFuaW5nXG5jb25zdCByZWdleENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4vLyBAcGFyYW0ge3BhdHRlcm59XG5jb25zdCBtYWtlUmVnZXggPSAocGF0dGVybiwgaWdub3JlQ2FzZSkgPT4ge1xuICBsZXQgc291cmNlID0gcmVnZXhDYWNoZVtwYXR0ZXJuXVxuXG4gIGlmICghc291cmNlKSB7XG4gICAgc291cmNlID0gUkVQTEFDRVJTLnJlZHVjZShcbiAgICAgIChwcmV2LCBjdXJyZW50KSA9PiBwcmV2LnJlcGxhY2UoY3VycmVudFswXSwgY3VycmVudFsxXS5iaW5kKHBhdHRlcm4pKSxcbiAgICAgIHBhdHRlcm5cbiAgICApXG4gICAgcmVnZXhDYWNoZVtwYXR0ZXJuXSA9IHNvdXJjZVxuICB9XG5cbiAgcmV0dXJuIGlnbm9yZUNhc2VcbiAgICA/IG5ldyBSZWdFeHAoc291cmNlLCAnaScpXG4gICAgOiBuZXcgUmVnRXhwKHNvdXJjZSlcbn1cblxuY29uc3QgaXNTdHJpbmcgPSBzdWJqZWN0ID0+IHR5cGVvZiBzdWJqZWN0ID09PSAnc3RyaW5nJ1xuXG4vLyA+IEEgYmxhbmsgbGluZSBtYXRjaGVzIG5vIGZpbGVzLCBzbyBpdCBjYW4gc2VydmUgYXMgYSBzZXBhcmF0b3IgZm9yIHJlYWRhYmlsaXR5LlxuY29uc3QgY2hlY2tQYXR0ZXJuID0gcGF0dGVybiA9PiBwYXR0ZXJuXG4gICYmIGlzU3RyaW5nKHBhdHRlcm4pXG4gICYmICFSRUdFWF9URVNUX0JMQU5LX0xJTkUudGVzdChwYXR0ZXJuKVxuXG4gIC8vID4gQSBsaW5lIHN0YXJ0aW5nIHdpdGggIyBzZXJ2ZXMgYXMgYSBjb21tZW50LlxuICAmJiBwYXR0ZXJuLmluZGV4T2YoJyMnKSAhPT0gMFxuXG5jb25zdCBzcGxpdFBhdHRlcm4gPSBwYXR0ZXJuID0+IHBhdHRlcm4uc3BsaXQoUkVHRVhfU1BMSVRBTExfQ1JMRilcblxuY2xhc3MgSWdub3JlUnVsZSB7XG4gIGNvbnN0cnVjdG9yIChcbiAgICBvcmlnaW4sXG4gICAgcGF0dGVybixcbiAgICBuZWdhdGl2ZSxcbiAgICByZWdleFxuICApIHtcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpblxuICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm5cbiAgICB0aGlzLm5lZ2F0aXZlID0gbmVnYXRpdmVcbiAgICB0aGlzLnJlZ2V4ID0gcmVnZXhcbiAgfVxufVxuXG5jb25zdCBjcmVhdGVSdWxlID0gKHBhdHRlcm4sIGlnbm9yZUNhc2UpID0+IHtcbiAgY29uc3Qgb3JpZ2luID0gcGF0dGVyblxuICBsZXQgbmVnYXRpdmUgPSBmYWxzZVxuXG4gIC8vID4gQW4gb3B0aW9uYWwgcHJlZml4IFwiIVwiIHdoaWNoIG5lZ2F0ZXMgdGhlIHBhdHRlcm47XG4gIGlmIChwYXR0ZXJuLmluZGV4T2YoJyEnKSA9PT0gMCkge1xuICAgIG5lZ2F0aXZlID0gdHJ1ZVxuICAgIHBhdHRlcm4gPSBwYXR0ZXJuLnN1YnN0cigxKVxuICB9XG5cbiAgcGF0dGVybiA9IHBhdHRlcm5cbiAgLy8gPiBQdXQgYSBiYWNrc2xhc2ggKFwiXFxcIikgaW4gZnJvbnQgb2YgdGhlIGZpcnN0IFwiIVwiIGZvciBwYXR0ZXJucyB0aGF0XG4gIC8vID4gICBiZWdpbiB3aXRoIGEgbGl0ZXJhbCBcIiFcIiwgZm9yIGV4YW1wbGUsIGBcIlxcIWltcG9ydGFudCEudHh0XCJgLlxuICAucmVwbGFjZShSRUdFWF9SRVBMQUNFX0xFQURJTkdfRVhDQVBFRF9FWENMQU1BVElPTiwgJyEnKVxuICAvLyA+IFB1dCBhIGJhY2tzbGFzaCAoXCJcXFwiKSBpbiBmcm9udCBvZiB0aGUgZmlyc3QgaGFzaCBmb3IgcGF0dGVybnMgdGhhdFxuICAvLyA+ICAgYmVnaW4gd2l0aCBhIGhhc2guXG4gIC5yZXBsYWNlKFJFR0VYX1JFUExBQ0VfTEVBRElOR19FWENBUEVEX0hBU0gsICcjJylcblxuICBjb25zdCByZWdleCA9IG1ha2VSZWdleChwYXR0ZXJuLCBpZ25vcmVDYXNlKVxuXG4gIHJldHVybiBuZXcgSWdub3JlUnVsZShcbiAgICBvcmlnaW4sXG4gICAgcGF0dGVybixcbiAgICBuZWdhdGl2ZSxcbiAgICByZWdleFxuICApXG59XG5cbmNvbnN0IHRocm93RXJyb3IgPSAobWVzc2FnZSwgQ3RvcikgPT4ge1xuICB0aHJvdyBuZXcgQ3RvcihtZXNzYWdlKVxufVxuXG5jb25zdCBjaGVja1BhdGggPSAocGF0aCwgb3JpZ2luYWxQYXRoLCBkb1Rocm93KSA9PiB7XG4gIGlmICghaXNTdHJpbmcocGF0aCkpIHtcbiAgICByZXR1cm4gZG9UaHJvdyhcbiAgICAgIGBwYXRoIG11c3QgYmUgYSBzdHJpbmcsIGJ1dCBnb3QgXFxgJHtvcmlnaW5hbFBhdGh9XFxgYCxcbiAgICAgIFR5cGVFcnJvclxuICAgIClcbiAgfVxuXG4gIC8vIFdlIGRvbid0IGtub3cgaWYgd2Ugc2hvdWxkIGlnbm9yZSBFTVBUWSwgc28gdGhyb3dcbiAgaWYgKCFwYXRoKSB7XG4gICAgcmV0dXJuIGRvVGhyb3coYHBhdGggbXVzdCBub3QgYmUgZW1wdHlgLCBUeXBlRXJyb3IpXG4gIH1cblxuICAvLyBDaGVjayBpZiBpdCBpcyBhIHJlbGF0aXZlIHBhdGhcbiAgaWYgKGNoZWNrUGF0aC5pc05vdFJlbGF0aXZlKHBhdGgpKSB7XG4gICAgY29uc3QgciA9ICdgcGF0aC5yZWxhdGl2ZSgpYGQnXG4gICAgcmV0dXJuIGRvVGhyb3coXG4gICAgICBgcGF0aCBzaG91bGQgYmUgYSAke3J9IHN0cmluZywgYnV0IGdvdCBcIiR7b3JpZ2luYWxQYXRofVwiYCxcbiAgICAgIFJhbmdlRXJyb3JcbiAgICApXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBpc05vdFJlbGF0aXZlID0gcGF0aCA9PiBSRUdFWF9URVNUX0lOVkFMSURfUEFUSC50ZXN0KHBhdGgpXG5cbmNoZWNrUGF0aC5pc05vdFJlbGF0aXZlID0gaXNOb3RSZWxhdGl2ZVxuY2hlY2tQYXRoLmNvbnZlcnQgPSBwID0+IHBcblxuY2xhc3MgSWdub3JlIHtcbiAgY29uc3RydWN0b3IgKHtcbiAgICBpZ25vcmVjYXNlID0gdHJ1ZSxcbiAgICBpZ25vcmVDYXNlID0gaWdub3JlY2FzZSxcbiAgICBhbGxvd1JlbGF0aXZlUGF0aHMgPSBmYWxzZVxuICB9ID0ge30pIHtcbiAgICBkZWZpbmUodGhpcywgS0VZX0lHTk9SRSwgdHJ1ZSlcblxuICAgIHRoaXMuX3J1bGVzID0gW11cbiAgICB0aGlzLl9pZ25vcmVDYXNlID0gaWdub3JlQ2FzZVxuICAgIHRoaXMuX2FsbG93UmVsYXRpdmVQYXRocyA9IGFsbG93UmVsYXRpdmVQYXRoc1xuICAgIHRoaXMuX2luaXRDYWNoZSgpXG4gIH1cblxuICBfaW5pdENhY2hlICgpIHtcbiAgICB0aGlzLl9pZ25vcmVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB0aGlzLl90ZXN0Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIH1cblxuICBfYWRkUGF0dGVybiAocGF0dGVybikge1xuICAgIC8vICMzMlxuICAgIGlmIChwYXR0ZXJuICYmIHBhdHRlcm5bS0VZX0lHTk9SRV0pIHtcbiAgICAgIHRoaXMuX3J1bGVzID0gdGhpcy5fcnVsZXMuY29uY2F0KHBhdHRlcm4uX3J1bGVzKVxuICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2hlY2tQYXR0ZXJuKHBhdHRlcm4pKSB7XG4gICAgICBjb25zdCBydWxlID0gY3JlYXRlUnVsZShwYXR0ZXJuLCB0aGlzLl9pZ25vcmVDYXNlKVxuICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlXG4gICAgICB0aGlzLl9ydWxlcy5wdXNoKHJ1bGUpXG4gICAgfVxuICB9XG5cbiAgLy8gQHBhcmFtIHtBcnJheTxzdHJpbmc+IHwgc3RyaW5nIHwgSWdub3JlfSBwYXR0ZXJuXG4gIGFkZCAocGF0dGVybikge1xuICAgIHRoaXMuX2FkZGVkID0gZmFsc2VcblxuICAgIG1ha2VBcnJheShcbiAgICAgIGlzU3RyaW5nKHBhdHRlcm4pXG4gICAgICAgID8gc3BsaXRQYXR0ZXJuKHBhdHRlcm4pXG4gICAgICAgIDogcGF0dGVyblxuICAgICkuZm9yRWFjaCh0aGlzLl9hZGRQYXR0ZXJuLCB0aGlzKVxuXG4gICAgLy8gU29tZSBydWxlcyBoYXZlIGp1c3QgYWRkZWQgdG8gdGhlIGlnbm9yZSxcbiAgICAvLyBtYWtpbmcgdGhlIGJlaGF2aW9yIGNoYW5nZWQuXG4gICAgaWYgKHRoaXMuX2FkZGVkKSB7XG4gICAgICB0aGlzLl9pbml0Q2FjaGUoKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBsZWdhY3lcbiAgYWRkUGF0dGVybiAocGF0dGVybikge1xuICAgIHJldHVybiB0aGlzLmFkZChwYXR0ZXJuKVxuICB9XG5cbiAgLy8gICAgICAgICAgfCAgICAgICAgICAgaWdub3JlZCA6IHVuaWdub3JlZFxuICAvLyBuZWdhdGl2ZSB8ICAgMDowICAgfCAgIDA6MSAgIHwgICAxOjAgICB8ICAgMToxXG4gIC8vIC0tLS0tLS0tIHwgLS0tLS0tLSB8IC0tLS0tLS0gfCAtLS0tLS0tIHwgLS0tLS0tLS1cbiAgLy8gICAgIDAgICAgfCAgVEVTVCAgIHwgIFRFU1QgICB8ICBTS0lQICAgfCAgICBYXG4gIC8vICAgICAxICAgIHwgIFRFU1RJRiB8ICBTS0lQICAgfCAgVEVTVCAgIHwgICAgWFxuXG4gIC8vIC0gU0tJUDogYWx3YXlzIHNraXBcbiAgLy8gLSBURVNUOiBhbHdheXMgdGVzdFxuICAvLyAtIFRFU1RJRjogb25seSB0ZXN0IGlmIGNoZWNrVW5pZ25vcmVkXG4gIC8vIC0gWDogdGhhdCBuZXZlciBoYXBwZW5cblxuICAvLyBAcGFyYW0ge2Jvb2xlYW59IHdoZXRoZXIgc2hvdWxkIGNoZWNrIGlmIHRoZSBwYXRoIGlzIHVuaWdub3JlZCxcbiAgLy8gICBzZXR0aW5nIGBjaGVja1VuaWdub3JlZGAgdG8gYGZhbHNlYCBjb3VsZCByZWR1Y2UgYWRkaXRpb25hbFxuICAvLyAgIHBhdGggbWF0Y2hpbmcuXG5cbiAgLy8gQHJldHVybnMge1Rlc3RSZXN1bHR9IHRydWUgaWYgYSBmaWxlIGlzIGlnbm9yZWRcbiAgX3Rlc3RPbmUgKHBhdGgsIGNoZWNrVW5pZ25vcmVkKSB7XG4gICAgbGV0IGlnbm9yZWQgPSBmYWxzZVxuICAgIGxldCB1bmlnbm9yZWQgPSBmYWxzZVxuXG4gICAgdGhpcy5fcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgIGNvbnN0IHtuZWdhdGl2ZX0gPSBydWxlXG4gICAgICBpZiAoXG4gICAgICAgIHVuaWdub3JlZCA9PT0gbmVnYXRpdmUgJiYgaWdub3JlZCAhPT0gdW5pZ25vcmVkXG4gICAgICAgIHx8IG5lZ2F0aXZlICYmICFpZ25vcmVkICYmICF1bmlnbm9yZWQgJiYgIWNoZWNrVW5pZ25vcmVkXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoZWQgPSBydWxlLnJlZ2V4LnRlc3QocGF0aClcblxuICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgaWdub3JlZCA9ICFuZWdhdGl2ZVxuICAgICAgICB1bmlnbm9yZWQgPSBuZWdhdGl2ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4ge1xuICAgICAgaWdub3JlZCxcbiAgICAgIHVuaWdub3JlZFxuICAgIH1cbiAgfVxuXG4gIC8vIEByZXR1cm5zIHtUZXN0UmVzdWx0fVxuICBfdGVzdCAob3JpZ2luYWxQYXRoLCBjYWNoZSwgY2hlY2tVbmlnbm9yZWQsIHNsaWNlcykge1xuICAgIGNvbnN0IHBhdGggPSBvcmlnaW5hbFBhdGhcbiAgICAgIC8vIFN1cHBvcnRzIG51bGxhYmxlIHBhdGhcbiAgICAgICYmIGNoZWNrUGF0aC5jb252ZXJ0KG9yaWdpbmFsUGF0aClcblxuICAgIGNoZWNrUGF0aChcbiAgICAgIHBhdGgsXG4gICAgICBvcmlnaW5hbFBhdGgsXG4gICAgICB0aGlzLl9hbGxvd1JlbGF0aXZlUGF0aHNcbiAgICAgICAgPyBSRVRVUk5fRkFMU0VcbiAgICAgICAgOiB0aHJvd0Vycm9yXG4gICAgKVxuXG4gICAgcmV0dXJuIHRoaXMuX3QocGF0aCwgY2FjaGUsIGNoZWNrVW5pZ25vcmVkLCBzbGljZXMpXG4gIH1cblxuICBfdCAocGF0aCwgY2FjaGUsIGNoZWNrVW5pZ25vcmVkLCBzbGljZXMpIHtcbiAgICBpZiAocGF0aCBpbiBjYWNoZSkge1xuICAgICAgcmV0dXJuIGNhY2hlW3BhdGhdXG4gICAgfVxuXG4gICAgaWYgKCFzbGljZXMpIHtcbiAgICAgIC8vIHBhdGgvdG8vYS5qc1xuICAgICAgLy8gWydwYXRoJywgJ3RvJywgJ2EuanMnXVxuICAgICAgc2xpY2VzID0gcGF0aC5zcGxpdChTTEFTSClcbiAgICB9XG5cbiAgICBzbGljZXMucG9wKClcblxuICAgIC8vIElmIHRoZSBwYXRoIGhhcyBubyBwYXJlbnQgZGlyZWN0b3J5LCBqdXN0IHRlc3QgaXRcbiAgICBpZiAoIXNsaWNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjYWNoZVtwYXRoXSA9IHRoaXMuX3Rlc3RPbmUocGF0aCwgY2hlY2tVbmlnbm9yZWQpXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5fdChcbiAgICAgIHNsaWNlcy5qb2luKFNMQVNIKSArIFNMQVNILFxuICAgICAgY2FjaGUsXG4gICAgICBjaGVja1VuaWdub3JlZCxcbiAgICAgIHNsaWNlc1xuICAgIClcblxuICAgIC8vIElmIHRoZSBwYXRoIGNvbnRhaW5zIGEgcGFyZW50IGRpcmVjdG9yeSwgY2hlY2sgdGhlIHBhcmVudCBmaXJzdFxuICAgIHJldHVybiBjYWNoZVtwYXRoXSA9IHBhcmVudC5pZ25vcmVkXG4gICAgICAvLyA+IEl0IGlzIG5vdCBwb3NzaWJsZSB0byByZS1pbmNsdWRlIGEgZmlsZSBpZiBhIHBhcmVudCBkaXJlY3Rvcnkgb2ZcbiAgICAgIC8vID4gICB0aGF0IGZpbGUgaXMgZXhjbHVkZWQuXG4gICAgICA/IHBhcmVudFxuICAgICAgOiB0aGlzLl90ZXN0T25lKHBhdGgsIGNoZWNrVW5pZ25vcmVkKVxuICB9XG5cbiAgaWdub3JlcyAocGF0aCkge1xuICAgIHJldHVybiB0aGlzLl90ZXN0KHBhdGgsIHRoaXMuX2lnbm9yZUNhY2hlLCBmYWxzZSkuaWdub3JlZFxuICB9XG5cbiAgY3JlYXRlRmlsdGVyICgpIHtcbiAgICByZXR1cm4gcGF0aCA9PiAhdGhpcy5pZ25vcmVzKHBhdGgpXG4gIH1cblxuICBmaWx0ZXIgKHBhdGhzKSB7XG4gICAgcmV0dXJuIG1ha2VBcnJheShwYXRocykuZmlsdGVyKHRoaXMuY3JlYXRlRmlsdGVyKCkpXG4gIH1cblxuICAvLyBAcmV0dXJucyB7VGVzdFJlc3VsdH1cbiAgdGVzdCAocGF0aCkge1xuICAgIHJldHVybiB0aGlzLl90ZXN0KHBhdGgsIHRoaXMuX3Rlc3RDYWNoZSwgdHJ1ZSlcbiAgfVxufVxuXG5jb25zdCBmYWN0b3J5ID0gb3B0aW9ucyA9PiBuZXcgSWdub3JlKG9wdGlvbnMpXG5cbmNvbnN0IGlzUGF0aFZhbGlkID0gcGF0aCA9PlxuICBjaGVja1BhdGgocGF0aCAmJiBjaGVja1BhdGguY29udmVydChwYXRoKSwgcGF0aCwgUkVUVVJOX0ZBTFNFKVxuXG5mYWN0b3J5LmlzUGF0aFZhbGlkID0gaXNQYXRoVmFsaWRcblxuLy8gRml4ZXMgdHlwZXNjcmlwdFxuZmFjdG9yeS5kZWZhdWx0ID0gZmFjdG9yeVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnlcblxuLy8gV2luZG93c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cbmlmIChcbiAgLy8gRGV0ZWN0IGBwcm9jZXNzYCBzbyB0aGF0IGl0IGNhbiBydW4gaW4gYnJvd3NlcnMuXG4gIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuICAmJiAoXG4gICAgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuSUdOT1JFX1RFU1RfV0lOMzJcbiAgICB8fCBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG4gIClcbikge1xuICAvKiBlc2xpbnQgbm8tY29udHJvbC1yZWdleDogXCJvZmZcIiAqL1xuICBjb25zdCBtYWtlUG9zaXggPSBzdHIgPT4gL15cXFxcXFxcXFxcP1xcXFwvLnRlc3Qoc3RyKVxuICB8fCAvW1wiPD58XFx1MDAwMC1cXHUwMDFGXSsvdS50ZXN0KHN0cilcbiAgICA/IHN0clxuICAgIDogc3RyLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuXG4gIGNoZWNrUGF0aC5jb252ZXJ0ID0gbWFrZVBvc2l4XG5cbiAgLy8gJ0M6XFxcXGZvbycgICAgIDwtICdDOlxcXFxmb28nIGhhcyBiZWVuIGNvbnZlcnRlZCB0byAnQzovJ1xuICAvLyAnZDpcXFxcZm9vJ1xuICBjb25zdCBSRUdJWF9JU19XSU5ET1dTX1BBVEhfQUJTT0xVVEUgPSAvXlthLXpdOlxcLy9pXG4gIGNoZWNrUGF0aC5pc05vdFJlbGF0aXZlID0gcGF0aCA9PlxuICAgIFJFR0lYX0lTX1dJTkRPV1NfUEFUSF9BQlNPTFVURS50ZXN0KHBhdGgpXG4gICAgfHwgaXNOb3RSZWxhdGl2ZShwYXRoKVxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiLyohXG5cbkpTWmlwIHYzLjcuMSAtIEEgSmF2YVNjcmlwdCBjbGFzcyBmb3IgZ2VuZXJhdGluZyBhbmQgcmVhZGluZyB6aXAgZmlsZXNcbjxodHRwOi8vc3R1YXJ0ay5jb20vanN6aXA+XG5cbihjKSAyMDA5LTIwMTYgU3R1YXJ0IEtuaWdodGxleSA8c3R1YXJ0IFthdF0gc3R1YXJ0ay5jb20+XG5EdWFsIGxpY2VuY2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBvciBHUEx2My4gU2VlIGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vU3R1ay9qc3ppcC9tYXN0ZXIvTElDRU5TRS5tYXJrZG93bi5cblxuSlNaaXAgdXNlcyB0aGUgbGlicmFyeSBwYWtvIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSA6XG5odHRwczovL2dpdGh1Yi5jb20vbm9kZWNhL3Bha28vYmxvYi9tYXN0ZXIvTElDRU5TRVxuKi9cblxuIWZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPXQoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sdCk7ZWxzZXsoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzKS5KU1ppcD10KCl9fShmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbiBzKGEsbyxoKXtmdW5jdGlvbiB1KHIsdCl7aWYoIW9bcl0pe2lmKCFhW3JdKXt2YXIgZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCF0JiZlKXJldHVybiBlKHIsITApO2lmKGwpcmV0dXJuIGwociwhMCk7dmFyIGk9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIityK1wiJ1wiKTt0aHJvdyBpLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsaX12YXIgbj1vW3JdPXtleHBvcnRzOnt9fTthW3JdWzBdLmNhbGwobi5leHBvcnRzLGZ1bmN0aW9uKHQpe3ZhciBlPWFbcl1bMV1bdF07cmV0dXJuIHUoZXx8dCl9LG4sbi5leHBvcnRzLHMsYSxvLGgpfXJldHVybiBvW3JdLmV4cG9ydHN9Zm9yKHZhciBsPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsdD0wO3Q8aC5sZW5ndGg7dCsrKXUoaFt0XSk7cmV0dXJuIHV9KHsxOltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGM9dChcIi4vdXRpbHNcIiksZD10KFwiLi9zdXBwb3J0XCIpLHA9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO3IuZW5jb2RlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxyLGksbixzLGEsbyxoPVtdLHU9MCxsPXQubGVuZ3RoLGY9bCxkPVwic3RyaW5nXCIhPT1jLmdldFR5cGVPZih0KTt1PHQubGVuZ3RoOylmPWwtdSxpPWQ/KGU9dFt1KytdLHI9dTxsP3RbdSsrXTowLHU8bD90W3UrK106MCk6KGU9dC5jaGFyQ29kZUF0KHUrKykscj11PGw/dC5jaGFyQ29kZUF0KHUrKyk6MCx1PGw/dC5jaGFyQ29kZUF0KHUrKyk6MCksbj1lPj4yLHM9KDMmZSk8PDR8cj4+NCxhPTE8Zj8oMTUmcik8PDJ8aT4+Njo2NCxvPTI8Zj82MyZpOjY0LGgucHVzaChwLmNoYXJBdChuKStwLmNoYXJBdChzKStwLmNoYXJBdChhKStwLmNoYXJBdChvKSk7cmV0dXJuIGguam9pbihcIlwiKX0sci5kZWNvZGU9ZnVuY3Rpb24odCl7dmFyIGUscixpLG4scyxhLG89MCxoPTAsdT1cImRhdGE6XCI7aWYodC5zdWJzdHIoMCx1Lmxlbmd0aCk9PT11KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGlucHV0LCBpdCBsb29rcyBsaWtlIGEgZGF0YSB1cmwuXCIpO3ZhciBsLGY9MyoodD10LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLFwiXCIpKS5sZW5ndGgvNDtpZih0LmNoYXJBdCh0Lmxlbmd0aC0xKT09PXAuY2hhckF0KDY0KSYmZi0tLHQuY2hhckF0KHQubGVuZ3RoLTIpPT09cC5jaGFyQXQoNjQpJiZmLS0sZiUxIT0wKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGlucHV0LCBiYWQgY29udGVudCBsZW5ndGguXCIpO2ZvcihsPWQudWludDhhcnJheT9uZXcgVWludDhBcnJheSgwfGYpOm5ldyBBcnJheSgwfGYpO288dC5sZW5ndGg7KWU9cC5pbmRleE9mKHQuY2hhckF0KG8rKykpPDwyfChuPXAuaW5kZXhPZih0LmNoYXJBdChvKyspKSk+PjQscj0oMTUmbik8PDR8KHM9cC5pbmRleE9mKHQuY2hhckF0KG8rKykpKT4+MixpPSgzJnMpPDw2fChhPXAuaW5kZXhPZih0LmNoYXJBdChvKyspKSksbFtoKytdPWUsNjQhPT1zJiYobFtoKytdPXIpLDY0IT09YSYmKGxbaCsrXT1pKTtyZXR1cm4gbH19LHtcIi4vc3VwcG9ydFwiOjMwLFwiLi91dGlsc1wiOjMyfV0sMjpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBpPXQoXCIuL2V4dGVybmFsXCIpLG49dChcIi4vc3RyZWFtL0RhdGFXb3JrZXJcIikscz10KFwiLi9zdHJlYW0vQ3JjMzJQcm9iZVwiKSxhPXQoXCIuL3N0cmVhbS9EYXRhTGVuZ3RoUHJvYmVcIik7ZnVuY3Rpb24gbyh0LGUscixpLG4pe3RoaXMuY29tcHJlc3NlZFNpemU9dCx0aGlzLnVuY29tcHJlc3NlZFNpemU9ZSx0aGlzLmNyYzMyPXIsdGhpcy5jb21wcmVzc2lvbj1pLHRoaXMuY29tcHJlc3NlZENvbnRlbnQ9bn1vLnByb3RvdHlwZT17Z2V0Q29udGVudFdvcmtlcjpmdW5jdGlvbigpe3ZhciB0PW5ldyBuKGkuUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29tcHJlc3NlZENvbnRlbnQpKS5waXBlKHRoaXMuY29tcHJlc3Npb24udW5jb21wcmVzc1dvcmtlcigpKS5waXBlKG5ldyBhKFwiZGF0YV9sZW5ndGhcIikpLGU9dGhpcztyZXR1cm4gdC5vbihcImVuZFwiLGZ1bmN0aW9uKCl7aWYodGhpcy5zdHJlYW1JbmZvLmRhdGFfbGVuZ3RoIT09ZS51bmNvbXByZXNzZWRTaXplKXRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IHVuY29tcHJlc3NlZCBkYXRhIHNpemUgbWlzbWF0Y2hcIil9KSx0fSxnZXRDb21wcmVzc2VkV29ya2VyOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBuKGkuUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29tcHJlc3NlZENvbnRlbnQpKS53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzZWRTaXplXCIsdGhpcy5jb21wcmVzc2VkU2l6ZSkud2l0aFN0cmVhbUluZm8oXCJ1bmNvbXByZXNzZWRTaXplXCIsdGhpcy51bmNvbXByZXNzZWRTaXplKS53aXRoU3RyZWFtSW5mbyhcImNyYzMyXCIsdGhpcy5jcmMzMikud2l0aFN0cmVhbUluZm8oXCJjb21wcmVzc2lvblwiLHRoaXMuY29tcHJlc3Npb24pfX0sby5jcmVhdGVXb3JrZXJGcm9tPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdC5waXBlKG5ldyBzKS5waXBlKG5ldyBhKFwidW5jb21wcmVzc2VkU2l6ZVwiKSkucGlwZShlLmNvbXByZXNzV29ya2VyKHIpKS5waXBlKG5ldyBhKFwiY29tcHJlc3NlZFNpemVcIikpLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3Npb25cIixlKX0sZS5leHBvcnRzPW99LHtcIi4vZXh0ZXJuYWxcIjo2LFwiLi9zdHJlYW0vQ3JjMzJQcm9iZVwiOjI1LFwiLi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlXCI6MjYsXCIuL3N0cmVhbS9EYXRhV29ya2VyXCI6Mjd9XSwzOltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9dChcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7ci5TVE9SRT17bWFnaWM6XCJcXDBcXDBcIixjb21wcmVzc1dvcmtlcjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkoXCJTVE9SRSBjb21wcmVzc2lvblwiKX0sdW5jb21wcmVzc1dvcmtlcjpmdW5jdGlvbigpe3JldHVybiBuZXcgaShcIlNUT1JFIGRlY29tcHJlc3Npb25cIil9fSxyLkRFRkxBVEU9dChcIi4vZmxhdGVcIil9LHtcIi4vZmxhdGVcIjo3LFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiOjI4fV0sNDpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBpPXQoXCIuL3V0aWxzXCIpO3ZhciBvPWZ1bmN0aW9uKCl7Zm9yKHZhciB0LGU9W10scj0wO3I8MjU2O3IrKyl7dD1yO2Zvcih2YXIgaT0wO2k8ODtpKyspdD0xJnQ/Mzk4ODI5MjM4NF50Pj4+MTp0Pj4+MTtlW3JdPXR9cmV0dXJuIGV9KCk7ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMCE9PXQmJnQubGVuZ3RoP1wic3RyaW5nXCIhPT1pLmdldFR5cGVPZih0KT9mdW5jdGlvbih0LGUscixpKXt2YXIgbj1vLHM9aStyO3RePS0xO2Zvcih2YXIgYT1pO2E8czthKyspdD10Pj4+OF5uWzI1NSYodF5lW2FdKV07cmV0dXJuLTFedH0oMHxlLHQsdC5sZW5ndGgsMCk6ZnVuY3Rpb24odCxlLHIsaSl7dmFyIG49byxzPWkrcjt0Xj0tMTtmb3IodmFyIGE9aTthPHM7YSsrKXQ9dD4+PjheblsyNTUmKHReZS5jaGFyQ29kZUF0KGEpKV07cmV0dXJuLTFedH0oMHxlLHQsdC5sZW5ndGgsMCk6MH19LHtcIi4vdXRpbHNcIjozMn1dLDU6W2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLmJhc2U2ND0hMSxyLmJpbmFyeT0hMSxyLmRpcj0hMSxyLmNyZWF0ZUZvbGRlcnM9ITAsci5kYXRlPW51bGwsci5jb21wcmVzc2lvbj1udWxsLHIuY29tcHJlc3Npb25PcHRpb25zPW51bGwsci5jb21tZW50PW51bGwsci51bml4UGVybWlzc2lvbnM9bnVsbCxyLmRvc1Blcm1pc3Npb25zPW51bGx9LHt9XSw2OltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9bnVsbDtpPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm9taXNlP1Byb21pc2U6dChcImxpZVwiKSxlLmV4cG9ydHM9e1Byb21pc2U6aX19LHtsaWU6Mzd9XSw3OltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXkmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBVaW50MTZBcnJheSYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQzMkFycmF5LG49dChcInBha29cIikscz10KFwiLi91dGlsc1wiKSxhPXQoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpLG89aT9cInVpbnQ4YXJyYXlcIjpcImFycmF5XCI7ZnVuY3Rpb24gaCh0LGUpe2EuY2FsbCh0aGlzLFwiRmxhdGVXb3JrZXIvXCIrdCksdGhpcy5fcGFrbz1udWxsLHRoaXMuX3Bha29BY3Rpb249dCx0aGlzLl9wYWtvT3B0aW9ucz1lLHRoaXMubWV0YT17fX1yLm1hZ2ljPVwiXFxiXFwwXCIscy5pbmhlcml0cyhoLGEpLGgucHJvdG90eXBlLnByb2Nlc3NDaHVuaz1mdW5jdGlvbih0KXt0aGlzLm1ldGE9dC5tZXRhLG51bGw9PT10aGlzLl9wYWtvJiZ0aGlzLl9jcmVhdGVQYWtvKCksdGhpcy5fcGFrby5wdXNoKHMudHJhbnNmb3JtVG8obyx0LmRhdGEpLCExKX0saC5wcm90b3R5cGUuZmx1c2g9ZnVuY3Rpb24oKXthLnByb3RvdHlwZS5mbHVzaC5jYWxsKHRoaXMpLG51bGw9PT10aGlzLl9wYWtvJiZ0aGlzLl9jcmVhdGVQYWtvKCksdGhpcy5fcGFrby5wdXNoKFtdLCEwKX0saC5wcm90b3R5cGUuY2xlYW5VcD1mdW5jdGlvbigpe2EucHJvdG90eXBlLmNsZWFuVXAuY2FsbCh0aGlzKSx0aGlzLl9wYWtvPW51bGx9LGgucHJvdG90eXBlLl9jcmVhdGVQYWtvPWZ1bmN0aW9uKCl7dGhpcy5fcGFrbz1uZXcgblt0aGlzLl9wYWtvQWN0aW9uXSh7cmF3OiEwLGxldmVsOnRoaXMuX3Bha29PcHRpb25zLmxldmVsfHwtMX0pO3ZhciBlPXRoaXM7dGhpcy5fcGFrby5vbkRhdGE9ZnVuY3Rpb24odCl7ZS5wdXNoKHtkYXRhOnQsbWV0YTplLm1ldGF9KX19LHIuY29tcHJlc3NXb3JrZXI9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBoKFwiRGVmbGF0ZVwiLHQpfSxyLnVuY29tcHJlc3NXb3JrZXI9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGgoXCJJbmZsYXRlXCIse30pfX0se1wiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiOjI4LFwiLi91dGlsc1wiOjMyLHBha286Mzh9XSw4OltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gQSh0LGUpe3ZhciByLGk9XCJcIjtmb3Iocj0wO3I8ZTtyKyspaSs9U3RyaW5nLmZyb21DaGFyQ29kZSgyNTUmdCksdD4+Pj04O3JldHVybiBpfWZ1bmN0aW9uIGkodCxlLHIsaSxuLHMpe3ZhciBhLG8saD10LmZpbGUsdT10LmNvbXByZXNzaW9uLGw9cyE9PU8udXRmOGVuY29kZSxmPUkudHJhbnNmb3JtVG8oXCJzdHJpbmdcIixzKGgubmFtZSkpLGQ9SS50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLE8udXRmOGVuY29kZShoLm5hbWUpKSxjPWguY29tbWVudCxwPUkudHJhbnNmb3JtVG8oXCJzdHJpbmdcIixzKGMpKSxtPUkudHJhbnNmb3JtVG8oXCJzdHJpbmdcIixPLnV0ZjhlbmNvZGUoYykpLF89ZC5sZW5ndGghPT1oLm5hbWUubGVuZ3RoLGc9bS5sZW5ndGghPT1jLmxlbmd0aCxiPVwiXCIsdj1cIlwiLHk9XCJcIix3PWguZGlyLGs9aC5kYXRlLHg9e2NyYzMyOjAsY29tcHJlc3NlZFNpemU6MCx1bmNvbXByZXNzZWRTaXplOjB9O2UmJiFyfHwoeC5jcmMzMj10LmNyYzMyLHguY29tcHJlc3NlZFNpemU9dC5jb21wcmVzc2VkU2l6ZSx4LnVuY29tcHJlc3NlZFNpemU9dC51bmNvbXByZXNzZWRTaXplKTt2YXIgUz0wO2UmJihTfD04KSxsfHwhXyYmIWd8fChTfD0yMDQ4KTt2YXIgej0wLEM9MDt3JiYoenw9MTYpLFwiVU5JWFwiPT09bj8oQz03OTgsenw9ZnVuY3Rpb24odCxlKXt2YXIgcj10O3JldHVybiB0fHwocj1lPzE2ODkzOjMzMjA0KSwoNjU1MzUmcik8PDE2fShoLnVuaXhQZXJtaXNzaW9ucyx3KSk6KEM9MjAsenw9ZnVuY3Rpb24odCl7cmV0dXJuIDYzJih0fHwwKX0oaC5kb3NQZXJtaXNzaW9ucykpLGE9ay5nZXRVVENIb3VycygpLGE8PD02LGF8PWsuZ2V0VVRDTWludXRlcygpLGE8PD01LGF8PWsuZ2V0VVRDU2Vjb25kcygpLzIsbz1rLmdldFVUQ0Z1bGxZZWFyKCktMTk4MCxvPDw9NCxvfD1rLmdldFVUQ01vbnRoKCkrMSxvPDw9NSxvfD1rLmdldFVUQ0RhdGUoKSxfJiYodj1BKDEsMSkrQShCKGYpLDQpK2QsYis9XCJ1cFwiK0Eodi5sZW5ndGgsMikrdiksZyYmKHk9QSgxLDEpK0EoQihwKSw0KSttLGIrPVwidWNcIitBKHkubGVuZ3RoLDIpK3kpO3ZhciBFPVwiXCI7cmV0dXJuIEUrPVwiXFxuXFwwXCIsRSs9QShTLDIpLEUrPXUubWFnaWMsRSs9QShhLDIpLEUrPUEobywyKSxFKz1BKHguY3JjMzIsNCksRSs9QSh4LmNvbXByZXNzZWRTaXplLDQpLEUrPUEoeC51bmNvbXByZXNzZWRTaXplLDQpLEUrPUEoZi5sZW5ndGgsMiksRSs9QShiLmxlbmd0aCwyKSx7ZmlsZVJlY29yZDpSLkxPQ0FMX0ZJTEVfSEVBREVSK0UrZitiLGRpclJlY29yZDpSLkNFTlRSQUxfRklMRV9IRUFERVIrQShDLDIpK0UrQShwLmxlbmd0aCwyKStcIlxcMFxcMFxcMFxcMFwiK0Eoeiw0KStBKGksNCkrZitiK3B9fXZhciBJPXQoXCIuLi91dGlsc1wiKSxuPXQoXCIuLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKSxPPXQoXCIuLi91dGY4XCIpLEI9dChcIi4uL2NyYzMyXCIpLFI9dChcIi4uL3NpZ25hdHVyZVwiKTtmdW5jdGlvbiBzKHQsZSxyLGkpe24uY2FsbCh0aGlzLFwiWmlwRmlsZVdvcmtlclwiKSx0aGlzLmJ5dGVzV3JpdHRlbj0wLHRoaXMuemlwQ29tbWVudD1lLHRoaXMuemlwUGxhdGZvcm09cix0aGlzLmVuY29kZUZpbGVOYW1lPWksdGhpcy5zdHJlYW1GaWxlcz10LHRoaXMuYWNjdW11bGF0ZT0hMSx0aGlzLmNvbnRlbnRCdWZmZXI9W10sdGhpcy5kaXJSZWNvcmRzPVtdLHRoaXMuY3VycmVudFNvdXJjZU9mZnNldD0wLHRoaXMuZW50cmllc0NvdW50PTAsdGhpcy5jdXJyZW50RmlsZT1udWxsLHRoaXMuX3NvdXJjZXM9W119SS5pbmhlcml0cyhzLG4pLHMucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24odCl7dmFyIGU9dC5tZXRhLnBlcmNlbnR8fDAscj10aGlzLmVudHJpZXNDb3VudCxpPXRoaXMuX3NvdXJjZXMubGVuZ3RoO3RoaXMuYWNjdW11bGF0ZT90aGlzLmNvbnRlbnRCdWZmZXIucHVzaCh0KToodGhpcy5ieXRlc1dyaXR0ZW4rPXQuZGF0YS5sZW5ndGgsbi5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMse2RhdGE6dC5kYXRhLG1ldGE6e2N1cnJlbnRGaWxlOnRoaXMuY3VycmVudEZpbGUscGVyY2VudDpyPyhlKzEwMCooci1pLTEpKS9yOjEwMH19KSl9LHMucHJvdG90eXBlLm9wZW5lZFNvdXJjZT1mdW5jdGlvbih0KXt0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQ9dGhpcy5ieXRlc1dyaXR0ZW4sdGhpcy5jdXJyZW50RmlsZT10LmZpbGUubmFtZTt2YXIgZT10aGlzLnN0cmVhbUZpbGVzJiYhdC5maWxlLmRpcjtpZihlKXt2YXIgcj1pKHQsZSwhMSx0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQsdGhpcy56aXBQbGF0Zm9ybSx0aGlzLmVuY29kZUZpbGVOYW1lKTt0aGlzLnB1c2goe2RhdGE6ci5maWxlUmVjb3JkLG1ldGE6e3BlcmNlbnQ6MH19KX1lbHNlIHRoaXMuYWNjdW11bGF0ZT0hMH0scy5wcm90b3R5cGUuY2xvc2VkU291cmNlPWZ1bmN0aW9uKHQpe3RoaXMuYWNjdW11bGF0ZT0hMTt2YXIgZT10aGlzLnN0cmVhbUZpbGVzJiYhdC5maWxlLmRpcixyPWkodCxlLCEwLHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCx0aGlzLnppcFBsYXRmb3JtLHRoaXMuZW5jb2RlRmlsZU5hbWUpO2lmKHRoaXMuZGlyUmVjb3Jkcy5wdXNoKHIuZGlyUmVjb3JkKSxlKXRoaXMucHVzaCh7ZGF0YTpmdW5jdGlvbih0KXtyZXR1cm4gUi5EQVRBX0RFU0NSSVBUT1IrQSh0LmNyYzMyLDQpK0EodC5jb21wcmVzc2VkU2l6ZSw0KStBKHQudW5jb21wcmVzc2VkU2l6ZSw0KX0odCksbWV0YTp7cGVyY2VudDoxMDB9fSk7ZWxzZSBmb3IodGhpcy5wdXNoKHtkYXRhOnIuZmlsZVJlY29yZCxtZXRhOntwZXJjZW50OjB9fSk7dGhpcy5jb250ZW50QnVmZmVyLmxlbmd0aDspdGhpcy5wdXNoKHRoaXMuY29udGVudEJ1ZmZlci5zaGlmdCgpKTt0aGlzLmN1cnJlbnRGaWxlPW51bGx9LHMucHJvdG90eXBlLmZsdXNoPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuYnl0ZXNXcml0dGVuLGU9MDtlPHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGg7ZSsrKXRoaXMucHVzaCh7ZGF0YTp0aGlzLmRpclJlY29yZHNbZV0sbWV0YTp7cGVyY2VudDoxMDB9fSk7dmFyIHI9dGhpcy5ieXRlc1dyaXR0ZW4tdCxpPWZ1bmN0aW9uKHQsZSxyLGksbil7dmFyIHM9SS50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLG4oaSkpO3JldHVybiBSLkNFTlRSQUxfRElSRUNUT1JZX0VORCtcIlxcMFxcMFxcMFxcMFwiK0EodCwyKStBKHQsMikrQShlLDQpK0Eociw0KStBKHMubGVuZ3RoLDIpK3N9KHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGgscix0LHRoaXMuemlwQ29tbWVudCx0aGlzLmVuY29kZUZpbGVOYW1lKTt0aGlzLnB1c2goe2RhdGE6aSxtZXRhOntwZXJjZW50OjEwMH19KX0scy5wcm90b3R5cGUucHJlcGFyZU5leHRTb3VyY2U9ZnVuY3Rpb24oKXt0aGlzLnByZXZpb3VzPXRoaXMuX3NvdXJjZXMuc2hpZnQoKSx0aGlzLm9wZW5lZFNvdXJjZSh0aGlzLnByZXZpb3VzLnN0cmVhbUluZm8pLHRoaXMuaXNQYXVzZWQ/dGhpcy5wcmV2aW91cy5wYXVzZSgpOnRoaXMucHJldmlvdXMucmVzdW1lKCl9LHMucHJvdG90eXBlLnJlZ2lzdGVyUHJldmlvdXM9ZnVuY3Rpb24odCl7dGhpcy5fc291cmNlcy5wdXNoKHQpO3ZhciBlPXRoaXM7cmV0dXJuIHQub24oXCJkYXRhXCIsZnVuY3Rpb24odCl7ZS5wcm9jZXNzQ2h1bmsodCl9KSx0Lm9uKFwiZW5kXCIsZnVuY3Rpb24oKXtlLmNsb3NlZFNvdXJjZShlLnByZXZpb3VzLnN0cmVhbUluZm8pLGUuX3NvdXJjZXMubGVuZ3RoP2UucHJlcGFyZU5leHRTb3VyY2UoKTplLmVuZCgpfSksdC5vbihcImVycm9yXCIsZnVuY3Rpb24odCl7ZS5lcnJvcih0KX0pLHRoaXN9LHMucHJvdG90eXBlLnJlc3VtZT1mdW5jdGlvbigpe3JldHVybiEhbi5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykmJighdGhpcy5wcmV2aW91cyYmdGhpcy5fc291cmNlcy5sZW5ndGg/KHRoaXMucHJlcGFyZU5leHRTb3VyY2UoKSwhMCk6dGhpcy5wcmV2aW91c3x8dGhpcy5fc291cmNlcy5sZW5ndGh8fHRoaXMuZ2VuZXJhdGVkRXJyb3I/dm9pZCAwOih0aGlzLmVuZCgpLCEwKSl9LHMucHJvdG90eXBlLmVycm9yPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX3NvdXJjZXM7aWYoIW4ucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcyx0KSlyZXR1cm4hMTtmb3IodmFyIHI9MDtyPGUubGVuZ3RoO3IrKyl0cnl7ZVtyXS5lcnJvcih0KX1jYXRjaCh0KXt9cmV0dXJuITB9LHMucHJvdG90eXBlLmxvY2s9ZnVuY3Rpb24oKXtuLnByb3RvdHlwZS5sb2NrLmNhbGwodGhpcyk7Zm9yKHZhciB0PXRoaXMuX3NvdXJjZXMsZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV0ubG9jaygpfSxlLmV4cG9ydHM9c30se1wiLi4vY3JjMzJcIjo0LFwiLi4vc2lnbmF0dXJlXCI6MjMsXCIuLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiOjI4LFwiLi4vdXRmOFwiOjMxLFwiLi4vdXRpbHNcIjozMn1dLDk6W2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgdT10KFwiLi4vY29tcHJlc3Npb25zXCIpLGk9dChcIi4vWmlwRmlsZVdvcmtlclwiKTtyLmdlbmVyYXRlV29ya2VyPWZ1bmN0aW9uKHQsYSxlKXt2YXIgbz1uZXcgaShhLnN0cmVhbUZpbGVzLGUsYS5wbGF0Zm9ybSxhLmVuY29kZUZpbGVOYW1lKSxoPTA7dHJ5e3QuZm9yRWFjaChmdW5jdGlvbih0LGUpe2grKzt2YXIgcj1mdW5jdGlvbih0LGUpe3ZhciByPXR8fGUsaT11W3JdO2lmKCFpKXRocm93IG5ldyBFcnJvcihyK1wiIGlzIG5vdCBhIHZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZCAhXCIpO3JldHVybiBpfShlLm9wdGlvbnMuY29tcHJlc3Npb24sYS5jb21wcmVzc2lvbiksaT1lLm9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zfHxhLmNvbXByZXNzaW9uT3B0aW9uc3x8e30sbj1lLmRpcixzPWUuZGF0ZTtlLl9jb21wcmVzc1dvcmtlcihyLGkpLndpdGhTdHJlYW1JbmZvKFwiZmlsZVwiLHtuYW1lOnQsZGlyOm4sZGF0ZTpzLGNvbW1lbnQ6ZS5jb21tZW50fHxcIlwiLHVuaXhQZXJtaXNzaW9uczplLnVuaXhQZXJtaXNzaW9ucyxkb3NQZXJtaXNzaW9uczplLmRvc1Blcm1pc3Npb25zfSkucGlwZShvKX0pLG8uZW50cmllc0NvdW50PWh9Y2F0Y2godCl7by5lcnJvcih0KX1yZXR1cm4gb319LHtcIi4uL2NvbXByZXNzaW9uc1wiOjMsXCIuL1ppcEZpbGVXb3JrZXJcIjo4fV0sMTA6W2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKCl7aWYoISh0aGlzIGluc3RhbmNlb2YgaSkpcmV0dXJuIG5ldyBpO2lmKGFyZ3VtZW50cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNvbnN0cnVjdG9yIHdpdGggcGFyYW1ldGVycyBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKTt0aGlzLmZpbGVzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5jb21tZW50PW51bGwsdGhpcy5yb290PVwiXCIsdGhpcy5jbG9uZT1mdW5jdGlvbigpe3ZhciB0PW5ldyBpO2Zvcih2YXIgZSBpbiB0aGlzKVwiZnVuY3Rpb25cIiE9dHlwZW9mIHRoaXNbZV0mJih0W2VdPXRoaXNbZV0pO3JldHVybiB0fX0oaS5wcm90b3R5cGU9dChcIi4vb2JqZWN0XCIpKS5sb2FkQXN5bmM9dChcIi4vbG9hZFwiKSxpLnN1cHBvcnQ9dChcIi4vc3VwcG9ydFwiKSxpLmRlZmF1bHRzPXQoXCIuL2RlZmF1bHRzXCIpLGkudmVyc2lvbj1cIjMuNy4xXCIsaS5sb2FkQXN5bmM9ZnVuY3Rpb24odCxlKXtyZXR1cm4obmV3IGkpLmxvYWRBc3luYyh0LGUpfSxpLmV4dGVybmFsPXQoXCIuL2V4dGVybmFsXCIpLGUuZXhwb3J0cz1pfSx7XCIuL2RlZmF1bHRzXCI6NSxcIi4vZXh0ZXJuYWxcIjo2LFwiLi9sb2FkXCI6MTEsXCIuL29iamVjdFwiOjE1LFwiLi9zdXBwb3J0XCI6MzB9XSwxMTpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBpPXQoXCIuL3V0aWxzXCIpLG49dChcIi4vZXh0ZXJuYWxcIiksbz10KFwiLi91dGY4XCIpLGg9dChcIi4vemlwRW50cmllc1wiKSxzPXQoXCIuL3N0cmVhbS9DcmMzMlByb2JlXCIpLHU9dChcIi4vbm9kZWpzVXRpbHNcIik7ZnVuY3Rpb24gbChpKXtyZXR1cm4gbmV3IG4uUHJvbWlzZShmdW5jdGlvbih0LGUpe3ZhciByPWkuZGVjb21wcmVzc2VkLmdldENvbnRlbnRXb3JrZXIoKS5waXBlKG5ldyBzKTtyLm9uKFwiZXJyb3JcIixmdW5jdGlvbih0KXtlKHQpfSkub24oXCJlbmRcIixmdW5jdGlvbigpe3Iuc3RyZWFtSW5mby5jcmMzMiE9PWkuZGVjb21wcmVzc2VkLmNyYzMyP2UobmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCA6IENSQzMyIG1pc21hdGNoXCIpKTp0KCl9KS5yZXN1bWUoKX0pfWUuZXhwb3J0cz1mdW5jdGlvbih0LHMpe3ZhciBhPXRoaXM7cmV0dXJuIHM9aS5leHRlbmQoc3x8e30se2Jhc2U2NDohMSxjaGVja0NSQzMyOiExLG9wdGltaXplZEJpbmFyeVN0cmluZzohMSxjcmVhdGVGb2xkZXJzOiExLGRlY29kZUZpbGVOYW1lOm8udXRmOGRlY29kZX0pLHUuaXNOb2RlJiZ1LmlzU3RyZWFtKHQpP24uUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSlNaaXAgY2FuJ3QgYWNjZXB0IGEgc3RyZWFtIHdoZW4gbG9hZGluZyBhIHppcCBmaWxlLlwiKSk6aS5wcmVwYXJlQ29udGVudChcInRoZSBsb2FkZWQgemlwIGZpbGVcIix0LCEwLHMub3B0aW1pemVkQmluYXJ5U3RyaW5nLHMuYmFzZTY0KS50aGVuKGZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBoKHMpO3JldHVybiBlLmxvYWQodCksZX0pLnRoZW4oZnVuY3Rpb24odCl7dmFyIGU9W24uUHJvbWlzZS5yZXNvbHZlKHQpXSxyPXQuZmlsZXM7aWYocy5jaGVja0NSQzMyKWZvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKWUucHVzaChsKHJbaV0pKTtyZXR1cm4gbi5Qcm9taXNlLmFsbChlKX0pLnRoZW4oZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuc2hpZnQoKSxyPWUuZmlsZXMsaT0wO2k8ci5sZW5ndGg7aSsrKXt2YXIgbj1yW2ldO2EuZmlsZShuLmZpbGVOYW1lU3RyLG4uZGVjb21wcmVzc2VkLHtiaW5hcnk6ITAsb3B0aW1pemVkQmluYXJ5U3RyaW5nOiEwLGRhdGU6bi5kYXRlLGRpcjpuLmRpcixjb21tZW50Om4uZmlsZUNvbW1lbnRTdHIubGVuZ3RoP24uZmlsZUNvbW1lbnRTdHI6bnVsbCx1bml4UGVybWlzc2lvbnM6bi51bml4UGVybWlzc2lvbnMsZG9zUGVybWlzc2lvbnM6bi5kb3NQZXJtaXNzaW9ucyxjcmVhdGVGb2xkZXJzOnMuY3JlYXRlRm9sZGVyc30pfXJldHVybiBlLnppcENvbW1lbnQubGVuZ3RoJiYoYS5jb21tZW50PWUuemlwQ29tbWVudCksYX0pfX0se1wiLi9leHRlcm5hbFwiOjYsXCIuL25vZGVqc1V0aWxzXCI6MTQsXCIuL3N0cmVhbS9DcmMzMlByb2JlXCI6MjUsXCIuL3V0ZjhcIjozMSxcIi4vdXRpbHNcIjozMixcIi4vemlwRW50cmllc1wiOjMzfV0sMTI6W2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgaT10KFwiLi4vdXRpbHNcIiksbj10KFwiLi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIik7ZnVuY3Rpb24gcyh0LGUpe24uY2FsbCh0aGlzLFwiTm9kZWpzIHN0cmVhbSBpbnB1dCBhZGFwdGVyIGZvciBcIit0KSx0aGlzLl91cHN0cmVhbUVuZGVkPSExLHRoaXMuX2JpbmRTdHJlYW0oZSl9aS5pbmhlcml0cyhzLG4pLHMucHJvdG90eXBlLl9iaW5kU3RyZWFtPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7KHRoaXMuX3N0cmVhbT10KS5wYXVzZSgpLHQub24oXCJkYXRhXCIsZnVuY3Rpb24odCl7ZS5wdXNoKHtkYXRhOnQsbWV0YTp7cGVyY2VudDowfX0pfSkub24oXCJlcnJvclwiLGZ1bmN0aW9uKHQpe2UuaXNQYXVzZWQ/dGhpcy5nZW5lcmF0ZWRFcnJvcj10OmUuZXJyb3IodCl9KS5vbihcImVuZFwiLGZ1bmN0aW9uKCl7ZS5pc1BhdXNlZD9lLl91cHN0cmVhbUVuZGVkPSEwOmUuZW5kKCl9KX0scy5wcm90b3R5cGUucGF1c2U9ZnVuY3Rpb24oKXtyZXR1cm4hIW4ucHJvdG90eXBlLnBhdXNlLmNhbGwodGhpcykmJih0aGlzLl9zdHJlYW0ucGF1c2UoKSwhMCl9LHMucHJvdG90eXBlLnJlc3VtZT1mdW5jdGlvbigpe3JldHVybiEhbi5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykmJih0aGlzLl91cHN0cmVhbUVuZGVkP3RoaXMuZW5kKCk6dGhpcy5fc3RyZWFtLnJlc3VtZSgpLCEwKX0sZS5leHBvcnRzPXN9LHtcIi4uL3N0cmVhbS9HZW5lcmljV29ya2VyXCI6MjgsXCIuLi91dGlsc1wiOjMyfV0sMTM6W2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj10KFwicmVhZGFibGUtc3RyZWFtXCIpLlJlYWRhYmxlO2Z1bmN0aW9uIGkodCxlLHIpe24uY2FsbCh0aGlzLGUpLHRoaXMuX2hlbHBlcj10O3ZhciBpPXRoaXM7dC5vbihcImRhdGFcIixmdW5jdGlvbih0LGUpe2kucHVzaCh0KXx8aS5faGVscGVyLnBhdXNlKCksciYmcihlKX0pLm9uKFwiZXJyb3JcIixmdW5jdGlvbih0KXtpLmVtaXQoXCJlcnJvclwiLHQpfSkub24oXCJlbmRcIixmdW5jdGlvbigpe2kucHVzaChudWxsKX0pfXQoXCIuLi91dGlsc1wiKS5pbmhlcml0cyhpLG4pLGkucHJvdG90eXBlLl9yZWFkPWZ1bmN0aW9uKCl7dGhpcy5faGVscGVyLnJlc3VtZSgpfSxlLmV4cG9ydHM9aX0se1wiLi4vdXRpbHNcIjozMixcInJlYWRhYmxlLXN0cmVhbVwiOjE2fV0sMTQ6W2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9e2lzTm9kZTpcInVuZGVmaW5lZFwiIT10eXBlb2YgQnVmZmVyLG5ld0J1ZmZlckZyb206ZnVuY3Rpb24odCxlKXtpZihCdWZmZXIuZnJvbSYmQnVmZmVyLmZyb20hPT1VaW50OEFycmF5LmZyb20pcmV0dXJuIEJ1ZmZlci5mcm9tKHQsZSk7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpdGhyb3cgbmV3IEVycm9yKCdUaGUgXCJkYXRhXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKTtyZXR1cm4gbmV3IEJ1ZmZlcih0LGUpfSxhbGxvY0J1ZmZlcjpmdW5jdGlvbih0KXtpZihCdWZmZXIuYWxsb2MpcmV0dXJuIEJ1ZmZlci5hbGxvYyh0KTt2YXIgZT1uZXcgQnVmZmVyKHQpO3JldHVybiBlLmZpbGwoMCksZX0saXNCdWZmZXI6ZnVuY3Rpb24odCl7cmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcih0KX0saXNTdHJlYW06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQub24mJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQucGF1c2UmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQucmVzdW1lfX19LHt9XSwxNTpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHModCxlLHIpe3ZhciBpLG49dS5nZXRUeXBlT2YoZSkscz11LmV4dGVuZChyfHx7fSxmKTtzLmRhdGU9cy5kYXRlfHxuZXcgRGF0ZSxudWxsIT09cy5jb21wcmVzc2lvbiYmKHMuY29tcHJlc3Npb249cy5jb21wcmVzc2lvbi50b1VwcGVyQ2FzZSgpKSxcInN0cmluZ1wiPT10eXBlb2Ygcy51bml4UGVybWlzc2lvbnMmJihzLnVuaXhQZXJtaXNzaW9ucz1wYXJzZUludChzLnVuaXhQZXJtaXNzaW9ucyw4KSkscy51bml4UGVybWlzc2lvbnMmJjE2Mzg0JnMudW5peFBlcm1pc3Npb25zJiYocy5kaXI9ITApLHMuZG9zUGVybWlzc2lvbnMmJjE2JnMuZG9zUGVybWlzc2lvbnMmJihzLmRpcj0hMCkscy5kaXImJih0PWcodCkpLHMuY3JlYXRlRm9sZGVycyYmKGk9Xyh0KSkmJmIuY2FsbCh0aGlzLGksITApO3ZhciBhPVwic3RyaW5nXCI9PT1uJiYhMT09PXMuYmluYXJ5JiYhMT09PXMuYmFzZTY0O3ImJnZvaWQgMCE9PXIuYmluYXJ5fHwocy5iaW5hcnk9IWEpLChlIGluc3RhbmNlb2YgZCYmMD09PWUudW5jb21wcmVzc2VkU2l6ZXx8cy5kaXJ8fCFlfHwwPT09ZS5sZW5ndGgpJiYocy5iYXNlNjQ9ITEscy5iaW5hcnk9ITAsZT1cIlwiLHMuY29tcHJlc3Npb249XCJTVE9SRVwiLG49XCJzdHJpbmdcIik7dmFyIG89bnVsbDtvPWUgaW5zdGFuY2VvZiBkfHxlIGluc3RhbmNlb2YgbD9lOnAuaXNOb2RlJiZwLmlzU3RyZWFtKGUpP25ldyBtKHQsZSk6dS5wcmVwYXJlQ29udGVudCh0LGUscy5iaW5hcnkscy5vcHRpbWl6ZWRCaW5hcnlTdHJpbmcscy5iYXNlNjQpO3ZhciBoPW5ldyBjKHQsbyxzKTt0aGlzLmZpbGVzW3RdPWh9dmFyIG49dChcIi4vdXRmOFwiKSx1PXQoXCIuL3V0aWxzXCIpLGw9dChcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIiksYT10KFwiLi9zdHJlYW0vU3RyZWFtSGVscGVyXCIpLGY9dChcIi4vZGVmYXVsdHNcIiksZD10KFwiLi9jb21wcmVzc2VkT2JqZWN0XCIpLGM9dChcIi4vemlwT2JqZWN0XCIpLG89dChcIi4vZ2VuZXJhdGVcIikscD10KFwiLi9ub2RlanNVdGlsc1wiKSxtPXQoXCIuL25vZGVqcy9Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXJcIiksXz1mdW5jdGlvbih0KXtcIi9cIj09PXQuc2xpY2UoLTEpJiYodD10LnN1YnN0cmluZygwLHQubGVuZ3RoLTEpKTt2YXIgZT10Lmxhc3RJbmRleE9mKFwiL1wiKTtyZXR1cm4gMDxlP3Quc3Vic3RyaW5nKDAsZSk6XCJcIn0sZz1mdW5jdGlvbih0KXtyZXR1cm5cIi9cIiE9PXQuc2xpY2UoLTEpJiYodCs9XCIvXCIpLHR9LGI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZT12b2lkIDAhPT1lP2U6Zi5jcmVhdGVGb2xkZXJzLHQ9Zyh0KSx0aGlzLmZpbGVzW3RdfHxzLmNhbGwodGhpcyx0LG51bGwse2RpcjohMCxjcmVhdGVGb2xkZXJzOmV9KSx0aGlzLmZpbGVzW3RdfTtmdW5jdGlvbiBoKHQpe3JldHVyblwiW29iamVjdCBSZWdFeHBdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCl9dmFyIGk9e2xvYWQ6ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIG1ldGhvZCBoYXMgYmVlbiByZW1vdmVkIGluIEpTWmlwIDMuMCwgcGxlYXNlIGNoZWNrIHRoZSB1cGdyYWRlIGd1aWRlLlwiKX0sZm9yRWFjaDpmdW5jdGlvbih0KXt2YXIgZSxyLGk7Zm9yKGUgaW4gdGhpcy5maWxlcylpPXRoaXMuZmlsZXNbZV0sKHI9ZS5zbGljZSh0aGlzLnJvb3QubGVuZ3RoLGUubGVuZ3RoKSkmJmUuc2xpY2UoMCx0aGlzLnJvb3QubGVuZ3RoKT09PXRoaXMucm9vdCYmdChyLGkpfSxmaWx0ZXI6ZnVuY3Rpb24ocil7dmFyIGk9W107cmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbih0LGUpe3IodCxlKSYmaS5wdXNoKGUpfSksaX0sZmlsZTpmdW5jdGlvbih0LGUscil7aWYoMSE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHQ9dGhpcy5yb290K3Qscy5jYWxsKHRoaXMsdCxlLHIpLHRoaXM7aWYoaCh0KSl7dmFyIGk9dDtyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24odCxlKXtyZXR1cm4hZS5kaXImJmkudGVzdCh0KX0pfXZhciBuPXRoaXMuZmlsZXNbdGhpcy5yb290K3RdO3JldHVybiBuJiYhbi5kaXI/bjpudWxsfSxmb2xkZXI6ZnVuY3Rpb24ocil7aWYoIXIpcmV0dXJuIHRoaXM7aWYoaChyKSlyZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5kaXImJnIudGVzdCh0KX0pO3ZhciB0PXRoaXMucm9vdCtyLGU9Yi5jYWxsKHRoaXMsdCksaT10aGlzLmNsb25lKCk7cmV0dXJuIGkucm9vdD1lLm5hbWUsaX0scmVtb3ZlOmZ1bmN0aW9uKHIpe3I9dGhpcy5yb290K3I7dmFyIHQ9dGhpcy5maWxlc1tyXTtpZih0fHwoXCIvXCIhPT1yLnNsaWNlKC0xKSYmKHIrPVwiL1wiKSx0PXRoaXMuZmlsZXNbcl0pLHQmJiF0LmRpcilkZWxldGUgdGhpcy5maWxlc1tyXTtlbHNlIGZvcih2YXIgZT10aGlzLmZpbHRlcihmdW5jdGlvbih0LGUpe3JldHVybiBlLm5hbWUuc2xpY2UoMCxyLmxlbmd0aCk9PT1yfSksaT0wO2k8ZS5sZW5ndGg7aSsrKWRlbGV0ZSB0aGlzLmZpbGVzW2VbaV0ubmFtZV07cmV0dXJuIHRoaXN9LGdlbmVyYXRlOmZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpfSxnZW5lcmF0ZUludGVybmFsU3RyZWFtOmZ1bmN0aW9uKHQpe3ZhciBlLHI9e307dHJ5e2lmKChyPXUuZXh0ZW5kKHR8fHt9LHtzdHJlYW1GaWxlczohMSxjb21wcmVzc2lvbjpcIlNUT1JFXCIsY29tcHJlc3Npb25PcHRpb25zOm51bGwsdHlwZTpcIlwiLHBsYXRmb3JtOlwiRE9TXCIsY29tbWVudDpudWxsLG1pbWVUeXBlOlwiYXBwbGljYXRpb24vemlwXCIsZW5jb2RlRmlsZU5hbWU6bi51dGY4ZW5jb2RlfSkpLnR5cGU9ci50eXBlLnRvTG93ZXJDYXNlKCksci5jb21wcmVzc2lvbj1yLmNvbXByZXNzaW9uLnRvVXBwZXJDYXNlKCksXCJiaW5hcnlzdHJpbmdcIj09PXIudHlwZSYmKHIudHlwZT1cInN0cmluZ1wiKSwhci50eXBlKXRocm93IG5ldyBFcnJvcihcIk5vIG91dHB1dCB0eXBlIHNwZWNpZmllZC5cIik7dS5jaGVja1N1cHBvcnQoci50eXBlKSxcImRhcndpblwiIT09ci5wbGF0Zm9ybSYmXCJmcmVlYnNkXCIhPT1yLnBsYXRmb3JtJiZcImxpbnV4XCIhPT1yLnBsYXRmb3JtJiZcInN1bm9zXCIhPT1yLnBsYXRmb3JtfHwoci5wbGF0Zm9ybT1cIlVOSVhcIiksXCJ3aW4zMlwiPT09ci5wbGF0Zm9ybSYmKHIucGxhdGZvcm09XCJET1NcIik7dmFyIGk9ci5jb21tZW50fHx0aGlzLmNvbW1lbnR8fFwiXCI7ZT1vLmdlbmVyYXRlV29ya2VyKHRoaXMscixpKX1jYXRjaCh0KXsoZT1uZXcgbChcImVycm9yXCIpKS5lcnJvcih0KX1yZXR1cm4gbmV3IGEoZSxyLnR5cGV8fFwic3RyaW5nXCIsci5taW1lVHlwZSl9LGdlbmVyYXRlQXN5bmM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKHQpLmFjY3VtdWxhdGUoZSl9LGdlbmVyYXRlTm9kZVN0cmVhbTpmdW5jdGlvbih0LGUpe3JldHVybih0PXR8fHt9KS50eXBlfHwodC50eXBlPVwibm9kZWJ1ZmZlclwiKSx0aGlzLmdlbmVyYXRlSW50ZXJuYWxTdHJlYW0odCkudG9Ob2RlanNTdHJlYW0oZSl9fTtlLmV4cG9ydHM9aX0se1wiLi9jb21wcmVzc2VkT2JqZWN0XCI6MixcIi4vZGVmYXVsdHNcIjo1LFwiLi9nZW5lcmF0ZVwiOjksXCIuL25vZGVqcy9Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXJcIjoxMixcIi4vbm9kZWpzVXRpbHNcIjoxNCxcIi4vc3RyZWFtL0dlbmVyaWNXb3JrZXJcIjoyOCxcIi4vc3RyZWFtL1N0cmVhbUhlbHBlclwiOjI5LFwiLi91dGY4XCI6MzEsXCIuL3V0aWxzXCI6MzIsXCIuL3ppcE9iamVjdFwiOjM1fV0sMTY6W2Z1bmN0aW9uKHQsZSxyKXtlLmV4cG9ydHM9dChcInN0cmVhbVwiKX0se3N0cmVhbTp2b2lkIDB9XSwxNzpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBpPXQoXCIuL0RhdGFSZWFkZXJcIik7ZnVuY3Rpb24gbih0KXtpLmNhbGwodGhpcyx0KTtmb3IodmFyIGU9MDtlPHRoaXMuZGF0YS5sZW5ndGg7ZSsrKXRbZV09MjU1JnRbZV19dChcIi4uL3V0aWxzXCIpLmluaGVyaXRzKG4saSksbi5wcm90b3R5cGUuYnl0ZUF0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGFbdGhpcy56ZXJvK3RdfSxuLnByb3RvdHlwZS5sYXN0SW5kZXhPZlNpZ25hdHVyZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5jaGFyQ29kZUF0KDApLHI9dC5jaGFyQ29kZUF0KDEpLGk9dC5jaGFyQ29kZUF0KDIpLG49dC5jaGFyQ29kZUF0KDMpLHM9dGhpcy5sZW5ndGgtNDswPD1zOy0tcylpZih0aGlzLmRhdGFbc109PT1lJiZ0aGlzLmRhdGFbcysxXT09PXImJnRoaXMuZGF0YVtzKzJdPT09aSYmdGhpcy5kYXRhW3MrM109PT1uKXJldHVybiBzLXRoaXMuemVybztyZXR1cm4tMX0sbi5wcm90b3R5cGUucmVhZEFuZENoZWNrU2lnbmF0dXJlPWZ1bmN0aW9uKHQpe3ZhciBlPXQuY2hhckNvZGVBdCgwKSxyPXQuY2hhckNvZGVBdCgxKSxpPXQuY2hhckNvZGVBdCgyKSxuPXQuY2hhckNvZGVBdCgzKSxzPXRoaXMucmVhZERhdGEoNCk7cmV0dXJuIGU9PT1zWzBdJiZyPT09c1sxXSYmaT09PXNbMl0mJm49PT1zWzNdfSxuLnByb3RvdHlwZS5yZWFkRGF0YT1mdW5jdGlvbih0KXtpZih0aGlzLmNoZWNrT2Zmc2V0KHQpLDA9PT10KXJldHVybltdO3ZhciBlPXRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8rdGhpcy5pbmRleCx0aGlzLnplcm8rdGhpcy5pbmRleCt0KTtyZXR1cm4gdGhpcy5pbmRleCs9dCxlfSxlLmV4cG9ydHM9bn0se1wiLi4vdXRpbHNcIjozMixcIi4vRGF0YVJlYWRlclwiOjE4fV0sMTg6W2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgaT10KFwiLi4vdXRpbHNcIik7ZnVuY3Rpb24gbih0KXt0aGlzLmRhdGE9dCx0aGlzLmxlbmd0aD10Lmxlbmd0aCx0aGlzLmluZGV4PTAsdGhpcy56ZXJvPTB9bi5wcm90b3R5cGU9e2NoZWNrT2Zmc2V0OmZ1bmN0aW9uKHQpe3RoaXMuY2hlY2tJbmRleCh0aGlzLmluZGV4K3QpfSxjaGVja0luZGV4OmZ1bmN0aW9uKHQpe2lmKHRoaXMubGVuZ3RoPHRoaXMuemVybyt0fHx0PDApdGhyb3cgbmV3IEVycm9yKFwiRW5kIG9mIGRhdGEgcmVhY2hlZCAoZGF0YSBsZW5ndGggPSBcIit0aGlzLmxlbmd0aCtcIiwgYXNrZWQgaW5kZXggPSBcIit0K1wiKS4gQ29ycnVwdGVkIHppcCA/XCIpfSxzZXRJbmRleDpmdW5jdGlvbih0KXt0aGlzLmNoZWNrSW5kZXgodCksdGhpcy5pbmRleD10fSxza2lwOmZ1bmN0aW9uKHQpe3RoaXMuc2V0SW5kZXgodGhpcy5pbmRleCt0KX0sYnl0ZUF0OmZ1bmN0aW9uKHQpe30scmVhZEludDpmdW5jdGlvbih0KXt2YXIgZSxyPTA7Zm9yKHRoaXMuY2hlY2tPZmZzZXQodCksZT10aGlzLmluZGV4K3QtMTtlPj10aGlzLmluZGV4O2UtLSlyPShyPDw4KSt0aGlzLmJ5dGVBdChlKTtyZXR1cm4gdGhpcy5pbmRleCs9dCxyfSxyZWFkU3RyaW5nOmZ1bmN0aW9uKHQpe3JldHVybiBpLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsdGhpcy5yZWFkRGF0YSh0KSl9LHJlYWREYXRhOmZ1bmN0aW9uKHQpe30sbGFzdEluZGV4T2ZTaWduYXR1cmU6ZnVuY3Rpb24odCl7fSxyZWFkQW5kQ2hlY2tTaWduYXR1cmU6ZnVuY3Rpb24odCl7fSxyZWFkRGF0ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucmVhZEludCg0KTtyZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk4MCsodD4+MjUmMTI3KSwodD4+MjEmMTUpLTEsdD4+MTYmMzEsdD4+MTEmMzEsdD4+NSY2MywoMzEmdCk8PDEpKX19LGUuZXhwb3J0cz1ufSx7XCIuLi91dGlsc1wiOjMyfV0sMTk6W2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgaT10KFwiLi9VaW50OEFycmF5UmVhZGVyXCIpO2Z1bmN0aW9uIG4odCl7aS5jYWxsKHRoaXMsdCl9dChcIi4uL3V0aWxzXCIpLmluaGVyaXRzKG4saSksbi5wcm90b3R5cGUucmVhZERhdGE9ZnVuY3Rpb24odCl7dGhpcy5jaGVja09mZnNldCh0KTt2YXIgZT10aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvK3RoaXMuaW5kZXgsdGhpcy56ZXJvK3RoaXMuaW5kZXgrdCk7cmV0dXJuIHRoaXMuaW5kZXgrPXQsZX0sZS5leHBvcnRzPW59LHtcIi4uL3V0aWxzXCI6MzIsXCIuL1VpbnQ4QXJyYXlSZWFkZXJcIjoyMX1dLDIwOltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9dChcIi4vRGF0YVJlYWRlclwiKTtmdW5jdGlvbiBuKHQpe2kuY2FsbCh0aGlzLHQpfXQoXCIuLi91dGlsc1wiKS5pbmhlcml0cyhuLGkpLG4ucHJvdG90eXBlLmJ5dGVBdD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy56ZXJvK3QpfSxuLnByb3RvdHlwZS5sYXN0SW5kZXhPZlNpZ25hdHVyZT1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kYXRhLmxhc3RJbmRleE9mKHQpLXRoaXMuemVyb30sbi5wcm90b3R5cGUucmVhZEFuZENoZWNrU2lnbmF0dXJlPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09dGhpcy5yZWFkRGF0YSg0KX0sbi5wcm90b3R5cGUucmVhZERhdGE9ZnVuY3Rpb24odCl7dGhpcy5jaGVja09mZnNldCh0KTt2YXIgZT10aGlzLmRhdGEuc2xpY2UodGhpcy56ZXJvK3RoaXMuaW5kZXgsdGhpcy56ZXJvK3RoaXMuaW5kZXgrdCk7cmV0dXJuIHRoaXMuaW5kZXgrPXQsZX0sZS5leHBvcnRzPW59LHtcIi4uL3V0aWxzXCI6MzIsXCIuL0RhdGFSZWFkZXJcIjoxOH1dLDIxOltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9dChcIi4vQXJyYXlSZWFkZXJcIik7ZnVuY3Rpb24gbih0KXtpLmNhbGwodGhpcyx0KX10KFwiLi4vdXRpbHNcIikuaW5oZXJpdHMobixpKSxuLnByb3RvdHlwZS5yZWFkRGF0YT1mdW5jdGlvbih0KXtpZih0aGlzLmNoZWNrT2Zmc2V0KHQpLDA9PT10KXJldHVybiBuZXcgVWludDhBcnJheSgwKTt2YXIgZT10aGlzLmRhdGEuc3ViYXJyYXkodGhpcy56ZXJvK3RoaXMuaW5kZXgsdGhpcy56ZXJvK3RoaXMuaW5kZXgrdCk7cmV0dXJuIHRoaXMuaW5kZXgrPXQsZX0sZS5leHBvcnRzPW59LHtcIi4uL3V0aWxzXCI6MzIsXCIuL0FycmF5UmVhZGVyXCI6MTd9XSwyMjpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBpPXQoXCIuLi91dGlsc1wiKSxuPXQoXCIuLi9zdXBwb3J0XCIpLHM9dChcIi4vQXJyYXlSZWFkZXJcIiksYT10KFwiLi9TdHJpbmdSZWFkZXJcIiksbz10KFwiLi9Ob2RlQnVmZmVyUmVhZGVyXCIpLGg9dChcIi4vVWludDhBcnJheVJlYWRlclwiKTtlLmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9aS5nZXRUeXBlT2YodCk7cmV0dXJuIGkuY2hlY2tTdXBwb3J0KGUpLFwic3RyaW5nXCIhPT1lfHxuLnVpbnQ4YXJyYXk/XCJub2RlYnVmZmVyXCI9PT1lP25ldyBvKHQpOm4udWludDhhcnJheT9uZXcgaChpLnRyYW5zZm9ybVRvKFwidWludDhhcnJheVwiLHQpKTpuZXcgcyhpLnRyYW5zZm9ybVRvKFwiYXJyYXlcIix0KSk6bmV3IGEodCl9fSx7XCIuLi9zdXBwb3J0XCI6MzAsXCIuLi91dGlsc1wiOjMyLFwiLi9BcnJheVJlYWRlclwiOjE3LFwiLi9Ob2RlQnVmZmVyUmVhZGVyXCI6MTksXCIuL1N0cmluZ1JlYWRlclwiOjIwLFwiLi9VaW50OEFycmF5UmVhZGVyXCI6MjF9XSwyMzpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3IuTE9DQUxfRklMRV9IRUFERVI9XCJQS1x1MDAwM1x1MDAwNFwiLHIuQ0VOVFJBTF9GSUxFX0hFQURFUj1cIlBLXHUwMDAxXHUwMDAyXCIsci5DRU5UUkFMX0RJUkVDVE9SWV9FTkQ9XCJQS1x1MDAwNVx1MDAwNlwiLHIuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUj1cIlBLXHUwMDA2XHUwMDA3XCIsci5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQ9XCJQS1x1MDAwNlx1MDAwNlwiLHIuREFUQV9ERVNDUklQVE9SPVwiUEtcdTAwMDdcXGJcIn0se31dLDI0OltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9dChcIi4vR2VuZXJpY1dvcmtlclwiKSxuPXQoXCIuLi91dGlsc1wiKTtmdW5jdGlvbiBzKHQpe2kuY2FsbCh0aGlzLFwiQ29udmVydFdvcmtlciB0byBcIit0KSx0aGlzLmRlc3RUeXBlPXR9bi5pbmhlcml0cyhzLGkpLHMucHJvdG90eXBlLnByb2Nlc3NDaHVuaz1mdW5jdGlvbih0KXt0aGlzLnB1c2goe2RhdGE6bi50cmFuc2Zvcm1Ubyh0aGlzLmRlc3RUeXBlLHQuZGF0YSksbWV0YTp0Lm1ldGF9KX0sZS5leHBvcnRzPXN9LHtcIi4uL3V0aWxzXCI6MzIsXCIuL0dlbmVyaWNXb3JrZXJcIjoyOH1dLDI1OltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9dChcIi4vR2VuZXJpY1dvcmtlclwiKSxuPXQoXCIuLi9jcmMzMlwiKTtmdW5jdGlvbiBzKCl7aS5jYWxsKHRoaXMsXCJDcmMzMlByb2JlXCIpLHRoaXMud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLDApfXQoXCIuLi91dGlsc1wiKS5pbmhlcml0cyhzLGkpLHMucHJvdG90eXBlLnByb2Nlc3NDaHVuaz1mdW5jdGlvbih0KXt0aGlzLnN0cmVhbUluZm8uY3JjMzI9bih0LmRhdGEsdGhpcy5zdHJlYW1JbmZvLmNyYzMyfHwwKSx0aGlzLnB1c2godCl9LGUuZXhwb3J0cz1zfSx7XCIuLi9jcmMzMlwiOjQsXCIuLi91dGlsc1wiOjMyLFwiLi9HZW5lcmljV29ya2VyXCI6Mjh9XSwyNjpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBpPXQoXCIuLi91dGlsc1wiKSxuPXQoXCIuL0dlbmVyaWNXb3JrZXJcIik7ZnVuY3Rpb24gcyh0KXtuLmNhbGwodGhpcyxcIkRhdGFMZW5ndGhQcm9iZSBmb3IgXCIrdCksdGhpcy5wcm9wTmFtZT10LHRoaXMud2l0aFN0cmVhbUluZm8odCwwKX1pLmluaGVyaXRzKHMsbikscy5wcm90b3R5cGUucHJvY2Vzc0NodW5rPWZ1bmN0aW9uKHQpe2lmKHQpe3ZhciBlPXRoaXMuc3RyZWFtSW5mb1t0aGlzLnByb3BOYW1lXXx8MDt0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV09ZSt0LmRhdGEubGVuZ3RofW4ucHJvdG90eXBlLnByb2Nlc3NDaHVuay5jYWxsKHRoaXMsdCl9LGUuZXhwb3J0cz1zfSx7XCIuLi91dGlsc1wiOjMyLFwiLi9HZW5lcmljV29ya2VyXCI6Mjh9XSwyNzpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBpPXQoXCIuLi91dGlsc1wiKSxuPXQoXCIuL0dlbmVyaWNXb3JrZXJcIik7ZnVuY3Rpb24gcyh0KXtuLmNhbGwodGhpcyxcIkRhdGFXb3JrZXJcIik7dmFyIGU9dGhpczt0aGlzLmRhdGFJc1JlYWR5PSExLHRoaXMuaW5kZXg9MCx0aGlzLm1heD0wLHRoaXMuZGF0YT1udWxsLHRoaXMudHlwZT1cIlwiLHRoaXMuX3RpY2tTY2hlZHVsZWQ9ITEsdC50aGVuKGZ1bmN0aW9uKHQpe2UuZGF0YUlzUmVhZHk9ITAsZS5kYXRhPXQsZS5tYXg9dCYmdC5sZW5ndGh8fDAsZS50eXBlPWkuZ2V0VHlwZU9mKHQpLGUuaXNQYXVzZWR8fGUuX3RpY2tBbmRSZXBlYXQoKX0sZnVuY3Rpb24odCl7ZS5lcnJvcih0KX0pfWkuaW5oZXJpdHMocyxuKSxzLnByb3RvdHlwZS5jbGVhblVwPWZ1bmN0aW9uKCl7bi5wcm90b3R5cGUuY2xlYW5VcC5jYWxsKHRoaXMpLHRoaXMuZGF0YT1udWxsfSxzLnByb3RvdHlwZS5yZXN1bWU9ZnVuY3Rpb24oKXtyZXR1cm4hIW4ucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpJiYoIXRoaXMuX3RpY2tTY2hlZHVsZWQmJnRoaXMuZGF0YUlzUmVhZHkmJih0aGlzLl90aWNrU2NoZWR1bGVkPSEwLGkuZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCxbXSx0aGlzKSksITApfSxzLnByb3RvdHlwZS5fdGlja0FuZFJlcGVhdD1mdW5jdGlvbigpe3RoaXMuX3RpY2tTY2hlZHVsZWQ9ITEsdGhpcy5pc1BhdXNlZHx8dGhpcy5pc0ZpbmlzaGVkfHwodGhpcy5fdGljaygpLHRoaXMuaXNGaW5pc2hlZHx8KGkuZGVsYXkodGhpcy5fdGlja0FuZFJlcGVhdCxbXSx0aGlzKSx0aGlzLl90aWNrU2NoZWR1bGVkPSEwKSl9LHMucHJvdG90eXBlLl90aWNrPWZ1bmN0aW9uKCl7aWYodGhpcy5pc1BhdXNlZHx8dGhpcy5pc0ZpbmlzaGVkKXJldHVybiExO3ZhciB0PW51bGwsZT1NYXRoLm1pbih0aGlzLm1heCx0aGlzLmluZGV4KzE2Mzg0KTtpZih0aGlzLmluZGV4Pj10aGlzLm1heClyZXR1cm4gdGhpcy5lbmQoKTtzd2l0Y2godGhpcy50eXBlKXtjYXNlXCJzdHJpbmdcIjp0PXRoaXMuZGF0YS5zdWJzdHJpbmcodGhpcy5pbmRleCxlKTticmVhaztjYXNlXCJ1aW50OGFycmF5XCI6dD10aGlzLmRhdGEuc3ViYXJyYXkodGhpcy5pbmRleCxlKTticmVhaztjYXNlXCJhcnJheVwiOmNhc2VcIm5vZGVidWZmZXJcIjp0PXRoaXMuZGF0YS5zbGljZSh0aGlzLmluZGV4LGUpfXJldHVybiB0aGlzLmluZGV4PWUsdGhpcy5wdXNoKHtkYXRhOnQsbWV0YTp7cGVyY2VudDp0aGlzLm1heD90aGlzLmluZGV4L3RoaXMubWF4KjEwMDowfX0pfSxlLmV4cG9ydHM9c30se1wiLi4vdXRpbHNcIjozMixcIi4vR2VuZXJpY1dvcmtlclwiOjI4fV0sMjg6W2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBpKHQpe3RoaXMubmFtZT10fHxcImRlZmF1bHRcIix0aGlzLnN0cmVhbUluZm89e30sdGhpcy5nZW5lcmF0ZWRFcnJvcj1udWxsLHRoaXMuZXh0cmFTdHJlYW1JbmZvPXt9LHRoaXMuaXNQYXVzZWQ9ITAsdGhpcy5pc0ZpbmlzaGVkPSExLHRoaXMuaXNMb2NrZWQ9ITEsdGhpcy5fbGlzdGVuZXJzPXtkYXRhOltdLGVuZDpbXSxlcnJvcjpbXX0sdGhpcy5wcmV2aW91cz1udWxsfWkucHJvdG90eXBlPXtwdXNoOmZ1bmN0aW9uKHQpe3RoaXMuZW1pdChcImRhdGFcIix0KX0sZW5kOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0ZpbmlzaGVkKXJldHVybiExO3RoaXMuZmx1c2goKTt0cnl7dGhpcy5lbWl0KFwiZW5kXCIpLHRoaXMuY2xlYW5VcCgpLHRoaXMuaXNGaW5pc2hlZD0hMH1jYXRjaCh0KXt0aGlzLmVtaXQoXCJlcnJvclwiLHQpfXJldHVybiEwfSxlcnJvcjpmdW5jdGlvbih0KXtyZXR1cm4hdGhpcy5pc0ZpbmlzaGVkJiYodGhpcy5pc1BhdXNlZD90aGlzLmdlbmVyYXRlZEVycm9yPXQ6KHRoaXMuaXNGaW5pc2hlZD0hMCx0aGlzLmVtaXQoXCJlcnJvclwiLHQpLHRoaXMucHJldmlvdXMmJnRoaXMucHJldmlvdXMuZXJyb3IodCksdGhpcy5jbGVhblVwKCkpLCEwKX0sb246ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5fbGlzdGVuZXJzW3RdLnB1c2goZSksdGhpc30sY2xlYW5VcDpmdW5jdGlvbigpe3RoaXMuc3RyZWFtSW5mbz10aGlzLmdlbmVyYXRlZEVycm9yPXRoaXMuZXh0cmFTdHJlYW1JbmZvPW51bGwsdGhpcy5fbGlzdGVuZXJzPVtdfSxlbWl0OmZ1bmN0aW9uKHQsZSl7aWYodGhpcy5fbGlzdGVuZXJzW3RdKWZvcih2YXIgcj0wO3I8dGhpcy5fbGlzdGVuZXJzW3RdLmxlbmd0aDtyKyspdGhpcy5fbGlzdGVuZXJzW3RdW3JdLmNhbGwodGhpcyxlKX0scGlwZTpmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWdpc3RlclByZXZpb3VzKHRoaXMpfSxyZWdpc3RlclByZXZpb3VzOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaXNMb2NrZWQpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIrdGhpcytcIicgaGFzIGFscmVhZHkgYmVlbiB1c2VkLlwiKTt0aGlzLnN0cmVhbUluZm89dC5zdHJlYW1JbmZvLHRoaXMubWVyZ2VTdHJlYW1JbmZvKCksdGhpcy5wcmV2aW91cz10O3ZhciBlPXRoaXM7cmV0dXJuIHQub24oXCJkYXRhXCIsZnVuY3Rpb24odCl7ZS5wcm9jZXNzQ2h1bmsodCl9KSx0Lm9uKFwiZW5kXCIsZnVuY3Rpb24oKXtlLmVuZCgpfSksdC5vbihcImVycm9yXCIsZnVuY3Rpb24odCl7ZS5lcnJvcih0KX0pLHRoaXN9LHBhdXNlOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaXNQYXVzZWQmJiF0aGlzLmlzRmluaXNoZWQmJih0aGlzLmlzUGF1c2VkPSEwLHRoaXMucHJldmlvdXMmJnRoaXMucHJldmlvdXMucGF1c2UoKSwhMCl9LHJlc3VtZTpmdW5jdGlvbigpe2lmKCF0aGlzLmlzUGF1c2VkfHx0aGlzLmlzRmluaXNoZWQpcmV0dXJuITE7dmFyIHQ9dGhpcy5pc1BhdXNlZD0hMTtyZXR1cm4gdGhpcy5nZW5lcmF0ZWRFcnJvciYmKHRoaXMuZXJyb3IodGhpcy5nZW5lcmF0ZWRFcnJvciksdD0hMCksdGhpcy5wcmV2aW91cyYmdGhpcy5wcmV2aW91cy5yZXN1bWUoKSwhdH0sZmx1c2g6ZnVuY3Rpb24oKXt9LHByb2Nlc3NDaHVuazpmdW5jdGlvbih0KXt0aGlzLnB1c2godCl9LHdpdGhTdHJlYW1JbmZvOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZXh0cmFTdHJlYW1JbmZvW3RdPWUsdGhpcy5tZXJnZVN0cmVhbUluZm8oKSx0aGlzfSxtZXJnZVN0cmVhbUluZm86ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gdGhpcy5leHRyYVN0cmVhbUluZm8pdGhpcy5leHRyYVN0cmVhbUluZm8uaGFzT3duUHJvcGVydHkodCkmJih0aGlzLnN0cmVhbUluZm9bdF09dGhpcy5leHRyYVN0cmVhbUluZm9bdF0pfSxsb2NrOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0xvY2tlZCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RyZWFtICdcIit0aGlzK1wiJyBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuXCIpO3RoaXMuaXNMb2NrZWQ9ITAsdGhpcy5wcmV2aW91cyYmdGhpcy5wcmV2aW91cy5sb2NrKCl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9XCJXb3JrZXIgXCIrdGhpcy5uYW1lO3JldHVybiB0aGlzLnByZXZpb3VzP3RoaXMucHJldmlvdXMrXCIgLT4gXCIrdDp0fX0sZS5leHBvcnRzPWl9LHt9XSwyOTpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBoPXQoXCIuLi91dGlsc1wiKSxuPXQoXCIuL0NvbnZlcnRXb3JrZXJcIikscz10KFwiLi9HZW5lcmljV29ya2VyXCIpLHU9dChcIi4uL2Jhc2U2NFwiKSxpPXQoXCIuLi9zdXBwb3J0XCIpLGE9dChcIi4uL2V4dGVybmFsXCIpLG89bnVsbDtpZihpLm5vZGVzdHJlYW0pdHJ5e289dChcIi4uL25vZGVqcy9Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyXCIpfWNhdGNoKHQpe31mdW5jdGlvbiBsKHQsbyl7cmV0dXJuIG5ldyBhLlByb21pc2UoZnVuY3Rpb24oZSxyKXt2YXIgaT1bXSxuPXQuX2ludGVybmFsVHlwZSxzPXQuX291dHB1dFR5cGUsYT10Ll9taW1lVHlwZTt0Lm9uKFwiZGF0YVwiLGZ1bmN0aW9uKHQsZSl7aS5wdXNoKHQpLG8mJm8oZSl9KS5vbihcImVycm9yXCIsZnVuY3Rpb24odCl7aT1bXSxyKHQpfSkub24oXCJlbmRcIixmdW5jdGlvbigpe3RyeXt2YXIgdD1mdW5jdGlvbih0LGUscil7c3dpdGNoKHQpe2Nhc2VcImJsb2JcIjpyZXR1cm4gaC5uZXdCbG9iKGgudHJhbnNmb3JtVG8oXCJhcnJheWJ1ZmZlclwiLGUpLHIpO2Nhc2VcImJhc2U2NFwiOnJldHVybiB1LmVuY29kZShlKTtkZWZhdWx0OnJldHVybiBoLnRyYW5zZm9ybVRvKHQsZSl9fShzLGZ1bmN0aW9uKHQsZSl7dmFyIHIsaT0wLG49bnVsbCxzPTA7Zm9yKHI9MDtyPGUubGVuZ3RoO3IrKylzKz1lW3JdLmxlbmd0aDtzd2l0Y2godCl7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIGUuam9pbihcIlwiKTtjYXNlXCJhcnJheVwiOnJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLGUpO2Nhc2VcInVpbnQ4YXJyYXlcIjpmb3Iobj1uZXcgVWludDhBcnJheShzKSxyPTA7cjxlLmxlbmd0aDtyKyspbi5zZXQoZVtyXSxpKSxpKz1lW3JdLmxlbmd0aDtyZXR1cm4gbjtjYXNlXCJub2RlYnVmZmVyXCI6cmV0dXJuIEJ1ZmZlci5jb25jYXQoZSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJjb25jYXQgOiB1bnN1cHBvcnRlZCB0eXBlICdcIit0K1wiJ1wiKX19KG4saSksYSk7ZSh0KX1jYXRjaCh0KXtyKHQpfWk9W119KS5yZXN1bWUoKX0pfWZ1bmN0aW9uIGYodCxlLHIpe3ZhciBpPWU7c3dpdGNoKGUpe2Nhc2VcImJsb2JcIjpjYXNlXCJhcnJheWJ1ZmZlclwiOmk9XCJ1aW50OGFycmF5XCI7YnJlYWs7Y2FzZVwiYmFzZTY0XCI6aT1cInN0cmluZ1wifXRyeXt0aGlzLl9pbnRlcm5hbFR5cGU9aSx0aGlzLl9vdXRwdXRUeXBlPWUsdGhpcy5fbWltZVR5cGU9cixoLmNoZWNrU3VwcG9ydChpKSx0aGlzLl93b3JrZXI9dC5waXBlKG5ldyBuKGkpKSx0LmxvY2soKX1jYXRjaCh0KXt0aGlzLl93b3JrZXI9bmV3IHMoXCJlcnJvclwiKSx0aGlzLl93b3JrZXIuZXJyb3IodCl9fWYucHJvdG90eXBlPXthY2N1bXVsYXRlOmZ1bmN0aW9uKHQpe3JldHVybiBsKHRoaXMsdCl9LG9uOmZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcztyZXR1cm5cImRhdGFcIj09PXQ/dGhpcy5fd29ya2VyLm9uKHQsZnVuY3Rpb24odCl7ZS5jYWxsKHIsdC5kYXRhLHQubWV0YSl9KTp0aGlzLl93b3JrZXIub24odCxmdW5jdGlvbigpe2guZGVsYXkoZSxhcmd1bWVudHMscil9KSx0aGlzfSxyZXN1bWU6ZnVuY3Rpb24oKXtyZXR1cm4gaC5kZWxheSh0aGlzLl93b3JrZXIucmVzdW1lLFtdLHRoaXMuX3dvcmtlciksdGhpc30scGF1c2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd29ya2VyLnBhdXNlKCksdGhpc30sdG9Ob2RlanNTdHJlYW06ZnVuY3Rpb24odCl7aWYoaC5jaGVja1N1cHBvcnQoXCJub2Rlc3RyZWFtXCIpLFwibm9kZWJ1ZmZlclwiIT09dGhpcy5fb3V0cHV0VHlwZSl0aHJvdyBuZXcgRXJyb3IodGhpcy5fb3V0cHV0VHlwZStcIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgbWV0aG9kXCIpO3JldHVybiBuZXcgbyh0aGlzLHtvYmplY3RNb2RlOlwibm9kZWJ1ZmZlclwiIT09dGhpcy5fb3V0cHV0VHlwZX0sdCl9fSxlLmV4cG9ydHM9Zn0se1wiLi4vYmFzZTY0XCI6MSxcIi4uL2V4dGVybmFsXCI6NixcIi4uL25vZGVqcy9Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyXCI6MTMsXCIuLi9zdXBwb3J0XCI6MzAsXCIuLi91dGlsc1wiOjMyLFwiLi9Db252ZXJ0V29ya2VyXCI6MjQsXCIuL0dlbmVyaWNXb3JrZXJcIjoyOH1dLDMwOltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7aWYoci5iYXNlNjQ9ITAsci5hcnJheT0hMCxyLnN0cmluZz0hMCxyLmFycmF5YnVmZmVyPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFVpbnQ4QXJyYXksci5ub2RlYnVmZmVyPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBCdWZmZXIsci51aW50OGFycmF5PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBVaW50OEFycmF5LFwidW5kZWZpbmVkXCI9PXR5cGVvZiBBcnJheUJ1ZmZlcilyLmJsb2I9ITE7ZWxzZXt2YXIgaT1uZXcgQXJyYXlCdWZmZXIoMCk7dHJ5e3IuYmxvYj0wPT09bmV3IEJsb2IoW2ldLHt0eXBlOlwiYXBwbGljYXRpb24vemlwXCJ9KS5zaXplfWNhdGNoKHQpe3RyeXt2YXIgbj1uZXcoc2VsZi5CbG9iQnVpbGRlcnx8c2VsZi5XZWJLaXRCbG9iQnVpbGRlcnx8c2VsZi5Nb3pCbG9iQnVpbGRlcnx8c2VsZi5NU0Jsb2JCdWlsZGVyKTtuLmFwcGVuZChpKSxyLmJsb2I9MD09PW4uZ2V0QmxvYihcImFwcGxpY2F0aW9uL3ppcFwiKS5zaXplfWNhdGNoKHQpe3IuYmxvYj0hMX19fXRyeXtyLm5vZGVzdHJlYW09ISF0KFwicmVhZGFibGUtc3RyZWFtXCIpLlJlYWRhYmxlfWNhdGNoKHQpe3Iubm9kZXN0cmVhbT0hMX19LHtcInJlYWRhYmxlLXN0cmVhbVwiOjE2fV0sMzE6W2Z1bmN0aW9uKHQsZSxzKXtcInVzZSBzdHJpY3RcIjtmb3IodmFyIG89dChcIi4vdXRpbHNcIiksaD10KFwiLi9zdXBwb3J0XCIpLHI9dChcIi4vbm9kZWpzVXRpbHNcIiksaT10KFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKSx1PW5ldyBBcnJheSgyNTYpLG49MDtuPDI1NjtuKyspdVtuXT0yNTI8PW4/NjoyNDg8PW4/NToyNDA8PW4/NDoyMjQ8PW4/MzoxOTI8PW4/MjoxO3VbMjU0XT11WzI1NF09MTtmdW5jdGlvbiBhKCl7aS5jYWxsKHRoaXMsXCJ1dGYtOCBkZWNvZGVcIiksdGhpcy5sZWZ0T3Zlcj1udWxsfWZ1bmN0aW9uIGwoKXtpLmNhbGwodGhpcyxcInV0Zi04IGVuY29kZVwiKX1zLnV0ZjhlbmNvZGU9ZnVuY3Rpb24odCl7cmV0dXJuIGgubm9kZWJ1ZmZlcj9yLm5ld0J1ZmZlckZyb20odCxcInV0Zi04XCIpOmZ1bmN0aW9uKHQpe3ZhciBlLHIsaSxuLHMsYT10Lmxlbmd0aCxvPTA7Zm9yKG49MDtuPGE7bisrKTU1Mjk2PT0oNjQ1MTImKHI9dC5jaGFyQ29kZUF0KG4pKSkmJm4rMTxhJiY1NjMyMD09KDY0NTEyJihpPXQuY2hhckNvZGVBdChuKzEpKSkmJihyPTY1NTM2KyhyLTU1Mjk2PDwxMCkrKGktNTYzMjApLG4rKyksbys9cjwxMjg/MTpyPDIwNDg/MjpyPDY1NTM2PzM6NDtmb3IoZT1oLnVpbnQ4YXJyYXk/bmV3IFVpbnQ4QXJyYXkobyk6bmV3IEFycmF5KG8pLG49cz0wO3M8bztuKyspNTUyOTY9PSg2NDUxMiYocj10LmNoYXJDb2RlQXQobikpKSYmbisxPGEmJjU2MzIwPT0oNjQ1MTImKGk9dC5jaGFyQ29kZUF0KG4rMSkpKSYmKHI9NjU1MzYrKHItNTUyOTY8PDEwKSsoaS01NjMyMCksbisrKSxyPDEyOD9lW3MrK109cjoocjwyMDQ4P2VbcysrXT0xOTJ8cj4+PjY6KHI8NjU1MzY/ZVtzKytdPTIyNHxyPj4+MTI6KGVbcysrXT0yNDB8cj4+PjE4LGVbcysrXT0xMjh8cj4+PjEyJjYzKSxlW3MrK109MTI4fHI+Pj42JjYzKSxlW3MrK109MTI4fDYzJnIpO3JldHVybiBlfSh0KX0scy51dGY4ZGVjb2RlPWZ1bmN0aW9uKHQpe3JldHVybiBoLm5vZGVidWZmZXI/by50cmFuc2Zvcm1UbyhcIm5vZGVidWZmZXJcIix0KS50b1N0cmluZyhcInV0Zi04XCIpOmZ1bmN0aW9uKHQpe3ZhciBlLHIsaSxuLHM9dC5sZW5ndGgsYT1uZXcgQXJyYXkoMipzKTtmb3IoZT1yPTA7ZTxzOylpZigoaT10W2UrK10pPDEyOClhW3IrK109aTtlbHNlIGlmKDQ8KG49dVtpXSkpYVtyKytdPTY1NTMzLGUrPW4tMTtlbHNle2ZvcihpJj0yPT09bj8zMTozPT09bj8xNTo3OzE8biYmZTxzOylpPWk8PDZ8NjMmdFtlKytdLG4tLTsxPG4/YVtyKytdPTY1NTMzOmk8NjU1MzY/YVtyKytdPWk6KGktPTY1NTM2LGFbcisrXT01NTI5NnxpPj4xMCYxMDIzLGFbcisrXT01NjMyMHwxMDIzJmkpfXJldHVybiBhLmxlbmd0aCE9PXImJihhLnN1YmFycmF5P2E9YS5zdWJhcnJheSgwLHIpOmEubGVuZ3RoPXIpLG8uYXBwbHlGcm9tQ2hhckNvZGUoYSl9KHQ9by50cmFuc2Zvcm1UbyhoLnVpbnQ4YXJyYXk/XCJ1aW50OGFycmF5XCI6XCJhcnJheVwiLHQpKX0sby5pbmhlcml0cyhhLGkpLGEucHJvdG90eXBlLnByb2Nlc3NDaHVuaz1mdW5jdGlvbih0KXt2YXIgZT1vLnRyYW5zZm9ybVRvKGgudWludDhhcnJheT9cInVpbnQ4YXJyYXlcIjpcImFycmF5XCIsdC5kYXRhKTtpZih0aGlzLmxlZnRPdmVyJiZ0aGlzLmxlZnRPdmVyLmxlbmd0aCl7aWYoaC51aW50OGFycmF5KXt2YXIgcj1lOyhlPW5ldyBVaW50OEFycmF5KHIubGVuZ3RoK3RoaXMubGVmdE92ZXIubGVuZ3RoKSkuc2V0KHRoaXMubGVmdE92ZXIsMCksZS5zZXQocix0aGlzLmxlZnRPdmVyLmxlbmd0aCl9ZWxzZSBlPXRoaXMubGVmdE92ZXIuY29uY2F0KGUpO3RoaXMubGVmdE92ZXI9bnVsbH12YXIgaT1mdW5jdGlvbih0LGUpe3ZhciByO2ZvcigoZT1lfHx0Lmxlbmd0aCk+dC5sZW5ndGgmJihlPXQubGVuZ3RoKSxyPWUtMTswPD1yJiYxMjg9PSgxOTImdFtyXSk7KXItLTtyZXR1cm4gcjwwP2U6MD09PXI/ZTpyK3VbdFtyXV0+ZT9yOmV9KGUpLG49ZTtpIT09ZS5sZW5ndGgmJihoLnVpbnQ4YXJyYXk/KG49ZS5zdWJhcnJheSgwLGkpLHRoaXMubGVmdE92ZXI9ZS5zdWJhcnJheShpLGUubGVuZ3RoKSk6KG49ZS5zbGljZSgwLGkpLHRoaXMubGVmdE92ZXI9ZS5zbGljZShpLGUubGVuZ3RoKSkpLHRoaXMucHVzaCh7ZGF0YTpzLnV0ZjhkZWNvZGUobiksbWV0YTp0Lm1ldGF9KX0sYS5wcm90b3R5cGUuZmx1c2g9ZnVuY3Rpb24oKXt0aGlzLmxlZnRPdmVyJiZ0aGlzLmxlZnRPdmVyLmxlbmd0aCYmKHRoaXMucHVzaCh7ZGF0YTpzLnV0ZjhkZWNvZGUodGhpcy5sZWZ0T3ZlciksbWV0YTp7fX0pLHRoaXMubGVmdE92ZXI9bnVsbCl9LHMuVXRmOERlY29kZVdvcmtlcj1hLG8uaW5oZXJpdHMobCxpKSxsLnByb3RvdHlwZS5wcm9jZXNzQ2h1bms9ZnVuY3Rpb24odCl7dGhpcy5wdXNoKHtkYXRhOnMudXRmOGVuY29kZSh0LmRhdGEpLG1ldGE6dC5tZXRhfSl9LHMuVXRmOEVuY29kZVdvcmtlcj1sfSx7XCIuL25vZGVqc1V0aWxzXCI6MTQsXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCI6MjgsXCIuL3N1cHBvcnRcIjozMCxcIi4vdXRpbHNcIjozMn1dLDMyOltmdW5jdGlvbih0LGUsYSl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dChcIi4vc3VwcG9ydFwiKSxoPXQoXCIuL2Jhc2U2NFwiKSxyPXQoXCIuL25vZGVqc1V0aWxzXCIpLGk9dChcInNldC1pbW1lZGlhdGUtc2hpbVwiKSx1PXQoXCIuL2V4dGVybmFsXCIpO2Z1bmN0aW9uIG4odCl7cmV0dXJuIHR9ZnVuY3Rpb24gbCh0LGUpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7KytyKWVbcl09MjU1JnQuY2hhckNvZGVBdChyKTtyZXR1cm4gZX1hLm5ld0Jsb2I9ZnVuY3Rpb24oZSxyKXthLmNoZWNrU3VwcG9ydChcImJsb2JcIik7dHJ5e3JldHVybiBuZXcgQmxvYihbZV0se3R5cGU6cn0pfWNhdGNoKHQpe3RyeXt2YXIgaT1uZXcoc2VsZi5CbG9iQnVpbGRlcnx8c2VsZi5XZWJLaXRCbG9iQnVpbGRlcnx8c2VsZi5Nb3pCbG9iQnVpbGRlcnx8c2VsZi5NU0Jsb2JCdWlsZGVyKTtyZXR1cm4gaS5hcHBlbmQoZSksaS5nZXRCbG9iKHIpfWNhdGNoKHQpe3Rocm93IG5ldyBFcnJvcihcIkJ1ZyA6IGNhbid0IGNvbnN0cnVjdCB0aGUgQmxvYi5cIil9fX07dmFyIHM9e3N0cmluZ2lmeUJ5Q2h1bms6ZnVuY3Rpb24odCxlLHIpe3ZhciBpPVtdLG49MCxzPXQubGVuZ3RoO2lmKHM8PXIpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCx0KTtmb3IoO248czspXCJhcnJheVwiPT09ZXx8XCJub2RlYnVmZmVyXCI9PT1lP2kucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsdC5zbGljZShuLE1hdGgubWluKG4rcixzKSkpKTppLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLHQuc3ViYXJyYXkobixNYXRoLm1pbihuK3IscykpKSksbis9cjtyZXR1cm4gaS5qb2luKFwiXCIpfSxzdHJpbmdpZnlCeUNoYXI6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVwiXCIscj0wO3I8dC5sZW5ndGg7cisrKWUrPVN0cmluZy5mcm9tQ2hhckNvZGUodFtyXSk7cmV0dXJuIGV9LGFwcGx5Q2FuQmVVc2VkOnt1aW50OGFycmF5OmZ1bmN0aW9uKCl7dHJ5e3JldHVybiBvLnVpbnQ4YXJyYXkmJjE9PT1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbmV3IFVpbnQ4QXJyYXkoMSkpLmxlbmd0aH1jYXRjaCh0KXtyZXR1cm4hMX19KCksbm9kZWJ1ZmZlcjpmdW5jdGlvbigpe3RyeXtyZXR1cm4gby5ub2RlYnVmZmVyJiYxPT09U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLHIuYWxsb2NCdWZmZXIoMSkpLmxlbmd0aH1jYXRjaCh0KXtyZXR1cm4hMX19KCl9fTtmdW5jdGlvbiBmKHQpe3ZhciBlPTY1NTM2LHI9YS5nZXRUeXBlT2YodCksaT0hMDtpZihcInVpbnQ4YXJyYXlcIj09PXI/aT1zLmFwcGx5Q2FuQmVVc2VkLnVpbnQ4YXJyYXk6XCJub2RlYnVmZmVyXCI9PT1yJiYoaT1zLmFwcGx5Q2FuQmVVc2VkLm5vZGVidWZmZXIpLGkpZm9yKDsxPGU7KXRyeXtyZXR1cm4gcy5zdHJpbmdpZnlCeUNodW5rKHQscixlKX1jYXRjaCh0KXtlPU1hdGguZmxvb3IoZS8yKX1yZXR1cm4gcy5zdHJpbmdpZnlCeUNoYXIodCl9ZnVuY3Rpb24gZCh0LGUpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKWVbcl09dFtyXTtyZXR1cm4gZX1hLmFwcGx5RnJvbUNoYXJDb2RlPWY7dmFyIGM9e307Yy5zdHJpbmc9e3N0cmluZzpuLGFycmF5OmZ1bmN0aW9uKHQpe3JldHVybiBsKHQsbmV3IEFycmF5KHQubGVuZ3RoKSl9LGFycmF5YnVmZmVyOmZ1bmN0aW9uKHQpe3JldHVybiBjLnN0cmluZy51aW50OGFycmF5KHQpLmJ1ZmZlcn0sdWludDhhcnJheTpmdW5jdGlvbih0KXtyZXR1cm4gbCh0LG5ldyBVaW50OEFycmF5KHQubGVuZ3RoKSl9LG5vZGVidWZmZXI6ZnVuY3Rpb24odCl7cmV0dXJuIGwodCxyLmFsbG9jQnVmZmVyKHQubGVuZ3RoKSl9fSxjLmFycmF5PXtzdHJpbmc6ZixhcnJheTpuLGFycmF5YnVmZmVyOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgVWludDhBcnJheSh0KS5idWZmZXJ9LHVpbnQ4YXJyYXk6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBVaW50OEFycmF5KHQpfSxub2RlYnVmZmVyOmZ1bmN0aW9uKHQpe3JldHVybiByLm5ld0J1ZmZlckZyb20odCl9fSxjLmFycmF5YnVmZmVyPXtzdHJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuIGYobmV3IFVpbnQ4QXJyYXkodCkpfSxhcnJheTpmdW5jdGlvbih0KXtyZXR1cm4gZChuZXcgVWludDhBcnJheSh0KSxuZXcgQXJyYXkodC5ieXRlTGVuZ3RoKSl9LGFycmF5YnVmZmVyOm4sdWludDhhcnJheTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkodCl9LG5vZGVidWZmZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHIubmV3QnVmZmVyRnJvbShuZXcgVWludDhBcnJheSh0KSl9fSxjLnVpbnQ4YXJyYXk9e3N0cmluZzpmLGFycmF5OmZ1bmN0aW9uKHQpe3JldHVybiBkKHQsbmV3IEFycmF5KHQubGVuZ3RoKSl9LGFycmF5YnVmZmVyOmZ1bmN0aW9uKHQpe3JldHVybiB0LmJ1ZmZlcn0sdWludDhhcnJheTpuLG5vZGVidWZmZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHIubmV3QnVmZmVyRnJvbSh0KX19LGMubm9kZWJ1ZmZlcj17c3RyaW5nOmYsYXJyYXk6ZnVuY3Rpb24odCl7cmV0dXJuIGQodCxuZXcgQXJyYXkodC5sZW5ndGgpKX0sYXJyYXlidWZmZXI6ZnVuY3Rpb24odCl7cmV0dXJuIGMubm9kZWJ1ZmZlci51aW50OGFycmF5KHQpLmJ1ZmZlcn0sdWludDhhcnJheTpmdW5jdGlvbih0KXtyZXR1cm4gZCh0LG5ldyBVaW50OEFycmF5KHQubGVuZ3RoKSl9LG5vZGVidWZmZXI6bn0sYS50cmFuc2Zvcm1Ubz1mdW5jdGlvbih0LGUpe2lmKGU9ZXx8XCJcIiwhdClyZXR1cm4gZTthLmNoZWNrU3VwcG9ydCh0KTt2YXIgcj1hLmdldFR5cGVPZihlKTtyZXR1cm4gY1tyXVt0XShlKX0sYS5nZXRUeXBlT2Y9ZnVuY3Rpb24odCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHQ/XCJzdHJpbmdcIjpcIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCk/XCJhcnJheVwiOm8ubm9kZWJ1ZmZlciYmci5pc0J1ZmZlcih0KT9cIm5vZGVidWZmZXJcIjpvLnVpbnQ4YXJyYXkmJnQgaW5zdGFuY2VvZiBVaW50OEFycmF5P1widWludDhhcnJheVwiOm8uYXJyYXlidWZmZXImJnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9cImFycmF5YnVmZmVyXCI6dm9pZCAwfSxhLmNoZWNrU3VwcG9ydD1mdW5jdGlvbih0KXtpZighb1t0LnRvTG93ZXJDYXNlKCldKXRocm93IG5ldyBFcnJvcih0K1wiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBwbGF0Zm9ybVwiKX0sYS5NQVhfVkFMVUVfMTZCSVRTPTY1NTM1LGEuTUFYX1ZBTFVFXzMyQklUUz0tMSxhLnByZXR0eT1mdW5jdGlvbih0KXt2YXIgZSxyLGk9XCJcIjtmb3Iocj0wO3I8KHR8fFwiXCIpLmxlbmd0aDtyKyspaSs9XCJcXFxceFwiKygoZT10LmNoYXJDb2RlQXQocikpPDE2P1wiMFwiOlwiXCIpK2UudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7cmV0dXJuIGl9LGEuZGVsYXk9ZnVuY3Rpb24odCxlLHIpe2koZnVuY3Rpb24oKXt0LmFwcGx5KHJ8fG51bGwsZXx8W10pfSl9LGEuaW5oZXJpdHM9ZnVuY3Rpb24odCxlKXtmdW5jdGlvbiByKCl7fXIucHJvdG90eXBlPWUucHJvdG90eXBlLHQucHJvdG90eXBlPW5ldyByfSxhLmV4dGVuZD1mdW5jdGlvbigpe3ZhciB0LGUscj17fTtmb3IodD0wO3Q8YXJndW1lbnRzLmxlbmd0aDt0KyspZm9yKGUgaW4gYXJndW1lbnRzW3RdKWFyZ3VtZW50c1t0XS5oYXNPd25Qcm9wZXJ0eShlKSYmdm9pZCAwPT09cltlXSYmKHJbZV09YXJndW1lbnRzW3RdW2VdKTtyZXR1cm4gcn0sYS5wcmVwYXJlQ29udGVudD1mdW5jdGlvbihyLHQsaSxuLHMpe3JldHVybiB1LlByb21pc2UucmVzb2x2ZSh0KS50aGVuKGZ1bmN0aW9uKGkpe3JldHVybiBvLmJsb2ImJihpIGluc3RhbmNlb2YgQmxvYnx8LTEhPT1bXCJbb2JqZWN0IEZpbGVdXCIsXCJbb2JqZWN0IEJsb2JdXCJdLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGkpKSkmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBGaWxlUmVhZGVyP25ldyB1LlByb21pc2UoZnVuY3Rpb24oZSxyKXt2YXIgdD1uZXcgRmlsZVJlYWRlcjt0Lm9ubG9hZD1mdW5jdGlvbih0KXtlKHQudGFyZ2V0LnJlc3VsdCl9LHQub25lcnJvcj1mdW5jdGlvbih0KXtyKHQudGFyZ2V0LmVycm9yKX0sdC5yZWFkQXNBcnJheUJ1ZmZlcihpKX0pOml9KS50aGVuKGZ1bmN0aW9uKHQpe3ZhciBlPWEuZ2V0VHlwZU9mKHQpO3JldHVybiBlPyhcImFycmF5YnVmZmVyXCI9PT1lP3Q9YS50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIix0KTpcInN0cmluZ1wiPT09ZSYmKHM/dD1oLmRlY29kZSh0KTppJiYhMCE9PW4mJih0PWZ1bmN0aW9uKHQpe3JldHVybiBsKHQsby51aW50OGFycmF5P25ldyBVaW50OEFycmF5KHQubGVuZ3RoKTpuZXcgQXJyYXkodC5sZW5ndGgpKX0odCkpKSx0KTp1LlByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkNhbid0IHJlYWQgdGhlIGRhdGEgb2YgJ1wiK3IrXCInLiBJcyBpdCBpbiBhIHN1cHBvcnRlZCBKYXZhU2NyaXB0IHR5cGUgKFN0cmluZywgQmxvYiwgQXJyYXlCdWZmZXIsIGV0YykgP1wiKSl9KX19LHtcIi4vYmFzZTY0XCI6MSxcIi4vZXh0ZXJuYWxcIjo2LFwiLi9ub2RlanNVdGlsc1wiOjE0LFwiLi9zdXBwb3J0XCI6MzAsXCJzZXQtaW1tZWRpYXRlLXNoaW1cIjo1NH1dLDMzOltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9dChcIi4vcmVhZGVyL3JlYWRlckZvclwiKSxuPXQoXCIuL3V0aWxzXCIpLHM9dChcIi4vc2lnbmF0dXJlXCIpLGE9dChcIi4vemlwRW50cnlcIiksbz0odChcIi4vdXRmOFwiKSx0KFwiLi9zdXBwb3J0XCIpKTtmdW5jdGlvbiBoKHQpe3RoaXMuZmlsZXM9W10sdGhpcy5sb2FkT3B0aW9ucz10fWgucHJvdG90eXBlPXtjaGVja1NpZ25hdHVyZTpmdW5jdGlvbih0KXtpZighdGhpcy5yZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlKHQpKXt0aGlzLnJlYWRlci5pbmRleC09NDt2YXIgZT10aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpO3Rocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiB1bmV4cGVjdGVkIHNpZ25hdHVyZSAoXCIrbi5wcmV0dHkoZSkrXCIsIGV4cGVjdGVkIFwiK24ucHJldHR5KHQpK1wiKVwiKX19LGlzU2lnbmF0dXJlOmZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcy5yZWFkZXIuaW5kZXg7dGhpcy5yZWFkZXIuc2V0SW5kZXgodCk7dmFyIGk9dGhpcy5yZWFkZXIucmVhZFN0cmluZyg0KT09PWU7cmV0dXJuIHRoaXMucmVhZGVyLnNldEluZGV4KHIpLGl9LHJlYWRCbG9ja0VuZE9mQ2VudHJhbDpmdW5jdGlvbigpe3RoaXMuZGlza051bWJlcj10aGlzLnJlYWRlci5yZWFkSW50KDIpLHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQ9dGhpcy5yZWFkZXIucmVhZEludCgyKSx0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzaz10aGlzLnJlYWRlci5yZWFkSW50KDIpLHRoaXMuY2VudHJhbERpclJlY29yZHM9dGhpcy5yZWFkZXIucmVhZEludCgyKSx0aGlzLmNlbnRyYWxEaXJTaXplPXRoaXMucmVhZGVyLnJlYWRJbnQoNCksdGhpcy5jZW50cmFsRGlyT2Zmc2V0PXRoaXMucmVhZGVyLnJlYWRJbnQoNCksdGhpcy56aXBDb21tZW50TGVuZ3RoPXRoaXMucmVhZGVyLnJlYWRJbnQoMik7dmFyIHQ9dGhpcy5yZWFkZXIucmVhZERhdGEodGhpcy56aXBDb21tZW50TGVuZ3RoKSxlPW8udWludDhhcnJheT9cInVpbnQ4YXJyYXlcIjpcImFycmF5XCIscj1uLnRyYW5zZm9ybVRvKGUsdCk7dGhpcy56aXBDb21tZW50PXRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUocil9LHJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsOmZ1bmN0aW9uKCl7dGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemU9dGhpcy5yZWFkZXIucmVhZEludCg4KSx0aGlzLnJlYWRlci5za2lwKDQpLHRoaXMuZGlza051bWJlcj10aGlzLnJlYWRlci5yZWFkSW50KDQpLHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQ9dGhpcy5yZWFkZXIucmVhZEludCg0KSx0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzaz10aGlzLnJlYWRlci5yZWFkSW50KDgpLHRoaXMuY2VudHJhbERpclJlY29yZHM9dGhpcy5yZWFkZXIucmVhZEludCg4KSx0aGlzLmNlbnRyYWxEaXJTaXplPXRoaXMucmVhZGVyLnJlYWRJbnQoOCksdGhpcy5jZW50cmFsRGlyT2Zmc2V0PXRoaXMucmVhZGVyLnJlYWRJbnQoOCksdGhpcy56aXA2NEV4dGVuc2libGVEYXRhPXt9O2Zvcih2YXIgdCxlLHIsaT10aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZS00NDswPGk7KXQ9dGhpcy5yZWFkZXIucmVhZEludCgyKSxlPXRoaXMucmVhZGVyLnJlYWRJbnQoNCkscj10aGlzLnJlYWRlci5yZWFkRGF0YShlKSx0aGlzLnppcDY0RXh0ZW5zaWJsZURhdGFbdF09e2lkOnQsbGVuZ3RoOmUsdmFsdWU6cn19LHJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsTG9jYXRvcjpmdW5jdGlvbigpe2lmKHRoaXMuZGlza1dpdGhaaXA2NENlbnRyYWxEaXJTdGFydD10aGlzLnJlYWRlci5yZWFkSW50KDQpLHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpcj10aGlzLnJlYWRlci5yZWFkSW50KDgpLHRoaXMuZGlza3NDb3VudD10aGlzLnJlYWRlci5yZWFkSW50KDQpLDE8dGhpcy5kaXNrc0NvdW50KXRocm93IG5ldyBFcnJvcihcIk11bHRpLXZvbHVtZXMgemlwIGFyZSBub3Qgc3VwcG9ydGVkXCIpfSxyZWFkTG9jYWxGaWxlczpmdW5jdGlvbigpe3ZhciB0LGU7Zm9yKHQ9MDt0PHRoaXMuZmlsZXMubGVuZ3RoO3QrKyllPXRoaXMuZmlsZXNbdF0sdGhpcy5yZWFkZXIuc2V0SW5kZXgoZS5sb2NhbEhlYWRlck9mZnNldCksdGhpcy5jaGVja1NpZ25hdHVyZShzLkxPQ0FMX0ZJTEVfSEVBREVSKSxlLnJlYWRMb2NhbFBhcnQodGhpcy5yZWFkZXIpLGUuaGFuZGxlVVRGOCgpLGUucHJvY2Vzc0F0dHJpYnV0ZXMoKX0scmVhZENlbnRyYWxEaXI6ZnVuY3Rpb24oKXt2YXIgdDtmb3IodGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5jZW50cmFsRGlyT2Zmc2V0KTt0aGlzLnJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmUocy5DRU5UUkFMX0ZJTEVfSEVBREVSKTspKHQ9bmV3IGEoe3ppcDY0OnRoaXMuemlwNjR9LHRoaXMubG9hZE9wdGlvbnMpKS5yZWFkQ2VudHJhbFBhcnQodGhpcy5yZWFkZXIpLHRoaXMuZmlsZXMucHVzaCh0KTtpZih0aGlzLmNlbnRyYWxEaXJSZWNvcmRzIT09dGhpcy5maWxlcy5sZW5ndGgmJjAhPT10aGlzLmNlbnRyYWxEaXJSZWNvcmRzJiYwPT09dGhpcy5maWxlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCBvciBidWc6IGV4cGVjdGVkIFwiK3RoaXMuY2VudHJhbERpclJlY29yZHMrXCIgcmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290IFwiK3RoaXMuZmlsZXMubGVuZ3RoKX0scmVhZEVuZE9mQ2VudHJhbDpmdW5jdGlvbigpe3ZhciB0PXRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHMuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtpZih0PDApdGhyb3chdGhpcy5pc1NpZ25hdHVyZSgwLHMuTE9DQUxfRklMRV9IRUFERVIpP25ldyBFcnJvcihcIkNhbid0IGZpbmQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IDogaXMgdGhpcyBhIHppcCBmaWxlID8gSWYgaXQgaXMsIHNlZSBodHRwczovL3N0dWsuZ2l0aHViLmlvL2pzemlwL2RvY3VtZW50YXRpb24vaG93dG8vcmVhZF96aXAuaHRtbFwiKTpuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVwiKTt0aGlzLnJlYWRlci5zZXRJbmRleCh0KTt2YXIgZT10O2lmKHRoaXMuY2hlY2tTaWduYXR1cmUocy5DRU5UUkFMX0RJUkVDVE9SWV9FTkQpLHRoaXMucmVhZEJsb2NrRW5kT2ZDZW50cmFsKCksdGhpcy5kaXNrTnVtYmVyPT09bi5NQVhfVkFMVUVfMTZCSVRTfHx0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0PT09bi5NQVhfVkFMVUVfMTZCSVRTfHx0aGlzLmNlbnRyYWxEaXJSZWNvcmRzT25UaGlzRGlzaz09PW4uTUFYX1ZBTFVFXzE2QklUU3x8dGhpcy5jZW50cmFsRGlyUmVjb3Jkcz09PW4uTUFYX1ZBTFVFXzE2QklUU3x8dGhpcy5jZW50cmFsRGlyU2l6ZT09PW4uTUFYX1ZBTFVFXzMyQklUU3x8dGhpcy5jZW50cmFsRGlyT2Zmc2V0PT09bi5NQVhfVkFMVUVfMzJCSVRTKXtpZih0aGlzLnppcDY0PSEwLCh0PXRoaXMucmVhZGVyLmxhc3RJbmRleE9mU2lnbmF0dXJlKHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUikpPDApdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogY2FuJ3QgZmluZCB0aGUgWklQNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3JcIik7aWYodGhpcy5yZWFkZXIuc2V0SW5kZXgodCksdGhpcy5jaGVja1NpZ25hdHVyZShzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpLHRoaXMucmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yKCksIXRoaXMuaXNTaWduYXR1cmUodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyLHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKSYmKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpcj10aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCksdGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyPDApKXRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IGNhbid0IGZpbmQgdGhlIFpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVwiKTt0aGlzLnJlYWRlci5zZXRJbmRleCh0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIpLHRoaXMuY2hlY2tTaWduYXR1cmUocy5aSVA2NF9DRU5UUkFMX0RJUkVDVE9SWV9FTkQpLHRoaXMucmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWwoKX12YXIgcj10aGlzLmNlbnRyYWxEaXJPZmZzZXQrdGhpcy5jZW50cmFsRGlyU2l6ZTt0aGlzLnppcDY0JiYocis9MjAscis9MTIrdGhpcy56aXA2NEVuZE9mQ2VudHJhbFNpemUpO3ZhciBpPWUtcjtpZigwPGkpdGhpcy5pc1NpZ25hdHVyZShlLHMuQ0VOVFJBTF9GSUxFX0hFQURFUil8fCh0aGlzLnJlYWRlci56ZXJvPWkpO2Vsc2UgaWYoaTwwKXRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IG1pc3NpbmcgXCIrTWF0aC5hYnMoaSkrXCIgYnl0ZXMuXCIpfSxwcmVwYXJlUmVhZGVyOmZ1bmN0aW9uKHQpe3RoaXMucmVhZGVyPWkodCl9LGxvYWQ6ZnVuY3Rpb24odCl7dGhpcy5wcmVwYXJlUmVhZGVyKHQpLHRoaXMucmVhZEVuZE9mQ2VudHJhbCgpLHRoaXMucmVhZENlbnRyYWxEaXIoKSx0aGlzLnJlYWRMb2NhbEZpbGVzKCl9fSxlLmV4cG9ydHM9aH0se1wiLi9yZWFkZXIvcmVhZGVyRm9yXCI6MjIsXCIuL3NpZ25hdHVyZVwiOjIzLFwiLi9zdXBwb3J0XCI6MzAsXCIuL3V0ZjhcIjozMSxcIi4vdXRpbHNcIjozMixcIi4vemlwRW50cnlcIjozNH1dLDM0OltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9dChcIi4vcmVhZGVyL3JlYWRlckZvclwiKSxzPXQoXCIuL3V0aWxzXCIpLG49dChcIi4vY29tcHJlc3NlZE9iamVjdFwiKSxhPXQoXCIuL2NyYzMyXCIpLG89dChcIi4vdXRmOFwiKSxoPXQoXCIuL2NvbXByZXNzaW9uc1wiKSx1PXQoXCIuL3N1cHBvcnRcIik7ZnVuY3Rpb24gbCh0LGUpe3RoaXMub3B0aW9ucz10LHRoaXMubG9hZE9wdGlvbnM9ZX1sLnByb3RvdHlwZT17aXNFbmNyeXB0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gMT09KDEmdGhpcy5iaXRGbGFnKX0sdXNlVVRGODpmdW5jdGlvbigpe3JldHVybiAyMDQ4PT0oMjA0OCZ0aGlzLmJpdEZsYWcpfSxyZWFkTG9jYWxQYXJ0OmZ1bmN0aW9uKHQpe3ZhciBlLHI7aWYodC5za2lwKDIyKSx0aGlzLmZpbGVOYW1lTGVuZ3RoPXQucmVhZEludCgyKSxyPXQucmVhZEludCgyKSx0aGlzLmZpbGVOYW1lPXQucmVhZERhdGEodGhpcy5maWxlTmFtZUxlbmd0aCksdC5za2lwKHIpLC0xPT09dGhpcy5jb21wcmVzc2VkU2l6ZXx8LTE9PT10aGlzLnVuY29tcHJlc3NlZFNpemUpdGhyb3cgbmV3IEVycm9yKFwiQnVnIG9yIGNvcnJ1cHRlZCB6aXAgOiBkaWRuJ3QgZ2V0IGVub3VnaCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBjZW50cmFsIGRpcmVjdG9yeSAoY29tcHJlc3NlZFNpemUgPT09IC0xIHx8IHVuY29tcHJlc3NlZFNpemUgPT09IC0xKVwiKTtpZihudWxsPT09KGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlIGluIGgpaWYoaC5oYXNPd25Qcm9wZXJ0eShlKSYmaFtlXS5tYWdpYz09PXQpcmV0dXJuIGhbZV07cmV0dXJuIG51bGx9KHRoaXMuY29tcHJlc3Npb25NZXRob2QpKSl0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogY29tcHJlc3Npb24gXCIrcy5wcmV0dHkodGhpcy5jb21wcmVzc2lvbk1ldGhvZCkrXCIgdW5rbm93biAoaW5uZXIgZmlsZSA6IFwiK3MudHJhbnNmb3JtVG8oXCJzdHJpbmdcIix0aGlzLmZpbGVOYW1lKStcIilcIik7dGhpcy5kZWNvbXByZXNzZWQ9bmV3IG4odGhpcy5jb21wcmVzc2VkU2l6ZSx0aGlzLnVuY29tcHJlc3NlZFNpemUsdGhpcy5jcmMzMixlLHQucmVhZERhdGEodGhpcy5jb21wcmVzc2VkU2l6ZSkpfSxyZWFkQ2VudHJhbFBhcnQ6ZnVuY3Rpb24odCl7dGhpcy52ZXJzaW9uTWFkZUJ5PXQucmVhZEludCgyKSx0LnNraXAoMiksdGhpcy5iaXRGbGFnPXQucmVhZEludCgyKSx0aGlzLmNvbXByZXNzaW9uTWV0aG9kPXQucmVhZFN0cmluZygyKSx0aGlzLmRhdGU9dC5yZWFkRGF0ZSgpLHRoaXMuY3JjMzI9dC5yZWFkSW50KDQpLHRoaXMuY29tcHJlc3NlZFNpemU9dC5yZWFkSW50KDQpLHRoaXMudW5jb21wcmVzc2VkU2l6ZT10LnJlYWRJbnQoNCk7dmFyIGU9dC5yZWFkSW50KDIpO2lmKHRoaXMuZXh0cmFGaWVsZHNMZW5ndGg9dC5yZWFkSW50KDIpLHRoaXMuZmlsZUNvbW1lbnRMZW5ndGg9dC5yZWFkSW50KDIpLHRoaXMuZGlza051bWJlclN0YXJ0PXQucmVhZEludCgyKSx0aGlzLmludGVybmFsRmlsZUF0dHJpYnV0ZXM9dC5yZWFkSW50KDIpLHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcz10LnJlYWRJbnQoNCksdGhpcy5sb2NhbEhlYWRlck9mZnNldD10LnJlYWRJbnQoNCksdGhpcy5pc0VuY3J5cHRlZCgpKXRocm93IG5ldyBFcnJvcihcIkVuY3J5cHRlZCB6aXAgYXJlIG5vdCBzdXBwb3J0ZWRcIik7dC5za2lwKGUpLHRoaXMucmVhZEV4dHJhRmllbGRzKHQpLHRoaXMucGFyc2VaSVA2NEV4dHJhRmllbGQodCksdGhpcy5maWxlQ29tbWVudD10LnJlYWREYXRhKHRoaXMuZmlsZUNvbW1lbnRMZW5ndGgpfSxwcm9jZXNzQXR0cmlidXRlczpmdW5jdGlvbigpe3RoaXMudW5peFBlcm1pc3Npb25zPW51bGwsdGhpcy5kb3NQZXJtaXNzaW9ucz1udWxsO3ZhciB0PXRoaXMudmVyc2lvbk1hZGVCeT4+ODt0aGlzLmRpcj0hISgxNiZ0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMpLDA9PXQmJih0aGlzLmRvc1Blcm1pc3Npb25zPTYzJnRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyksMz09dCYmKHRoaXMudW5peFBlcm1pc3Npb25zPXRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcz4+MTYmNjU1MzUpLHRoaXMuZGlyfHxcIi9cIiE9PXRoaXMuZmlsZU5hbWVTdHIuc2xpY2UoLTEpfHwodGhpcy5kaXI9ITApfSxwYXJzZVpJUDY0RXh0cmFGaWVsZDpmdW5jdGlvbih0KXtpZih0aGlzLmV4dHJhRmllbGRzWzFdKXt2YXIgZT1pKHRoaXMuZXh0cmFGaWVsZHNbMV0udmFsdWUpO3RoaXMudW5jb21wcmVzc2VkU2l6ZT09PXMuTUFYX1ZBTFVFXzMyQklUUyYmKHRoaXMudW5jb21wcmVzc2VkU2l6ZT1lLnJlYWRJbnQoOCkpLHRoaXMuY29tcHJlc3NlZFNpemU9PT1zLk1BWF9WQUxVRV8zMkJJVFMmJih0aGlzLmNvbXByZXNzZWRTaXplPWUucmVhZEludCg4KSksdGhpcy5sb2NhbEhlYWRlck9mZnNldD09PXMuTUFYX1ZBTFVFXzMyQklUUyYmKHRoaXMubG9jYWxIZWFkZXJPZmZzZXQ9ZS5yZWFkSW50KDgpKSx0aGlzLmRpc2tOdW1iZXJTdGFydD09PXMuTUFYX1ZBTFVFXzMyQklUUyYmKHRoaXMuZGlza051bWJlclN0YXJ0PWUucmVhZEludCg0KSl9fSxyZWFkRXh0cmFGaWVsZHM6ZnVuY3Rpb24odCl7dmFyIGUscixpLG49dC5pbmRleCt0aGlzLmV4dHJhRmllbGRzTGVuZ3RoO2Zvcih0aGlzLmV4dHJhRmllbGRzfHwodGhpcy5leHRyYUZpZWxkcz17fSk7dC5pbmRleCs0PG47KWU9dC5yZWFkSW50KDIpLHI9dC5yZWFkSW50KDIpLGk9dC5yZWFkRGF0YShyKSx0aGlzLmV4dHJhRmllbGRzW2VdPXtpZDplLGxlbmd0aDpyLHZhbHVlOml9O3Quc2V0SW5kZXgobil9LGhhbmRsZVVURjg6ZnVuY3Rpb24oKXt2YXIgdD11LnVpbnQ4YXJyYXk/XCJ1aW50OGFycmF5XCI6XCJhcnJheVwiO2lmKHRoaXMudXNlVVRGOCgpKXRoaXMuZmlsZU5hbWVTdHI9by51dGY4ZGVjb2RlKHRoaXMuZmlsZU5hbWUpLHRoaXMuZmlsZUNvbW1lbnRTdHI9by51dGY4ZGVjb2RlKHRoaXMuZmlsZUNvbW1lbnQpO2Vsc2V7dmFyIGU9dGhpcy5maW5kRXh0cmFGaWVsZFVuaWNvZGVQYXRoKCk7aWYobnVsbCE9PWUpdGhpcy5maWxlTmFtZVN0cj1lO2Vsc2V7dmFyIHI9cy50cmFuc2Zvcm1Ubyh0LHRoaXMuZmlsZU5hbWUpO3RoaXMuZmlsZU5hbWVTdHI9dGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShyKX12YXIgaT10aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZUNvbW1lbnQoKTtpZihudWxsIT09aSl0aGlzLmZpbGVDb21tZW50U3RyPWk7ZWxzZXt2YXIgbj1zLnRyYW5zZm9ybVRvKHQsdGhpcy5maWxlQ29tbWVudCk7dGhpcy5maWxlQ29tbWVudFN0cj10aGlzLmxvYWRPcHRpb25zLmRlY29kZUZpbGVOYW1lKG4pfX19LGZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGg6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmV4dHJhRmllbGRzWzI4Nzg5XTtpZih0KXt2YXIgZT1pKHQudmFsdWUpO3JldHVybiAxIT09ZS5yZWFkSW50KDEpP251bGw6YSh0aGlzLmZpbGVOYW1lKSE9PWUucmVhZEludCg0KT9udWxsOm8udXRmOGRlY29kZShlLnJlYWREYXRhKHQubGVuZ3RoLTUpKX1yZXR1cm4gbnVsbH0sZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZXh0cmFGaWVsZHNbMjU0NjFdO2lmKHQpe3ZhciBlPWkodC52YWx1ZSk7cmV0dXJuIDEhPT1lLnJlYWRJbnQoMSk/bnVsbDphKHRoaXMuZmlsZUNvbW1lbnQpIT09ZS5yZWFkSW50KDQpP251bGw6by51dGY4ZGVjb2RlKGUucmVhZERhdGEodC5sZW5ndGgtNSkpfXJldHVybiBudWxsfX0sZS5leHBvcnRzPWx9LHtcIi4vY29tcHJlc3NlZE9iamVjdFwiOjIsXCIuL2NvbXByZXNzaW9uc1wiOjMsXCIuL2NyYzMyXCI6NCxcIi4vcmVhZGVyL3JlYWRlckZvclwiOjIyLFwiLi9zdXBwb3J0XCI6MzAsXCIuL3V0ZjhcIjozMSxcIi4vdXRpbHNcIjozMn1dLDM1OltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gaSh0LGUscil7dGhpcy5uYW1lPXQsdGhpcy5kaXI9ci5kaXIsdGhpcy5kYXRlPXIuZGF0ZSx0aGlzLmNvbW1lbnQ9ci5jb21tZW50LHRoaXMudW5peFBlcm1pc3Npb25zPXIudW5peFBlcm1pc3Npb25zLHRoaXMuZG9zUGVybWlzc2lvbnM9ci5kb3NQZXJtaXNzaW9ucyx0aGlzLl9kYXRhPWUsdGhpcy5fZGF0YUJpbmFyeT1yLmJpbmFyeSx0aGlzLm9wdGlvbnM9e2NvbXByZXNzaW9uOnIuY29tcHJlc3Npb24sY29tcHJlc3Npb25PcHRpb25zOnIuY29tcHJlc3Npb25PcHRpb25zfX12YXIgcz10KFwiLi9zdHJlYW0vU3RyZWFtSGVscGVyXCIpLG49dChcIi4vc3RyZWFtL0RhdGFXb3JrZXJcIiksYT10KFwiLi91dGY4XCIpLG89dChcIi4vY29tcHJlc3NlZE9iamVjdFwiKSxoPXQoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO2kucHJvdG90eXBlPXtpbnRlcm5hbFN0cmVhbTpmdW5jdGlvbih0KXt2YXIgZT1udWxsLHI9XCJzdHJpbmdcIjt0cnl7aWYoIXQpdGhyb3cgbmV3IEVycm9yKFwiTm8gb3V0cHV0IHR5cGUgc3BlY2lmaWVkLlwiKTt2YXIgaT1cInN0cmluZ1wiPT09KHI9dC50b0xvd2VyQ2FzZSgpKXx8XCJ0ZXh0XCI9PT1yO1wiYmluYXJ5c3RyaW5nXCIhPT1yJiZcInRleHRcIiE9PXJ8fChyPVwic3RyaW5nXCIpLGU9dGhpcy5fZGVjb21wcmVzc1dvcmtlcigpO3ZhciBuPSF0aGlzLl9kYXRhQmluYXJ5O24mJiFpJiYoZT1lLnBpcGUobmV3IGEuVXRmOEVuY29kZVdvcmtlcikpLCFuJiZpJiYoZT1lLnBpcGUobmV3IGEuVXRmOERlY29kZVdvcmtlcikpfWNhdGNoKHQpeyhlPW5ldyBoKFwiZXJyb3JcIikpLmVycm9yKHQpfXJldHVybiBuZXcgcyhlLHIsXCJcIil9LGFzeW5jOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odCkuYWNjdW11bGF0ZShlKX0sbm9kZVN0cmVhbTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmludGVybmFsU3RyZWFtKHR8fFwibm9kZWJ1ZmZlclwiKS50b05vZGVqc1N0cmVhbShlKX0sX2NvbXByZXNzV29ya2VyOmZ1bmN0aW9uKHQsZSl7aWYodGhpcy5fZGF0YSBpbnN0YW5jZW9mIG8mJnRoaXMuX2RhdGEuY29tcHJlc3Npb24ubWFnaWM9PT10Lm1hZ2ljKXJldHVybiB0aGlzLl9kYXRhLmdldENvbXByZXNzZWRXb3JrZXIoKTt2YXIgcj10aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7cmV0dXJuIHRoaXMuX2RhdGFCaW5hcnl8fChyPXIucGlwZShuZXcgYS5VdGY4RW5jb2RlV29ya2VyKSksby5jcmVhdGVXb3JrZXJGcm9tKHIsdCxlKX0sX2RlY29tcHJlc3NXb3JrZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZGF0YSBpbnN0YW5jZW9mIG8/dGhpcy5fZGF0YS5nZXRDb250ZW50V29ya2VyKCk6dGhpcy5fZGF0YSBpbnN0YW5jZW9mIGg/dGhpcy5fZGF0YTpuZXcgbih0aGlzLl9kYXRhKX19O2Zvcih2YXIgdT1bXCJhc1RleHRcIixcImFzQmluYXJ5XCIsXCJhc05vZGVCdWZmZXJcIixcImFzVWludDhBcnJheVwiLFwiYXNBcnJheUJ1ZmZlclwiXSxsPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiVGhpcyBtZXRob2QgaGFzIGJlZW4gcmVtb3ZlZCBpbiBKU1ppcCAzLjAsIHBsZWFzZSBjaGVjayB0aGUgdXBncmFkZSBndWlkZS5cIil9LGY9MDtmPHUubGVuZ3RoO2YrKylpLnByb3RvdHlwZVt1W2ZdXT1sO2UuZXhwb3J0cz1pfSx7XCIuL2NvbXByZXNzZWRPYmplY3RcIjoyLFwiLi9zdHJlYW0vRGF0YVdvcmtlclwiOjI3LFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiOjI4LFwiLi9zdHJlYW0vU3RyZWFtSGVscGVyXCI6MjksXCIuL3V0ZjhcIjozMX1dLDM2OltmdW5jdGlvbih0LGwsZSl7KGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO3ZhciByLGksdD1lLk11dGF0aW9uT2JzZXJ2ZXJ8fGUuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtpZih0KXt2YXIgbj0wLHM9bmV3IHQodSksYT1lLmRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO3Mub2JzZXJ2ZShhLHtjaGFyYWN0ZXJEYXRhOiEwfSkscj1mdW5jdGlvbigpe2EuZGF0YT1uPSsrbiUyfX1lbHNlIGlmKGUuc2V0SW1tZWRpYXRlfHx2b2lkIDA9PT1lLk1lc3NhZ2VDaGFubmVsKXI9XCJkb2N1bWVudFwiaW4gZSYmXCJvbnJlYWR5c3RhdGVjaGFuZ2VcImluIGUuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKT9mdW5jdGlvbigpe3ZhciB0PWUuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTt0Lm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe3UoKSx0Lm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsLHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0KSx0PW51bGx9LGUuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKHQpfTpmdW5jdGlvbigpe3NldFRpbWVvdXQodSwwKX07ZWxzZXt2YXIgbz1uZXcgZS5NZXNzYWdlQ2hhbm5lbDtvLnBvcnQxLm9ubWVzc2FnZT11LHI9ZnVuY3Rpb24oKXtvLnBvcnQyLnBvc3RNZXNzYWdlKDApfX12YXIgaD1bXTtmdW5jdGlvbiB1KCl7dmFyIHQsZTtpPSEwO2Zvcih2YXIgcj1oLmxlbmd0aDtyOyl7Zm9yKGU9aCxoPVtdLHQ9LTE7Kyt0PHI7KWVbdF0oKTtyPWgubGVuZ3RofWk9ITF9bC5leHBvcnRzPWZ1bmN0aW9uKHQpezEhPT1oLnB1c2godCl8fGl8fHIoKX19KS5jYWxsKHRoaXMsXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fSl9LHt9XSwzNzpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoXCJpbW1lZGlhdGVcIik7ZnVuY3Rpb24gdSgpe312YXIgbD17fSxzPVtcIlJFSkVDVEVEXCJdLGE9W1wiRlVMRklMTEVEXCJdLGk9W1wiUEVORElOR1wiXTtmdW5jdGlvbiBvKHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcInJlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvblwiKTt0aGlzLnN0YXRlPWksdGhpcy5xdWV1ZT1bXSx0aGlzLm91dGNvbWU9dm9pZCAwLHQhPT11JiZjKHRoaXMsdCl9ZnVuY3Rpb24gaCh0LGUscil7dGhpcy5wcm9taXNlPXQsXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmKHRoaXMub25GdWxmaWxsZWQ9ZSx0aGlzLmNhbGxGdWxmaWxsZWQ9dGhpcy5vdGhlckNhbGxGdWxmaWxsZWQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHImJih0aGlzLm9uUmVqZWN0ZWQ9cix0aGlzLmNhbGxSZWplY3RlZD10aGlzLm90aGVyQ2FsbFJlamVjdGVkKX1mdW5jdGlvbiBmKGUscixpKXtuKGZ1bmN0aW9uKCl7dmFyIHQ7dHJ5e3Q9cihpKX1jYXRjaCh0KXtyZXR1cm4gbC5yZWplY3QoZSx0KX10PT09ZT9sLnJlamVjdChlLG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmXCIpKTpsLnJlc29sdmUoZSx0KX0pfWZ1bmN0aW9uIGQodCl7dmFyIGU9dCYmdC50aGVuO2lmKHQmJihcIm9iamVjdFwiPT10eXBlb2YgdHx8XCJmdW5jdGlvblwiPT10eXBlb2YgdCkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUpcmV0dXJuIGZ1bmN0aW9uKCl7ZS5hcHBseSh0LGFyZ3VtZW50cyl9fWZ1bmN0aW9uIGMoZSx0KXt2YXIgcj0hMTtmdW5jdGlvbiBpKHQpe3J8fChyPSEwLGwucmVqZWN0KGUsdCkpfWZ1bmN0aW9uIG4odCl7cnx8KHI9ITAsbC5yZXNvbHZlKGUsdCkpfXZhciBzPXAoZnVuY3Rpb24oKXt0KG4saSl9KTtcImVycm9yXCI9PT1zLnN0YXR1cyYmaShzLnZhbHVlKX1mdW5jdGlvbiBwKHQsZSl7dmFyIHI9e307dHJ5e3IudmFsdWU9dChlKSxyLnN0YXR1cz1cInN1Y2Nlc3NcIn1jYXRjaCh0KXtyLnN0YXR1cz1cImVycm9yXCIsci52YWx1ZT10fXJldHVybiByfShlLmV4cG9ydHM9bykucHJvdG90eXBlLmZpbmFsbHk9ZnVuY3Rpb24oZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSlyZXR1cm4gdGhpczt2YXIgcj10aGlzLmNvbnN0cnVjdG9yO3JldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIHIucmVzb2x2ZShlKCkpLnRoZW4oZnVuY3Rpb24oKXtyZXR1cm4gdH0pfSxmdW5jdGlvbih0KXtyZXR1cm4gci5yZXNvbHZlKGUoKSkudGhlbihmdW5jdGlvbigpe3Rocm93IHR9KX0pfSxvLnByb3RvdHlwZS5jYXRjaD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aGVuKG51bGwsdCl9LG8ucHJvdG90eXBlLnRoZW49ZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0JiZ0aGlzLnN0YXRlPT09YXx8XCJmdW5jdGlvblwiIT10eXBlb2YgZSYmdGhpcy5zdGF0ZT09PXMpcmV0dXJuIHRoaXM7dmFyIHI9bmV3IHRoaXMuY29uc3RydWN0b3IodSk7dGhpcy5zdGF0ZSE9PWk/ZihyLHRoaXMuc3RhdGU9PT1hP3Q6ZSx0aGlzLm91dGNvbWUpOnRoaXMucXVldWUucHVzaChuZXcgaChyLHQsZSkpO3JldHVybiByfSxoLnByb3RvdHlwZS5jYWxsRnVsZmlsbGVkPWZ1bmN0aW9uKHQpe2wucmVzb2x2ZSh0aGlzLnByb21pc2UsdCl9LGgucHJvdG90eXBlLm90aGVyQ2FsbEZ1bGZpbGxlZD1mdW5jdGlvbih0KXtmKHRoaXMucHJvbWlzZSx0aGlzLm9uRnVsZmlsbGVkLHQpfSxoLnByb3RvdHlwZS5jYWxsUmVqZWN0ZWQ9ZnVuY3Rpb24odCl7bC5yZWplY3QodGhpcy5wcm9taXNlLHQpfSxoLnByb3RvdHlwZS5vdGhlckNhbGxSZWplY3RlZD1mdW5jdGlvbih0KXtmKHRoaXMucHJvbWlzZSx0aGlzLm9uUmVqZWN0ZWQsdCl9LGwucmVzb2x2ZT1mdW5jdGlvbih0LGUpe3ZhciByPXAoZCxlKTtpZihcImVycm9yXCI9PT1yLnN0YXR1cylyZXR1cm4gbC5yZWplY3QodCxyLnZhbHVlKTt2YXIgaT1yLnZhbHVlO2lmKGkpYyh0LGkpO2Vsc2V7dC5zdGF0ZT1hLHQub3V0Y29tZT1lO2Zvcih2YXIgbj0tMSxzPXQucXVldWUubGVuZ3RoOysrbjxzOyl0LnF1ZXVlW25dLmNhbGxGdWxmaWxsZWQoZSl9cmV0dXJuIHR9LGwucmVqZWN0PWZ1bmN0aW9uKHQsZSl7dC5zdGF0ZT1zLHQub3V0Y29tZT1lO2Zvcih2YXIgcj0tMSxpPXQucXVldWUubGVuZ3RoOysrcjxpOyl0LnF1ZXVlW3JdLmNhbGxSZWplY3RlZChlKTtyZXR1cm4gdH0sby5yZXNvbHZlPWZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiB0aGlzKXJldHVybiB0O3JldHVybiBsLnJlc29sdmUobmV3IHRoaXModSksdCl9LG8ucmVqZWN0PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyB0aGlzKHUpO3JldHVybiBsLnJlamVjdChlLHQpfSxvLmFsbD1mdW5jdGlvbih0KXt2YXIgcj10aGlzO2lmKFwiW29iamVjdCBBcnJheV1cIiE9PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSlyZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcihcIm11c3QgYmUgYW4gYXJyYXlcIikpO3ZhciBpPXQubGVuZ3RoLG49ITE7aWYoIWkpcmV0dXJuIHRoaXMucmVzb2x2ZShbXSk7dmFyIHM9bmV3IEFycmF5KGkpLGE9MCxlPS0xLG89bmV3IHRoaXModSk7Zm9yKDsrK2U8aTspaCh0W2VdLGUpO3JldHVybiBvO2Z1bmN0aW9uIGgodCxlKXtyLnJlc29sdmUodCkudGhlbihmdW5jdGlvbih0KXtzW2VdPXQsKythIT09aXx8bnx8KG49ITAsbC5yZXNvbHZlKG8scykpfSxmdW5jdGlvbih0KXtufHwobj0hMCxsLnJlamVjdChvLHQpKX0pfX0sby5yYWNlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7aWYoXCJbb2JqZWN0IEFycmF5XVwiIT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpKXJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKFwibXVzdCBiZSBhbiBhcnJheVwiKSk7dmFyIHI9dC5sZW5ndGgsaT0hMTtpZighcilyZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTt2YXIgbj0tMSxzPW5ldyB0aGlzKHUpO2Zvcig7KytuPHI7KWE9dFtuXSxlLnJlc29sdmUoYSkudGhlbihmdW5jdGlvbih0KXtpfHwoaT0hMCxsLnJlc29sdmUocyx0KSl9LGZ1bmN0aW9uKHQpe2l8fChpPSEwLGwucmVqZWN0KHMsdCkpfSk7dmFyIGE7cmV0dXJuIHN9fSx7aW1tZWRpYXRlOjM2fV0sMzg6W2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgaT17fTsoMCx0KFwiLi9saWIvdXRpbHMvY29tbW9uXCIpLmFzc2lnbikoaSx0KFwiLi9saWIvZGVmbGF0ZVwiKSx0KFwiLi9saWIvaW5mbGF0ZVwiKSx0KFwiLi9saWIvemxpYi9jb25zdGFudHNcIikpLGUuZXhwb3J0cz1pfSx7XCIuL2xpYi9kZWZsYXRlXCI6MzksXCIuL2xpYi9pbmZsYXRlXCI6NDAsXCIuL2xpYi91dGlscy9jb21tb25cIjo0MSxcIi4vbGliL3psaWIvY29uc3RhbnRzXCI6NDR9XSwzOTpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBhPXQoXCIuL3psaWIvZGVmbGF0ZVwiKSxvPXQoXCIuL3V0aWxzL2NvbW1vblwiKSxoPXQoXCIuL3V0aWxzL3N0cmluZ3NcIiksbj10KFwiLi96bGliL21lc3NhZ2VzXCIpLHM9dChcIi4vemxpYi96c3RyZWFtXCIpLHU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxsPTAsZj0tMSxkPTAsYz04O2Z1bmN0aW9uIHAodCl7aWYoISh0aGlzIGluc3RhbmNlb2YgcCkpcmV0dXJuIG5ldyBwKHQpO3RoaXMub3B0aW9ucz1vLmFzc2lnbih7bGV2ZWw6ZixtZXRob2Q6YyxjaHVua1NpemU6MTYzODQsd2luZG93Qml0czoxNSxtZW1MZXZlbDo4LHN0cmF0ZWd5OmQsdG86XCJcIn0sdHx8e30pO3ZhciBlPXRoaXMub3B0aW9ucztlLnJhdyYmMDxlLndpbmRvd0JpdHM/ZS53aW5kb3dCaXRzPS1lLndpbmRvd0JpdHM6ZS5nemlwJiYwPGUud2luZG93Qml0cyYmZS53aW5kb3dCaXRzPDE2JiYoZS53aW5kb3dCaXRzKz0xNiksdGhpcy5lcnI9MCx0aGlzLm1zZz1cIlwiLHRoaXMuZW5kZWQ9ITEsdGhpcy5jaHVua3M9W10sdGhpcy5zdHJtPW5ldyBzLHRoaXMuc3RybS5hdmFpbF9vdXQ9MDt2YXIgcj1hLmRlZmxhdGVJbml0Mih0aGlzLnN0cm0sZS5sZXZlbCxlLm1ldGhvZCxlLndpbmRvd0JpdHMsZS5tZW1MZXZlbCxlLnN0cmF0ZWd5KTtpZihyIT09bCl0aHJvdyBuZXcgRXJyb3IobltyXSk7aWYoZS5oZWFkZXImJmEuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sZS5oZWFkZXIpLGUuZGljdGlvbmFyeSl7dmFyIGk7aWYoaT1cInN0cmluZ1wiPT10eXBlb2YgZS5kaWN0aW9uYXJ5P2guc3RyaW5nMmJ1ZihlLmRpY3Rpb25hcnkpOlwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIj09PXUuY2FsbChlLmRpY3Rpb25hcnkpP25ldyBVaW50OEFycmF5KGUuZGljdGlvbmFyeSk6ZS5kaWN0aW9uYXJ5LChyPWEuZGVmbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLGkpKSE9PWwpdGhyb3cgbmV3IEVycm9yKG5bcl0pO3RoaXMuX2RpY3Rfc2V0PSEwfX1mdW5jdGlvbiBpKHQsZSl7dmFyIHI9bmV3IHAoZSk7aWYoci5wdXNoKHQsITApLHIuZXJyKXRocm93IHIubXNnfHxuW3IuZXJyXTtyZXR1cm4gci5yZXN1bHR9cC5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0LGUpe3ZhciByLGksbj10aGlzLnN0cm0scz10aGlzLm9wdGlvbnMuY2h1bmtTaXplO2lmKHRoaXMuZW5kZWQpcmV0dXJuITE7aT1lPT09fn5lP2U6ITA9PT1lPzQ6MCxcInN0cmluZ1wiPT10eXBlb2YgdD9uLmlucHV0PWguc3RyaW5nMmJ1Zih0KTpcIltvYmplY3QgQXJyYXlCdWZmZXJdXCI9PT11LmNhbGwodCk/bi5pbnB1dD1uZXcgVWludDhBcnJheSh0KTpuLmlucHV0PXQsbi5uZXh0X2luPTAsbi5hdmFpbF9pbj1uLmlucHV0Lmxlbmd0aDtkb3tpZigwPT09bi5hdmFpbF9vdXQmJihuLm91dHB1dD1uZXcgby5CdWY4KHMpLG4ubmV4dF9vdXQ9MCxuLmF2YWlsX291dD1zKSwxIT09KHI9YS5kZWZsYXRlKG4saSkpJiZyIT09bClyZXR1cm4gdGhpcy5vbkVuZChyKSwhKHRoaXMuZW5kZWQ9ITApOzAhPT1uLmF2YWlsX291dCYmKDAhPT1uLmF2YWlsX2lufHw0IT09aSYmMiE9PWkpfHwoXCJzdHJpbmdcIj09PXRoaXMub3B0aW9ucy50bz90aGlzLm9uRGF0YShoLmJ1ZjJiaW5zdHJpbmcoby5zaHJpbmtCdWYobi5vdXRwdXQsbi5uZXh0X291dCkpKTp0aGlzLm9uRGF0YShvLnNocmlua0J1ZihuLm91dHB1dCxuLm5leHRfb3V0KSkpfXdoaWxlKCgwPG4uYXZhaWxfaW58fDA9PT1uLmF2YWlsX291dCkmJjEhPT1yKTtyZXR1cm4gND09PWk/KHI9YS5kZWZsYXRlRW5kKHRoaXMuc3RybSksdGhpcy5vbkVuZChyKSx0aGlzLmVuZGVkPSEwLHI9PT1sKToyIT09aXx8KHRoaXMub25FbmQobCksIShuLmF2YWlsX291dD0wKSl9LHAucHJvdG90eXBlLm9uRGF0YT1mdW5jdGlvbih0KXt0aGlzLmNodW5rcy5wdXNoKHQpfSxwLnByb3RvdHlwZS5vbkVuZD1mdW5jdGlvbih0KXt0PT09bCYmKFwic3RyaW5nXCI9PT10aGlzLm9wdGlvbnMudG8/dGhpcy5yZXN1bHQ9dGhpcy5jaHVua3Muam9pbihcIlwiKTp0aGlzLnJlc3VsdD1vLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpKSx0aGlzLmNodW5rcz1bXSx0aGlzLmVycj10LHRoaXMubXNnPXRoaXMuc3RybS5tc2d9LHIuRGVmbGF0ZT1wLHIuZGVmbGF0ZT1pLHIuZGVmbGF0ZVJhdz1mdW5jdGlvbih0LGUpe3JldHVybihlPWV8fHt9KS5yYXc9ITAsaSh0LGUpfSxyLmd6aXA9ZnVuY3Rpb24odCxlKXtyZXR1cm4oZT1lfHx7fSkuZ3ppcD0hMCxpKHQsZSl9fSx7XCIuL3V0aWxzL2NvbW1vblwiOjQxLFwiLi91dGlscy9zdHJpbmdzXCI6NDIsXCIuL3psaWIvZGVmbGF0ZVwiOjQ2LFwiLi96bGliL21lc3NhZ2VzXCI6NTEsXCIuL3psaWIvenN0cmVhbVwiOjUzfV0sNDA6W2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgZD10KFwiLi96bGliL2luZmxhdGVcIiksYz10KFwiLi91dGlscy9jb21tb25cIikscD10KFwiLi91dGlscy9zdHJpbmdzXCIpLG09dChcIi4vemxpYi9jb25zdGFudHNcIiksaT10KFwiLi96bGliL21lc3NhZ2VzXCIpLG49dChcIi4vemxpYi96c3RyZWFtXCIpLHM9dChcIi4vemxpYi9nemhlYWRlclwiKSxfPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7ZnVuY3Rpb24gYSh0KXtpZighKHRoaXMgaW5zdGFuY2VvZiBhKSlyZXR1cm4gbmV3IGEodCk7dGhpcy5vcHRpb25zPWMuYXNzaWduKHtjaHVua1NpemU6MTYzODQsd2luZG93Qml0czowLHRvOlwiXCJ9LHR8fHt9KTt2YXIgZT10aGlzLm9wdGlvbnM7ZS5yYXcmJjA8PWUud2luZG93Qml0cyYmZS53aW5kb3dCaXRzPDE2JiYoZS53aW5kb3dCaXRzPS1lLndpbmRvd0JpdHMsMD09PWUud2luZG93Qml0cyYmKGUud2luZG93Qml0cz0tMTUpKSwhKDA8PWUud2luZG93Qml0cyYmZS53aW5kb3dCaXRzPDE2KXx8dCYmdC53aW5kb3dCaXRzfHwoZS53aW5kb3dCaXRzKz0zMiksMTU8ZS53aW5kb3dCaXRzJiZlLndpbmRvd0JpdHM8NDgmJjA9PSgxNSZlLndpbmRvd0JpdHMpJiYoZS53aW5kb3dCaXRzfD0xNSksdGhpcy5lcnI9MCx0aGlzLm1zZz1cIlwiLHRoaXMuZW5kZWQ9ITEsdGhpcy5jaHVua3M9W10sdGhpcy5zdHJtPW5ldyBuLHRoaXMuc3RybS5hdmFpbF9vdXQ9MDt2YXIgcj1kLmluZmxhdGVJbml0Mih0aGlzLnN0cm0sZS53aW5kb3dCaXRzKTtpZihyIT09bS5aX09LKXRocm93IG5ldyBFcnJvcihpW3JdKTt0aGlzLmhlYWRlcj1uZXcgcyxkLmluZmxhdGVHZXRIZWFkZXIodGhpcy5zdHJtLHRoaXMuaGVhZGVyKX1mdW5jdGlvbiBvKHQsZSl7dmFyIHI9bmV3IGEoZSk7aWYoci5wdXNoKHQsITApLHIuZXJyKXRocm93IHIubXNnfHxpW3IuZXJyXTtyZXR1cm4gci5yZXN1bHR9YS5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0LGUpe3ZhciByLGksbixzLGEsbyxoPXRoaXMuc3RybSx1PXRoaXMub3B0aW9ucy5jaHVua1NpemUsbD10aGlzLm9wdGlvbnMuZGljdGlvbmFyeSxmPSExO2lmKHRoaXMuZW5kZWQpcmV0dXJuITE7aT1lPT09fn5lP2U6ITA9PT1lP20uWl9GSU5JU0g6bS5aX05PX0ZMVVNILFwic3RyaW5nXCI9PXR5cGVvZiB0P2guaW5wdXQ9cC5iaW5zdHJpbmcyYnVmKHQpOlwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIj09PV8uY2FsbCh0KT9oLmlucHV0PW5ldyBVaW50OEFycmF5KHQpOmguaW5wdXQ9dCxoLm5leHRfaW49MCxoLmF2YWlsX2luPWguaW5wdXQubGVuZ3RoO2Rve2lmKDA9PT1oLmF2YWlsX291dCYmKGgub3V0cHV0PW5ldyBjLkJ1ZjgodSksaC5uZXh0X291dD0wLGguYXZhaWxfb3V0PXUpLChyPWQuaW5mbGF0ZShoLG0uWl9OT19GTFVTSCkpPT09bS5aX05FRURfRElDVCYmbCYmKG89XCJzdHJpbmdcIj09dHlwZW9mIGw/cC5zdHJpbmcyYnVmKGwpOlwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIj09PV8uY2FsbChsKT9uZXcgVWludDhBcnJheShsKTpsLHI9ZC5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sbykpLHI9PT1tLlpfQlVGX0VSUk9SJiYhMD09PWYmJihyPW0uWl9PSyxmPSExKSxyIT09bS5aX1NUUkVBTV9FTkQmJnIhPT1tLlpfT0spcmV0dXJuIHRoaXMub25FbmQociksISh0aGlzLmVuZGVkPSEwKTtoLm5leHRfb3V0JiYoMCE9PWguYXZhaWxfb3V0JiZyIT09bS5aX1NUUkVBTV9FTkQmJigwIT09aC5hdmFpbF9pbnx8aSE9PW0uWl9GSU5JU0gmJmkhPT1tLlpfU1lOQ19GTFVTSCl8fChcInN0cmluZ1wiPT09dGhpcy5vcHRpb25zLnRvPyhuPXAudXRmOGJvcmRlcihoLm91dHB1dCxoLm5leHRfb3V0KSxzPWgubmV4dF9vdXQtbixhPXAuYnVmMnN0cmluZyhoLm91dHB1dCxuKSxoLm5leHRfb3V0PXMsaC5hdmFpbF9vdXQ9dS1zLHMmJmMuYXJyYXlTZXQoaC5vdXRwdXQsaC5vdXRwdXQsbixzLDApLHRoaXMub25EYXRhKGEpKTp0aGlzLm9uRGF0YShjLnNocmlua0J1ZihoLm91dHB1dCxoLm5leHRfb3V0KSkpKSwwPT09aC5hdmFpbF9pbiYmMD09PWguYXZhaWxfb3V0JiYoZj0hMCl9d2hpbGUoKDA8aC5hdmFpbF9pbnx8MD09PWguYXZhaWxfb3V0KSYmciE9PW0uWl9TVFJFQU1fRU5EKTtyZXR1cm4gcj09PW0uWl9TVFJFQU1fRU5EJiYoaT1tLlpfRklOSVNIKSxpPT09bS5aX0ZJTklTSD8ocj1kLmluZmxhdGVFbmQodGhpcy5zdHJtKSx0aGlzLm9uRW5kKHIpLHRoaXMuZW5kZWQ9ITAscj09PW0uWl9PSyk6aSE9PW0uWl9TWU5DX0ZMVVNIfHwodGhpcy5vbkVuZChtLlpfT0spLCEoaC5hdmFpbF9vdXQ9MCkpfSxhLnByb3RvdHlwZS5vbkRhdGE9ZnVuY3Rpb24odCl7dGhpcy5jaHVua3MucHVzaCh0KX0sYS5wcm90b3R5cGUub25FbmQ9ZnVuY3Rpb24odCl7dD09PW0uWl9PSyYmKFwic3RyaW5nXCI9PT10aGlzLm9wdGlvbnMudG8/dGhpcy5yZXN1bHQ9dGhpcy5jaHVua3Muam9pbihcIlwiKTp0aGlzLnJlc3VsdD1jLmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpKSx0aGlzLmNodW5rcz1bXSx0aGlzLmVycj10LHRoaXMubXNnPXRoaXMuc3RybS5tc2d9LHIuSW5mbGF0ZT1hLHIuaW5mbGF0ZT1vLHIuaW5mbGF0ZVJhdz1mdW5jdGlvbih0LGUpe3JldHVybihlPWV8fHt9KS5yYXc9ITAsbyh0LGUpfSxyLnVuZ3ppcD1vfSx7XCIuL3V0aWxzL2NvbW1vblwiOjQxLFwiLi91dGlscy9zdHJpbmdzXCI6NDIsXCIuL3psaWIvY29uc3RhbnRzXCI6NDQsXCIuL3psaWIvZ3poZWFkZXJcIjo0NyxcIi4vemxpYi9pbmZsYXRlXCI6NDksXCIuL3psaWIvbWVzc2FnZXNcIjo1MSxcIi4vemxpYi96c3RyZWFtXCI6NTN9XSw0MTpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBpPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBVaW50OEFycmF5JiZcInVuZGVmaW5lZFwiIT10eXBlb2YgVWludDE2QXJyYXkmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBJbnQzMkFycmF5O3IuYXNzaWduPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7ZS5sZW5ndGg7KXt2YXIgcj1lLnNoaWZ0KCk7aWYocil7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHIpdGhyb3cgbmV3IFR5cGVFcnJvcihyK1wibXVzdCBiZSBub24tb2JqZWN0XCIpO2Zvcih2YXIgaSBpbiByKXIuaGFzT3duUHJvcGVydHkoaSkmJih0W2ldPXJbaV0pfX1yZXR1cm4gdH0sci5zaHJpbmtCdWY9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5sZW5ndGg9PT1lP3Q6dC5zdWJhcnJheT90LnN1YmFycmF5KDAsZSk6KHQubGVuZ3RoPWUsdCl9O3ZhciBuPXthcnJheVNldDpmdW5jdGlvbih0LGUscixpLG4pe2lmKGUuc3ViYXJyYXkmJnQuc3ViYXJyYXkpdC5zZXQoZS5zdWJhcnJheShyLHIraSksbik7ZWxzZSBmb3IodmFyIHM9MDtzPGk7cysrKXRbbitzXT1lW3Irc119LGZsYXR0ZW5DaHVua3M6ZnVuY3Rpb24odCl7dmFyIGUscixpLG4scyxhO2ZvcihlPWk9MCxyPXQubGVuZ3RoO2U8cjtlKyspaSs9dFtlXS5sZW5ndGg7Zm9yKGE9bmV3IFVpbnQ4QXJyYXkoaSksZT1uPTAscj10Lmxlbmd0aDtlPHI7ZSsrKXM9dFtlXSxhLnNldChzLG4pLG4rPXMubGVuZ3RoO3JldHVybiBhfX0scz17YXJyYXlTZXQ6ZnVuY3Rpb24odCxlLHIsaSxuKXtmb3IodmFyIHM9MDtzPGk7cysrKXRbbitzXT1lW3Irc119LGZsYXR0ZW5DaHVua3M6ZnVuY3Rpb24odCl7cmV0dXJuW10uY29uY2F0LmFwcGx5KFtdLHQpfX07ci5zZXRUeXBlZD1mdW5jdGlvbih0KXt0PyhyLkJ1Zjg9VWludDhBcnJheSxyLkJ1ZjE2PVVpbnQxNkFycmF5LHIuQnVmMzI9SW50MzJBcnJheSxyLmFzc2lnbihyLG4pKTooci5CdWY4PUFycmF5LHIuQnVmMTY9QXJyYXksci5CdWYzMj1BcnJheSxyLmFzc2lnbihyLHMpKX0sci5zZXRUeXBlZChpKX0se31dLDQyOltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGg9dChcIi4vY29tbW9uXCIpLG49ITAscz0hMDt0cnl7U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLFswXSl9Y2F0Y2godCl7bj0hMX10cnl7U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLG5ldyBVaW50OEFycmF5KDEpKX1jYXRjaCh0KXtzPSExfWZvcih2YXIgdT1uZXcgaC5CdWY4KDI1NiksaT0wO2k8MjU2O2krKyl1W2ldPTI1Mjw9aT82OjI0ODw9aT81OjI0MDw9aT80OjIyNDw9aT8zOjE5Mjw9aT8yOjE7ZnVuY3Rpb24gbCh0LGUpe2lmKGU8NjU1MzcmJih0LnN1YmFycmF5JiZzfHwhdC5zdWJhcnJheSYmbikpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxoLnNocmlua0J1Zih0LGUpKTtmb3IodmFyIHI9XCJcIixpPTA7aTxlO2krKylyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRbaV0pO3JldHVybiByfXVbMjU0XT11WzI1NF09MSxyLnN0cmluZzJidWY9ZnVuY3Rpb24odCl7dmFyIGUscixpLG4scyxhPXQubGVuZ3RoLG89MDtmb3Iobj0wO248YTtuKyspNTUyOTY9PSg2NDUxMiYocj10LmNoYXJDb2RlQXQobikpKSYmbisxPGEmJjU2MzIwPT0oNjQ1MTImKGk9dC5jaGFyQ29kZUF0KG4rMSkpKSYmKHI9NjU1MzYrKHItNTUyOTY8PDEwKSsoaS01NjMyMCksbisrKSxvKz1yPDEyOD8xOnI8MjA0OD8yOnI8NjU1MzY/Mzo0O2ZvcihlPW5ldyBoLkJ1Zjgobyksbj1zPTA7czxvO24rKyk1NTI5Nj09KDY0NTEyJihyPXQuY2hhckNvZGVBdChuKSkpJiZuKzE8YSYmNTYzMjA9PSg2NDUxMiYoaT10LmNoYXJDb2RlQXQobisxKSkpJiYocj02NTUzNisoci01NTI5Njw8MTApKyhpLTU2MzIwKSxuKyspLHI8MTI4P2VbcysrXT1yOihyPDIwNDg/ZVtzKytdPTE5MnxyPj4+Njoocjw2NTUzNj9lW3MrK109MjI0fHI+Pj4xMjooZVtzKytdPTI0MHxyPj4+MTgsZVtzKytdPTEyOHxyPj4+MTImNjMpLGVbcysrXT0xMjh8cj4+PjYmNjMpLGVbcysrXT0xMjh8NjMmcik7cmV0dXJuIGV9LHIuYnVmMmJpbnN0cmluZz1mdW5jdGlvbih0KXtyZXR1cm4gbCh0LHQubGVuZ3RoKX0sci5iaW5zdHJpbmcyYnVmPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgaC5CdWY4KHQubGVuZ3RoKSxyPTAsaT1lLmxlbmd0aDtyPGk7cisrKWVbcl09dC5jaGFyQ29kZUF0KHIpO3JldHVybiBlfSxyLmJ1ZjJzdHJpbmc9ZnVuY3Rpb24odCxlKXt2YXIgcixpLG4scyxhPWV8fHQubGVuZ3RoLG89bmV3IEFycmF5KDIqYSk7Zm9yKHI9aT0wO3I8YTspaWYoKG49dFtyKytdKTwxMjgpb1tpKytdPW47ZWxzZSBpZig0PChzPXVbbl0pKW9baSsrXT02NTUzMyxyKz1zLTE7ZWxzZXtmb3IobiY9Mj09PXM/MzE6Mz09PXM/MTU6NzsxPHMmJnI8YTspbj1uPDw2fDYzJnRbcisrXSxzLS07MTxzP29baSsrXT02NTUzMzpuPDY1NTM2P29baSsrXT1uOihuLT02NTUzNixvW2krK109NTUyOTZ8bj4+MTAmMTAyMyxvW2krK109NTYzMjB8MTAyMyZuKX1yZXR1cm4gbChvLGkpfSxyLnV0Zjhib3JkZXI9ZnVuY3Rpb24odCxlKXt2YXIgcjtmb3IoKGU9ZXx8dC5sZW5ndGgpPnQubGVuZ3RoJiYoZT10Lmxlbmd0aCkscj1lLTE7MDw9ciYmMTI4PT0oMTkyJnRbcl0pOylyLS07cmV0dXJuIHI8MD9lOjA9PT1yP2U6cit1W3Rbcl1dPmU/cjplfX0se1wiLi9jb21tb25cIjo0MX1dLDQzOltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSxyLGkpe2Zvcih2YXIgbj02NTUzNSZ0fDAscz10Pj4+MTYmNjU1MzV8MCxhPTA7MCE9PXI7KXtmb3Ioci09YT0yZTM8cj8yZTM6cjtzPXMrKG49bitlW2krK118MCl8MCwtLWE7KTtuJT02NTUyMSxzJT02NTUyMX1yZXR1cm4gbnxzPDwxNnwwfX0se31dLDQ0OltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXtaX05PX0ZMVVNIOjAsWl9QQVJUSUFMX0ZMVVNIOjEsWl9TWU5DX0ZMVVNIOjIsWl9GVUxMX0ZMVVNIOjMsWl9GSU5JU0g6NCxaX0JMT0NLOjUsWl9UUkVFUzo2LFpfT0s6MCxaX1NUUkVBTV9FTkQ6MSxaX05FRURfRElDVDoyLFpfRVJSTk86LTEsWl9TVFJFQU1fRVJST1I6LTIsWl9EQVRBX0VSUk9SOi0zLFpfQlVGX0VSUk9SOi01LFpfTk9fQ09NUFJFU1NJT046MCxaX0JFU1RfU1BFRUQ6MSxaX0JFU1RfQ09NUFJFU1NJT046OSxaX0RFRkFVTFRfQ09NUFJFU1NJT046LTEsWl9GSUxURVJFRDoxLFpfSFVGRk1BTl9PTkxZOjIsWl9STEU6MyxaX0ZJWEVEOjQsWl9ERUZBVUxUX1NUUkFURUdZOjAsWl9CSU5BUlk6MCxaX1RFWFQ6MSxaX1VOS05PV046MixaX0RFRkxBVEVEOjh9fSx7fV0sNDU6W2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbz1mdW5jdGlvbigpe2Zvcih2YXIgdCxlPVtdLHI9MDtyPDI1NjtyKyspe3Q9cjtmb3IodmFyIGk9MDtpPDg7aSsrKXQ9MSZ0PzM5ODgyOTIzODRedD4+PjE6dD4+PjE7ZVtyXT10fXJldHVybiBlfSgpO2UuZXhwb3J0cz1mdW5jdGlvbih0LGUscixpKXt2YXIgbj1vLHM9aStyO3RePS0xO2Zvcih2YXIgYT1pO2E8czthKyspdD10Pj4+OF5uWzI1NSYodF5lW2FdKV07cmV0dXJuLTFedH19LHt9XSw0NjpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBoLGQ9dChcIi4uL3V0aWxzL2NvbW1vblwiKSx1PXQoXCIuL3RyZWVzXCIpLGM9dChcIi4vYWRsZXIzMlwiKSxwPXQoXCIuL2NyYzMyXCIpLGk9dChcIi4vbWVzc2FnZXNcIiksbD0wLGY9NCxtPTAsXz0tMixnPS0xLGI9NCxuPTIsdj04LHk9OSxzPTI4NixhPTMwLG89MTksdz0yKnMrMSxrPTE1LHg9MyxTPTI1OCx6PVMreCsxLEM9NDIsRT0xMTMsQT0xLEk9MixPPTMsQj00O2Z1bmN0aW9uIFIodCxlKXtyZXR1cm4gdC5tc2c9aVtlXSxlfWZ1bmN0aW9uIFQodCl7cmV0dXJuKHQ8PDEpLSg0PHQ/OTowKX1mdW5jdGlvbiBEKHQpe2Zvcih2YXIgZT10Lmxlbmd0aDswPD0tLWU7KXRbZV09MH1mdW5jdGlvbiBGKHQpe3ZhciBlPXQuc3RhdGUscj1lLnBlbmRpbmc7cj50LmF2YWlsX291dCYmKHI9dC5hdmFpbF9vdXQpLDAhPT1yJiYoZC5hcnJheVNldCh0Lm91dHB1dCxlLnBlbmRpbmdfYnVmLGUucGVuZGluZ19vdXQscix0Lm5leHRfb3V0KSx0Lm5leHRfb3V0Kz1yLGUucGVuZGluZ19vdXQrPXIsdC50b3RhbF9vdXQrPXIsdC5hdmFpbF9vdXQtPXIsZS5wZW5kaW5nLT1yLDA9PT1lLnBlbmRpbmcmJihlLnBlbmRpbmdfb3V0PTApKX1mdW5jdGlvbiBOKHQsZSl7dS5fdHJfZmx1c2hfYmxvY2sodCwwPD10LmJsb2NrX3N0YXJ0P3QuYmxvY2tfc3RhcnQ6LTEsdC5zdHJzdGFydC10LmJsb2NrX3N0YXJ0LGUpLHQuYmxvY2tfc3RhcnQ9dC5zdHJzdGFydCxGKHQuc3RybSl9ZnVuY3Rpb24gVSh0LGUpe3QucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPWV9ZnVuY3Rpb24gUCh0LGUpe3QucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPWU+Pj44JjI1NSx0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXT0yNTUmZX1mdW5jdGlvbiBMKHQsZSl7dmFyIHIsaSxuPXQubWF4X2NoYWluX2xlbmd0aCxzPXQuc3Ryc3RhcnQsYT10LnByZXZfbGVuZ3RoLG89dC5uaWNlX21hdGNoLGg9dC5zdHJzdGFydD50Lndfc2l6ZS16P3Quc3Ryc3RhcnQtKHQud19zaXplLXopOjAsdT10LndpbmRvdyxsPXQud19tYXNrLGY9dC5wcmV2LGQ9dC5zdHJzdGFydCtTLGM9dVtzK2EtMV0scD11W3MrYV07dC5wcmV2X2xlbmd0aD49dC5nb29kX21hdGNoJiYobj4+PTIpLG8+dC5sb29rYWhlYWQmJihvPXQubG9va2FoZWFkKTtkb3tpZih1WyhyPWUpK2FdPT09cCYmdVtyK2EtMV09PT1jJiZ1W3JdPT09dVtzXSYmdVsrK3JdPT09dVtzKzFdKXtzKz0yLHIrKztkb3t9d2hpbGUodVsrK3NdPT09dVsrK3JdJiZ1Wysrc109PT11Wysrcl0mJnVbKytzXT09PXVbKytyXSYmdVsrK3NdPT09dVsrK3JdJiZ1Wysrc109PT11Wysrcl0mJnVbKytzXT09PXVbKytyXSYmdVsrK3NdPT09dVsrK3JdJiZ1Wysrc109PT11Wysrcl0mJnM8ZCk7aWYoaT1TLShkLXMpLHM9ZC1TLGE8aSl7aWYodC5tYXRjaF9zdGFydD1lLG88PShhPWkpKWJyZWFrO2M9dVtzK2EtMV0scD11W3MrYV19fX13aGlsZSgoZT1mW2UmbF0pPmgmJjAhPS0tbik7cmV0dXJuIGE8PXQubG9va2FoZWFkP2E6dC5sb29rYWhlYWR9ZnVuY3Rpb24gaih0KXt2YXIgZSxyLGksbixzLGEsbyxoLHUsbCxmPXQud19zaXplO2Rve2lmKG49dC53aW5kb3dfc2l6ZS10Lmxvb2thaGVhZC10LnN0cnN0YXJ0LHQuc3Ryc3RhcnQ+PWYrKGYteikpe2ZvcihkLmFycmF5U2V0KHQud2luZG93LHQud2luZG93LGYsZiwwKSx0Lm1hdGNoX3N0YXJ0LT1mLHQuc3Ryc3RhcnQtPWYsdC5ibG9ja19zdGFydC09ZixlPXI9dC5oYXNoX3NpemU7aT10LmhlYWRbLS1lXSx0LmhlYWRbZV09Zjw9aT9pLWY6MCwtLXI7KTtmb3IoZT1yPWY7aT10LnByZXZbLS1lXSx0LnByZXZbZV09Zjw9aT9pLWY6MCwtLXI7KTtuKz1mfWlmKDA9PT10LnN0cm0uYXZhaWxfaW4pYnJlYWs7aWYoYT10LnN0cm0sbz10LndpbmRvdyxoPXQuc3Ryc3RhcnQrdC5sb29rYWhlYWQsdT1uLGw9dm9pZCAwLGw9YS5hdmFpbF9pbix1PGwmJihsPXUpLHI9MD09PWw/MDooYS5hdmFpbF9pbi09bCxkLmFycmF5U2V0KG8sYS5pbnB1dCxhLm5leHRfaW4sbCxoKSwxPT09YS5zdGF0ZS53cmFwP2EuYWRsZXI9YyhhLmFkbGVyLG8sbCxoKToyPT09YS5zdGF0ZS53cmFwJiYoYS5hZGxlcj1wKGEuYWRsZXIsbyxsLGgpKSxhLm5leHRfaW4rPWwsYS50b3RhbF9pbis9bCxsKSx0Lmxvb2thaGVhZCs9cix0Lmxvb2thaGVhZCt0Lmluc2VydD49eClmb3Iocz10LnN0cnN0YXJ0LXQuaW5zZXJ0LHQuaW5zX2g9dC53aW5kb3dbc10sdC5pbnNfaD0odC5pbnNfaDw8dC5oYXNoX3NoaWZ0XnQud2luZG93W3MrMV0pJnQuaGFzaF9tYXNrO3QuaW5zZXJ0JiYodC5pbnNfaD0odC5pbnNfaDw8dC5oYXNoX3NoaWZ0XnQud2luZG93W3MreC0xXSkmdC5oYXNoX21hc2ssdC5wcmV2W3MmdC53X21hc2tdPXQuaGVhZFt0Lmluc19oXSx0LmhlYWRbdC5pbnNfaF09cyxzKyssdC5pbnNlcnQtLSwhKHQubG9va2FoZWFkK3QuaW5zZXJ0PHgpKTspO313aGlsZSh0Lmxvb2thaGVhZDx6JiYwIT09dC5zdHJtLmF2YWlsX2luKX1mdW5jdGlvbiBaKHQsZSl7Zm9yKHZhciByLGk7Oyl7aWYodC5sb29rYWhlYWQ8eil7aWYoaih0KSx0Lmxvb2thaGVhZDx6JiZlPT09bClyZXR1cm4gQTtpZigwPT09dC5sb29rYWhlYWQpYnJlYWt9aWYocj0wLHQubG9va2FoZWFkPj14JiYodC5pbnNfaD0odC5pbnNfaDw8dC5oYXNoX3NoaWZ0XnQud2luZG93W3Quc3Ryc3RhcnQreC0xXSkmdC5oYXNoX21hc2sscj10LnByZXZbdC5zdHJzdGFydCZ0LndfbWFza109dC5oZWFkW3QuaW5zX2hdLHQuaGVhZFt0Lmluc19oXT10LnN0cnN0YXJ0KSwwIT09ciYmdC5zdHJzdGFydC1yPD10Lndfc2l6ZS16JiYodC5tYXRjaF9sZW5ndGg9TCh0LHIpKSx0Lm1hdGNoX2xlbmd0aD49eClpZihpPXUuX3RyX3RhbGx5KHQsdC5zdHJzdGFydC10Lm1hdGNoX3N0YXJ0LHQubWF0Y2hfbGVuZ3RoLXgpLHQubG9va2FoZWFkLT10Lm1hdGNoX2xlbmd0aCx0Lm1hdGNoX2xlbmd0aDw9dC5tYXhfbGF6eV9tYXRjaCYmdC5sb29rYWhlYWQ+PXgpe2Zvcih0Lm1hdGNoX2xlbmd0aC0tO3Quc3Ryc3RhcnQrKyx0Lmluc19oPSh0Lmluc19oPDx0Lmhhc2hfc2hpZnRedC53aW5kb3dbdC5zdHJzdGFydCt4LTFdKSZ0Lmhhc2hfbWFzayxyPXQucHJldlt0LnN0cnN0YXJ0JnQud19tYXNrXT10LmhlYWRbdC5pbnNfaF0sdC5oZWFkW3QuaW5zX2hdPXQuc3Ryc3RhcnQsMCE9LS10Lm1hdGNoX2xlbmd0aDspO3Quc3Ryc3RhcnQrK31lbHNlIHQuc3Ryc3RhcnQrPXQubWF0Y2hfbGVuZ3RoLHQubWF0Y2hfbGVuZ3RoPTAsdC5pbnNfaD10LndpbmRvd1t0LnN0cnN0YXJ0XSx0Lmluc19oPSh0Lmluc19oPDx0Lmhhc2hfc2hpZnRedC53aW5kb3dbdC5zdHJzdGFydCsxXSkmdC5oYXNoX21hc2s7ZWxzZSBpPXUuX3RyX3RhbGx5KHQsMCx0LndpbmRvd1t0LnN0cnN0YXJ0XSksdC5sb29rYWhlYWQtLSx0LnN0cnN0YXJ0Kys7aWYoaSYmKE4odCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpKXJldHVybiBBfXJldHVybiB0Lmluc2VydD10LnN0cnN0YXJ0PHgtMT90LnN0cnN0YXJ0OngtMSxlPT09Zj8oTih0LCEwKSwwPT09dC5zdHJtLmF2YWlsX291dD9POkIpOnQubGFzdF9saXQmJihOKHQsITEpLDA9PT10LnN0cm0uYXZhaWxfb3V0KT9BOkl9ZnVuY3Rpb24gVyh0LGUpe2Zvcih2YXIgcixpLG47Oyl7aWYodC5sb29rYWhlYWQ8eil7aWYoaih0KSx0Lmxvb2thaGVhZDx6JiZlPT09bClyZXR1cm4gQTtpZigwPT09dC5sb29rYWhlYWQpYnJlYWt9aWYocj0wLHQubG9va2FoZWFkPj14JiYodC5pbnNfaD0odC5pbnNfaDw8dC5oYXNoX3NoaWZ0XnQud2luZG93W3Quc3Ryc3RhcnQreC0xXSkmdC5oYXNoX21hc2sscj10LnByZXZbdC5zdHJzdGFydCZ0LndfbWFza109dC5oZWFkW3QuaW5zX2hdLHQuaGVhZFt0Lmluc19oXT10LnN0cnN0YXJ0KSx0LnByZXZfbGVuZ3RoPXQubWF0Y2hfbGVuZ3RoLHQucHJldl9tYXRjaD10Lm1hdGNoX3N0YXJ0LHQubWF0Y2hfbGVuZ3RoPXgtMSwwIT09ciYmdC5wcmV2X2xlbmd0aDx0Lm1heF9sYXp5X21hdGNoJiZ0LnN0cnN0YXJ0LXI8PXQud19zaXplLXomJih0Lm1hdGNoX2xlbmd0aD1MKHQsciksdC5tYXRjaF9sZW5ndGg8PTUmJigxPT09dC5zdHJhdGVneXx8dC5tYXRjaF9sZW5ndGg9PT14JiY0MDk2PHQuc3Ryc3RhcnQtdC5tYXRjaF9zdGFydCkmJih0Lm1hdGNoX2xlbmd0aD14LTEpKSx0LnByZXZfbGVuZ3RoPj14JiZ0Lm1hdGNoX2xlbmd0aDw9dC5wcmV2X2xlbmd0aCl7Zm9yKG49dC5zdHJzdGFydCt0Lmxvb2thaGVhZC14LGk9dS5fdHJfdGFsbHkodCx0LnN0cnN0YXJ0LTEtdC5wcmV2X21hdGNoLHQucHJldl9sZW5ndGgteCksdC5sb29rYWhlYWQtPXQucHJldl9sZW5ndGgtMSx0LnByZXZfbGVuZ3RoLT0yOysrdC5zdHJzdGFydDw9biYmKHQuaW5zX2g9KHQuaW5zX2g8PHQuaGFzaF9zaGlmdF50LndpbmRvd1t0LnN0cnN0YXJ0K3gtMV0pJnQuaGFzaF9tYXNrLHI9dC5wcmV2W3Quc3Ryc3RhcnQmdC53X21hc2tdPXQuaGVhZFt0Lmluc19oXSx0LmhlYWRbdC5pbnNfaF09dC5zdHJzdGFydCksMCE9LS10LnByZXZfbGVuZ3RoOyk7aWYodC5tYXRjaF9hdmFpbGFibGU9MCx0Lm1hdGNoX2xlbmd0aD14LTEsdC5zdHJzdGFydCsrLGkmJihOKHQsITEpLDA9PT10LnN0cm0uYXZhaWxfb3V0KSlyZXR1cm4gQX1lbHNlIGlmKHQubWF0Y2hfYXZhaWxhYmxlKXtpZigoaT11Ll90cl90YWxseSh0LDAsdC53aW5kb3dbdC5zdHJzdGFydC0xXSkpJiZOKHQsITEpLHQuc3Ryc3RhcnQrKyx0Lmxvb2thaGVhZC0tLDA9PT10LnN0cm0uYXZhaWxfb3V0KXJldHVybiBBfWVsc2UgdC5tYXRjaF9hdmFpbGFibGU9MSx0LnN0cnN0YXJ0KyssdC5sb29rYWhlYWQtLX1yZXR1cm4gdC5tYXRjaF9hdmFpbGFibGUmJihpPXUuX3RyX3RhbGx5KHQsMCx0LndpbmRvd1t0LnN0cnN0YXJ0LTFdKSx0Lm1hdGNoX2F2YWlsYWJsZT0wKSx0Lmluc2VydD10LnN0cnN0YXJ0PHgtMT90LnN0cnN0YXJ0OngtMSxlPT09Zj8oTih0LCEwKSwwPT09dC5zdHJtLmF2YWlsX291dD9POkIpOnQubGFzdF9saXQmJihOKHQsITEpLDA9PT10LnN0cm0uYXZhaWxfb3V0KT9BOkl9ZnVuY3Rpb24gTSh0LGUscixpLG4pe3RoaXMuZ29vZF9sZW5ndGg9dCx0aGlzLm1heF9sYXp5PWUsdGhpcy5uaWNlX2xlbmd0aD1yLHRoaXMubWF4X2NoYWluPWksdGhpcy5mdW5jPW59ZnVuY3Rpb24gSCgpe3RoaXMuc3RybT1udWxsLHRoaXMuc3RhdHVzPTAsdGhpcy5wZW5kaW5nX2J1Zj1udWxsLHRoaXMucGVuZGluZ19idWZfc2l6ZT0wLHRoaXMucGVuZGluZ19vdXQ9MCx0aGlzLnBlbmRpbmc9MCx0aGlzLndyYXA9MCx0aGlzLmd6aGVhZD1udWxsLHRoaXMuZ3ppbmRleD0wLHRoaXMubWV0aG9kPXYsdGhpcy5sYXN0X2ZsdXNoPS0xLHRoaXMud19zaXplPTAsdGhpcy53X2JpdHM9MCx0aGlzLndfbWFzaz0wLHRoaXMud2luZG93PW51bGwsdGhpcy53aW5kb3dfc2l6ZT0wLHRoaXMucHJldj1udWxsLHRoaXMuaGVhZD1udWxsLHRoaXMuaW5zX2g9MCx0aGlzLmhhc2hfc2l6ZT0wLHRoaXMuaGFzaF9iaXRzPTAsdGhpcy5oYXNoX21hc2s9MCx0aGlzLmhhc2hfc2hpZnQ9MCx0aGlzLmJsb2NrX3N0YXJ0PTAsdGhpcy5tYXRjaF9sZW5ndGg9MCx0aGlzLnByZXZfbWF0Y2g9MCx0aGlzLm1hdGNoX2F2YWlsYWJsZT0wLHRoaXMuc3Ryc3RhcnQ9MCx0aGlzLm1hdGNoX3N0YXJ0PTAsdGhpcy5sb29rYWhlYWQ9MCx0aGlzLnByZXZfbGVuZ3RoPTAsdGhpcy5tYXhfY2hhaW5fbGVuZ3RoPTAsdGhpcy5tYXhfbGF6eV9tYXRjaD0wLHRoaXMubGV2ZWw9MCx0aGlzLnN0cmF0ZWd5PTAsdGhpcy5nb29kX21hdGNoPTAsdGhpcy5uaWNlX21hdGNoPTAsdGhpcy5keW5fbHRyZWU9bmV3IGQuQnVmMTYoMip3KSx0aGlzLmR5bl9kdHJlZT1uZXcgZC5CdWYxNigyKigyKmErMSkpLHRoaXMuYmxfdHJlZT1uZXcgZC5CdWYxNigyKigyKm8rMSkpLEQodGhpcy5keW5fbHRyZWUpLEQodGhpcy5keW5fZHRyZWUpLEQodGhpcy5ibF90cmVlKSx0aGlzLmxfZGVzYz1udWxsLHRoaXMuZF9kZXNjPW51bGwsdGhpcy5ibF9kZXNjPW51bGwsdGhpcy5ibF9jb3VudD1uZXcgZC5CdWYxNihrKzEpLHRoaXMuaGVhcD1uZXcgZC5CdWYxNigyKnMrMSksRCh0aGlzLmhlYXApLHRoaXMuaGVhcF9sZW49MCx0aGlzLmhlYXBfbWF4PTAsdGhpcy5kZXB0aD1uZXcgZC5CdWYxNigyKnMrMSksRCh0aGlzLmRlcHRoKSx0aGlzLmxfYnVmPTAsdGhpcy5saXRfYnVmc2l6ZT0wLHRoaXMubGFzdF9saXQ9MCx0aGlzLmRfYnVmPTAsdGhpcy5vcHRfbGVuPTAsdGhpcy5zdGF0aWNfbGVuPTAsdGhpcy5tYXRjaGVzPTAsdGhpcy5pbnNlcnQ9MCx0aGlzLmJpX2J1Zj0wLHRoaXMuYmlfdmFsaWQ9MH1mdW5jdGlvbiBHKHQpe3ZhciBlO3JldHVybiB0JiZ0LnN0YXRlPyh0LnRvdGFsX2luPXQudG90YWxfb3V0PTAsdC5kYXRhX3R5cGU9biwoZT10LnN0YXRlKS5wZW5kaW5nPTAsZS5wZW5kaW5nX291dD0wLGUud3JhcDwwJiYoZS53cmFwPS1lLndyYXApLGUuc3RhdHVzPWUud3JhcD9DOkUsdC5hZGxlcj0yPT09ZS53cmFwPzA6MSxlLmxhc3RfZmx1c2g9bCx1Ll90cl9pbml0KGUpLG0pOlIodCxfKX1mdW5jdGlvbiBLKHQpe3ZhciBlPUcodCk7cmV0dXJuIGU9PT1tJiZmdW5jdGlvbih0KXt0LndpbmRvd19zaXplPTIqdC53X3NpemUsRCh0LmhlYWQpLHQubWF4X2xhenlfbWF0Y2g9aFt0LmxldmVsXS5tYXhfbGF6eSx0Lmdvb2RfbWF0Y2g9aFt0LmxldmVsXS5nb29kX2xlbmd0aCx0Lm5pY2VfbWF0Y2g9aFt0LmxldmVsXS5uaWNlX2xlbmd0aCx0Lm1heF9jaGFpbl9sZW5ndGg9aFt0LmxldmVsXS5tYXhfY2hhaW4sdC5zdHJzdGFydD0wLHQuYmxvY2tfc3RhcnQ9MCx0Lmxvb2thaGVhZD0wLHQuaW5zZXJ0PTAsdC5tYXRjaF9sZW5ndGg9dC5wcmV2X2xlbmd0aD14LTEsdC5tYXRjaF9hdmFpbGFibGU9MCx0Lmluc19oPTB9KHQuc3RhdGUpLGV9ZnVuY3Rpb24gWSh0LGUscixpLG4scyl7aWYoIXQpcmV0dXJuIF87dmFyIGE9MTtpZihlPT09ZyYmKGU9NiksaTwwPyhhPTAsaT0taSk6MTU8aSYmKGE9MixpLT0xNiksbjwxfHx5PG58fHIhPT12fHxpPDh8fDE1PGl8fGU8MHx8OTxlfHxzPDB8fGI8cylyZXR1cm4gUih0LF8pOzg9PT1pJiYoaT05KTt2YXIgbz1uZXcgSDtyZXR1cm4odC5zdGF0ZT1vKS5zdHJtPXQsby53cmFwPWEsby5nemhlYWQ9bnVsbCxvLndfYml0cz1pLG8ud19zaXplPTE8PG8ud19iaXRzLG8ud19tYXNrPW8ud19zaXplLTEsby5oYXNoX2JpdHM9bis3LG8uaGFzaF9zaXplPTE8PG8uaGFzaF9iaXRzLG8uaGFzaF9tYXNrPW8uaGFzaF9zaXplLTEsby5oYXNoX3NoaWZ0PX5+KChvLmhhc2hfYml0cyt4LTEpL3gpLG8ud2luZG93PW5ldyBkLkJ1ZjgoMipvLndfc2l6ZSksby5oZWFkPW5ldyBkLkJ1ZjE2KG8uaGFzaF9zaXplKSxvLnByZXY9bmV3IGQuQnVmMTYoby53X3NpemUpLG8ubGl0X2J1ZnNpemU9MTw8bis2LG8ucGVuZGluZ19idWZfc2l6ZT00Km8ubGl0X2J1ZnNpemUsby5wZW5kaW5nX2J1Zj1uZXcgZC5CdWY4KG8ucGVuZGluZ19idWZfc2l6ZSksby5kX2J1Zj0xKm8ubGl0X2J1ZnNpemUsby5sX2J1Zj0zKm8ubGl0X2J1ZnNpemUsby5sZXZlbD1lLG8uc3RyYXRlZ3k9cyxvLm1ldGhvZD1yLEsodCl9aD1bbmV3IE0oMCwwLDAsMCxmdW5jdGlvbih0LGUpe3ZhciByPTY1NTM1O2ZvcihyPnQucGVuZGluZ19idWZfc2l6ZS01JiYocj10LnBlbmRpbmdfYnVmX3NpemUtNSk7Oyl7aWYodC5sb29rYWhlYWQ8PTEpe2lmKGoodCksMD09PXQubG9va2FoZWFkJiZlPT09bClyZXR1cm4gQTtpZigwPT09dC5sb29rYWhlYWQpYnJlYWt9dC5zdHJzdGFydCs9dC5sb29rYWhlYWQsdC5sb29rYWhlYWQ9MDt2YXIgaT10LmJsb2NrX3N0YXJ0K3I7aWYoKDA9PT10LnN0cnN0YXJ0fHx0LnN0cnN0YXJ0Pj1pKSYmKHQubG9va2FoZWFkPXQuc3Ryc3RhcnQtaSx0LnN0cnN0YXJ0PWksTih0LCExKSwwPT09dC5zdHJtLmF2YWlsX291dCkpcmV0dXJuIEE7aWYodC5zdHJzdGFydC10LmJsb2NrX3N0YXJ0Pj10Lndfc2l6ZS16JiYoTih0LCExKSwwPT09dC5zdHJtLmF2YWlsX291dCkpcmV0dXJuIEF9cmV0dXJuIHQuaW5zZXJ0PTAsZT09PWY/KE4odCwhMCksMD09PXQuc3RybS5hdmFpbF9vdXQ/TzpCKToodC5zdHJzdGFydD50LmJsb2NrX3N0YXJ0JiYoTih0LCExKSx0LnN0cm0uYXZhaWxfb3V0KSxBKX0pLG5ldyBNKDQsNCw4LDQsWiksbmV3IE0oNCw1LDE2LDgsWiksbmV3IE0oNCw2LDMyLDMyLFopLG5ldyBNKDQsNCwxNiwxNixXKSxuZXcgTSg4LDE2LDMyLDMyLFcpLG5ldyBNKDgsMTYsMTI4LDEyOCxXKSxuZXcgTSg4LDMyLDEyOCwyNTYsVyksbmV3IE0oMzIsMTI4LDI1OCwxMDI0LFcpLG5ldyBNKDMyLDI1OCwyNTgsNDA5NixXKV0sci5kZWZsYXRlSW5pdD1mdW5jdGlvbih0LGUpe3JldHVybiBZKHQsZSx2LDE1LDgsMCl9LHIuZGVmbGF0ZUluaXQyPVksci5kZWZsYXRlUmVzZXQ9SyxyLmRlZmxhdGVSZXNldEtlZXA9RyxyLmRlZmxhdGVTZXRIZWFkZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCYmdC5zdGF0ZT8yIT09dC5zdGF0ZS53cmFwP186KHQuc3RhdGUuZ3poZWFkPWUsbSk6X30sci5kZWZsYXRlPWZ1bmN0aW9uKHQsZSl7dmFyIHIsaSxuLHM7aWYoIXR8fCF0LnN0YXRlfHw1PGV8fGU8MClyZXR1cm4gdD9SKHQsXyk6XztpZihpPXQuc3RhdGUsIXQub3V0cHV0fHwhdC5pbnB1dCYmMCE9PXQuYXZhaWxfaW58fDY2Nj09PWkuc3RhdHVzJiZlIT09ZilyZXR1cm4gUih0LDA9PT10LmF2YWlsX291dD8tNTpfKTtpZihpLnN0cm09dCxyPWkubGFzdF9mbHVzaCxpLmxhc3RfZmx1c2g9ZSxpLnN0YXR1cz09PUMpaWYoMj09PWkud3JhcCl0LmFkbGVyPTAsVShpLDMxKSxVKGksMTM5KSxVKGksOCksaS5nemhlYWQ/KFUoaSwoaS5nemhlYWQudGV4dD8xOjApKyhpLmd6aGVhZC5oY3JjPzI6MCkrKGkuZ3poZWFkLmV4dHJhPzQ6MCkrKGkuZ3poZWFkLm5hbWU/ODowKSsoaS5nemhlYWQuY29tbWVudD8xNjowKSksVShpLDI1NSZpLmd6aGVhZC50aW1lKSxVKGksaS5nemhlYWQudGltZT4+OCYyNTUpLFUoaSxpLmd6aGVhZC50aW1lPj4xNiYyNTUpLFUoaSxpLmd6aGVhZC50aW1lPj4yNCYyNTUpLFUoaSw5PT09aS5sZXZlbD8yOjI8PWkuc3RyYXRlZ3l8fGkubGV2ZWw8Mj80OjApLFUoaSwyNTUmaS5nemhlYWQub3MpLGkuZ3poZWFkLmV4dHJhJiZpLmd6aGVhZC5leHRyYS5sZW5ndGgmJihVKGksMjU1JmkuZ3poZWFkLmV4dHJhLmxlbmd0aCksVShpLGkuZ3poZWFkLmV4dHJhLmxlbmd0aD4+OCYyNTUpKSxpLmd6aGVhZC5oY3JjJiYodC5hZGxlcj1wKHQuYWRsZXIsaS5wZW5kaW5nX2J1ZixpLnBlbmRpbmcsMCkpLGkuZ3ppbmRleD0wLGkuc3RhdHVzPTY5KTooVShpLDApLFUoaSwwKSxVKGksMCksVShpLDApLFUoaSwwKSxVKGksOT09PWkubGV2ZWw/MjoyPD1pLnN0cmF0ZWd5fHxpLmxldmVsPDI/NDowKSxVKGksMyksaS5zdGF0dXM9RSk7ZWxzZXt2YXIgYT12KyhpLndfYml0cy04PDw0KTw8ODthfD0oMjw9aS5zdHJhdGVneXx8aS5sZXZlbDwyPzA6aS5sZXZlbDw2PzE6Nj09PWkubGV2ZWw/MjozKTw8NiwwIT09aS5zdHJzdGFydCYmKGF8PTMyKSxhKz0zMS1hJTMxLGkuc3RhdHVzPUUsUChpLGEpLDAhPT1pLnN0cnN0YXJ0JiYoUChpLHQuYWRsZXI+Pj4xNiksUChpLDY1NTM1JnQuYWRsZXIpKSx0LmFkbGVyPTF9aWYoNjk9PT1pLnN0YXR1cylpZihpLmd6aGVhZC5leHRyYSl7Zm9yKG49aS5wZW5kaW5nO2kuZ3ppbmRleDwoNjU1MzUmaS5nemhlYWQuZXh0cmEubGVuZ3RoKSYmKGkucGVuZGluZyE9PWkucGVuZGluZ19idWZfc2l6ZXx8KGkuZ3poZWFkLmhjcmMmJmkucGVuZGluZz5uJiYodC5hZGxlcj1wKHQuYWRsZXIsaS5wZW5kaW5nX2J1ZixpLnBlbmRpbmctbixuKSksRih0KSxuPWkucGVuZGluZyxpLnBlbmRpbmchPT1pLnBlbmRpbmdfYnVmX3NpemUpKTspVShpLDI1NSZpLmd6aGVhZC5leHRyYVtpLmd6aW5kZXhdKSxpLmd6aW5kZXgrKztpLmd6aGVhZC5oY3JjJiZpLnBlbmRpbmc+biYmKHQuYWRsZXI9cCh0LmFkbGVyLGkucGVuZGluZ19idWYsaS5wZW5kaW5nLW4sbikpLGkuZ3ppbmRleD09PWkuZ3poZWFkLmV4dHJhLmxlbmd0aCYmKGkuZ3ppbmRleD0wLGkuc3RhdHVzPTczKX1lbHNlIGkuc3RhdHVzPTczO2lmKDczPT09aS5zdGF0dXMpaWYoaS5nemhlYWQubmFtZSl7bj1pLnBlbmRpbmc7ZG97aWYoaS5wZW5kaW5nPT09aS5wZW5kaW5nX2J1Zl9zaXplJiYoaS5nemhlYWQuaGNyYyYmaS5wZW5kaW5nPm4mJih0LmFkbGVyPXAodC5hZGxlcixpLnBlbmRpbmdfYnVmLGkucGVuZGluZy1uLG4pKSxGKHQpLG49aS5wZW5kaW5nLGkucGVuZGluZz09PWkucGVuZGluZ19idWZfc2l6ZSkpe3M9MTticmVha31zPWkuZ3ppbmRleDxpLmd6aGVhZC5uYW1lLmxlbmd0aD8yNTUmaS5nemhlYWQubmFtZS5jaGFyQ29kZUF0KGkuZ3ppbmRleCsrKTowLFUoaSxzKX13aGlsZSgwIT09cyk7aS5nemhlYWQuaGNyYyYmaS5wZW5kaW5nPm4mJih0LmFkbGVyPXAodC5hZGxlcixpLnBlbmRpbmdfYnVmLGkucGVuZGluZy1uLG4pKSwwPT09cyYmKGkuZ3ppbmRleD0wLGkuc3RhdHVzPTkxKX1lbHNlIGkuc3RhdHVzPTkxO2lmKDkxPT09aS5zdGF0dXMpaWYoaS5nemhlYWQuY29tbWVudCl7bj1pLnBlbmRpbmc7ZG97aWYoaS5wZW5kaW5nPT09aS5wZW5kaW5nX2J1Zl9zaXplJiYoaS5nemhlYWQuaGNyYyYmaS5wZW5kaW5nPm4mJih0LmFkbGVyPXAodC5hZGxlcixpLnBlbmRpbmdfYnVmLGkucGVuZGluZy1uLG4pKSxGKHQpLG49aS5wZW5kaW5nLGkucGVuZGluZz09PWkucGVuZGluZ19idWZfc2l6ZSkpe3M9MTticmVha31zPWkuZ3ppbmRleDxpLmd6aGVhZC5jb21tZW50Lmxlbmd0aD8yNTUmaS5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KGkuZ3ppbmRleCsrKTowLFUoaSxzKX13aGlsZSgwIT09cyk7aS5nemhlYWQuaGNyYyYmaS5wZW5kaW5nPm4mJih0LmFkbGVyPXAodC5hZGxlcixpLnBlbmRpbmdfYnVmLGkucGVuZGluZy1uLG4pKSwwPT09cyYmKGkuc3RhdHVzPTEwMyl9ZWxzZSBpLnN0YXR1cz0xMDM7aWYoMTAzPT09aS5zdGF0dXMmJihpLmd6aGVhZC5oY3JjPyhpLnBlbmRpbmcrMj5pLnBlbmRpbmdfYnVmX3NpemUmJkYodCksaS5wZW5kaW5nKzI8PWkucGVuZGluZ19idWZfc2l6ZSYmKFUoaSwyNTUmdC5hZGxlciksVShpLHQuYWRsZXI+PjgmMjU1KSx0LmFkbGVyPTAsaS5zdGF0dXM9RSkpOmkuc3RhdHVzPUUpLDAhPT1pLnBlbmRpbmcpe2lmKEYodCksMD09PXQuYXZhaWxfb3V0KXJldHVybiBpLmxhc3RfZmx1c2g9LTEsbX1lbHNlIGlmKDA9PT10LmF2YWlsX2luJiZUKGUpPD1UKHIpJiZlIT09ZilyZXR1cm4gUih0LC01KTtpZig2NjY9PT1pLnN0YXR1cyYmMCE9PXQuYXZhaWxfaW4pcmV0dXJuIFIodCwtNSk7aWYoMCE9PXQuYXZhaWxfaW58fDAhPT1pLmxvb2thaGVhZHx8ZSE9PWwmJjY2NiE9PWkuc3RhdHVzKXt2YXIgbz0yPT09aS5zdHJhdGVneT9mdW5jdGlvbih0LGUpe2Zvcih2YXIgcjs7KXtpZigwPT09dC5sb29rYWhlYWQmJihqKHQpLDA9PT10Lmxvb2thaGVhZCkpe2lmKGU9PT1sKXJldHVybiBBO2JyZWFrfWlmKHQubWF0Y2hfbGVuZ3RoPTAscj11Ll90cl90YWxseSh0LDAsdC53aW5kb3dbdC5zdHJzdGFydF0pLHQubG9va2FoZWFkLS0sdC5zdHJzdGFydCsrLHImJihOKHQsITEpLDA9PT10LnN0cm0uYXZhaWxfb3V0KSlyZXR1cm4gQX1yZXR1cm4gdC5pbnNlcnQ9MCxlPT09Zj8oTih0LCEwKSwwPT09dC5zdHJtLmF2YWlsX291dD9POkIpOnQubGFzdF9saXQmJihOKHQsITEpLDA9PT10LnN0cm0uYXZhaWxfb3V0KT9BOkl9KGksZSk6Mz09PWkuc3RyYXRlZ3k/ZnVuY3Rpb24odCxlKXtmb3IodmFyIHIsaSxuLHMsYT10LndpbmRvdzs7KXtpZih0Lmxvb2thaGVhZDw9Uyl7aWYoaih0KSx0Lmxvb2thaGVhZDw9UyYmZT09PWwpcmV0dXJuIEE7aWYoMD09PXQubG9va2FoZWFkKWJyZWFrfWlmKHQubWF0Y2hfbGVuZ3RoPTAsdC5sb29rYWhlYWQ+PXgmJjA8dC5zdHJzdGFydCYmKGk9YVtuPXQuc3Ryc3RhcnQtMV0pPT09YVsrK25dJiZpPT09YVsrK25dJiZpPT09YVsrK25dKXtzPXQuc3Ryc3RhcnQrUztkb3t9d2hpbGUoaT09PWFbKytuXSYmaT09PWFbKytuXSYmaT09PWFbKytuXSYmaT09PWFbKytuXSYmaT09PWFbKytuXSYmaT09PWFbKytuXSYmaT09PWFbKytuXSYmaT09PWFbKytuXSYmbjxzKTt0Lm1hdGNoX2xlbmd0aD1TLShzLW4pLHQubWF0Y2hfbGVuZ3RoPnQubG9va2FoZWFkJiYodC5tYXRjaF9sZW5ndGg9dC5sb29rYWhlYWQpfWlmKHQubWF0Y2hfbGVuZ3RoPj14PyhyPXUuX3RyX3RhbGx5KHQsMSx0Lm1hdGNoX2xlbmd0aC14KSx0Lmxvb2thaGVhZC09dC5tYXRjaF9sZW5ndGgsdC5zdHJzdGFydCs9dC5tYXRjaF9sZW5ndGgsdC5tYXRjaF9sZW5ndGg9MCk6KHI9dS5fdHJfdGFsbHkodCwwLHQud2luZG93W3Quc3Ryc3RhcnRdKSx0Lmxvb2thaGVhZC0tLHQuc3Ryc3RhcnQrKyksciYmKE4odCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpKXJldHVybiBBfXJldHVybiB0Lmluc2VydD0wLGU9PT1mPyhOKHQsITApLDA9PT10LnN0cm0uYXZhaWxfb3V0P086Qik6dC5sYXN0X2xpdCYmKE4odCwhMSksMD09PXQuc3RybS5hdmFpbF9vdXQpP0E6SX0oaSxlKTpoW2kubGV2ZWxdLmZ1bmMoaSxlKTtpZihvIT09TyYmbyE9PUJ8fChpLnN0YXR1cz02NjYpLG89PT1BfHxvPT09TylyZXR1cm4gMD09PXQuYXZhaWxfb3V0JiYoaS5sYXN0X2ZsdXNoPS0xKSxtO2lmKG89PT1JJiYoMT09PWU/dS5fdHJfYWxpZ24oaSk6NSE9PWUmJih1Ll90cl9zdG9yZWRfYmxvY2soaSwwLDAsITEpLDM9PT1lJiYoRChpLmhlYWQpLDA9PT1pLmxvb2thaGVhZCYmKGkuc3Ryc3RhcnQ9MCxpLmJsb2NrX3N0YXJ0PTAsaS5pbnNlcnQ9MCkpKSxGKHQpLDA9PT10LmF2YWlsX291dCkpcmV0dXJuIGkubGFzdF9mbHVzaD0tMSxtfXJldHVybiBlIT09Zj9tOmkud3JhcDw9MD8xOigyPT09aS53cmFwPyhVKGksMjU1JnQuYWRsZXIpLFUoaSx0LmFkbGVyPj44JjI1NSksVShpLHQuYWRsZXI+PjE2JjI1NSksVShpLHQuYWRsZXI+PjI0JjI1NSksVShpLDI1NSZ0LnRvdGFsX2luKSxVKGksdC50b3RhbF9pbj4+OCYyNTUpLFUoaSx0LnRvdGFsX2luPj4xNiYyNTUpLFUoaSx0LnRvdGFsX2luPj4yNCYyNTUpKTooUChpLHQuYWRsZXI+Pj4xNiksUChpLDY1NTM1JnQuYWRsZXIpKSxGKHQpLDA8aS53cmFwJiYoaS53cmFwPS1pLndyYXApLDAhPT1pLnBlbmRpbmc/bToxKX0sci5kZWZsYXRlRW5kPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiB0JiZ0LnN0YXRlPyhlPXQuc3RhdGUuc3RhdHVzKSE9PUMmJjY5IT09ZSYmNzMhPT1lJiY5MSE9PWUmJjEwMyE9PWUmJmUhPT1FJiY2NjYhPT1lP1IodCxfKToodC5zdGF0ZT1udWxsLGU9PT1FP1IodCwtMyk6bSk6X30sci5kZWZsYXRlU2V0RGljdGlvbmFyeT1mdW5jdGlvbih0LGUpe3ZhciByLGksbixzLGEsbyxoLHUsbD1lLmxlbmd0aDtpZighdHx8IXQuc3RhdGUpcmV0dXJuIF87aWYoMj09PShzPShyPXQuc3RhdGUpLndyYXApfHwxPT09cyYmci5zdGF0dXMhPT1DfHxyLmxvb2thaGVhZClyZXR1cm4gXztmb3IoMT09PXMmJih0LmFkbGVyPWModC5hZGxlcixlLGwsMCkpLHIud3JhcD0wLGw+PXIud19zaXplJiYoMD09PXMmJihEKHIuaGVhZCksci5zdHJzdGFydD0wLHIuYmxvY2tfc3RhcnQ9MCxyLmluc2VydD0wKSx1PW5ldyBkLkJ1Zjgoci53X3NpemUpLGQuYXJyYXlTZXQodSxlLGwtci53X3NpemUsci53X3NpemUsMCksZT11LGw9ci53X3NpemUpLGE9dC5hdmFpbF9pbixvPXQubmV4dF9pbixoPXQuaW5wdXQsdC5hdmFpbF9pbj1sLHQubmV4dF9pbj0wLHQuaW5wdXQ9ZSxqKHIpO3IubG9va2FoZWFkPj14Oyl7Zm9yKGk9ci5zdHJzdGFydCxuPXIubG9va2FoZWFkLSh4LTEpO3IuaW5zX2g9KHIuaW5zX2g8PHIuaGFzaF9zaGlmdF5yLndpbmRvd1tpK3gtMV0pJnIuaGFzaF9tYXNrLHIucHJldltpJnIud19tYXNrXT1yLmhlYWRbci5pbnNfaF0sci5oZWFkW3IuaW5zX2hdPWksaSsrLC0tbjspO3Iuc3Ryc3RhcnQ9aSxyLmxvb2thaGVhZD14LTEsaihyKX1yZXR1cm4gci5zdHJzdGFydCs9ci5sb29rYWhlYWQsci5ibG9ja19zdGFydD1yLnN0cnN0YXJ0LHIuaW5zZXJ0PXIubG9va2FoZWFkLHIubG9va2FoZWFkPTAsci5tYXRjaF9sZW5ndGg9ci5wcmV2X2xlbmd0aD14LTEsci5tYXRjaF9hdmFpbGFibGU9MCx0Lm5leHRfaW49byx0LmlucHV0PWgsdC5hdmFpbF9pbj1hLHIud3JhcD1zLG19LHIuZGVmbGF0ZUluZm89XCJwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpXCJ9LHtcIi4uL3V0aWxzL2NvbW1vblwiOjQxLFwiLi9hZGxlcjMyXCI6NDMsXCIuL2NyYzMyXCI6NDUsXCIuL21lc3NhZ2VzXCI6NTEsXCIuL3RyZWVzXCI6NTJ9XSw0NzpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbigpe3RoaXMudGV4dD0wLHRoaXMudGltZT0wLHRoaXMueGZsYWdzPTAsdGhpcy5vcz0wLHRoaXMuZXh0cmE9bnVsbCx0aGlzLmV4dHJhX2xlbj0wLHRoaXMubmFtZT1cIlwiLHRoaXMuY29tbWVudD1cIlwiLHRoaXMuaGNyYz0wLHRoaXMuZG9uZT0hMX19LHt9XSw0ODpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciByLGksbixzLGEsbyxoLHUsbCxmLGQsYyxwLG0sXyxnLGIsdix5LHcsayx4LFMseixDO3I9dC5zdGF0ZSxpPXQubmV4dF9pbix6PXQuaW5wdXQsbj1pKyh0LmF2YWlsX2luLTUpLHM9dC5uZXh0X291dCxDPXQub3V0cHV0LGE9cy0oZS10LmF2YWlsX291dCksbz1zKyh0LmF2YWlsX291dC0yNTcpLGg9ci5kbWF4LHU9ci53c2l6ZSxsPXIud2hhdmUsZj1yLnduZXh0LGQ9ci53aW5kb3csYz1yLmhvbGQscD1yLmJpdHMsbT1yLmxlbmNvZGUsXz1yLmRpc3Rjb2RlLGc9KDE8PHIubGVuYml0cyktMSxiPSgxPDxyLmRpc3RiaXRzKS0xO3Q6ZG97cDwxNSYmKGMrPXpbaSsrXTw8cCxwKz04LGMrPXpbaSsrXTw8cCxwKz04KSx2PW1bYyZnXTtlOmZvcig7Oyl7aWYoYz4+Pj15PXY+Pj4yNCxwLT15LDA9PT0oeT12Pj4+MTYmMjU1KSlDW3MrK109NjU1MzUmdjtlbHNle2lmKCEoMTYmeSkpe2lmKDA9PSg2NCZ5KSl7dj1tWyg2NTUzNSZ2KSsoYyYoMTw8eSktMSldO2NvbnRpbnVlIGV9aWYoMzImeSl7ci5tb2RlPTEyO2JyZWFrIHR9dC5tc2c9XCJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGVcIixyLm1vZGU9MzA7YnJlYWsgdH13PTY1NTM1JnYsKHkmPTE1KSYmKHA8eSYmKGMrPXpbaSsrXTw8cCxwKz04KSx3Kz1jJigxPDx5KS0xLGM+Pj49eSxwLT15KSxwPDE1JiYoYys9eltpKytdPDxwLHArPTgsYys9eltpKytdPDxwLHArPTgpLHY9X1tjJmJdO3I6Zm9yKDs7KXtpZihjPj4+PXk9dj4+PjI0LHAtPXksISgxNiYoeT12Pj4+MTYmMjU1KSkpe2lmKDA9PSg2NCZ5KSl7dj1fWyg2NTUzNSZ2KSsoYyYoMTw8eSktMSldO2NvbnRpbnVlIHJ9dC5tc2c9XCJpbnZhbGlkIGRpc3RhbmNlIGNvZGVcIixyLm1vZGU9MzA7YnJlYWsgdH1pZihrPTY1NTM1JnYscDwoeSY9MTUpJiYoYys9eltpKytdPDxwLChwKz04KTx5JiYoYys9eltpKytdPDxwLHArPTgpKSxoPChrKz1jJigxPDx5KS0xKSl7dC5tc2c9XCJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFja1wiLHIubW9kZT0zMDticmVhayB0fWlmKGM+Pj49eSxwLT15LCh5PXMtYSk8ayl7aWYobDwoeT1rLXkpJiZyLnNhbmUpe3QubXNnPVwiaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2tcIixyLm1vZGU9MzA7YnJlYWsgdH1pZihTPWQsKHg9MCk9PT1mKXtpZih4Kz11LXkseTx3KXtmb3Iody09eTtDW3MrK109ZFt4KytdLC0teTspO3g9cy1rLFM9Q319ZWxzZSBpZihmPHkpe2lmKHgrPXUrZi15LCh5LT1mKTx3KXtmb3Iody09eTtDW3MrK109ZFt4KytdLC0teTspO2lmKHg9MCxmPHcpe2Zvcih3LT15PWY7Q1tzKytdPWRbeCsrXSwtLXk7KTt4PXMtayxTPUN9fX1lbHNlIGlmKHgrPWYteSx5PHcpe2Zvcih3LT15O0NbcysrXT1kW3grK10sLS15Oyk7eD1zLWssUz1DfWZvcig7Mjx3OylDW3MrK109U1t4KytdLENbcysrXT1TW3grK10sQ1tzKytdPVNbeCsrXSx3LT0zO3cmJihDW3MrK109U1t4KytdLDE8dyYmKENbcysrXT1TW3grK10pKX1lbHNle2Zvcih4PXMtaztDW3MrK109Q1t4KytdLENbcysrXT1DW3grK10sQ1tzKytdPUNbeCsrXSwyPCh3LT0zKTspO3cmJihDW3MrK109Q1t4KytdLDE8dyYmKENbcysrXT1DW3grK10pKX1icmVha319YnJlYWt9fXdoaWxlKGk8biYmczxvKTtpLT13PXA+PjMsYyY9KDE8PChwLT13PDwzKSktMSx0Lm5leHRfaW49aSx0Lm5leHRfb3V0PXMsdC5hdmFpbF9pbj1pPG4/bi1pKzU6NS0oaS1uKSx0LmF2YWlsX291dD1zPG8/by1zKzI1NzoyNTctKHMtbyksci5ob2xkPWMsci5iaXRzPXB9fSx7fV0sNDk6W2Z1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgST10KFwiLi4vdXRpbHMvY29tbW9uXCIpLE89dChcIi4vYWRsZXIzMlwiKSxCPXQoXCIuL2NyYzMyXCIpLFI9dChcIi4vaW5mZmFzdFwiKSxUPXQoXCIuL2luZnRyZWVzXCIpLEQ9MSxGPTIsTj0wLFU9LTIsUD0xLGk9ODUyLG49NTkyO2Z1bmN0aW9uIEwodCl7cmV0dXJuKHQ+Pj4yNCYyNTUpKyh0Pj4+OCY2NTI4MCkrKCg2NTI4MCZ0KTw8OCkrKCgyNTUmdCk8PDI0KX1mdW5jdGlvbiBzKCl7dGhpcy5tb2RlPTAsdGhpcy5sYXN0PSExLHRoaXMud3JhcD0wLHRoaXMuaGF2ZWRpY3Q9ITEsdGhpcy5mbGFncz0wLHRoaXMuZG1heD0wLHRoaXMuY2hlY2s9MCx0aGlzLnRvdGFsPTAsdGhpcy5oZWFkPW51bGwsdGhpcy53Yml0cz0wLHRoaXMud3NpemU9MCx0aGlzLndoYXZlPTAsdGhpcy53bmV4dD0wLHRoaXMud2luZG93PW51bGwsdGhpcy5ob2xkPTAsdGhpcy5iaXRzPTAsdGhpcy5sZW5ndGg9MCx0aGlzLm9mZnNldD0wLHRoaXMuZXh0cmE9MCx0aGlzLmxlbmNvZGU9bnVsbCx0aGlzLmRpc3Rjb2RlPW51bGwsdGhpcy5sZW5iaXRzPTAsdGhpcy5kaXN0Yml0cz0wLHRoaXMubmNvZGU9MCx0aGlzLm5sZW49MCx0aGlzLm5kaXN0PTAsdGhpcy5oYXZlPTAsdGhpcy5uZXh0PW51bGwsdGhpcy5sZW5zPW5ldyBJLkJ1ZjE2KDMyMCksdGhpcy53b3JrPW5ldyBJLkJ1ZjE2KDI4OCksdGhpcy5sZW5keW49bnVsbCx0aGlzLmRpc3RkeW49bnVsbCx0aGlzLnNhbmU9MCx0aGlzLmJhY2s9MCx0aGlzLndhcz0wfWZ1bmN0aW9uIGEodCl7dmFyIGU7cmV0dXJuIHQmJnQuc3RhdGU/KGU9dC5zdGF0ZSx0LnRvdGFsX2luPXQudG90YWxfb3V0PWUudG90YWw9MCx0Lm1zZz1cIlwiLGUud3JhcCYmKHQuYWRsZXI9MSZlLndyYXApLGUubW9kZT1QLGUubGFzdD0wLGUuaGF2ZWRpY3Q9MCxlLmRtYXg9MzI3NjgsZS5oZWFkPW51bGwsZS5ob2xkPTAsZS5iaXRzPTAsZS5sZW5jb2RlPWUubGVuZHluPW5ldyBJLkJ1ZjMyKGkpLGUuZGlzdGNvZGU9ZS5kaXN0ZHluPW5ldyBJLkJ1ZjMyKG4pLGUuc2FuZT0xLGUuYmFjaz0tMSxOKTpVfWZ1bmN0aW9uIG8odCl7dmFyIGU7cmV0dXJuIHQmJnQuc3RhdGU/KChlPXQuc3RhdGUpLndzaXplPTAsZS53aGF2ZT0wLGUud25leHQ9MCxhKHQpKTpVfWZ1bmN0aW9uIGgodCxlKXt2YXIgcixpO3JldHVybiB0JiZ0LnN0YXRlPyhpPXQuc3RhdGUsZTwwPyhyPTAsZT0tZSk6KHI9MSsoZT4+NCksZTw0OCYmKGUmPTE1KSksZSYmKGU8OHx8MTU8ZSk/VToobnVsbCE9PWkud2luZG93JiZpLndiaXRzIT09ZSYmKGkud2luZG93PW51bGwpLGkud3JhcD1yLGkud2JpdHM9ZSxvKHQpKSk6VX1mdW5jdGlvbiB1KHQsZSl7dmFyIHIsaTtyZXR1cm4gdD8oaT1uZXcgcywodC5zdGF0ZT1pKS53aW5kb3c9bnVsbCwocj1oKHQsZSkpIT09TiYmKHQuc3RhdGU9bnVsbCkscik6VX12YXIgbCxmLGQ9ITA7ZnVuY3Rpb24gaih0KXtpZihkKXt2YXIgZTtmb3IobD1uZXcgSS5CdWYzMig1MTIpLGY9bmV3IEkuQnVmMzIoMzIpLGU9MDtlPDE0NDspdC5sZW5zW2UrK109ODtmb3IoO2U8MjU2Oyl0LmxlbnNbZSsrXT05O2Zvcig7ZTwyODA7KXQubGVuc1tlKytdPTc7Zm9yKDtlPDI4ODspdC5sZW5zW2UrK109ODtmb3IoVChELHQubGVucywwLDI4OCxsLDAsdC53b3JrLHtiaXRzOjl9KSxlPTA7ZTwzMjspdC5sZW5zW2UrK109NTtUKEYsdC5sZW5zLDAsMzIsZiwwLHQud29yayx7Yml0czo1fSksZD0hMX10LmxlbmNvZGU9bCx0LmxlbmJpdHM9OSx0LmRpc3Rjb2RlPWYsdC5kaXN0Yml0cz01fWZ1bmN0aW9uIFoodCxlLHIsaSl7dmFyIG4scz10LnN0YXRlO3JldHVybiBudWxsPT09cy53aW5kb3cmJihzLndzaXplPTE8PHMud2JpdHMscy53bmV4dD0wLHMud2hhdmU9MCxzLndpbmRvdz1uZXcgSS5CdWY4KHMud3NpemUpKSxpPj1zLndzaXplPyhJLmFycmF5U2V0KHMud2luZG93LGUsci1zLndzaXplLHMud3NpemUsMCkscy53bmV4dD0wLHMud2hhdmU9cy53c2l6ZSk6KGk8KG49cy53c2l6ZS1zLnduZXh0KSYmKG49aSksSS5hcnJheVNldChzLndpbmRvdyxlLHItaSxuLHMud25leHQpLChpLT1uKT8oSS5hcnJheVNldChzLndpbmRvdyxlLHItaSxpLDApLHMud25leHQ9aSxzLndoYXZlPXMud3NpemUpOihzLnduZXh0Kz1uLHMud25leHQ9PT1zLndzaXplJiYocy53bmV4dD0wKSxzLndoYXZlPHMud3NpemUmJihzLndoYXZlKz1uKSkpLDB9ci5pbmZsYXRlUmVzZXQ9byxyLmluZmxhdGVSZXNldDI9aCxyLmluZmxhdGVSZXNldEtlZXA9YSxyLmluZmxhdGVJbml0PWZ1bmN0aW9uKHQpe3JldHVybiB1KHQsMTUpfSxyLmluZmxhdGVJbml0Mj11LHIuaW5mbGF0ZT1mdW5jdGlvbih0LGUpe3ZhciByLGksbixzLGEsbyxoLHUsbCxmLGQsYyxwLG0sXyxnLGIsdix5LHcsayx4LFMseixDPTAsRT1uZXcgSS5CdWY4KDQpLEE9WzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdO2lmKCF0fHwhdC5zdGF0ZXx8IXQub3V0cHV0fHwhdC5pbnB1dCYmMCE9PXQuYXZhaWxfaW4pcmV0dXJuIFU7MTI9PT0ocj10LnN0YXRlKS5tb2RlJiYoci5tb2RlPTEzKSxhPXQubmV4dF9vdXQsbj10Lm91dHB1dCxoPXQuYXZhaWxfb3V0LHM9dC5uZXh0X2luLGk9dC5pbnB1dCxvPXQuYXZhaWxfaW4sdT1yLmhvbGQsbD1yLmJpdHMsZj1vLGQ9aCx4PU47dDpmb3IoOzspc3dpdGNoKHIubW9kZSl7Y2FzZSBQOmlmKDA9PT1yLndyYXApe3IubW9kZT0xMzticmVha31mb3IoO2w8MTY7KXtpZigwPT09bylicmVhayB0O28tLSx1Kz1pW3MrK108PGwsbCs9OH1pZigyJnIud3JhcCYmMzU2MTU9PT11KXtFW3IuY2hlY2s9MF09MjU1JnUsRVsxXT11Pj4+OCYyNTUsci5jaGVjaz1CKHIuY2hlY2ssRSwyLDApLGw9dT0wLHIubW9kZT0yO2JyZWFrfWlmKHIuZmxhZ3M9MCxyLmhlYWQmJihyLmhlYWQuZG9uZT0hMSksISgxJnIud3JhcCl8fCgoKDI1NSZ1KTw8OCkrKHU+PjgpKSUzMSl7dC5tc2c9XCJpbmNvcnJlY3QgaGVhZGVyIGNoZWNrXCIsci5tb2RlPTMwO2JyZWFrfWlmKDghPSgxNSZ1KSl7dC5tc2c9XCJ1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZFwiLHIubW9kZT0zMDticmVha31pZihsLT00LGs9OCsoMTUmKHU+Pj49NCkpLDA9PT1yLndiaXRzKXIud2JpdHM9aztlbHNlIGlmKGs+ci53Yml0cyl7dC5tc2c9XCJpbnZhbGlkIHdpbmRvdyBzaXplXCIsci5tb2RlPTMwO2JyZWFrfXIuZG1heD0xPDxrLHQuYWRsZXI9ci5jaGVjaz0xLHIubW9kZT01MTImdT8xMDoxMixsPXU9MDticmVhaztjYXNlIDI6Zm9yKDtsPDE2Oyl7aWYoMD09PW8pYnJlYWsgdDtvLS0sdSs9aVtzKytdPDxsLGwrPTh9aWYoci5mbGFncz11LDghPSgyNTUmci5mbGFncykpe3QubXNnPVwidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2RcIixyLm1vZGU9MzA7YnJlYWt9aWYoNTczNDQmci5mbGFncyl7dC5tc2c9XCJ1bmtub3duIGhlYWRlciBmbGFncyBzZXRcIixyLm1vZGU9MzA7YnJlYWt9ci5oZWFkJiYoci5oZWFkLnRleHQ9dT4+OCYxKSw1MTImci5mbGFncyYmKEVbMF09MjU1JnUsRVsxXT11Pj4+OCYyNTUsci5jaGVjaz1CKHIuY2hlY2ssRSwyLDApKSxsPXU9MCxyLm1vZGU9MztjYXNlIDM6Zm9yKDtsPDMyOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0sdSs9aVtzKytdPDxsLGwrPTh9ci5oZWFkJiYoci5oZWFkLnRpbWU9dSksNTEyJnIuZmxhZ3MmJihFWzBdPTI1NSZ1LEVbMV09dT4+PjgmMjU1LEVbMl09dT4+PjE2JjI1NSxFWzNdPXU+Pj4yNCYyNTUsci5jaGVjaz1CKHIuY2hlY2ssRSw0LDApKSxsPXU9MCxyLm1vZGU9NDtjYXNlIDQ6Zm9yKDtsPDE2Oyl7aWYoMD09PW8pYnJlYWsgdDtvLS0sdSs9aVtzKytdPDxsLGwrPTh9ci5oZWFkJiYoci5oZWFkLnhmbGFncz0yNTUmdSxyLmhlYWQub3M9dT4+OCksNTEyJnIuZmxhZ3MmJihFWzBdPTI1NSZ1LEVbMV09dT4+PjgmMjU1LHIuY2hlY2s9QihyLmNoZWNrLEUsMiwwKSksbD11PTAsci5tb2RlPTU7Y2FzZSA1OmlmKDEwMjQmci5mbGFncyl7Zm9yKDtsPDE2Oyl7aWYoMD09PW8pYnJlYWsgdDtvLS0sdSs9aVtzKytdPDxsLGwrPTh9ci5sZW5ndGg9dSxyLmhlYWQmJihyLmhlYWQuZXh0cmFfbGVuPXUpLDUxMiZyLmZsYWdzJiYoRVswXT0yNTUmdSxFWzFdPXU+Pj44JjI1NSxyLmNoZWNrPUIoci5jaGVjayxFLDIsMCkpLGw9dT0wfWVsc2Ugci5oZWFkJiYoci5oZWFkLmV4dHJhPW51bGwpO3IubW9kZT02O2Nhc2UgNjppZigxMDI0JnIuZmxhZ3MmJihvPChjPXIubGVuZ3RoKSYmKGM9byksYyYmKHIuaGVhZCYmKGs9ci5oZWFkLmV4dHJhX2xlbi1yLmxlbmd0aCxyLmhlYWQuZXh0cmF8fChyLmhlYWQuZXh0cmE9bmV3IEFycmF5KHIuaGVhZC5leHRyYV9sZW4pKSxJLmFycmF5U2V0KHIuaGVhZC5leHRyYSxpLHMsYyxrKSksNTEyJnIuZmxhZ3MmJihyLmNoZWNrPUIoci5jaGVjayxpLGMscykpLG8tPWMscys9YyxyLmxlbmd0aC09Yyksci5sZW5ndGgpKWJyZWFrIHQ7ci5sZW5ndGg9MCxyLm1vZGU9NztjYXNlIDc6aWYoMjA0OCZyLmZsYWdzKXtpZigwPT09bylicmVhayB0O2ZvcihjPTA7az1pW3MrYysrXSxyLmhlYWQmJmsmJnIubGVuZ3RoPDY1NTM2JiYoci5oZWFkLm5hbWUrPVN0cmluZy5mcm9tQ2hhckNvZGUoaykpLGsmJmM8bzspO2lmKDUxMiZyLmZsYWdzJiYoci5jaGVjaz1CKHIuY2hlY2ssaSxjLHMpKSxvLT1jLHMrPWMsaylicmVhayB0fWVsc2Ugci5oZWFkJiYoci5oZWFkLm5hbWU9bnVsbCk7ci5sZW5ndGg9MCxyLm1vZGU9ODtjYXNlIDg6aWYoNDA5NiZyLmZsYWdzKXtpZigwPT09bylicmVhayB0O2ZvcihjPTA7az1pW3MrYysrXSxyLmhlYWQmJmsmJnIubGVuZ3RoPDY1NTM2JiYoci5oZWFkLmNvbW1lbnQrPVN0cmluZy5mcm9tQ2hhckNvZGUoaykpLGsmJmM8bzspO2lmKDUxMiZyLmZsYWdzJiYoci5jaGVjaz1CKHIuY2hlY2ssaSxjLHMpKSxvLT1jLHMrPWMsaylicmVhayB0fWVsc2Ugci5oZWFkJiYoci5oZWFkLmNvbW1lbnQ9bnVsbCk7ci5tb2RlPTk7Y2FzZSA5OmlmKDUxMiZyLmZsYWdzKXtmb3IoO2w8MTY7KXtpZigwPT09bylicmVhayB0O28tLSx1Kz1pW3MrK108PGwsbCs9OH1pZih1IT09KDY1NTM1JnIuY2hlY2spKXt0Lm1zZz1cImhlYWRlciBjcmMgbWlzbWF0Y2hcIixyLm1vZGU9MzA7YnJlYWt9bD11PTB9ci5oZWFkJiYoci5oZWFkLmhjcmM9ci5mbGFncz4+OSYxLHIuaGVhZC5kb25lPSEwKSx0LmFkbGVyPXIuY2hlY2s9MCxyLm1vZGU9MTI7YnJlYWs7Y2FzZSAxMDpmb3IoO2w8MzI7KXtpZigwPT09bylicmVhayB0O28tLSx1Kz1pW3MrK108PGwsbCs9OH10LmFkbGVyPXIuY2hlY2s9TCh1KSxsPXU9MCxyLm1vZGU9MTE7Y2FzZSAxMTppZigwPT09ci5oYXZlZGljdClyZXR1cm4gdC5uZXh0X291dD1hLHQuYXZhaWxfb3V0PWgsdC5uZXh0X2luPXMsdC5hdmFpbF9pbj1vLHIuaG9sZD11LHIuYml0cz1sLDI7dC5hZGxlcj1yLmNoZWNrPTEsci5tb2RlPTEyO2Nhc2UgMTI6aWYoNT09PWV8fDY9PT1lKWJyZWFrIHQ7Y2FzZSAxMzppZihyLmxhc3Qpe3U+Pj49NyZsLGwtPTcmbCxyLm1vZGU9Mjc7YnJlYWt9Zm9yKDtsPDM7KXtpZigwPT09bylicmVhayB0O28tLSx1Kz1pW3MrK108PGwsbCs9OH1zd2l0Y2goci5sYXN0PTEmdSxsLT0xLDMmKHU+Pj49MSkpe2Nhc2UgMDpyLm1vZGU9MTQ7YnJlYWs7Y2FzZSAxOmlmKGoociksci5tb2RlPTIwLDYhPT1lKWJyZWFrO3U+Pj49MixsLT0yO2JyZWFrIHQ7Y2FzZSAyOnIubW9kZT0xNzticmVhaztjYXNlIDM6dC5tc2c9XCJpbnZhbGlkIGJsb2NrIHR5cGVcIixyLm1vZGU9MzB9dT4+Pj0yLGwtPTI7YnJlYWs7Y2FzZSAxNDpmb3IodT4+Pj03JmwsbC09NyZsO2w8MzI7KXtpZigwPT09bylicmVhayB0O28tLSx1Kz1pW3MrK108PGwsbCs9OH1pZigoNjU1MzUmdSkhPSh1Pj4+MTZeNjU1MzUpKXt0Lm1zZz1cImludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHNcIixyLm1vZGU9MzA7YnJlYWt9aWYoci5sZW5ndGg9NjU1MzUmdSxsPXU9MCxyLm1vZGU9MTUsNj09PWUpYnJlYWsgdDtjYXNlIDE1OnIubW9kZT0xNjtjYXNlIDE2OmlmKGM9ci5sZW5ndGgpe2lmKG88YyYmKGM9byksaDxjJiYoYz1oKSwwPT09YylicmVhayB0O0kuYXJyYXlTZXQobixpLHMsYyxhKSxvLT1jLHMrPWMsaC09YyxhKz1jLHIubGVuZ3RoLT1jO2JyZWFrfXIubW9kZT0xMjticmVhaztjYXNlIDE3OmZvcig7bDwxNDspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLHUrPWlbcysrXTw8bCxsKz04fWlmKHIubmxlbj0yNTcrKDMxJnUpLHU+Pj49NSxsLT01LHIubmRpc3Q9MSsoMzEmdSksdT4+Pj01LGwtPTUsci5uY29kZT00KygxNSZ1KSx1Pj4+PTQsbC09NCwyODY8ci5ubGVufHwzMDxyLm5kaXN0KXt0Lm1zZz1cInRvbyBtYW55IGxlbmd0aCBvciBkaXN0YW5jZSBzeW1ib2xzXCIsci5tb2RlPTMwO2JyZWFrfXIuaGF2ZT0wLHIubW9kZT0xODtjYXNlIDE4OmZvcig7ci5oYXZlPHIubmNvZGU7KXtmb3IoO2w8Mzspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLHUrPWlbcysrXTw8bCxsKz04fXIubGVuc1tBW3IuaGF2ZSsrXV09NyZ1LHU+Pj49MyxsLT0zfWZvcig7ci5oYXZlPDE5OylyLmxlbnNbQVtyLmhhdmUrK11dPTA7aWYoci5sZW5jb2RlPXIubGVuZHluLHIubGVuYml0cz03LFM9e2JpdHM6ci5sZW5iaXRzfSx4PVQoMCxyLmxlbnMsMCwxOSxyLmxlbmNvZGUsMCxyLndvcmssUyksci5sZW5iaXRzPVMuYml0cyx4KXt0Lm1zZz1cImludmFsaWQgY29kZSBsZW5ndGhzIHNldFwiLHIubW9kZT0zMDticmVha31yLmhhdmU9MCxyLm1vZGU9MTk7Y2FzZSAxOTpmb3IoO3IuaGF2ZTxyLm5sZW4rci5uZGlzdDspe2Zvcig7Zz0oQz1yLmxlbmNvZGVbdSYoMTw8ci5sZW5iaXRzKS0xXSk+Pj4xNiYyNTUsYj02NTUzNSZDLCEoKF89Qz4+PjI0KTw9bCk7KXtpZigwPT09bylicmVhayB0O28tLSx1Kz1pW3MrK108PGwsbCs9OH1pZihiPDE2KXU+Pj49XyxsLT1fLHIubGVuc1tyLmhhdmUrK109YjtlbHNle2lmKDE2PT09Yil7Zm9yKHo9XysyO2w8ejspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLHUrPWlbcysrXTw8bCxsKz04fWlmKHU+Pj49XyxsLT1fLDA9PT1yLmhhdmUpe3QubXNnPVwiaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdFwiLHIubW9kZT0zMDticmVha31rPXIubGVuc1tyLmhhdmUtMV0sYz0zKygzJnUpLHU+Pj49MixsLT0yfWVsc2UgaWYoMTc9PT1iKXtmb3Ioej1fKzM7bDx6Oyl7aWYoMD09PW8pYnJlYWsgdDtvLS0sdSs9aVtzKytdPDxsLGwrPTh9bC09XyxrPTAsYz0zKyg3Jih1Pj4+PV8pKSx1Pj4+PTMsbC09M31lbHNle2Zvcih6PV8rNztsPHo7KXtpZigwPT09bylicmVhayB0O28tLSx1Kz1pW3MrK108PGwsbCs9OH1sLT1fLGs9MCxjPTExKygxMjcmKHU+Pj49XykpLHU+Pj49NyxsLT03fWlmKHIuaGF2ZStjPnIubmxlbityLm5kaXN0KXt0Lm1zZz1cImludmFsaWQgYml0IGxlbmd0aCByZXBlYXRcIixyLm1vZGU9MzA7YnJlYWt9Zm9yKDtjLS07KXIubGVuc1tyLmhhdmUrK109a319aWYoMzA9PT1yLm1vZGUpYnJlYWs7aWYoMD09PXIubGVuc1syNTZdKXt0Lm1zZz1cImludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9ja1wiLHIubW9kZT0zMDticmVha31pZihyLmxlbmJpdHM9OSxTPXtiaXRzOnIubGVuYml0c30seD1UKEQsci5sZW5zLDAsci5ubGVuLHIubGVuY29kZSwwLHIud29yayxTKSxyLmxlbmJpdHM9Uy5iaXRzLHgpe3QubXNnPVwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0XCIsci5tb2RlPTMwO2JyZWFrfWlmKHIuZGlzdGJpdHM9NixyLmRpc3Rjb2RlPXIuZGlzdGR5bixTPXtiaXRzOnIuZGlzdGJpdHN9LHg9VChGLHIubGVucyxyLm5sZW4sci5uZGlzdCxyLmRpc3Rjb2RlLDAsci53b3JrLFMpLHIuZGlzdGJpdHM9Uy5iaXRzLHgpe3QubXNnPVwiaW52YWxpZCBkaXN0YW5jZXMgc2V0XCIsci5tb2RlPTMwO2JyZWFrfWlmKHIubW9kZT0yMCw2PT09ZSlicmVhayB0O2Nhc2UgMjA6ci5tb2RlPTIxO2Nhc2UgMjE6aWYoNjw9byYmMjU4PD1oKXt0Lm5leHRfb3V0PWEsdC5hdmFpbF9vdXQ9aCx0Lm5leHRfaW49cyx0LmF2YWlsX2luPW8sci5ob2xkPXUsci5iaXRzPWwsUih0LGQpLGE9dC5uZXh0X291dCxuPXQub3V0cHV0LGg9dC5hdmFpbF9vdXQscz10Lm5leHRfaW4saT10LmlucHV0LG89dC5hdmFpbF9pbix1PXIuaG9sZCxsPXIuYml0cywxMj09PXIubW9kZSYmKHIuYmFjaz0tMSk7YnJlYWt9Zm9yKHIuYmFjaz0wO2c9KEM9ci5sZW5jb2RlW3UmKDE8PHIubGVuYml0cyktMV0pPj4+MTYmMjU1LGI9NjU1MzUmQywhKChfPUM+Pj4yNCk8PWwpOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0sdSs9aVtzKytdPDxsLGwrPTh9aWYoZyYmMD09KDI0MCZnKSl7Zm9yKHY9Xyx5PWcsdz1iO2c9KEM9ci5sZW5jb2RlW3crKCh1JigxPDx2K3kpLTEpPj52KV0pPj4+MTYmMjU1LGI9NjU1MzUmQywhKHYrKF89Qz4+PjI0KTw9bCk7KXtpZigwPT09bylicmVhayB0O28tLSx1Kz1pW3MrK108PGwsbCs9OH11Pj4+PXYsbC09dixyLmJhY2srPXZ9aWYodT4+Pj1fLGwtPV8sci5iYWNrKz1fLHIubGVuZ3RoPWIsMD09PWcpe3IubW9kZT0yNjticmVha31pZigzMiZnKXtyLmJhY2s9LTEsci5tb2RlPTEyO2JyZWFrfWlmKDY0Jmcpe3QubXNnPVwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXCIsci5tb2RlPTMwO2JyZWFrfXIuZXh0cmE9MTUmZyxyLm1vZGU9MjI7Y2FzZSAyMjppZihyLmV4dHJhKXtmb3Ioej1yLmV4dHJhO2w8ejspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLHUrPWlbcysrXTw8bCxsKz04fXIubGVuZ3RoKz11JigxPDxyLmV4dHJhKS0xLHU+Pj49ci5leHRyYSxsLT1yLmV4dHJhLHIuYmFjays9ci5leHRyYX1yLndhcz1yLmxlbmd0aCxyLm1vZGU9MjM7Y2FzZSAyMzpmb3IoO2c9KEM9ci5kaXN0Y29kZVt1JigxPDxyLmRpc3RiaXRzKS0xXSk+Pj4xNiYyNTUsYj02NTUzNSZDLCEoKF89Qz4+PjI0KTw9bCk7KXtpZigwPT09bylicmVhayB0O28tLSx1Kz1pW3MrK108PGwsbCs9OH1pZigwPT0oMjQwJmcpKXtmb3Iodj1fLHk9Zyx3PWI7Zz0oQz1yLmRpc3Rjb2RlW3crKCh1JigxPDx2K3kpLTEpPj52KV0pPj4+MTYmMjU1LGI9NjU1MzUmQywhKHYrKF89Qz4+PjI0KTw9bCk7KXtpZigwPT09bylicmVhayB0O28tLSx1Kz1pW3MrK108PGwsbCs9OH11Pj4+PXYsbC09dixyLmJhY2srPXZ9aWYodT4+Pj1fLGwtPV8sci5iYWNrKz1fLDY0Jmcpe3QubXNnPVwiaW52YWxpZCBkaXN0YW5jZSBjb2RlXCIsci5tb2RlPTMwO2JyZWFrfXIub2Zmc2V0PWIsci5leHRyYT0xNSZnLHIubW9kZT0yNDtjYXNlIDI0OmlmKHIuZXh0cmEpe2Zvcih6PXIuZXh0cmE7bDx6Oyl7aWYoMD09PW8pYnJlYWsgdDtvLS0sdSs9aVtzKytdPDxsLGwrPTh9ci5vZmZzZXQrPXUmKDE8PHIuZXh0cmEpLTEsdT4+Pj1yLmV4dHJhLGwtPXIuZXh0cmEsci5iYWNrKz1yLmV4dHJhfWlmKHIub2Zmc2V0PnIuZG1heCl7dC5tc2c9XCJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFja1wiLHIubW9kZT0zMDticmVha31yLm1vZGU9MjU7Y2FzZSAyNTppZigwPT09aClicmVhayB0O2lmKGM9ZC1oLHIub2Zmc2V0PmMpe2lmKChjPXIub2Zmc2V0LWMpPnIud2hhdmUmJnIuc2FuZSl7dC5tc2c9XCJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFja1wiLHIubW9kZT0zMDticmVha31wPWM+ci53bmV4dD8oYy09ci53bmV4dCxyLndzaXplLWMpOnIud25leHQtYyxjPnIubGVuZ3RoJiYoYz1yLmxlbmd0aCksbT1yLndpbmRvd31lbHNlIG09bixwPWEtci5vZmZzZXQsYz1yLmxlbmd0aDtmb3IoaDxjJiYoYz1oKSxoLT1jLHIubGVuZ3RoLT1jO25bYSsrXT1tW3ArK10sLS1jOyk7MD09PXIubGVuZ3RoJiYoci5tb2RlPTIxKTticmVhaztjYXNlIDI2OmlmKDA9PT1oKWJyZWFrIHQ7blthKytdPXIubGVuZ3RoLGgtLSxyLm1vZGU9MjE7YnJlYWs7Y2FzZSAyNzppZihyLndyYXApe2Zvcig7bDwzMjspe2lmKDA9PT1vKWJyZWFrIHQ7by0tLHV8PWlbcysrXTw8bCxsKz04fWlmKGQtPWgsdC50b3RhbF9vdXQrPWQsci50b3RhbCs9ZCxkJiYodC5hZGxlcj1yLmNoZWNrPXIuZmxhZ3M/QihyLmNoZWNrLG4sZCxhLWQpOk8oci5jaGVjayxuLGQsYS1kKSksZD1oLChyLmZsYWdzP3U6TCh1KSkhPT1yLmNoZWNrKXt0Lm1zZz1cImluY29ycmVjdCBkYXRhIGNoZWNrXCIsci5tb2RlPTMwO2JyZWFrfWw9dT0wfXIubW9kZT0yODtjYXNlIDI4OmlmKHIud3JhcCYmci5mbGFncyl7Zm9yKDtsPDMyOyl7aWYoMD09PW8pYnJlYWsgdDtvLS0sdSs9aVtzKytdPDxsLGwrPTh9aWYodSE9PSg0Mjk0OTY3Mjk1JnIudG90YWwpKXt0Lm1zZz1cImluY29ycmVjdCBsZW5ndGggY2hlY2tcIixyLm1vZGU9MzA7YnJlYWt9bD11PTB9ci5tb2RlPTI5O2Nhc2UgMjk6eD0xO2JyZWFrIHQ7Y2FzZSAzMDp4PS0zO2JyZWFrIHQ7Y2FzZSAzMTpyZXR1cm4tNDtjYXNlIDMyOmRlZmF1bHQ6cmV0dXJuIFV9cmV0dXJuIHQubmV4dF9vdXQ9YSx0LmF2YWlsX291dD1oLHQubmV4dF9pbj1zLHQuYXZhaWxfaW49byxyLmhvbGQ9dSxyLmJpdHM9bCwoci53c2l6ZXx8ZCE9PXQuYXZhaWxfb3V0JiZyLm1vZGU8MzAmJihyLm1vZGU8Mjd8fDQhPT1lKSkmJloodCx0Lm91dHB1dCx0Lm5leHRfb3V0LGQtdC5hdmFpbF9vdXQpPyhyLm1vZGU9MzEsLTQpOihmLT10LmF2YWlsX2luLGQtPXQuYXZhaWxfb3V0LHQudG90YWxfaW4rPWYsdC50b3RhbF9vdXQrPWQsci50b3RhbCs9ZCxyLndyYXAmJmQmJih0LmFkbGVyPXIuY2hlY2s9ci5mbGFncz9CKHIuY2hlY2ssbixkLHQubmV4dF9vdXQtZCk6TyhyLmNoZWNrLG4sZCx0Lm5leHRfb3V0LWQpKSx0LmRhdGFfdHlwZT1yLmJpdHMrKHIubGFzdD82NDowKSsoMTI9PT1yLm1vZGU/MTI4OjApKygyMD09PXIubW9kZXx8MTU9PT1yLm1vZGU/MjU2OjApLCgwPT1mJiYwPT09ZHx8ND09PWUpJiZ4PT09TiYmKHg9LTUpLHgpfSxyLmluZmxhdGVFbmQ9ZnVuY3Rpb24odCl7aWYoIXR8fCF0LnN0YXRlKXJldHVybiBVO3ZhciBlPXQuc3RhdGU7cmV0dXJuIGUud2luZG93JiYoZS53aW5kb3c9bnVsbCksdC5zdGF0ZT1udWxsLE59LHIuaW5mbGF0ZUdldEhlYWRlcj1mdW5jdGlvbih0LGUpe3ZhciByO3JldHVybiB0JiZ0LnN0YXRlPzA9PSgyJihyPXQuc3RhdGUpLndyYXApP1U6KChyLmhlYWQ9ZSkuZG9uZT0hMSxOKTpVfSxyLmluZmxhdGVTZXREaWN0aW9uYXJ5PWZ1bmN0aW9uKHQsZSl7dmFyIHIsaT1lLmxlbmd0aDtyZXR1cm4gdCYmdC5zdGF0ZT8wIT09KHI9dC5zdGF0ZSkud3JhcCYmMTEhPT1yLm1vZGU/VToxMT09PXIubW9kZSYmTygxLGUsaSwwKSE9PXIuY2hlY2s/LTM6Wih0LGUsaSxpKT8oci5tb2RlPTMxLC00KTooci5oYXZlZGljdD0xLE4pOlV9LHIuaW5mbGF0ZUluZm89XCJwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpXCJ9LHtcIi4uL3V0aWxzL2NvbW1vblwiOjQxLFwiLi9hZGxlcjMyXCI6NDMsXCIuL2NyYzMyXCI6NDUsXCIuL2luZmZhc3RcIjo0OCxcIi4vaW5mdHJlZXNcIjo1MH1dLDUwOltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIEQ9dChcIi4uL3V0aWxzL2NvbW1vblwiKSxGPVszLDQsNSw2LDcsOCw5LDEwLDExLDEzLDE1LDE3LDE5LDIzLDI3LDMxLDM1LDQzLDUxLDU5LDY3LDgzLDk5LDExNSwxMzEsMTYzLDE5NSwyMjcsMjU4LDAsMF0sTj1bMTYsMTYsMTYsMTYsMTYsMTYsMTYsMTYsMTcsMTcsMTcsMTcsMTgsMTgsMTgsMTgsMTksMTksMTksMTksMjAsMjAsMjAsMjAsMjEsMjEsMjEsMjEsMTYsNzIsNzhdLFU9WzEsMiwzLDQsNSw3LDksMTMsMTcsMjUsMzMsNDksNjUsOTcsMTI5LDE5MywyNTcsMzg1LDUxMyw3NjksMTAyNSwxNTM3LDIwNDksMzA3Myw0MDk3LDYxNDUsODE5MywxMjI4OSwxNjM4NSwyNDU3NywwLDBdLFA9WzE2LDE2LDE2LDE2LDE3LDE3LDE4LDE4LDE5LDE5LDIwLDIwLDIxLDIxLDIyLDIyLDIzLDIzLDI0LDI0LDI1LDI1LDI2LDI2LDI3LDI3LDI4LDI4LDI5LDI5LDY0LDY0XTtlLmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIsaSxuLHMsYSxvKXt2YXIgaCx1LGwsZixkLGMscCxtLF8sZz1vLmJpdHMsYj0wLHY9MCx5PTAsdz0wLGs9MCx4PTAsUz0wLHo9MCxDPTAsRT0wLEE9bnVsbCxJPTAsTz1uZXcgRC5CdWYxNigxNiksQj1uZXcgRC5CdWYxNigxNiksUj1udWxsLFQ9MDtmb3IoYj0wO2I8PTE1O2IrKylPW2JdPTA7Zm9yKHY9MDt2PGk7disrKU9bZVtyK3ZdXSsrO2ZvcihrPWcsdz0xNTsxPD13JiYwPT09T1t3XTt3LS0pO2lmKHc8ayYmKGs9dyksMD09PXcpcmV0dXJuIG5bcysrXT0yMDk3MTUyMCxuW3MrK109MjA5NzE1MjAsby5iaXRzPTEsMDtmb3IoeT0xO3k8dyYmMD09PU9beV07eSsrKTtmb3Ioazx5JiYoaz15KSxiPXo9MTtiPD0xNTtiKyspaWYoejw8PTEsKHotPU9bYl0pPDApcmV0dXJuLTE7aWYoMDx6JiYoMD09PXR8fDEhPT13KSlyZXR1cm4tMTtmb3IoQlsxXT0wLGI9MTtiPDE1O2IrKylCW2IrMV09QltiXStPW2JdO2Zvcih2PTA7djxpO3YrKykwIT09ZVtyK3ZdJiYoYVtCW2Vbcit2XV0rK109dik7aWYoYz0wPT09dD8oQT1SPWEsMTkpOjE9PT10PyhBPUYsSS09MjU3LFI9TixULT0yNTcsMjU2KTooQT1VLFI9UCwtMSksYj15LGQ9cyxTPXY9RT0wLGw9LTEsZj0oQz0xPDwoeD1rKSktMSwxPT09dCYmODUyPEN8fDI9PT10JiY1OTI8QylyZXR1cm4gMTtmb3IoOzspe2ZvcihwPWItUyxfPWFbdl08Yz8obT0wLGFbdl0pOmFbdl0+Yz8obT1SW1QrYVt2XV0sQVtJK2Fbdl1dKToobT05NiwwKSxoPTE8PGItUyx5PXU9MTw8eDtuW2QrKEU+PlMpKyh1LT1oKV09cDw8MjR8bTw8MTZ8X3wwLDAhPT11Oyk7Zm9yKGg9MTw8Yi0xO0UmaDspaD4+PTE7aWYoMCE9PWg/KEUmPWgtMSxFKz1oKTpFPTAsdisrLDA9PS0tT1tiXSl7aWYoYj09PXcpYnJlYWs7Yj1lW3IrYVt2XV19aWYoazxiJiYoRSZmKSE9PWwpe2ZvcigwPT09UyYmKFM9ayksZCs9eSx6PTE8PCh4PWItUyk7eCtTPHcmJiEoKHotPU9beCtTXSk8PTApOyl4Kyssejw8PTE7aWYoQys9MTw8eCwxPT09dCYmODUyPEN8fDI9PT10JiY1OTI8QylyZXR1cm4gMTtuW2w9RSZmXT1rPDwyNHx4PDwxNnxkLXN8MH19cmV0dXJuIDAhPT1FJiYobltkK0VdPWItUzw8MjR8NjQ8PDE2fDApLG8uYml0cz1rLDB9fSx7XCIuLi91dGlscy9jb21tb25cIjo0MX1dLDUxOltmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7ZS5leHBvcnRzPXsyOlwibmVlZCBkaWN0aW9uYXJ5XCIsMTpcInN0cmVhbSBlbmRcIiwwOlwiXCIsXCItMVwiOlwiZmlsZSBlcnJvclwiLFwiLTJcIjpcInN0cmVhbSBlcnJvclwiLFwiLTNcIjpcImRhdGEgZXJyb3JcIixcIi00XCI6XCJpbnN1ZmZpY2llbnQgbWVtb3J5XCIsXCItNVwiOlwiYnVmZmVyIGVycm9yXCIsXCItNlwiOlwiaW5jb21wYXRpYmxlIHZlcnNpb25cIn19LHt9XSw1MjpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXQoXCIuLi91dGlscy9jb21tb25cIiksbz0wLGg9MTtmdW5jdGlvbiBpKHQpe2Zvcih2YXIgZT10Lmxlbmd0aDswPD0tLWU7KXRbZV09MH12YXIgcz0wLGE9MjksdT0yNTYsbD11KzErYSxmPTMwLGQ9MTksXz0yKmwrMSxnPTE1LGM9MTYscD03LG09MjU2LGI9MTYsdj0xNyx5PTE4LHc9WzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF0saz1bMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM10seD1bMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN10sUz1bMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0sej1uZXcgQXJyYXkoMioobCsyKSk7aSh6KTt2YXIgQz1uZXcgQXJyYXkoMipmKTtpKEMpO3ZhciBFPW5ldyBBcnJheSg1MTIpO2koRSk7dmFyIEE9bmV3IEFycmF5KDI1Nik7aShBKTt2YXIgST1uZXcgQXJyYXkoYSk7aShJKTt2YXIgTyxCLFIsVD1uZXcgQXJyYXkoZik7ZnVuY3Rpb24gRCh0LGUscixpLG4pe3RoaXMuc3RhdGljX3RyZWU9dCx0aGlzLmV4dHJhX2JpdHM9ZSx0aGlzLmV4dHJhX2Jhc2U9cix0aGlzLmVsZW1zPWksdGhpcy5tYXhfbGVuZ3RoPW4sdGhpcy5oYXNfc3RyZWU9dCYmdC5sZW5ndGh9ZnVuY3Rpb24gRih0LGUpe3RoaXMuZHluX3RyZWU9dCx0aGlzLm1heF9jb2RlPTAsdGhpcy5zdGF0X2Rlc2M9ZX1mdW5jdGlvbiBOKHQpe3JldHVybiB0PDI1Nj9FW3RdOkVbMjU2Kyh0Pj4+NyldfWZ1bmN0aW9uIFUodCxlKXt0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXT0yNTUmZSx0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXT1lPj4+OCYyNTV9ZnVuY3Rpb24gUCh0LGUscil7dC5iaV92YWxpZD5jLXI/KHQuYmlfYnVmfD1lPDx0LmJpX3ZhbGlkJjY1NTM1LFUodCx0LmJpX2J1ZiksdC5iaV9idWY9ZT4+Yy10LmJpX3ZhbGlkLHQuYmlfdmFsaWQrPXItYyk6KHQuYmlfYnVmfD1lPDx0LmJpX3ZhbGlkJjY1NTM1LHQuYmlfdmFsaWQrPXIpfWZ1bmN0aW9uIEwodCxlLHIpe1AodCxyWzIqZV0sclsyKmUrMV0pfWZ1bmN0aW9uIGoodCxlKXtmb3IodmFyIHI9MDtyfD0xJnQsdD4+Pj0xLHI8PD0xLDA8LS1lOyk7cmV0dXJuIHI+Pj4xfWZ1bmN0aW9uIFoodCxlLHIpe3ZhciBpLG4scz1uZXcgQXJyYXkoZysxKSxhPTA7Zm9yKGk9MTtpPD1nO2krKylzW2ldPWE9YStyW2ktMV08PDE7Zm9yKG49MDtuPD1lO24rKyl7dmFyIG89dFsyKm4rMV07MCE9PW8mJih0WzIqbl09aihzW29dKyssbykpfX1mdW5jdGlvbiBXKHQpe3ZhciBlO2ZvcihlPTA7ZTxsO2UrKyl0LmR5bl9sdHJlZVsyKmVdPTA7Zm9yKGU9MDtlPGY7ZSsrKXQuZHluX2R0cmVlWzIqZV09MDtmb3IoZT0wO2U8ZDtlKyspdC5ibF90cmVlWzIqZV09MDt0LmR5bl9sdHJlZVsyKm1dPTEsdC5vcHRfbGVuPXQuc3RhdGljX2xlbj0wLHQubGFzdF9saXQ9dC5tYXRjaGVzPTB9ZnVuY3Rpb24gTSh0KXs4PHQuYmlfdmFsaWQ/VSh0LHQuYmlfYnVmKTowPHQuYmlfdmFsaWQmJih0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXT10LmJpX2J1ZiksdC5iaV9idWY9MCx0LmJpX3ZhbGlkPTB9ZnVuY3Rpb24gSCh0LGUscixpKXt2YXIgbj0yKmUscz0yKnI7cmV0dXJuIHRbbl08dFtzXXx8dFtuXT09PXRbc10mJmlbZV08PWlbcl19ZnVuY3Rpb24gRyh0LGUscil7Zm9yKHZhciBpPXQuaGVhcFtyXSxuPXI8PDE7bjw9dC5oZWFwX2xlbiYmKG48dC5oZWFwX2xlbiYmSChlLHQuaGVhcFtuKzFdLHQuaGVhcFtuXSx0LmRlcHRoKSYmbisrLCFIKGUsaSx0LmhlYXBbbl0sdC5kZXB0aCkpOyl0LmhlYXBbcl09dC5oZWFwW25dLHI9bixuPDw9MTt0LmhlYXBbcl09aX1mdW5jdGlvbiBLKHQsZSxyKXt2YXIgaSxuLHMsYSxvPTA7aWYoMCE9PXQubGFzdF9saXQpZm9yKDtpPXQucGVuZGluZ19idWZbdC5kX2J1ZisyKm9dPDw4fHQucGVuZGluZ19idWZbdC5kX2J1ZisyKm8rMV0sbj10LnBlbmRpbmdfYnVmW3QubF9idWYrb10sbysrLDA9PT1pP0wodCxuLGUpOihMKHQsKHM9QVtuXSkrdSsxLGUpLDAhPT0oYT13W3NdKSYmUCh0LG4tPUlbc10sYSksTCh0LHM9TigtLWkpLHIpLDAhPT0oYT1rW3NdKSYmUCh0LGktPVRbc10sYSkpLG88dC5sYXN0X2xpdDspO0wodCxtLGUpfWZ1bmN0aW9uIFkodCxlKXt2YXIgcixpLG4scz1lLmR5bl90cmVlLGE9ZS5zdGF0X2Rlc2Muc3RhdGljX3RyZWUsbz1lLnN0YXRfZGVzYy5oYXNfc3RyZWUsaD1lLnN0YXRfZGVzYy5lbGVtcyx1PS0xO2Zvcih0LmhlYXBfbGVuPTAsdC5oZWFwX21heD1fLHI9MDtyPGg7cisrKTAhPT1zWzIqcl0/KHQuaGVhcFsrK3QuaGVhcF9sZW5dPXU9cix0LmRlcHRoW3JdPTApOnNbMipyKzFdPTA7Zm9yKDt0LmhlYXBfbGVuPDI7KXNbMioobj10LmhlYXBbKyt0LmhlYXBfbGVuXT11PDI/Kyt1OjApXT0xLHQuZGVwdGhbbl09MCx0Lm9wdF9sZW4tLSxvJiYodC5zdGF0aWNfbGVuLT1hWzIqbisxXSk7Zm9yKGUubWF4X2NvZGU9dSxyPXQuaGVhcF9sZW4+PjE7MTw9cjtyLS0pRyh0LHMscik7Zm9yKG49aDtyPXQuaGVhcFsxXSx0LmhlYXBbMV09dC5oZWFwW3QuaGVhcF9sZW4tLV0sRyh0LHMsMSksaT10LmhlYXBbMV0sdC5oZWFwWy0tdC5oZWFwX21heF09cix0LmhlYXBbLS10LmhlYXBfbWF4XT1pLHNbMipuXT1zWzIqcl0rc1syKmldLHQuZGVwdGhbbl09KHQuZGVwdGhbcl0+PXQuZGVwdGhbaV0/dC5kZXB0aFtyXTp0LmRlcHRoW2ldKSsxLHNbMipyKzFdPXNbMippKzFdPW4sdC5oZWFwWzFdPW4rKyxHKHQscywxKSwyPD10LmhlYXBfbGVuOyk7dC5oZWFwWy0tdC5oZWFwX21heF09dC5oZWFwWzFdLGZ1bmN0aW9uKHQsZSl7dmFyIHIsaSxuLHMsYSxvLGg9ZS5keW5fdHJlZSx1PWUubWF4X2NvZGUsbD1lLnN0YXRfZGVzYy5zdGF0aWNfdHJlZSxmPWUuc3RhdF9kZXNjLmhhc19zdHJlZSxkPWUuc3RhdF9kZXNjLmV4dHJhX2JpdHMsYz1lLnN0YXRfZGVzYy5leHRyYV9iYXNlLHA9ZS5zdGF0X2Rlc2MubWF4X2xlbmd0aCxtPTA7Zm9yKHM9MDtzPD1nO3MrKyl0LmJsX2NvdW50W3NdPTA7Zm9yKGhbMip0LmhlYXBbdC5oZWFwX21heF0rMV09MCxyPXQuaGVhcF9tYXgrMTtyPF87cisrKXA8KHM9aFsyKmhbMiooaT10LmhlYXBbcl0pKzFdKzFdKzEpJiYocz1wLG0rKyksaFsyKmkrMV09cyx1PGl8fCh0LmJsX2NvdW50W3NdKyssYT0wLGM8PWkmJihhPWRbaS1jXSksbz1oWzIqaV0sdC5vcHRfbGVuKz1vKihzK2EpLGYmJih0LnN0YXRpY19sZW4rPW8qKGxbMippKzFdK2EpKSk7aWYoMCE9PW0pe2Rve2ZvcihzPXAtMTswPT09dC5ibF9jb3VudFtzXTspcy0tO3QuYmxfY291bnRbc10tLSx0LmJsX2NvdW50W3MrMV0rPTIsdC5ibF9jb3VudFtwXS0tLG0tPTJ9d2hpbGUoMDxtKTtmb3Iocz1wOzAhPT1zO3MtLSlmb3IoaT10LmJsX2NvdW50W3NdOzAhPT1pOyl1PChuPXQuaGVhcFstLXJdKXx8KGhbMipuKzFdIT09cyYmKHQub3B0X2xlbis9KHMtaFsyKm4rMV0pKmhbMipuXSxoWzIqbisxXT1zKSxpLS0pfX0odCxlKSxaKHMsdSx0LmJsX2NvdW50KX1mdW5jdGlvbiBYKHQsZSxyKXt2YXIgaSxuLHM9LTEsYT1lWzFdLG89MCxoPTcsdT00O2ZvcigwPT09YSYmKGg9MTM4LHU9MyksZVsyKihyKzEpKzFdPTY1NTM1LGk9MDtpPD1yO2krKyluPWEsYT1lWzIqKGkrMSkrMV0sKytvPGgmJm49PT1hfHwobzx1P3QuYmxfdHJlZVsyKm5dKz1vOjAhPT1uPyhuIT09cyYmdC5ibF90cmVlWzIqbl0rKyx0LmJsX3RyZWVbMipiXSsrKTpvPD0xMD90LmJsX3RyZWVbMip2XSsrOnQuYmxfdHJlZVsyKnldKysscz1uLHU9KG89MCk9PT1hPyhoPTEzOCwzKTpuPT09YT8oaD02LDMpOihoPTcsNCkpfWZ1bmN0aW9uIFYodCxlLHIpe3ZhciBpLG4scz0tMSxhPWVbMV0sbz0wLGg9Nyx1PTQ7Zm9yKDA9PT1hJiYoaD0xMzgsdT0zKSxpPTA7aTw9cjtpKyspaWYobj1hLGE9ZVsyKihpKzEpKzFdLCEoKytvPGgmJm49PT1hKSl7aWYobzx1KWZvcig7TCh0LG4sdC5ibF90cmVlKSwwIT0tLW87KTtlbHNlIDAhPT1uPyhuIT09cyYmKEwodCxuLHQuYmxfdHJlZSksby0tKSxMKHQsYix0LmJsX3RyZWUpLFAodCxvLTMsMikpOm88PTEwPyhMKHQsdix0LmJsX3RyZWUpLFAodCxvLTMsMykpOihMKHQseSx0LmJsX3RyZWUpLFAodCxvLTExLDcpKTtzPW4sdT0obz0wKT09PWE/KGg9MTM4LDMpOm49PT1hPyhoPTYsMyk6KGg9Nyw0KX19aShUKTt2YXIgcT0hMTtmdW5jdGlvbiBKKHQsZSxyLGkpe1AodCwoczw8MSkrKGk/MTowKSwzKSxmdW5jdGlvbih0LGUscixpKXtNKHQpLGkmJihVKHQsciksVSh0LH5yKSksbi5hcnJheVNldCh0LnBlbmRpbmdfYnVmLHQud2luZG93LGUscix0LnBlbmRpbmcpLHQucGVuZGluZys9cn0odCxlLHIsITApfXIuX3RyX2luaXQ9ZnVuY3Rpb24odCl7cXx8KGZ1bmN0aW9uKCl7dmFyIHQsZSxyLGksbixzPW5ldyBBcnJheShnKzEpO2ZvcihpPXI9MDtpPGEtMTtpKyspZm9yKElbaV09cix0PTA7dDwxPDx3W2ldO3QrKylBW3IrK109aTtmb3IoQVtyLTFdPWksaT1uPTA7aTwxNjtpKyspZm9yKFRbaV09bix0PTA7dDwxPDxrW2ldO3QrKylFW24rK109aTtmb3Iobj4+PTc7aTxmO2krKylmb3IoVFtpXT1uPDw3LHQ9MDt0PDE8PGtbaV0tNzt0KyspRVsyNTYrbisrXT1pO2ZvcihlPTA7ZTw9ZztlKyspc1tlXT0wO2Zvcih0PTA7dDw9MTQzOyl6WzIqdCsxXT04LHQrKyxzWzhdKys7Zm9yKDt0PD0yNTU7KXpbMip0KzFdPTksdCsrLHNbOV0rKztmb3IoO3Q8PTI3OTspelsyKnQrMV09Nyx0Kyssc1s3XSsrO2Zvcig7dDw9Mjg3Oyl6WzIqdCsxXT04LHQrKyxzWzhdKys7Zm9yKFooeixsKzEscyksdD0wO3Q8Zjt0KyspQ1syKnQrMV09NSxDWzIqdF09aih0LDUpO089bmV3IEQoeix3LHUrMSxsLGcpLEI9bmV3IEQoQyxrLDAsZixnKSxSPW5ldyBEKG5ldyBBcnJheSgwKSx4LDAsZCxwKX0oKSxxPSEwKSx0LmxfZGVzYz1uZXcgRih0LmR5bl9sdHJlZSxPKSx0LmRfZGVzYz1uZXcgRih0LmR5bl9kdHJlZSxCKSx0LmJsX2Rlc2M9bmV3IEYodC5ibF90cmVlLFIpLHQuYmlfYnVmPTAsdC5iaV92YWxpZD0wLFcodCl9LHIuX3RyX3N0b3JlZF9ibG9jaz1KLHIuX3RyX2ZsdXNoX2Jsb2NrPWZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBuLHMsYT0wOzA8dC5sZXZlbD8oMj09PXQuc3RybS5kYXRhX3R5cGUmJih0LnN0cm0uZGF0YV90eXBlPWZ1bmN0aW9uKHQpe3ZhciBlLHI9NDA5MzYyNDQ0Nztmb3IoZT0wO2U8PTMxO2UrKyxyPj4+PTEpaWYoMSZyJiYwIT09dC5keW5fbHRyZWVbMiplXSlyZXR1cm4gbztpZigwIT09dC5keW5fbHRyZWVbMThdfHwwIT09dC5keW5fbHRyZWVbMjBdfHwwIT09dC5keW5fbHRyZWVbMjZdKXJldHVybiBoO2ZvcihlPTMyO2U8dTtlKyspaWYoMCE9PXQuZHluX2x0cmVlWzIqZV0pcmV0dXJuIGg7cmV0dXJuIG99KHQpKSxZKHQsdC5sX2Rlc2MpLFkodCx0LmRfZGVzYyksYT1mdW5jdGlvbih0KXt2YXIgZTtmb3IoWCh0LHQuZHluX2x0cmVlLHQubF9kZXNjLm1heF9jb2RlKSxYKHQsdC5keW5fZHRyZWUsdC5kX2Rlc2MubWF4X2NvZGUpLFkodCx0LmJsX2Rlc2MpLGU9ZC0xOzM8PWUmJjA9PT10LmJsX3RyZWVbMipTW2VdKzFdO2UtLSk7cmV0dXJuIHQub3B0X2xlbis9MyooZSsxKSs1KzUrNCxlfSh0KSxuPXQub3B0X2xlbiszKzc+Pj4zLChzPXQuc3RhdGljX2xlbiszKzc+Pj4zKTw9biYmKG49cykpOm49cz1yKzUscis0PD1uJiYtMSE9PWU/Sih0LGUscixpKTo0PT09dC5zdHJhdGVneXx8cz09PW4/KFAodCwyKyhpPzE6MCksMyksSyh0LHosQykpOihQKHQsNCsoaT8xOjApLDMpLGZ1bmN0aW9uKHQsZSxyLGkpe3ZhciBuO2ZvcihQKHQsZS0yNTcsNSksUCh0LHItMSw1KSxQKHQsaS00LDQpLG49MDtuPGk7bisrKVAodCx0LmJsX3RyZWVbMipTW25dKzFdLDMpO1YodCx0LmR5bl9sdHJlZSxlLTEpLFYodCx0LmR5bl9kdHJlZSxyLTEpfSh0LHQubF9kZXNjLm1heF9jb2RlKzEsdC5kX2Rlc2MubWF4X2NvZGUrMSxhKzEpLEsodCx0LmR5bl9sdHJlZSx0LmR5bl9kdHJlZSkpLFcodCksaSYmTSh0KX0sci5fdHJfdGFsbHk9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0LnBlbmRpbmdfYnVmW3QuZF9idWYrMip0Lmxhc3RfbGl0XT1lPj4+OCYyNTUsdC5wZW5kaW5nX2J1Zlt0LmRfYnVmKzIqdC5sYXN0X2xpdCsxXT0yNTUmZSx0LnBlbmRpbmdfYnVmW3QubF9idWYrdC5sYXN0X2xpdF09MjU1JnIsdC5sYXN0X2xpdCsrLDA9PT1lP3QuZHluX2x0cmVlWzIqcl0rKzoodC5tYXRjaGVzKyssZS0tLHQuZHluX2x0cmVlWzIqKEFbcl0rdSsxKV0rKyx0LmR5bl9kdHJlZVsyKk4oZSldKyspLHQubGFzdF9saXQ9PT10LmxpdF9idWZzaXplLTF9LHIuX3RyX2FsaWduPWZ1bmN0aW9uKHQpe1AodCwyLDMpLEwodCxtLHopLGZ1bmN0aW9uKHQpezE2PT09dC5iaV92YWxpZD8oVSh0LHQuYmlfYnVmKSx0LmJpX2J1Zj0wLHQuYmlfdmFsaWQ9MCk6ODw9dC5iaV92YWxpZCYmKHQucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPTI1NSZ0LmJpX2J1Zix0LmJpX2J1Zj4+PTgsdC5iaV92YWxpZC09OCl9KHQpfX0se1wiLi4vdXRpbHMvY29tbW9uXCI6NDF9XSw1MzpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1mdW5jdGlvbigpe3RoaXMuaW5wdXQ9bnVsbCx0aGlzLm5leHRfaW49MCx0aGlzLmF2YWlsX2luPTAsdGhpcy50b3RhbF9pbj0wLHRoaXMub3V0cHV0PW51bGwsdGhpcy5uZXh0X291dD0wLHRoaXMuYXZhaWxfb3V0PTAsdGhpcy50b3RhbF9vdXQ9MCx0aGlzLm1zZz1cIlwiLHRoaXMuc3RhdGU9bnVsbCx0aGlzLmRhdGFfdHlwZT0yLHRoaXMuYWRsZXI9MH19LHt9XSw1NDpbZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBzZXRJbW1lZGlhdGU/c2V0SW1tZWRpYXRlOmZ1bmN0aW9uKCl7dmFyIHQ9W10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKTt0LnNwbGljZSgxLDAsMCksc2V0VGltZW91dC5hcHBseShudWxsLHQpfX0se31dfSx7fSxbMTBdKSgxMCl9KTsiLCJtb2R1bGUuZXhwb3J0cyA9IG1pbmltYXRjaFxubWluaW1hdGNoLk1pbmltYXRjaCA9IE1pbmltYXRjaFxuXG5jb25zdCBwYXRoID0gKCgpID0+IHsgdHJ5IHsgcmV0dXJuIHJlcXVpcmUoJ3BhdGgnKSB9IGNhdGNoIChlKSB7fX0pKCkgfHwge1xuICBzZXA6ICcvJ1xufVxubWluaW1hdGNoLnNlcCA9IHBhdGguc2VwXG5cbmNvbnN0IEdMT0JTVEFSID0gbWluaW1hdGNoLkdMT0JTVEFSID0gTWluaW1hdGNoLkdMT0JTVEFSID0ge31cbmNvbnN0IGV4cGFuZCA9IHJlcXVpcmUoJ2JyYWNlLWV4cGFuc2lvbicpXG5cbmNvbnN0IHBsVHlwZXMgPSB7XG4gICchJzogeyBvcGVuOiAnKD86KD8hKD86JywgY2xvc2U6ICcpKVteL10qPyknfSxcbiAgJz8nOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyk/JyB9LFxuICAnKyc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSsnIH0sXG4gICcqJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpKicgfSxcbiAgJ0AnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyknIH1cbn1cblxuLy8gYW55IHNpbmdsZSB0aGluZyBvdGhlciB0aGFuIC9cbi8vIGRvbid0IG5lZWQgdG8gZXNjYXBlIC8gd2hlbiB1c2luZyBuZXcgUmVnRXhwKClcbmNvbnN0IHFtYXJrID0gJ1teL10nXG5cbi8vICogPT4gYW55IG51bWJlciBvZiBjaGFyYWN0ZXJzXG5jb25zdCBzdGFyID0gcW1hcmsgKyAnKj8nXG5cbi8vICoqIHdoZW4gZG90cyBhcmUgYWxsb3dlZC4gIEFueXRoaW5nIGdvZXMsIGV4Y2VwdCAuLiBhbmQgLlxuLy8gbm90ICheIG9yIC8gZm9sbG93ZWQgYnkgb25lIG9yIHR3byBkb3RzIGZvbGxvd2VkIGJ5ICQgb3IgLyksXG4vLyBmb2xsb3dlZCBieSBhbnl0aGluZywgYW55IG51bWJlciBvZiB0aW1lcy5cbmNvbnN0IHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXFxcL3xeKSg/OlxcXFwuezEsMn0pKCR8XFxcXFxcLykpLikqPydcblxuLy8gbm90IGEgXiBvciAvIGZvbGxvd2VkIGJ5IGEgZG90LFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG5jb25zdCB0d29TdGFyTm9Eb3QgPSAnKD86KD8hKD86XFxcXFxcL3xeKVxcXFwuKS4pKj8nXG5cbi8vIGNoYXJhY3RlcnMgdGhhdCBuZWVkIHRvIGJlIGVzY2FwZWQgaW4gUmVnRXhwLlxuY29uc3QgcmVTcGVjaWFscyA9IGNoYXJTZXQoJygpLip7fSs/W11eJFxcXFwhJylcblxuLy8gXCJhYmNcIiAtPiB7IGE6dHJ1ZSwgYjp0cnVlLCBjOnRydWUgfVxuZnVuY3Rpb24gY2hhclNldCAocykge1xuICByZXR1cm4gcy5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uIChzZXQsIGMpIHtcbiAgICBzZXRbY10gPSB0cnVlXG4gICAgcmV0dXJuIHNldFxuICB9LCB7fSlcbn1cblxuLy8gbm9ybWFsaXplcyBzbGFzaGVzLlxuY29uc3Qgc2xhc2hTcGxpdCA9IC9cXC8rL1xuXG5taW5pbWF0Y2guZmlsdGVyID0gZmlsdGVyXG5mdW5jdGlvbiBmaWx0ZXIgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgcmV0dXJuIGZ1bmN0aW9uIChwLCBpLCBsaXN0KSB7XG4gICAgcmV0dXJuIG1pbmltYXRjaChwLCBwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dCAoYSwgYikge1xuICBhID0gYSB8fCB7fVxuICBiID0gYiB8fCB7fVxuICBjb25zdCB0ID0ge31cbiAgT2JqZWN0LmtleXMoYSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHRba10gPSBhW2tdXG4gIH0pXG4gIE9iamVjdC5rZXlzKGIpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB0W2tdID0gYltrXVxuICB9KVxuICByZXR1cm4gdFxufVxuXG5taW5pbWF0Y2guZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGVmKSB7XG4gIGlmICghZGVmIHx8IHR5cGVvZiBkZWYgIT09ICdvYmplY3QnIHx8ICFPYmplY3Qua2V5cyhkZWYpLmxlbmd0aCkge1xuICAgIHJldHVybiBtaW5pbWF0Y2hcbiAgfVxuXG4gIGNvbnN0IG9yaWcgPSBtaW5pbWF0Y2hcblxuICBjb25zdCBtID0gZnVuY3Rpb24gbWluaW1hdGNoIChwLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcocCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLk1pbmltYXRjaCA9IGZ1bmN0aW9uIE1pbmltYXRjaCAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgb3JpZy5NaW5pbWF0Y2gocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cbiAgbS5NaW5pbWF0Y2guZGVmYXVsdHMgPSBvcHRpb25zID0+IHtcbiAgICByZXR1cm4gb3JpZy5kZWZhdWx0cyhleHQoZGVmLCBvcHRpb25zKSkuTWluaW1hdGNoXG4gIH1cblxuICBtLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLmZpbHRlcihwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0uZGVmYXVsdHMgPSBmdW5jdGlvbiBkZWZhdWx0cyAob3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLmRlZmF1bHRzKGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5tYWtlUmUgPSBmdW5jdGlvbiBtYWtlUmUgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3JpZy5tYWtlUmUocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLmJyYWNlRXhwYW5kID0gZnVuY3Rpb24gYnJhY2VFeHBhbmQgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3JpZy5icmFjZUV4cGFuZChwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0ubWF0Y2ggPSBmdW5jdGlvbiAobGlzdCwgcGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLm1hdGNoKGxpc3QsIHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgcmV0dXJuIG1cbn1cblxuTWluaW1hdGNoLmRlZmF1bHRzID0gZnVuY3Rpb24gKGRlZikge1xuICByZXR1cm4gbWluaW1hdGNoLmRlZmF1bHRzKGRlZikuTWluaW1hdGNoXG59XG5cbmZ1bmN0aW9uIG1pbmltYXRjaCAocCwgcGF0dGVybiwgb3B0aW9ucykge1xuICBhc3NlcnRWYWxpZFBhdHRlcm4ocGF0dGVybilcblxuICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fVxuXG4gIC8vIHNob3J0Y3V0OiBjb21tZW50cyBtYXRjaCBub3RoaW5nLlxuICBpZiAoIW9wdGlvbnMubm9jb21tZW50ICYmIHBhdHRlcm4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIFwiXCIgb25seSBtYXRjaGVzIFwiXCJcbiAgaWYgKHBhdHRlcm4udHJpbSgpID09PSAnJykgcmV0dXJuIHAgPT09ICcnXG5cbiAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucykubWF0Y2gocClcbn1cblxuZnVuY3Rpb24gTWluaW1hdGNoIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNaW5pbWF0Y2gpKSB7XG4gICAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgfVxuXG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG4gIHBhdHRlcm4gPSBwYXR0ZXJuLnRyaW0oKVxuXG4gIC8vIHdpbmRvd3Mgc3VwcG9ydDogbmVlZCB0byB1c2UgLywgbm90IFxcXG4gIGlmIChwYXRoLnNlcCAhPT0gJy8nKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4uc3BsaXQocGF0aC5zZXApLmpvaW4oJy8nKVxuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB0aGlzLnNldCA9IFtdXG4gIHRoaXMucGF0dGVybiA9IHBhdHRlcm5cbiAgdGhpcy5yZWdleHAgPSBudWxsXG4gIHRoaXMubmVnYXRlID0gZmFsc2VcbiAgdGhpcy5jb21tZW50ID0gZmFsc2VcbiAgdGhpcy5lbXB0eSA9IGZhbHNlXG5cbiAgLy8gbWFrZSB0aGUgc2V0IG9mIHJlZ2V4cHMgZXRjLlxuICB0aGlzLm1ha2UoKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKCkge31cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYWtlID0gbWFrZVxuZnVuY3Rpb24gbWFrZSAoKSB7XG4gIC8vIGRvbid0IGRvIGl0IG1vcmUgdGhhbiBvbmNlLlxuICBpZiAodGhpcy5fbWFkZSkgcmV0dXJuXG5cbiAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhdHRlcm5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyBlbXB0eSBwYXR0ZXJucyBhbmQgY29tbWVudHMgbWF0Y2ggbm90aGluZy5cbiAgaWYgKCFvcHRpb25zLm5vY29tbWVudCAmJiBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgdGhpcy5jb21tZW50ID0gdHJ1ZVxuICAgIHJldHVyblxuICB9XG4gIGlmICghcGF0dGVybikge1xuICAgIHRoaXMuZW1wdHkgPSB0cnVlXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBzdGVwIDE6IGZpZ3VyZSBvdXQgbmVnYXRpb24sIGV0Yy5cbiAgdGhpcy5wYXJzZU5lZ2F0ZSgpXG5cbiAgLy8gc3RlcCAyOiBleHBhbmQgYnJhY2VzXG4gIHZhciBzZXQgPSB0aGlzLmdsb2JTZXQgPSB0aGlzLmJyYWNlRXhwYW5kKClcblxuICBpZiAob3B0aW9ucy5kZWJ1ZykgdGhpcy5kZWJ1ZyA9IGNvbnNvbGUuZXJyb3JcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIHN0ZXAgMzogbm93IHdlIGhhdmUgYSBzZXQsIHNvIHR1cm4gZWFjaCBvbmUgaW50byBhIHNlcmllcyBvZiBwYXRoLXBvcnRpb25cbiAgLy8gbWF0Y2hpbmcgcGF0dGVybnMuXG4gIC8vIFRoZXNlIHdpbGwgYmUgcmVnZXhwcywgZXhjZXB0IGluIHRoZSBjYXNlIG9mIFwiKipcIiwgd2hpY2ggaXNcbiAgLy8gc2V0IHRvIHRoZSBHTE9CU1RBUiBvYmplY3QgZm9yIGdsb2JzdGFyIGJlaGF2aW9yLFxuICAvLyBhbmQgd2lsbCBub3QgY29udGFpbiBhbnkgLyBjaGFyYWN0ZXJzXG4gIHNldCA9IHRoaXMuZ2xvYlBhcnRzID0gc2V0Lm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnNwbGl0KHNsYXNoU3BsaXQpXG4gIH0pXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAvLyBnbG9iIC0tPiByZWdleHBzXG4gIHNldCA9IHNldC5tYXAoZnVuY3Rpb24gKHMsIHNpLCBzZXQpIHtcbiAgICByZXR1cm4gcy5tYXAodGhpcy5wYXJzZSwgdGhpcylcbiAgfSwgdGhpcylcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIGZpbHRlciBvdXQgZXZlcnl0aGluZyB0aGF0IGRpZG4ndCBjb21waWxlIHByb3Blcmx5LlxuICBzZXQgPSBzZXQuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMuaW5kZXhPZihmYWxzZSkgPT09IC0xXG4gIH0pXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICB0aGlzLnNldCA9IHNldFxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLnBhcnNlTmVnYXRlID0gcGFyc2VOZWdhdGVcbmZ1bmN0aW9uIHBhcnNlTmVnYXRlICgpIHtcbiAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhdHRlcm5cbiAgdmFyIG5lZ2F0ZSA9IGZhbHNlXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gIHZhciBuZWdhdGVPZmZzZXQgPSAwXG5cbiAgaWYgKG9wdGlvbnMubm9uZWdhdGUpIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGF0dGVybi5sZW5ndGhcbiAgICA7IGkgPCBsICYmIHBhdHRlcm4uY2hhckF0KGkpID09PSAnISdcbiAgICA7IGkrKykge1xuICAgIG5lZ2F0ZSA9ICFuZWdhdGVcbiAgICBuZWdhdGVPZmZzZXQrK1xuICB9XG5cbiAgaWYgKG5lZ2F0ZU9mZnNldCkgdGhpcy5wYXR0ZXJuID0gcGF0dGVybi5zdWJzdHIobmVnYXRlT2Zmc2V0KVxuICB0aGlzLm5lZ2F0ZSA9IG5lZ2F0ZVxufVxuXG4vLyBCcmFjZSBleHBhbnNpb246XG4vLyBhe2IsY31kIC0+IGFiZCBhY2Rcbi8vIGF7Yix9YyAtPiBhYmMgYWNcbi8vIGF7MC4uM31kIC0+IGEwZCBhMWQgYTJkIGEzZFxuLy8gYXtiLGN7ZCxlfWZ9ZyAtPiBhYmcgYWNkZmcgYWNlZmdcbi8vIGF7YixjfWR7ZSxmfWcgLT4gYWJkZWcgYWNkZWcgYWJkZWcgYWJkZmdcbi8vXG4vLyBJbnZhbGlkIHNldHMgYXJlIG5vdCBleHBhbmRlZC5cbi8vIGF7Mi4ufWIgLT4gYXsyLi59YlxuLy8gYXtifWMgLT4gYXtifWNcbm1pbmltYXRjaC5icmFjZUV4cGFuZCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBicmFjZUV4cGFuZChwYXR0ZXJuLCBvcHRpb25zKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLmJyYWNlRXhwYW5kID0gYnJhY2VFeHBhbmRcblxuZnVuY3Rpb24gYnJhY2VFeHBhbmQgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBNaW5pbWF0Y2gpIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuICB9XG5cbiAgcGF0dGVybiA9IHR5cGVvZiBwYXR0ZXJuID09PSAndW5kZWZpbmVkJ1xuICAgID8gdGhpcy5wYXR0ZXJuIDogcGF0dGVyblxuXG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIGlmIChvcHRpb25zLm5vYnJhY2UgfHwgIS9cXHsoPzooPyFcXHspLikqXFx9Ly50ZXN0KHBhdHRlcm4pKSB7XG4gICAgLy8gc2hvcnRjdXQuIG5vIG5lZWQgdG8gZXhwYW5kLlxuICAgIHJldHVybiBbcGF0dGVybl1cbiAgfVxuXG4gIHJldHVybiBleHBhbmQocGF0dGVybilcbn1cblxuY29uc3QgTUFYX1BBVFRFUk5fTEVOR1RIID0gMTAyNCAqIDY0XG5jb25zdCBhc3NlcnRWYWxpZFBhdHRlcm4gPSBwYXR0ZXJuID0+IHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgcGF0dGVybicpXG4gIH1cblxuICBpZiAocGF0dGVybi5sZW5ndGggPiBNQVhfUEFUVEVSTl9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXR0ZXJuIGlzIHRvbyBsb25nJylcbiAgfVxufVxuXG4vLyBwYXJzZSBhIGNvbXBvbmVudCBvZiB0aGUgZXhwYW5kZWQgc2V0LlxuLy8gQXQgdGhpcyBwb2ludCwgbm8gcGF0dGVybiBtYXkgY29udGFpbiBcIi9cIiBpbiBpdFxuLy8gc28gd2UncmUgZ29pbmcgdG8gcmV0dXJuIGEgMmQgYXJyYXksIHdoZXJlIGVhY2ggZW50cnkgaXMgdGhlIGZ1bGxcbi8vIHBhdHRlcm4sIHNwbGl0IG9uICcvJywgYW5kIHRoZW4gdHVybmVkIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24uXG4vLyBBIHJlZ2V4cCBpcyBtYWRlIGF0IHRoZSBlbmQgd2hpY2ggam9pbnMgZWFjaCBhcnJheSB3aXRoIGFuXG4vLyBlc2NhcGVkIC8sIGFuZCBhbm90aGVyIGZ1bGwgb25lIHdoaWNoIGpvaW5zIGVhY2ggcmVnZXhwIHdpdGggfC5cbi8vXG4vLyBGb2xsb3dpbmcgdGhlIGxlYWQgb2YgQmFzaCA0LjEsIG5vdGUgdGhhdCBcIioqXCIgb25seSBoYXMgc3BlY2lhbCBtZWFuaW5nXG4vLyB3aGVuIGl0IGlzIHRoZSAqb25seSogdGhpbmcgaW4gYSBwYXRoIHBvcnRpb24uICBPdGhlcndpc2UsIGFueSBzZXJpZXNcbi8vIG9mICogaXMgZXF1aXZhbGVudCB0byBhIHNpbmdsZSAqLiAgR2xvYnN0YXIgYmVoYXZpb3IgaXMgZW5hYmxlZCBieVxuLy8gZGVmYXVsdCwgYW5kIGNhbiBiZSBkaXNhYmxlZCBieSBzZXR0aW5nIG9wdGlvbnMubm9nbG9ic3Rhci5cbk1pbmltYXRjaC5wcm90b3R5cGUucGFyc2UgPSBwYXJzZVxuY29uc3QgU1VCUEFSU0UgPSB7fVxuZnVuY3Rpb24gcGFyc2UgKHBhdHRlcm4sIGlzU3ViKSB7XG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgLy8gc2hvcnRjdXRzXG4gIGlmICghb3B0aW9ucy5ub2dsb2JzdGFyICYmIHBhdHRlcm4gPT09ICcqKicpIHJldHVybiBHTE9CU1RBUlxuICBpZiAocGF0dGVybiA9PT0gJycpIHJldHVybiAnJ1xuXG4gIHZhciByZSA9ICcnXG4gIHZhciBoYXNNYWdpYyA9IGZhbHNlXG4gIHZhciBlc2NhcGluZyA9IGZhbHNlXG4gIC8vID8gPT4gb25lIHNpbmdsZSBjaGFyYWN0ZXJcbiAgdmFyIHBhdHRlcm5MaXN0U3RhY2sgPSBbXVxuICB2YXIgbmVnYXRpdmVMaXN0cyA9IFtdXG4gIHZhciBzdGF0ZUNoYXJcbiAgdmFyIGluQ2xhc3MgPSBmYWxzZVxuICB2YXIgcmVDbGFzc1N0YXJ0ID0gLTFcbiAgdmFyIGNsYXNzU3RhcnQgPSAtMVxuICAvLyAuIGFuZCAuLiBuZXZlciBtYXRjaCBhbnl0aGluZyB0aGF0IGRvZXNuJ3Qgc3RhcnQgd2l0aCAuLFxuICAvLyBldmVuIHdoZW4gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICB2YXIgcGF0dGVyblN0YXJ0ID0gcGF0dGVybi5jaGFyQXQoMCkgPT09ICcuJyA/ICcnIC8vIGFueXRoaW5nXG4gIC8vIG5vdCAoc3RhcnQgb3IgLyBmb2xsb3dlZCBieSAuIG9yIC4uIGZvbGxvd2VkIGJ5IC8gb3IgZW5kKVxuICA6IG9wdGlvbnMuZG90ID8gJyg/ISg/Ol58XFxcXFxcLylcXFxcLnsxLDJ9KD86JHxcXFxcXFwvKSknXG4gIDogJyg/IVxcXFwuKSdcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZnVuY3Rpb24gY2xlYXJTdGF0ZUNoYXIgKCkge1xuICAgIGlmIChzdGF0ZUNoYXIpIHtcbiAgICAgIC8vIHdlIGhhZCBzb21lIHN0YXRlLXRyYWNraW5nIGNoYXJhY3RlclxuICAgICAgLy8gdGhhdCB3YXNuJ3QgY29uc3VtZWQgYnkgdGhpcyBwYXNzLlxuICAgICAgc3dpdGNoIChzdGF0ZUNoYXIpIHtcbiAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgcmUgKz0gc3RhclxuICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICByZSArPSBxbWFya1xuICAgICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlICs9ICdcXFxcJyArIHN0YXRlQ2hhclxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgc2VsZi5kZWJ1ZygnY2xlYXJTdGF0ZUNoYXIgJWogJWonLCBzdGF0ZUNoYXIsIHJlKVxuICAgICAgc3RhdGVDaGFyID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0dGVybi5sZW5ndGgsIGNcbiAgICA7IChpIDwgbGVuKSAmJiAoYyA9IHBhdHRlcm4uY2hhckF0KGkpKVxuICAgIDsgaSsrKSB7XG4gICAgdGhpcy5kZWJ1ZygnJXNcXHQlcyAlcyAlaicsIHBhdHRlcm4sIGksIHJlLCBjKVxuXG4gICAgLy8gc2tpcCBvdmVyIGFueSB0aGF0IGFyZSBlc2NhcGVkLlxuICAgIGlmIChlc2NhcGluZyAmJiByZVNwZWNpYWxzW2NdKSB7XG4gICAgICByZSArPSAnXFxcXCcgKyBjXG4gICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHN3aXRjaCAoYykge1xuICAgICAgY2FzZSAnLyc6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgICAgICAgLy8gY29tcGxldGVseSBub3QgYWxsb3dlZCwgZXZlbiBlc2NhcGVkLlxuICAgICAgICAvLyBTaG91bGQgYWxyZWFkeSBiZSBwYXRoLXNwbGl0IGJ5IG5vdy5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIGVzY2FwaW5nID0gdHJ1ZVxuICAgICAgY29udGludWVcblxuICAgICAgLy8gdGhlIHZhcmlvdXMgc3RhdGVDaGFyIHZhbHVlc1xuICAgICAgLy8gZm9yIHRoZSBcImV4dGdsb2JcIiBzdHVmZi5cbiAgICAgIGNhc2UgJz8nOlxuICAgICAgY2FzZSAnKic6XG4gICAgICBjYXNlICcrJzpcbiAgICAgIGNhc2UgJ0AnOlxuICAgICAgY2FzZSAnISc6XG4gICAgICAgIHRoaXMuZGVidWcoJyVzXFx0JXMgJXMgJWogPC0tIHN0YXRlQ2hhcicsIHBhdHRlcm4sIGksIHJlLCBjKVxuXG4gICAgICAgIC8vIGFsbCBvZiB0aG9zZSBhcmUgbGl0ZXJhbHMgaW5zaWRlIGEgY2xhc3MsIGV4Y2VwdCB0aGF0XG4gICAgICAgIC8vIHRoZSBnbG9iIFshYV0gbWVhbnMgW15hXSBpbiByZWdleHBcbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKCcgIGluIGNsYXNzJylcbiAgICAgICAgICBpZiAoYyA9PT0gJyEnICYmIGkgPT09IGNsYXNzU3RhcnQgKyAxKSBjID0gJ14nXG4gICAgICAgICAgcmUgKz0gY1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzdGF0ZUNoYXIsIHRoZW4gaXQgbWVhbnNcbiAgICAgICAgLy8gdGhhdCB0aGVyZSB3YXMgc29tZXRoaW5nIGxpa2UgKiogb3IgKz8gaW4gdGhlcmUuXG4gICAgICAgIC8vIEhhbmRsZSB0aGUgc3RhdGVDaGFyLCB0aGVuIHByb2NlZWQgd2l0aCB0aGlzIG9uZS5cbiAgICAgICAgc2VsZi5kZWJ1ZygnY2FsbCBjbGVhclN0YXRlQ2hhciAlaicsIHN0YXRlQ2hhcilcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBzdGF0ZUNoYXIgPSBjXG4gICAgICAgIC8vIGlmIGV4dGdsb2IgaXMgZGlzYWJsZWQsIHRoZW4gKyhhc2RmfGZvbykgaXNuJ3QgYSB0aGluZy5cbiAgICAgICAgLy8ganVzdCBjbGVhciB0aGUgc3RhdGVjaGFyICpub3cqLCByYXRoZXIgdGhhbiBldmVuIGRpdmluZyBpbnRvXG4gICAgICAgIC8vIHRoZSBwYXR0ZXJuTGlzdCBzdHVmZi5cbiAgICAgICAgaWYgKG9wdGlvbnMubm9leHQpIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJygnOlxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICcoJ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0YXRlQ2hhcikge1xuICAgICAgICAgIHJlICs9ICdcXFxcKCdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgcGF0dGVybkxpc3RTdGFjay5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBzdGF0ZUNoYXIsXG4gICAgICAgICAgc3RhcnQ6IGkgLSAxLFxuICAgICAgICAgIHJlU3RhcnQ6IHJlLmxlbmd0aCxcbiAgICAgICAgICBvcGVuOiBwbFR5cGVzW3N0YXRlQ2hhcl0ub3BlbixcbiAgICAgICAgICBjbG9zZTogcGxUeXBlc1tzdGF0ZUNoYXJdLmNsb3NlXG4gICAgICAgIH0pXG4gICAgICAgIC8vIG5lZ2F0aW9uIGlzICg/Oig/IWpzKVteL10qKVxuICAgICAgICByZSArPSBzdGF0ZUNoYXIgPT09ICchJyA/ICcoPzooPyEoPzonIDogJyg/OidcbiAgICAgICAgdGhpcy5kZWJ1ZygncGxUeXBlICVqICVqJywgc3RhdGVDaGFyLCByZSlcbiAgICAgICAgc3RhdGVDaGFyID0gZmFsc2VcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJyknOlxuICAgICAgICBpZiAoaW5DbGFzcyB8fCAhcGF0dGVybkxpc3RTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCknXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIHZhciBwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKClcbiAgICAgICAgLy8gbmVnYXRpb24gaXMgKD86KD8hanMpW14vXSopXG4gICAgICAgIC8vIFRoZSBvdGhlcnMgYXJlICg/OjxwYXR0ZXJuPik8dHlwZT5cbiAgICAgICAgcmUgKz0gcGwuY2xvc2VcbiAgICAgICAgaWYgKHBsLnR5cGUgPT09ICchJykge1xuICAgICAgICAgIG5lZ2F0aXZlTGlzdHMucHVzaChwbClcbiAgICAgICAgfVxuICAgICAgICBwbC5yZUVuZCA9IHJlLmxlbmd0aFxuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGlmIChpbkNsYXNzIHx8ICFwYXR0ZXJuTGlzdFN0YWNrLmxlbmd0aCB8fCBlc2NhcGluZykge1xuICAgICAgICAgIHJlICs9ICdcXFxcfCdcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgcmUgKz0gJ3wnXG4gICAgICBjb250aW51ZVxuXG4gICAgICAvLyB0aGVzZSBhcmUgbW9zdGx5IHRoZSBzYW1lIGluIHJlZ2V4cCBhbmQgZ2xvYlxuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIC8vIHN3YWxsb3cgYW55IHN0YXRlLXRyYWNraW5nIGNoYXIgYmVmb3JlIHRoZSBbXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcblxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaW5DbGFzcyA9IHRydWVcbiAgICAgICAgY2xhc3NTdGFydCA9IGlcbiAgICAgICAgcmVDbGFzc1N0YXJ0ID0gcmUubGVuZ3RoXG4gICAgICAgIHJlICs9IGNcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJ10nOlxuICAgICAgICAvLyAgYSByaWdodCBicmFja2V0IHNoYWxsIGxvc2UgaXRzIHNwZWNpYWxcbiAgICAgICAgLy8gIG1lYW5pbmcgYW5kIHJlcHJlc2VudCBpdHNlbGYgaW5cbiAgICAgICAgLy8gIGEgYnJhY2tldCBleHByZXNzaW9uIGlmIGl0IG9jY3Vyc1xuICAgICAgICAvLyAgZmlyc3QgaW4gdGhlIGxpc3QuICAtLSBQT1NJWC4yIDIuOC4zLjJcbiAgICAgICAgaWYgKGkgPT09IGNsYXNzU3RhcnQgKyAxIHx8ICFpbkNsYXNzKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgY1xuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGxlZnQgYSBjbGFzcyBvcGVuLlxuICAgICAgICAvLyBcIlt6LWFdXCIgaXMgdmFsaWQsIGVxdWl2YWxlbnQgdG8gXCJcXFt6LWFcXF1cIlxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIC8vIHNwbGl0IHdoZXJlIHRoZSBsYXN0IFsgd2FzLCBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgIC8vIGFuIGludmFsaWQgcmUuIGlmIHNvLCByZS13YWxrIHRoZSBjb250ZW50cyBvZiB0aGVcbiAgICAgICAgICAvLyB3b3VsZC1iZSBjbGFzcyB0byByZS10cmFuc2xhdGUgYW55IGNoYXJhY3RlcnMgdGhhdFxuICAgICAgICAgIC8vIHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXNcbiAgICAgICAgICAvLyBUT0RPOiBJdCB3b3VsZCBwcm9iYWJseSBiZSBmYXN0ZXIgdG8gZGV0ZXJtaW5lIHRoaXNcbiAgICAgICAgICAvLyB3aXRob3V0IGEgdHJ5L2NhdGNoIGFuZCBhIG5ldyBSZWdFeHAsIGJ1dCBpdCdzIHRyaWNreVxuICAgICAgICAgIC8vIHRvIGRvIHNhZmVseS4gIEZvciBub3csIHRoaXMgaXMgc2FmZSBhbmQgd29ya3MuXG4gICAgICAgICAgdmFyIGNzID0gcGF0dGVybi5zdWJzdHJpbmcoY2xhc3NTdGFydCArIDEsIGkpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFJlZ0V4cCgnWycgKyBjcyArICddJylcbiAgICAgICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICAgICAgLy8gbm90IGEgdmFsaWQgY2xhc3MhXG4gICAgICAgICAgICB2YXIgc3AgPSB0aGlzLnBhcnNlKGNzLCBTVUJQQVJTRSlcbiAgICAgICAgICAgIHJlID0gcmUuc3Vic3RyKDAsIHJlQ2xhc3NTdGFydCkgKyAnXFxcXFsnICsgc3BbMF0gKyAnXFxcXF0nXG4gICAgICAgICAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IHNwWzFdXG4gICAgICAgICAgICBpbkNsYXNzID0gZmFsc2VcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluaXNoIHVwIHRoZSBjbGFzcy5cbiAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIGluQ2xhc3MgPSBmYWxzZVxuICAgICAgICByZSArPSBjXG4gICAgICBjb250aW51ZVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBzd2FsbG93IGFueSBzdGF0ZSBjaGFyIHRoYXQgd2Fzbid0IGNvbnN1bWVkXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcblxuICAgICAgICBpZiAoZXNjYXBpbmcpIHtcbiAgICAgICAgICAvLyBubyBuZWVkXG4gICAgICAgICAgZXNjYXBpbmcgPSBmYWxzZVxuICAgICAgICB9IGVsc2UgaWYgKHJlU3BlY2lhbHNbY11cbiAgICAgICAgICAmJiAhKGMgPT09ICdeJyAmJiBpbkNsYXNzKSkge1xuICAgICAgICAgIHJlICs9ICdcXFxcJ1xuICAgICAgICB9XG5cbiAgICAgICAgcmUgKz0gY1xuXG4gICAgfSAvLyBzd2l0Y2hcbiAgfSAvLyBmb3JcblxuICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgbGVmdCBhIGNsYXNzIG9wZW4uXG4gIC8vIFwiW2FiY1wiIGlzIHZhbGlkLCBlcXVpdmFsZW50IHRvIFwiXFxbYWJjXCJcbiAgaWYgKGluQ2xhc3MpIHtcbiAgICAvLyBzcGxpdCB3aGVyZSB0aGUgbGFzdCBbIHdhcywgYW5kIGVzY2FwZSBpdFxuICAgIC8vIHRoaXMgaXMgYSBodWdlIHBpdGEuICBXZSBub3cgaGF2ZSB0byByZS13YWxrXG4gICAgLy8gdGhlIGNvbnRlbnRzIG9mIHRoZSB3b3VsZC1iZSBjbGFzcyB0byByZS10cmFuc2xhdGVcbiAgICAvLyBhbnkgY2hhcmFjdGVycyB0aGF0IHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXNcbiAgICBjcyA9IHBhdHRlcm4uc3Vic3RyKGNsYXNzU3RhcnQgKyAxKVxuICAgIHNwID0gdGhpcy5wYXJzZShjcywgU1VCUEFSU0UpXG4gICAgcmUgPSByZS5zdWJzdHIoMCwgcmVDbGFzc1N0YXJ0KSArICdcXFxcWycgKyBzcFswXVxuICAgIGhhc01hZ2ljID0gaGFzTWFnaWMgfHwgc3BbMV1cbiAgfVxuXG4gIC8vIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB3ZSBoYWQgYSArKCB0aGluZyBhdCB0aGUgKmVuZCpcbiAgLy8gb2YgdGhlIHBhdHRlcm4uXG4gIC8vIGVhY2ggcGF0dGVybiBsaXN0IHN0YWNrIGFkZHMgMyBjaGFycywgYW5kIHdlIG5lZWQgdG8gZ28gdGhyb3VnaFxuICAvLyBhbmQgZXNjYXBlIGFueSB8IGNoYXJzIHRoYXQgd2VyZSBwYXNzZWQgdGhyb3VnaCBhcy1pcyBmb3IgdGhlIHJlZ2V4cC5cbiAgLy8gR28gdGhyb3VnaCBhbmQgZXNjYXBlIHRoZW0sIHRha2luZyBjYXJlIG5vdCB0byBkb3VibGUtZXNjYXBlIGFueVxuICAvLyB8IGNoYXJzIHRoYXQgd2VyZSBhbHJlYWR5IGVzY2FwZWQuXG4gIGZvciAocGwgPSBwYXR0ZXJuTGlzdFN0YWNrLnBvcCgpOyBwbDsgcGwgPSBwYXR0ZXJuTGlzdFN0YWNrLnBvcCgpKSB7XG4gICAgdmFyIHRhaWwgPSByZS5zbGljZShwbC5yZVN0YXJ0ICsgcGwub3Blbi5sZW5ndGgpXG4gICAgdGhpcy5kZWJ1Zygnc2V0dGluZyB0YWlsJywgcmUsIHBsKVxuICAgIC8vIG1heWJlIHNvbWUgZXZlbiBudW1iZXIgb2YgXFwsIHRoZW4gbWF5YmUgMSBcXCwgZm9sbG93ZWQgYnkgYSB8XG4gICAgdGFpbCA9IHRhaWwucmVwbGFjZSgvKCg/OlxcXFx7Mn0pezAsNjR9KShcXFxcPylcXHwvZywgZnVuY3Rpb24gKF8sICQxLCAkMikge1xuICAgICAgaWYgKCEkMikge1xuICAgICAgICAvLyB0aGUgfCBpc24ndCBhbHJlYWR5IGVzY2FwZWQsIHNvIGVzY2FwZSBpdC5cbiAgICAgICAgJDIgPSAnXFxcXCdcbiAgICAgIH1cblxuICAgICAgLy8gbmVlZCB0byBlc2NhcGUgYWxsIHRob3NlIHNsYXNoZXMgKmFnYWluKiwgd2l0aG91dCBlc2NhcGluZyB0aGVcbiAgICAgIC8vIG9uZSB0aGF0IHdlIG5lZWQgZm9yIGVzY2FwaW5nIHRoZSB8IGNoYXJhY3Rlci4gIEFzIGl0IHdvcmtzIG91dCxcbiAgICAgIC8vIGVzY2FwaW5nIGFuIGV2ZW4gbnVtYmVyIG9mIHNsYXNoZXMgY2FuIGJlIGRvbmUgYnkgc2ltcGx5IHJlcGVhdGluZ1xuICAgICAgLy8gaXQgZXhhY3RseSBhZnRlciBpdHNlbGYuICBUaGF0J3Mgd2h5IHRoaXMgdHJpY2sgd29ya3MuXG4gICAgICAvL1xuICAgICAgLy8gSSBhbSBzb3JyeSB0aGF0IHlvdSBoYXZlIHRvIHNlZSB0aGlzLlxuICAgICAgcmV0dXJuICQxICsgJDEgKyAkMiArICd8J1xuICAgIH0pXG5cbiAgICB0aGlzLmRlYnVnKCd0YWlsPSVqXFxuICAgJXMnLCB0YWlsLCB0YWlsLCBwbCwgcmUpXG4gICAgdmFyIHQgPSBwbC50eXBlID09PSAnKicgPyBzdGFyXG4gICAgICA6IHBsLnR5cGUgPT09ICc/JyA/IHFtYXJrXG4gICAgICA6ICdcXFxcJyArIHBsLnR5cGVcblxuICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgIHJlID0gcmUuc2xpY2UoMCwgcGwucmVTdGFydCkgKyB0ICsgJ1xcXFwoJyArIHRhaWxcbiAgfVxuXG4gIC8vIGhhbmRsZSB0cmFpbGluZyB0aGluZ3MgdGhhdCBvbmx5IG1hdHRlciBhdCB0aGUgdmVyeSBlbmQuXG4gIGNsZWFyU3RhdGVDaGFyKClcbiAgaWYgKGVzY2FwaW5nKSB7XG4gICAgLy8gdHJhaWxpbmcgXFxcXFxuICAgIHJlICs9ICdcXFxcXFxcXCdcbiAgfVxuXG4gIC8vIG9ubHkgbmVlZCB0byBhcHBseSB0aGUgbm9kb3Qgc3RhcnQgaWYgdGhlIHJlIHN0YXJ0cyB3aXRoXG4gIC8vIHNvbWV0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGNhcHR1cmUgYSBkb3RcbiAgdmFyIGFkZFBhdHRlcm5TdGFydCA9IGZhbHNlXG4gIHN3aXRjaCAocmUuY2hhckF0KDApKSB7XG4gICAgY2FzZSAnLic6XG4gICAgY2FzZSAnWyc6XG4gICAgY2FzZSAnKCc6IGFkZFBhdHRlcm5TdGFydCA9IHRydWVcbiAgfVxuXG4gIC8vIEhhY2sgdG8gd29yayBhcm91bmQgbGFjayBvZiBuZWdhdGl2ZSBsb29rYmVoaW5kIGluIEpTXG4gIC8vIEEgcGF0dGVybiBsaWtlOiAqLiEoeCkuISh5fHopIG5lZWRzIHRvIGVuc3VyZSB0aGF0IGEgbmFtZVxuICAvLyBsaWtlICdhLnh5ei55eicgZG9lc24ndCBtYXRjaC4gIFNvLCB0aGUgZmlyc3QgbmVnYXRpdmVcbiAgLy8gbG9va2FoZWFkLCBoYXMgdG8gbG9vayBBTEwgdGhlIHdheSBhaGVhZCwgdG8gdGhlIGVuZCBvZlxuICAvLyB0aGUgcGF0dGVybi5cbiAgZm9yICh2YXIgbiA9IG5lZ2F0aXZlTGlzdHMubGVuZ3RoIC0gMTsgbiA+IC0xOyBuLS0pIHtcbiAgICB2YXIgbmwgPSBuZWdhdGl2ZUxpc3RzW25dXG5cbiAgICB2YXIgbmxCZWZvcmUgPSByZS5zbGljZSgwLCBubC5yZVN0YXJ0KVxuICAgIHZhciBubEZpcnN0ID0gcmUuc2xpY2UobmwucmVTdGFydCwgbmwucmVFbmQgLSA4KVxuICAgIHZhciBubExhc3QgPSByZS5zbGljZShubC5yZUVuZCAtIDgsIG5sLnJlRW5kKVxuICAgIHZhciBubEFmdGVyID0gcmUuc2xpY2UobmwucmVFbmQpXG5cbiAgICBubExhc3QgKz0gbmxBZnRlclxuXG4gICAgLy8gSGFuZGxlIG5lc3RlZCBzdHVmZiBsaWtlICooKi5qc3whKCouanNvbikpLCB3aGVyZSBvcGVuIHBhcmVuc1xuICAgIC8vIG1lYW4gdGhhdCB3ZSBzaG91bGQgKm5vdCogaW5jbHVkZSB0aGUgKSBpbiB0aGUgYml0IHRoYXQgaXMgY29uc2lkZXJlZFxuICAgIC8vIFwiYWZ0ZXJcIiB0aGUgbmVnYXRlZCBzZWN0aW9uLlxuICAgIHZhciBvcGVuUGFyZW5zQmVmb3JlID0gbmxCZWZvcmUuc3BsaXQoJygnKS5sZW5ndGggLSAxXG4gICAgdmFyIGNsZWFuQWZ0ZXIgPSBubEFmdGVyXG4gICAgZm9yIChpID0gMDsgaSA8IG9wZW5QYXJlbnNCZWZvcmU7IGkrKykge1xuICAgICAgY2xlYW5BZnRlciA9IGNsZWFuQWZ0ZXIucmVwbGFjZSgvXFwpWysqP10/LywgJycpXG4gICAgfVxuICAgIG5sQWZ0ZXIgPSBjbGVhbkFmdGVyXG5cbiAgICB2YXIgZG9sbGFyID0gJydcbiAgICBpZiAobmxBZnRlciA9PT0gJycgJiYgaXNTdWIgIT09IFNVQlBBUlNFKSB7XG4gICAgICBkb2xsYXIgPSAnJCdcbiAgICB9XG4gICAgdmFyIG5ld1JlID0gbmxCZWZvcmUgKyBubEZpcnN0ICsgbmxBZnRlciArIGRvbGxhciArIG5sTGFzdFxuICAgIHJlID0gbmV3UmVcbiAgfVxuXG4gIC8vIGlmIHRoZSByZSBpcyBub3QgXCJcIiBhdCB0aGlzIHBvaW50LCB0aGVuIHdlIG5lZWQgdG8gbWFrZSBzdXJlXG4gIC8vIGl0IGRvZXNuJ3QgbWF0Y2ggYWdhaW5zdCBhbiBlbXB0eSBwYXRoIHBhcnQuXG4gIC8vIE90aGVyd2lzZSBhLyogd2lsbCBtYXRjaCBhLywgd2hpY2ggaXQgc2hvdWxkIG5vdC5cbiAgaWYgKHJlICE9PSAnJyAmJiBoYXNNYWdpYykge1xuICAgIHJlID0gJyg/PS4pJyArIHJlXG4gIH1cblxuICBpZiAoYWRkUGF0dGVyblN0YXJ0KSB7XG4gICAgcmUgPSBwYXR0ZXJuU3RhcnQgKyByZVxuICB9XG5cbiAgLy8gcGFyc2luZyBqdXN0IGEgcGllY2Ugb2YgYSBsYXJnZXIgcGF0dGVybi5cbiAgaWYgKGlzU3ViID09PSBTVUJQQVJTRSkge1xuICAgIHJldHVybiBbcmUsIGhhc01hZ2ljXVxuICB9XG5cbiAgLy8gc2tpcCB0aGUgcmVnZXhwIGZvciBub24tbWFnaWNhbCBwYXR0ZXJuc1xuICAvLyB1bmVzY2FwZSBhbnl0aGluZyBpbiBpdCwgdGhvdWdoLCBzbyB0aGF0IGl0J2xsIGJlXG4gIC8vIGFuIGV4YWN0IG1hdGNoIGFnYWluc3QgYSBmaWxlIGV0Yy5cbiAgaWYgKCFoYXNNYWdpYykge1xuICAgIHJldHVybiBnbG9iVW5lc2NhcGUocGF0dGVybilcbiAgfVxuXG4gIHZhciBmbGFncyA9IG9wdGlvbnMubm9jYXNlID8gJ2knIDogJydcbiAgdHJ5IHtcbiAgICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cCgnXicgKyByZSArICckJywgZmxhZ3MpXG4gIH0gY2F0Y2ggKGVyKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHNob3VsZCBiZSBpbXBvc3NpYmxlICovIHtcbiAgICAvLyBJZiBpdCB3YXMgYW4gaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24sIHRoZW4gaXQgY2FuJ3QgbWF0Y2hcbiAgICAvLyBhbnl0aGluZy4gIFRoaXMgdHJpY2sgbG9va3MgZm9yIGEgY2hhcmFjdGVyIGFmdGVyIHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgc3RyaW5nLCB3aGljaCBpcyBvZiBjb3Vyc2UgaW1wb3NzaWJsZSwgZXhjZXB0IGluIG11bHRpLWxpbmVcbiAgICAvLyBtb2RlLCBidXQgaXQncyBub3QgYSAvbSByZWdleC5cbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnJC4nKVxuICB9XG5cbiAgcmVnRXhwLl9nbG9iID0gcGF0dGVyblxuICByZWdFeHAuX3NyYyA9IHJlXG5cbiAgcmV0dXJuIHJlZ0V4cFxufVxuXG5taW5pbWF0Y2gubWFrZVJlID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucyB8fCB7fSkubWFrZVJlKClcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYWtlUmUgPSBtYWtlUmVcbmZ1bmN0aW9uIG1ha2VSZSAoKSB7XG4gIGlmICh0aGlzLnJlZ2V4cCB8fCB0aGlzLnJlZ2V4cCA9PT0gZmFsc2UpIHJldHVybiB0aGlzLnJlZ2V4cFxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIHRoaXMuc2V0IGlzIGEgMmQgYXJyYXkgb2YgcGFydGlhbFxuICAvLyBwYXR0ZXJuIHN0cmluZ3MsIG9yIFwiKipcIi5cbiAgLy9cbiAgLy8gSXQncyBiZXR0ZXIgdG8gdXNlIC5tYXRjaCgpLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRuJ3RcbiAgLy8gYmUgdXNlZCwgcmVhbGx5LCBidXQgaXQncyBwcmV0dHkgY29udmVuaWVudCBzb21ldGltZXMsXG4gIC8vIHdoZW4geW91IGp1c3Qgd2FudCB0byB3b3JrIHdpdGggYSByZWdleC5cbiAgdmFyIHNldCA9IHRoaXMuc2V0XG5cbiAgaWYgKCFzZXQubGVuZ3RoKSB7XG4gICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICAgIHJldHVybiB0aGlzLnJlZ2V4cFxuICB9XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdmFyIHR3b1N0YXIgPSBvcHRpb25zLm5vZ2xvYnN0YXIgPyBzdGFyXG4gICAgOiBvcHRpb25zLmRvdCA/IHR3b1N0YXJEb3RcbiAgICA6IHR3b1N0YXJOb0RvdFxuICB2YXIgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnXG5cbiAgdmFyIHJlID0gc2V0Lm1hcChmdW5jdGlvbiAocGF0dGVybikge1xuICAgIHJldHVybiBwYXR0ZXJuLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIChwID09PSBHTE9CU1RBUikgPyB0d29TdGFyXG4gICAgICA6ICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpID8gcmVnRXhwRXNjYXBlKHApXG4gICAgICA6IHAuX3NyY1xuICAgIH0pLmpvaW4oJ1xcXFxcXC8nKVxuICB9KS5qb2luKCd8JylcblxuICAvLyBtdXN0IG1hdGNoIGVudGlyZSBwYXR0ZXJuXG4gIC8vIGVuZGluZyBpbiBhICogb3IgKiogd2lsbCBtYWtlIGl0IGxlc3Mgc3RyaWN0LlxuICByZSA9ICdeKD86JyArIHJlICsgJykkJ1xuXG4gIC8vIGNhbiBtYXRjaCBhbnl0aGluZywgYXMgbG9uZyBhcyBpdCdzIG5vdCB0aGlzLlxuICBpZiAodGhpcy5uZWdhdGUpIHJlID0gJ14oPyEnICsgcmUgKyAnKS4qJCdcblxuICB0cnkge1xuICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChyZSwgZmxhZ3MpXG4gIH0gY2F0Y2ggKGV4KSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHNob3VsZCBiZSBpbXBvc3NpYmxlICovIHtcbiAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRoaXMucmVnZXhwXG59XG5cbm1pbmltYXRjaC5tYXRjaCA9IGZ1bmN0aW9uIChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIGNvbnN0IG1tID0gbmV3IE1pbmltYXRjaChwYXR0ZXJuLCBvcHRpb25zKVxuICBsaXN0ID0gbGlzdC5maWx0ZXIoZnVuY3Rpb24gKGYpIHtcbiAgICByZXR1cm4gbW0ubWF0Y2goZilcbiAgfSlcbiAgaWYgKG1tLm9wdGlvbnMubm9udWxsICYmICFsaXN0Lmxlbmd0aCkge1xuICAgIGxpc3QucHVzaChwYXR0ZXJuKVxuICB9XG4gIHJldHVybiBsaXN0XG59XG5cbk1pbmltYXRjaC5wcm90b3R5cGUubWF0Y2ggPSBtYXRjaFxuZnVuY3Rpb24gbWF0Y2ggKGYsIHBhcnRpYWwpIHtcbiAgdGhpcy5kZWJ1ZygnbWF0Y2gnLCBmLCB0aGlzLnBhdHRlcm4pXG4gIC8vIHNob3J0LWNpcmN1aXQgaW4gdGhlIGNhc2Ugb2YgYnVzdGVkIHRoaW5ncy5cbiAgLy8gY29tbWVudHMsIGV0Yy5cbiAgaWYgKHRoaXMuY29tbWVudCkgcmV0dXJuIGZhbHNlXG4gIGlmICh0aGlzLmVtcHR5KSByZXR1cm4gZiA9PT0gJydcblxuICBpZiAoZiA9PT0gJy8nICYmIHBhcnRpYWwpIHJldHVybiB0cnVlXG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyB3aW5kb3dzOiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgaWYgKHBhdGguc2VwICE9PSAnLycpIHtcbiAgICBmID0gZi5zcGxpdChwYXRoLnNlcCkuam9pbignLycpXG4gIH1cblxuICAvLyB0cmVhdCB0aGUgdGVzdCBwYXRoIGFzIGEgc2V0IG9mIHBhdGhwYXJ0cy5cbiAgZiA9IGYuc3BsaXQoc2xhc2hTcGxpdClcbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzcGxpdCcsIGYpXG5cbiAgLy8ganVzdCBPTkUgb2YgdGhlIHBhdHRlcm4gc2V0cyBpbiB0aGlzLnNldCBuZWVkcyB0byBtYXRjaFxuICAvLyBpbiBvcmRlciBmb3IgaXQgdG8gYmUgdmFsaWQuICBJZiBuZWdhdGluZywgdGhlbiBqdXN0IG9uZVxuICAvLyBtYXRjaCBtZWFucyB0aGF0IHdlIGhhdmUgZmFpbGVkLlxuICAvLyBFaXRoZXIgd2F5LCByZXR1cm4gb24gdGhlIGZpcnN0IGhpdC5cblxuICB2YXIgc2V0ID0gdGhpcy5zZXRcbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sICdzZXQnLCBzZXQpXG5cbiAgLy8gRmluZCB0aGUgYmFzZW5hbWUgb2YgdGhlIHBhdGggYnkgbG9va2luZyBmb3IgdGhlIGxhc3Qgbm9uLWVtcHR5IHNlZ21lbnRcbiAgdmFyIGZpbGVuYW1lXG4gIHZhciBpXG4gIGZvciAoaSA9IGYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBmaWxlbmFtZSA9IGZbaV1cbiAgICBpZiAoZmlsZW5hbWUpIGJyZWFrXG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhdHRlcm4gPSBzZXRbaV1cbiAgICB2YXIgZmlsZSA9IGZcbiAgICBpZiAob3B0aW9ucy5tYXRjaEJhc2UgJiYgcGF0dGVybi5sZW5ndGggPT09IDEpIHtcbiAgICAgIGZpbGUgPSBbZmlsZW5hbWVdXG4gICAgfVxuICAgIHZhciBoaXQgPSB0aGlzLm1hdGNoT25lKGZpbGUsIHBhdHRlcm4sIHBhcnRpYWwpXG4gICAgaWYgKGhpdCkge1xuICAgICAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkgcmV0dXJuIHRydWVcbiAgICAgIHJldHVybiAhdGhpcy5uZWdhdGVcbiAgICB9XG4gIH1cblxuICAvLyBkaWRuJ3QgZ2V0IGFueSBoaXRzLiAgdGhpcyBpcyBzdWNjZXNzIGlmIGl0J3MgYSBuZWdhdGl2ZVxuICAvLyBwYXR0ZXJuLCBmYWlsdXJlIG90aGVyd2lzZS5cbiAgaWYgKG9wdGlvbnMuZmxpcE5lZ2F0ZSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiB0aGlzLm5lZ2F0ZVxufVxuXG4vLyBzZXQgcGFydGlhbCB0byB0cnVlIHRvIHRlc3QgaWYsIGZvciBleGFtcGxlLFxuLy8gXCIvYS9iXCIgbWF0Y2hlcyB0aGUgc3RhcnQgb2YgXCIvKi9iLyovZFwiXG4vLyBQYXJ0aWFsIG1lYW5zLCBpZiB5b3UgcnVuIG91dCBvZiBmaWxlIGJlZm9yZSB5b3UgcnVuXG4vLyBvdXQgb2YgcGF0dGVybiwgdGhlbiB0aGF0J3MgZmluZSwgYXMgbG9uZyBhcyBhbGxcbi8vIHRoZSBwYXJ0cyBtYXRjaC5cbk1pbmltYXRjaC5wcm90b3R5cGUubWF0Y2hPbmUgPSBmdW5jdGlvbiAoZmlsZSwgcGF0dGVybiwgcGFydGlhbCkge1xuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIHRoaXMuZGVidWcoJ21hdGNoT25lJyxcbiAgICB7ICd0aGlzJzogdGhpcywgZmlsZTogZmlsZSwgcGF0dGVybjogcGF0dGVybiB9KVxuXG4gIHRoaXMuZGVidWcoJ21hdGNoT25lJywgZmlsZS5sZW5ndGgsIHBhdHRlcm4ubGVuZ3RoKVxuXG4gIGZvciAodmFyIGZpID0gMCxcbiAgICAgIHBpID0gMCxcbiAgICAgIGZsID0gZmlsZS5sZW5ndGgsXG4gICAgICBwbCA9IHBhdHRlcm4ubGVuZ3RoXG4gICAgICA7IChmaSA8IGZsKSAmJiAocGkgPCBwbClcbiAgICAgIDsgZmkrKywgcGkrKykge1xuICAgIHRoaXMuZGVidWcoJ21hdGNoT25lIGxvb3AnKVxuICAgIHZhciBwID0gcGF0dGVybltwaV1cbiAgICB2YXIgZiA9IGZpbGVbZmldXG5cbiAgICB0aGlzLmRlYnVnKHBhdHRlcm4sIHAsIGYpXG5cbiAgICAvLyBzaG91bGQgYmUgaW1wb3NzaWJsZS5cbiAgICAvLyBzb21lIGludmFsaWQgcmVnZXhwIHN0dWZmIGluIHRoZSBzZXQuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHAgPT09IGZhbHNlKSByZXR1cm4gZmFsc2VcblxuICAgIGlmIChwID09PSBHTE9CU1RBUikge1xuICAgICAgdGhpcy5kZWJ1ZygnR0xPQlNUQVInLCBbcGF0dGVybiwgcCwgZl0pXG5cbiAgICAgIC8vIFwiKipcIlxuICAgICAgLy8gYS8qKi9iLyoqL2Mgd291bGQgbWF0Y2ggdGhlIGZvbGxvd2luZzpcbiAgICAgIC8vIGEvYi94L3kvei9jXG4gICAgICAvLyBhL3gveS96L2IvY1xuICAgICAgLy8gYS9iL3gvYi94L2NcbiAgICAgIC8vIGEvYi9jXG4gICAgICAvLyBUbyBkbyB0aGlzLCB0YWtlIHRoZSByZXN0IG9mIHRoZSBwYXR0ZXJuIGFmdGVyXG4gICAgICAvLyB0aGUgKiosIGFuZCBzZWUgaWYgaXQgd291bGQgbWF0Y2ggdGhlIGZpbGUgcmVtYWluZGVyLlxuICAgICAgLy8gSWYgc28sIHJldHVybiBzdWNjZXNzLlxuICAgICAgLy8gSWYgbm90LCB0aGUgKiogXCJzd2FsbG93c1wiIGEgc2VnbWVudCwgYW5kIHRyeSBhZ2Fpbi5cbiAgICAgIC8vIFRoaXMgaXMgcmVjdXJzaXZlbHkgYXdmdWwuXG4gICAgICAvL1xuICAgICAgLy8gYS8qKi9iLyoqL2MgbWF0Y2hpbmcgYS9iL3gveS96L2NcbiAgICAgIC8vIC0gYSBtYXRjaGVzIGFcbiAgICAgIC8vIC0gZG91Ymxlc3RhclxuICAgICAgLy8gICAtIG1hdGNoT25lKGIveC95L3ovYywgYi8qKi9jKVxuICAgICAgLy8gICAgIC0gYiBtYXRjaGVzIGJcbiAgICAgIC8vICAgICAtIGRvdWJsZXN0YXJcbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeC95L3ovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoeS96L2MsIGMpIC0+IG5vXG4gICAgICAvLyAgICAgICAtIG1hdGNoT25lKHovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoYywgYykgeWVzLCBoaXRcbiAgICAgIHZhciBmciA9IGZpXG4gICAgICB2YXIgcHIgPSBwaSArIDFcbiAgICAgIGlmIChwciA9PT0gcGwpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZygnKiogYXQgdGhlIGVuZCcpXG4gICAgICAgIC8vIGEgKiogYXQgdGhlIGVuZCB3aWxsIGp1c3Qgc3dhbGxvdyB0aGUgcmVzdC5cbiAgICAgICAgLy8gV2UgaGF2ZSBmb3VuZCBhIG1hdGNoLlxuICAgICAgICAvLyBob3dldmVyLCBpdCB3aWxsIG5vdCBzd2FsbG93IC8ueCwgdW5sZXNzXG4gICAgICAgIC8vIG9wdGlvbnMuZG90IGlzIHNldC5cbiAgICAgICAgLy8gLiBhbmQgLi4gYXJlICpuZXZlciogbWF0Y2hlZCBieSAqKiwgZm9yIGV4cGxvc2l2ZWx5XG4gICAgICAgIC8vIGV4cG9uZW50aWFsIHJlYXNvbnMuXG4gICAgICAgIGZvciAoOyBmaSA8IGZsOyBmaSsrKSB7XG4gICAgICAgICAgaWYgKGZpbGVbZmldID09PSAnLicgfHwgZmlsZVtmaV0gPT09ICcuLicgfHxcbiAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgZmlsZVtmaV0uY2hhckF0KDApID09PSAnLicpKSByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICAvLyBvaywgbGV0J3Mgc2VlIGlmIHdlIGNhbiBzd2FsbG93IHdoYXRldmVyIHdlIGNhbi5cbiAgICAgIHdoaWxlIChmciA8IGZsKSB7XG4gICAgICAgIHZhciBzd2FsbG93ZWUgPSBmaWxlW2ZyXVxuXG4gICAgICAgIHRoaXMuZGVidWcoJ1xcbmdsb2JzdGFyIHdoaWxlJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByLCBzd2FsbG93ZWUpXG5cbiAgICAgICAgLy8gWFhYIHJlbW92ZSB0aGlzIHNsaWNlLiAgSnVzdCBwYXNzIHRoZSBzdGFydCBpbmRleC5cbiAgICAgICAgaWYgKHRoaXMubWF0Y2hPbmUoZmlsZS5zbGljZShmciksIHBhdHRlcm4uc2xpY2UocHIpLCBwYXJ0aWFsKSkge1xuICAgICAgICAgIHRoaXMuZGVidWcoJ2dsb2JzdGFyIGZvdW5kIG1hdGNoIScsIGZyLCBmbCwgc3dhbGxvd2VlKVxuICAgICAgICAgIC8vIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjYW4ndCBzd2FsbG93IFwiLlwiIG9yIFwiLi5cIiBldmVyLlxuICAgICAgICAgIC8vIGNhbiBvbmx5IHN3YWxsb3cgXCIuZm9vXCIgd2hlbiBleHBsaWNpdGx5IGFza2VkLlxuICAgICAgICAgIGlmIChzd2FsbG93ZWUgPT09ICcuJyB8fCBzd2FsbG93ZWUgPT09ICcuLicgfHxcbiAgICAgICAgICAgICghb3B0aW9ucy5kb3QgJiYgc3dhbGxvd2VlLmNoYXJBdCgwKSA9PT0gJy4nKSkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZygnZG90IGRldGVjdGVkIScsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcilcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gKiogc3dhbGxvd3MgYSBzZWdtZW50LCBhbmQgY29udGludWUuXG4gICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgc3dhbGxvdyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZScpXG4gICAgICAgICAgZnIrK1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIG1hdGNoIHdhcyBmb3VuZC5cbiAgICAgIC8vIEhvd2V2ZXIsIGluIHBhcnRpYWwgbW9kZSwgd2UgY2FuJ3Qgc2F5IHRoaXMgaXMgbmVjZXNzYXJpbHkgb3Zlci5cbiAgICAgIC8vIElmIHRoZXJlJ3MgbW9yZSAqcGF0dGVybiogbGVmdCwgdGhlblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocGFydGlhbCkge1xuICAgICAgICAvLyByYW4gb3V0IG9mIGZpbGVcbiAgICAgICAgdGhpcy5kZWJ1ZygnXFxuPj4+IG5vIG1hdGNoLCBwYXJ0aWFsPycsIGZpbGUsIGZyLCBwYXR0ZXJuLCBwcilcbiAgICAgICAgaWYgKGZyID09PSBmbCkgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIHNvbWV0aGluZyBvdGhlciB0aGFuICoqXG4gICAgLy8gbm9uLW1hZ2ljIHBhdHRlcm5zIGp1c3QgaGF2ZSB0byBtYXRjaCBleGFjdGx5XG4gICAgLy8gcGF0dGVybnMgd2l0aCBtYWdpYyBoYXZlIGJlZW4gdHVybmVkIGludG8gcmVnZXhwcy5cbiAgICB2YXIgaGl0XG4gICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKG9wdGlvbnMubm9jYXNlKSB7XG4gICAgICAgIGhpdCA9IGYudG9Mb3dlckNhc2UoKSA9PT0gcC50b0xvd2VyQ2FzZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoaXQgPSBmID09PSBwXG4gICAgICB9XG4gICAgICB0aGlzLmRlYnVnKCdzdHJpbmcgbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGhpdCA9IGYubWF0Y2gocClcbiAgICAgIHRoaXMuZGVidWcoJ3BhdHRlcm4gbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfVxuXG4gICAgaWYgKCFoaXQpIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gTm90ZTogZW5kaW5nIGluIC8gbWVhbnMgdGhhdCB3ZSdsbCBnZXQgYSBmaW5hbCBcIlwiXG4gIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4uICBUaGlzIGNhbiBvbmx5IG1hdGNoIGFcbiAgLy8gY29ycmVzcG9uZGluZyBcIlwiIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gIC8vIElmIHRoZSBmaWxlIGVuZHMgaW4gLywgdGhlbiBpdCBjYW4gb25seSBtYXRjaCBhXG4gIC8vIGEgcGF0dGVybiB0aGF0IGVuZHMgaW4gLywgdW5sZXNzIHRoZSBwYXR0ZXJuIGp1c3RcbiAgLy8gZG9lc24ndCBoYXZlIGFueSBtb3JlIGZvciBpdC4gQnV0LCBhL2IvIHNob3VsZCAqbm90KlxuICAvLyBtYXRjaCBcImEvYi8qXCIsIGV2ZW4gdGhvdWdoIFwiXCIgbWF0Y2hlcyBhZ2FpbnN0IHRoZVxuICAvLyBbXi9dKj8gcGF0dGVybiwgZXhjZXB0IGluIHBhcnRpYWwgbW9kZSwgd2hlcmUgaXQgbWlnaHRcbiAgLy8gc2ltcGx5IG5vdCBiZSByZWFjaGVkIHlldC5cbiAgLy8gSG93ZXZlciwgYS9iLyBzaG91bGQgc3RpbGwgc2F0aXNmeSBhLypcblxuICAvLyBub3cgZWl0aGVyIHdlIGZlbGwgb2ZmIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIG9yIHdlJ3JlIGRvbmUuXG4gIGlmIChmaSA9PT0gZmwgJiYgcGkgPT09IHBsKSB7XG4gICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuIGFuZCBmaWxlbmFtZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIGFuIGV4YWN0IGhpdCFcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKGZpID09PSBmbCkge1xuICAgIC8vIHJhbiBvdXQgb2YgZmlsZSwgYnV0IHN0aWxsIGhhZCBwYXR0ZXJuIGxlZnQuXG4gICAgLy8gdGhpcyBpcyBvayBpZiB3ZSdyZSBkb2luZyB0aGUgbWF0Y2ggYXMgcGFydCBvZlxuICAgIC8vIGEgZ2xvYiBmcyB0cmF2ZXJzYWwuXG4gICAgcmV0dXJuIHBhcnRpYWxcbiAgfSBlbHNlIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmIChwaSA9PT0gcGwpIHtcbiAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4sIHN0aWxsIGhhdmUgZmlsZSBsZWZ0LlxuICAgIC8vIHRoaXMgaXMgb25seSBhY2NlcHRhYmxlIGlmIHdlJ3JlIG9uIHRoZSB2ZXJ5IGxhc3RcbiAgICAvLyBlbXB0eSBzZWdtZW50IG9mIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgLy8gYS8qIHNob3VsZCBtYXRjaCBhL2IvXG4gICAgcmV0dXJuIChmaSA9PT0gZmwgLSAxKSAmJiAoZmlsZVtmaV0gPT09ICcnKVxuICB9XG5cbiAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlLlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB0aHJvdyBuZXcgRXJyb3IoJ3d0Zj8nKVxufVxuXG4vLyByZXBsYWNlIHN0dWZmIGxpa2UgXFwqIHdpdGggKlxuZnVuY3Rpb24gZ2xvYlVuZXNjYXBlIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJylcbn1cblxuZnVuY3Rpb24gcmVnRXhwRXNjYXBlIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJylcbn1cbiIsIi8vIFRvcCBsZXZlbCBmaWxlIGlzIGp1c3QgYSBtaXhpbiBvZiBzdWJtb2R1bGVzICYgY29uc3RhbnRzXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgPSByZXF1aXJlKCcuL2xpYi91dGlscy9jb21tb24nKS5hc3NpZ247XG5cbnZhciBkZWZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9kZWZsYXRlJyk7XG52YXIgaW5mbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvaW5mbGF0ZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbnZhciBwYWtvID0ge307XG5cbmFzc2lnbihwYWtvLCBkZWZsYXRlLCBpbmZsYXRlLCBjb25zdGFudHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBha287XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9kZWZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcblxudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuXG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSAgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbRGVmbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGFycmF5IGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cmluZ3MuYnVmMmJpbnN0cmluZyh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpO1xuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IFpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChaX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGRhdGEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9pbmZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBjICAgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcbnZhciBHWmhlYWRlciAgICAgPSByZXF1aXJlKCcuL3psaWIvZ3poZWFkZXInKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhpbmZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIEluZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMCxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTtcblxuICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcblxuICAvLyBTZXR1cCBkaWN0aW9uYXJ5XG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH1cbiAgICBpZiAob3B0LnJhdykgeyAvL0luIHJhdyBtb2RlIHdlIG5lZWQgdG8gc2V0IHRoZSBkaWN0aW9uYXJ5IGVhcmx5XG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YVxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgb3V0cHV0IGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbSW5mbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGRlY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcbiAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7XG5cbiAgLy8gRmxhZyB0byBwcm9wZXJseSBwcm9jZXNzIFpfQlVGX0VSUk9SIG9uIHRlc3RpbmcgaW5mbGF0ZSBjYWxsXG4gIC8vIHdoZW4gd2UgY2hlY2sgdGhhdCBhbGwgb3V0cHV0IGRhdGEgd2FzIGZsdXNoZWQuXG4gIHZhciBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IGMuWl9GSU5JU0ggOiBjLlpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIE9ubHkgYmluYXJ5IHN0cmluZ3MgY2FuIGJlIGRlY29tcHJlc3NlZCBvbiBwcmFjdGljZVxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLmJpbnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGMuWl9OT19GTFVTSCk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdGlvbmFyeSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7XG4gICAgICBzdGF0dXMgPSBjLlpfT0s7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWxcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHsgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsgfVxuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gbm8gbW9yZSBpbnB1dCBkYXRhLCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpbnRlcm5hbCBpbmZsYXRlIGJ1ZmZlcnNcbiAgICAvLyBhcmUgZmx1c2hlZC4gVGhlIG9ubHkgd2F5IHRvIGRvIGl0IHdoZW4gYXZhaWxfb3V0ID0gMCAtIHJ1biBvbmUgbW9yZVxuICAgIC8vIGluZmxhdGUgcGFzcy4gQnV0IGlmIG91dHB1dCBkYXRhIG5vdCBleGlzdHMsIGluZmxhdGUgcmV0dXJuIFpfQlVGX0VSUk9SLlxuICAgIC8vIEhlcmUgd2Ugc2V0IGZsYWcgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHByb3Blcmx5LlxuICAgIC8vXG4gICAgLy8gTk9URS4gRGVmbGF0ZSBkb2VzIG5vdCByZXR1cm4gZXJyb3IgaW4gdGhpcyBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkcyBzdWNoXG4gICAgLy8gbG9naWMuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpO1xuXG4gIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7XG4gICAgX21vZGUgPSBjLlpfRklOSVNIO1xuICB9XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKGMuWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IGMuWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBHbHVlICYgY29udmVydCBoZXJlLCB1bnRpbCB3ZSB0ZWFjaCBwYWtvIHRvIHNlbmRcbiAgICAgIC8vIHV0ZjggYWxpZ25lZCBzdHJpbmdzIHRvIG9uRGF0YVxuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGlucHV0ID0gcGFrby5kZWZsYXRlKFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgeyB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7XG5leHBvcnRzLnVuZ3ppcCAgPSBpbmZsYXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5mdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iLCIvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmlcbi8vXG52YXIgU1RSX0FQUExZX09LID0gdHJ1ZTtcbnZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbIDAgXSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9XG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpO1xuZm9yICh2YXIgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXIgKHVzZWQgaW4gMiBwbGFjZXMpXG5mdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7XG4gIC8vIE9uIENocm9tZSwgdGhlIGFyZ3VtZW50cyBpbiBhIGZ1bmN0aW9uIGNhbGwgdGhhdCBhcmUgYWxsb3dlZCBpcyBgNjU1MzRgLlxuICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaXMgc21hbGxlciB0aGFuIHRoYXQsIHdlIGNhbiB1c2UgdGhpcyBvcHRpbWl6YXRpb24sXG4gIC8vIG90aGVyd2lzZSB3ZSB3aWxsIHRha2UgYSBzbG93ZXIgcGF0aC5cbiAgaWYgKGxlbiA8IDY1NTM0KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICAvL1pfTUVNX0VSUk9SOiAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG4vL3ZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG4vL3ZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG5cbnZhciBaX0ZJTFRFUkVEICAgICAgICAgICAgPSAxO1xudmFyIFpfSFVGRk1BTl9PTkxZICAgICAgICA9IDI7XG52YXIgWl9STEUgICAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbi8vdmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG4vL3ZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIHZhciBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICB2YXIgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgdmFyIGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7XG4gIHZhciBzdGF0dXM7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHM7XG4gIHZhciBzdHIsIG47XG4gIHZhciB3cmFwO1xuICB2YXIgYXZhaWw7XG4gIHZhciBuZXh0O1xuICB2YXIgaW5wdXQ7XG4gIHZhciB0bXBEaWN0O1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpO1xuICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG52YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbi8vdmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG4vL3ZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbi8vdmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xudmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbnZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbnZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbnZhciAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG52YXIgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG52YXIgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xudmFyICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xudmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbnZhciAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbnZhciAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xudmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbnZhciAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG52YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbnZhciAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbnZhciAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbnZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbnZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufVxuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgd3JhcDtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHJldDtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkge1xuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xudmFyIHZpcmdpbiA9IHRydWU7XG5cbnZhciBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cbmZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7XG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICB2YXIgc3ltO1xuXG4gICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgICAgY2FzZSBIRUFEOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVElNRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAgIC8vPT09XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhUUkE6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW50IHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE5BTUU6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT01NRU5UOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEhDUkM6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRTpcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEVETzpcbiAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxhc3QgPSAoaG9sZCAmIDB4MDEpLypCSVRTKDEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgICBiaXRzIC09IDE7XG4gICAgICAgIC8vLS0tLy9cblxuICAgICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVE9SRUQ6XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFlfOlxuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZOlxuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgICAgdXRpbHMuYXJyYXlTZXQob3V0cHV0LCBpbnB1dCwgbmV4dCwgY29weSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUJMRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwMyk7Ly9CSVRTKDIpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgNyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDB4N2YpOy8vQklUUyg3KTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICAgIGJpdHMgLT0gNztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogYnVpbGQgY29kZSB0YWJsZXMgLS0gbm90ZTogZG8gbm90IGNoYW5nZSB0aGUgbGVuYml0cyBvciBkaXN0Yml0c1xuICAgICAgICAgICB2YWx1ZXMgaGVyZSAoOSBhbmQgNikgd2l0aG91dCByZWFkaW5nIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgICAgLy8tLS1cblxuICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7XG4gICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNUOlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNURVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTUFUQ0g6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5O1xuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCBcImluZmxhdGUuYyB0b28gZmFyXFxuXCIpKTtcbi8vICAgICAgICAgIGNvcHkgLT0gc3RhdGUud2hhdmU7XG4vLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4vLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbi8vICAgICAgICAgIGxlZnQgLT0gY29weTtcbi8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuLy8gICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gMDtcbi8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4vLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbi8vICAgICAgICAgIGJyZWFrO1xuLy8jZW5kaWZcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMSVQ6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBsZWZ0LS07XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDSEVDSzpcbiAgICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAvLyBVc2UgJ3wnIGluc3RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgX291dCAtPSBsZWZ0O1xuICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgICBpZiAoX291dCkge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vXG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgICAgY2FzZSBTWU5DOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5mX2xlYXZlIDwtIGhlcmUgaXMgcmVhbCBwbGFjZSBmb3IgXCJnb3RvIGluZl9sZWF2ZVwiLCBlbXVsYXRlZCB2aWEgXCJicmVhayBpbmZfbGVhdmVcIlxuXG4gIC8qXG4gICAgIFJldHVybiBmcm9tIGluZmxhdGUoKSwgdXBkYXRpbmcgdGhlIHRvdGFsIGNvdW50cyBhbmQgdGhlIGNoZWNrIHZhbHVlLlxuICAgICBJZiB0aGVyZSB3YXMgbm8gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBpbmZsYXRlKCkgY2FsbCwgcmV0dXJuIGEgYnVmZmVyXG4gICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLlxuICAgICBOb3RlOiBhIG1lbW9yeSBlcnJvciBmcm9tIGluZmxhdGUoKSBpcyBub24tcmVjb3ZlcmFibGUuXG4gICAqL1xuXG4gIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAvLy0tLVxuXG4gIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSB7XG4gICAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIH1cbiAgfVxuICBfaW4gLT0gc3RybS5hdmFpbF9pbjtcbiAgX291dCAtPSBzdHJtLmF2YWlsX291dDtcbiAgc3RybS50b3RhbF9pbiArPSBfaW47XG4gIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHtcbiAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAvKlVQREFURShzdGF0ZS5jaGVjaywgc3RybS5uZXh0X291dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7XG4gIH1cbiAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7XG4gIGlmICgoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwKSB8fCBmbHVzaCA9PT0gWl9GSU5JU0gpICYmIHJldCA9PT0gWl9PSykge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzdGF0ZTtcbiAgdmFyIGRpY3RpZDtcbiAgdmFyIHJldDtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gLyogPT0gWl9OVUxMICovIHx8ICFzdHJtLnN0YXRlIC8qID09IFpfTlVMTCAqLykgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgfVxuICBzdGF0ZS5oYXZlZGljdCA9IDE7XG4gIC8vIFRyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgZGljdGlvbmFyeSBzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7XG5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xuZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7XG5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xuZXhwb3J0cy5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbnZhciBsYmFzZSA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl07XG5cbnZhciBsZXh0ID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl07XG5cbnZhciBkYmFzZSA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXTtcblxudmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpXG57XG4gIHZhciBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICB2YXIgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICB2YXIgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgdmFyIG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIHZhciByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIHZhciBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIHZhciBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgdmFyIGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICB2YXIgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICB2YXIgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgdmFyIGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIHZhciBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgdmFyIGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIHZhciBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgdmFyIGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGJhc2VfaW5kZXggPSAwO1xuLy8gIHZhciBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICB2YXIgZXh0cmEgPSBudWxsO1xuICB2YXIgZXh0cmFfaW5kZXggPSAwO1xuXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtdW5hcnktb3BzICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL3ZhciBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy92YXIgWl9STEUgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbi8vdmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG52YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbnZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbnZhciBTVE9SRURfQkxPQ0sgPSAwO1xudmFyIFNUQVRJQ19UUkVFUyA9IDE7XG52YXIgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbnZhciBNSU5fTUFUQ0ggICAgPSAzO1xudmFyIE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG52YXIgTUFYX0JJVFMgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG52YXIgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbnZhciBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG52YXIgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF07XG5cbnZhciBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXTtcblxudmFyIGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN107XG5cbnZhciBibF9vcmRlciA9XG4gIFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtcbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbnZhciBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnN0ZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbnZhciBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxudmFyIHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpO1xuemVybyhzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG52YXIgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8oX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG52YXIgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTtcbnplcm8oYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyk7XG56ZXJvKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbmZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn1cblxuXG52YXIgc3RhdGljX2xfZGVzYztcbnZhciBzdGF0aWNfZF9kZXNjO1xudmFyIHN0YXRpY19ibF9kZXNjO1xuXG5cbmZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn1cblxuXG5cbmZ1bmN0aW9uIGRfY29kZShkaXN0KSB7XG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5mdW5jdGlvbiBwdXRfc2hvcnQocywgdykge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkge1xuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0vKi5Db2RlKi8sIHRyZWVbYyAqIDIgKyAxXS8qLkxlbiovKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5mdW5jdGlvbiBiaV9mbHVzaChzKSB7XG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICB2YXIgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICB2YXIgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgdmFyIG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIHZhciBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICB2YXIgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgdmFyIHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIHZhciBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIHZhciBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudClcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICB2YXIgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7XG4gIHZhciBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgdmFyIGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgdmFyIGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIHZhciBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7XG4gIHZhciBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBiaV93aW5kdXAocylcbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgICAgKmJ1ZjsgICAgLyogdGhlIGlucHV0IGRhdGEgKi9cbi8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqL1xuLy9pbnQgICAgICBoZWFkZXI7ICAvKiB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW4gKi9cbntcbiAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbi8vICB3aGlsZSAobGVuLS0pIHtcbi8vICAgIHB1dF9ieXRlKHMsICpidWYrKyk7XG4vLyAgfVxuICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XG4gIHZhciBfbjIgPSBuICogMjtcbiAgdmFyIF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5mdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIHZhciB2ID0gcy5oZWFwW2tdO1xuICB2YXIgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gdmFyIFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIHZhciBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgdmFyIGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIHZhciBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICB2YXIgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICB2YXIgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgdmFyIG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB2YXIgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIC8qIHRyZWVbbWF4X2NvZGUrMV0uTGVuID0gLTE7ICovICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5mdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHtcbiAgdmFyIG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7XG4gIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpO1xuXG4gIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWU6ICovXG4gIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTtcbiAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxuICAgKiB0aGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aHMgY29kZXMgYW5kIHRoZSA1KzUrNCBiaXRzIGZvciB0aGUgY291bnRzLlxuICAgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcbiAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcbiAgICogMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuICAgKi9cbiAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5mdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2Rlcylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIHZhciByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgdmFyIGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICB2YXIgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufVxuXG5cbnZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBfdHJfaW5pdChzKVxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIF90cl9hbGlnbihzKSB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOyAgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICB2YXIgbWF4X2JsaW5kZXggPSAwOyAgICAgICAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWQgKi9cbiAgaWYgKHMubGV2ZWwgPiAwKSB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqL1xuICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5sYXN0X2xpdCkpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy92YXIgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59XG5cbmV4cG9ydHMuX3RyX2luaXQgID0gX3RyX2luaXQ7XG5leHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrO1xuZXhwb3J0cy5fdHJfZmx1c2hfYmxvY2sgID0gX3RyX2ZsdXNoX2Jsb2NrO1xuZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7XG5leHBvcnRzLl90cl9hbGlnbiA9IF90cl9hbGlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFpTdHJlYW07XG4iLCIvLyAncGF0aCcgbW9kdWxlIGV4dHJhY3RlZCBmcm9tIE5vZGUuanMgdjguMTEuMSAob25seSB0aGUgcG9zaXggcGFydClcbi8vIHRyYW5zcGxpdGVkIHdpdGggQmFiZWxcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzZXJ0UGF0aChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICcgKyBKU09OLnN0cmluZ2lmeShwYXRoKSk7XG4gIH1cbn1cblxuLy8gUmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIHdpdGggZGlyZWN0b3J5IG5hbWVzXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdQb3NpeChwYXRoLCBhbGxvd0Fib3ZlUm9vdCkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gIHZhciBsYXN0U2xhc2ggPSAtMTtcbiAgdmFyIGRvdHMgPSAwO1xuICB2YXIgY29kZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcGF0aC5sZW5ndGg7ICsraSkge1xuICAgIGlmIChpIDwgcGF0aC5sZW5ndGgpXG4gICAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGVsc2UgaWYgKGNvZGUgPT09IDQ3IC8qLyovKVxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgY29kZSA9IDQ3IC8qLyovO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gaSAtIDEgfHwgZG90cyA9PT0gMSkge1xuICAgICAgICAvLyBOT09QXG4gICAgICB9IGVsc2UgaWYgKGxhc3RTbGFzaCAhPT0gaSAtIDEgJiYgZG90cyA9PT0gMikge1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA8IDIgfHwgbGFzdFNlZ21lbnRMZW5ndGggIT09IDIgfHwgcmVzLmNoYXJDb2RlQXQocmVzLmxlbmd0aCAtIDEpICE9PSA0NiAvKi4qLyB8fCByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMikgIT09IDQ2IC8qLiovKSB7XG4gICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgbGFzdFNsYXNoSW5kZXggPSByZXMubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCAhPT0gcmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJlcyA9ICcnO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuc2xpY2UoMCwgbGFzdFNsYXNoSW5kZXgpO1xuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gcmVzLmxlbmd0aCAtIDEgLSByZXMubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgICBkb3RzID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXMubGVuZ3RoID09PSAyIHx8IHJlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJlcyA9ICcnO1xuICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgICAgICAgIGlmIChyZXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJlcyArPSAnLy4uJztcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXMgPSAnLi4nO1xuICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgIHJlcyArPSAnLycgKyBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmVzID0gcGF0aC5zbGljZShsYXN0U2xhc2ggKyAxLCBpKTtcbiAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSBpIC0gbGFzdFNsYXNoIC0gMTtcbiAgICAgIH1cbiAgICAgIGxhc3RTbGFzaCA9IGk7XG4gICAgICBkb3RzID0gMDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDQ2IC8qLiovICYmIGRvdHMgIT09IC0xKSB7XG4gICAgICArK2RvdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvdHMgPSAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gX2Zvcm1hdChzZXAsIHBhdGhPYmplY3QpIHtcbiAgdmFyIGRpciA9IHBhdGhPYmplY3QuZGlyIHx8IHBhdGhPYmplY3Qucm9vdDtcbiAgdmFyIGJhc2UgPSBwYXRoT2JqZWN0LmJhc2UgfHwgKHBhdGhPYmplY3QubmFtZSB8fCAnJykgKyAocGF0aE9iamVjdC5leHQgfHwgJycpO1xuICBpZiAoIWRpcikge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGlmIChkaXIgPT09IHBhdGhPYmplY3Qucm9vdCkge1xuICAgIHJldHVybiBkaXIgKyBiYXNlO1xuICB9XG4gIHJldHVybiBkaXIgKyBzZXAgKyBiYXNlO1xufVxuXG52YXIgcG9zaXggPSB7XG4gIC8vIHBhdGgucmVzb2x2ZShbZnJvbSAuLi5dLCB0bylcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICB2YXIgcmVzb2x2ZWRQYXRoID0gJyc7XG4gICAgdmFyIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcbiAgICB2YXIgY3dkO1xuXG4gICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICAgIHZhciBwYXRoO1xuICAgICAgaWYgKGkgPj0gMClcbiAgICAgICAgcGF0aCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoY3dkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgY3dkID0gcHJvY2Vzcy5jd2QoKTtcbiAgICAgICAgcGF0aCA9IGN3ZDtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgICAgLy8gU2tpcCBlbXB0eSBlbnRyaWVzXG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gICAgLy8gaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKCkgZmFpbHMpXG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVTdHJpbmdQb3NpeChyZXNvbHZlZFBhdGgsICFyZXNvbHZlZEFic29sdXRlKTtcblxuICAgIGlmIChyZXNvbHZlZEFic29sdXRlKSB7XG4gICAgICBpZiAocmVzb2x2ZWRQYXRoLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAnLyc7XG4gICAgfSBlbHNlIGlmIChyZXNvbHZlZFBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkUGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcuJztcbiAgICB9XG4gIH0sXG5cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUocGF0aCkge1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG5cbiAgICB2YXIgaXNBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyovKi87XG4gICAgdmFyIHRyYWlsaW5nU2VwYXJhdG9yID0gcGF0aC5jaGFyQ29kZUF0KHBhdGgubGVuZ3RoIC0gMSkgPT09IDQ3IC8qLyovO1xuXG4gICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gICAgcGF0aCA9IG5vcm1hbGl6ZVN0cmluZ1Bvc2l4KHBhdGgsICFpc0Fic29sdXRlKTtcblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCAmJiAhaXNBYnNvbHV0ZSkgcGF0aCA9ICcuJztcbiAgICBpZiAocGF0aC5sZW5ndGggPiAwICYmIHRyYWlsaW5nU2VwYXJhdG9yKSBwYXRoICs9ICcvJztcblxuICAgIGlmIChpc0Fic29sdXRlKSByZXR1cm4gJy8nICsgcGF0aDtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICBpc0Fic29sdXRlOiBmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA+IDAgJiYgcGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKi8qLztcbiAgfSxcblxuICBqb2luOiBmdW5jdGlvbiBqb2luKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuICcuJztcbiAgICB2YXIgam9pbmVkO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuICAgICAgYXNzZXJ0UGF0aChhcmcpO1xuICAgICAgaWYgKGFyZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICBqb2luZWQgPSBhcmc7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBqb2luZWQgKz0gJy8nICsgYXJnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm4gJy4nO1xuICAgIHJldHVybiBwb3NpeC5ub3JtYWxpemUoam9pbmVkKTtcbiAgfSxcblxuICByZWxhdGl2ZTogZnVuY3Rpb24gcmVsYXRpdmUoZnJvbSwgdG8pIHtcbiAgICBhc3NlcnRQYXRoKGZyb20pO1xuICAgIGFzc2VydFBhdGgodG8pO1xuXG4gICAgaWYgKGZyb20gPT09IHRvKSByZXR1cm4gJyc7XG5cbiAgICBmcm9tID0gcG9zaXgucmVzb2x2ZShmcm9tKTtcbiAgICB0byA9IHBvc2l4LnJlc29sdmUodG8pO1xuXG4gICAgaWYgKGZyb20gPT09IHRvKSByZXR1cm4gJyc7XG5cbiAgICAvLyBUcmltIGFueSBsZWFkaW5nIGJhY2tzbGFzaGVzXG4gICAgdmFyIGZyb21TdGFydCA9IDE7XG4gICAgZm9yICg7IGZyb21TdGFydCA8IGZyb20ubGVuZ3RoOyArK2Zyb21TdGFydCkge1xuICAgICAgaWYgKGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQpICE9PSA0NyAvKi8qLylcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBmcm9tRW5kID0gZnJvbS5sZW5ndGg7XG4gICAgdmFyIGZyb21MZW4gPSBmcm9tRW5kIC0gZnJvbVN0YXJ0O1xuXG4gICAgLy8gVHJpbSBhbnkgbGVhZGluZyBiYWNrc2xhc2hlc1xuICAgIHZhciB0b1N0YXJ0ID0gMTtcbiAgICBmb3IgKDsgdG9TdGFydCA8IHRvLmxlbmd0aDsgKyt0b1N0YXJ0KSB7XG4gICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0KSAhPT0gNDcgLyovKi8pXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgdG9FbmQgPSB0by5sZW5ndGg7XG4gICAgdmFyIHRvTGVuID0gdG9FbmQgLSB0b1N0YXJ0O1xuXG4gICAgLy8gQ29tcGFyZSBwYXRocyB0byBmaW5kIHRoZSBsb25nZXN0IGNvbW1vbiBwYXRoIGZyb20gcm9vdFxuICAgIHZhciBsZW5ndGggPSBmcm9tTGVuIDwgdG9MZW4gPyBmcm9tTGVuIDogdG9MZW47XG4gICAgdmFyIGxhc3RDb21tb25TZXAgPSAtMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPD0gbGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChpID09PSBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHRvTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGB0b2AuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nL2Zvby9iYXInOyB0bz0nL2Zvby9iYXIvYmF6J1xuICAgICAgICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQgKyBpICsgMSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIHJvb3RcbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvJzsgdG89Jy9mb28nXG4gICAgICAgICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCArIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmcm9tTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYGZyb21gLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyL2Jheic7IHRvPScvZm9vL2JhcidcbiAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgcm9vdC5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vJzsgdG89Jy8nXG4gICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB2YXIgZnJvbUNvZGUgPSBmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSk7XG4gICAgICB2YXIgdG9Db2RlID0gdG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSk7XG4gICAgICBpZiAoZnJvbUNvZGUgIT09IHRvQ29kZSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBlbHNlIGlmIChmcm9tQ29kZSA9PT0gNDcgLyovKi8pXG4gICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgIH1cblxuICAgIHZhciBvdXQgPSAnJztcbiAgICAvLyBHZW5lcmF0ZSB0aGUgcmVsYXRpdmUgcGF0aCBiYXNlZCBvbiB0aGUgcGF0aCBkaWZmZXJlbmNlIGJldHdlZW4gYHRvYFxuICAgIC8vIGFuZCBgZnJvbWBcbiAgICBmb3IgKGkgPSBmcm9tU3RhcnQgKyBsYXN0Q29tbW9uU2VwICsgMTsgaSA8PSBmcm9tRW5kOyArK2kpIHtcbiAgICAgIGlmIChpID09PSBmcm9tRW5kIHx8IGZyb20uY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgaWYgKG91dC5sZW5ndGggPT09IDApXG4gICAgICAgICAgb3V0ICs9ICcuLic7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBvdXQgKz0gJy8uLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTGFzdGx5LCBhcHBlbmQgdGhlIHJlc3Qgb2YgdGhlIGRlc3RpbmF0aW9uIChgdG9gKSBwYXRoIHRoYXQgY29tZXMgYWZ0ZXJcbiAgICAvLyB0aGUgY29tbW9uIHBhdGggcGFydHNcbiAgICBpZiAob3V0Lmxlbmd0aCA+IDApXG4gICAgICByZXR1cm4gb3V0ICsgdG8uc2xpY2UodG9TdGFydCArIGxhc3RDb21tb25TZXApO1xuICAgIGVsc2Uge1xuICAgICAgdG9TdGFydCArPSBsYXN0Q29tbW9uU2VwO1xuICAgICAgaWYgKHRvLmNoYXJDb2RlQXQodG9TdGFydCkgPT09IDQ3IC8qLyovKVxuICAgICAgICArK3RvU3RhcnQ7XG4gICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCk7XG4gICAgfVxuICB9LFxuXG4gIF9tYWtlTG9uZzogZnVuY3Rpb24gX21ha2VMb25nKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfSxcblxuICBkaXJuYW1lOiBmdW5jdGlvbiBkaXJuYW1lKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcuJztcbiAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgaGFzUm9vdCA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7XG4gICAgaWYgKGhhc1Jvb3QgJiYgZW5kID09PSAxKSByZXR1cm4gJy8vJztcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xuICB9LFxuXG4gIGJhc2VuYW1lOiBmdW5jdGlvbiBiYXNlbmFtZShwYXRoLCBleHQpIHtcbiAgICBpZiAoZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGV4dCAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIGFzc2VydFBhdGgocGF0aCk7XG5cbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCAmJiBleHQubGVuZ3RoID4gMCAmJiBleHQubGVuZ3RoIDw9IHBhdGgubGVuZ3RoKSB7XG4gICAgICBpZiAoZXh0Lmxlbmd0aCA9PT0gcGF0aC5sZW5ndGggJiYgZXh0ID09PSBwYXRoKSByZXR1cm4gJyc7XG4gICAgICB2YXIgZXh0SWR4ID0gZXh0Lmxlbmd0aCAtIDE7XG4gICAgICB2YXIgZmlyc3ROb25TbGFzaEVuZCA9IC0xO1xuICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChmaXJzdE5vblNsYXNoRW5kID09PSAtMSkge1xuICAgICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIHJlbWVtYmVyIHRoaXMgaW5kZXggaW4gY2FzZVxuICAgICAgICAgICAgLy8gd2UgbmVlZCBpdCBpZiB0aGUgZXh0ZW5zaW9uIGVuZHMgdXAgbm90IG1hdGNoaW5nXG4gICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGZpcnN0Tm9uU2xhc2hFbmQgPSBpICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4dElkeCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGV4cGxpY2l0IGV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4dC5jaGFyQ29kZUF0KGV4dElkeCkpIHtcbiAgICAgICAgICAgICAgaWYgKC0tZXh0SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIGV4dGVuc2lvbiwgc28gbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBFeHRlbnNpb24gZG9lcyBub3QgbWF0Y2gsIHNvIG91ciByZXN1bHQgaXMgdGhlIGVudGlyZSBwYXRoXG4gICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICBleHRJZHggPSAtMTtcbiAgICAgICAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7ZWxzZSBpZiAoZW5kID09PSAtMSkgZW5kID0gcGF0aC5sZW5ndGg7XG4gICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSA0NyAvKi8qLykge1xuICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgICAgIC8vIHBhdGggY29tcG9uZW50XG4gICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfSxcblxuICBleHRuYW1lOiBmdW5jdGlvbiBleHRuYW1lKHBhdGgpIHtcbiAgICBhc3NlcnRQYXRoKHBhdGgpO1xuICAgIHZhciBzdGFydERvdCA9IC0xO1xuICAgIHZhciBzdGFydFBhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKVxuICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgfSxcblxuICBmb3JtYXQ6IGZ1bmN0aW9uIGZvcm1hdChwYXRoT2JqZWN0KSB7XG4gICAgaWYgKHBhdGhPYmplY3QgPT09IG51bGwgfHwgdHlwZW9mIHBhdGhPYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJwYXRoT2JqZWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHBhdGhPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gX2Zvcm1hdCgnLycsIHBhdGhPYmplY3QpO1xuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbiBwYXJzZShwYXRoKSB7XG4gICAgYXNzZXJ0UGF0aChwYXRoKTtcblxuICAgIHZhciByZXQgPSB7IHJvb3Q6ICcnLCBkaXI6ICcnLCBiYXNlOiAnJywgZXh0OiAnJywgbmFtZTogJycgfTtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiByZXQ7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGlzQWJzb2x1dGUgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgICB2YXIgc3RhcnQ7XG4gICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgIHJldC5yb290ID0gJy8nO1xuICAgICAgc3RhcnQgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHZhciBzdGFydERvdCA9IC0xO1xuICAgIHZhciBzdGFydFBhcnQgPSAwO1xuICAgIHZhciBlbmQgPSAtMTtcbiAgICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTtcblxuICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG5cbiAgICAvLyBHZXQgbm9uLWRpciBpbmZvXG4gICAgZm9yICg7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgIC8vIGV4dGVuc2lvblxuICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKSBzdGFydERvdCA9IGk7ZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpIHByZURvdFN0YXRlID0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdFxuICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7XG4gICAgICBpZiAoZW5kICE9PSAtMSkge1xuICAgICAgICBpZiAoc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUpIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKDEsIGVuZCk7ZWxzZSByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGFydFBhcnQgPT09IDAgJiYgaXNBYnNvbHV0ZSkge1xuICAgICAgICByZXQubmFtZSA9IHBhdGguc2xpY2UoMSwgc3RhcnREb3QpO1xuICAgICAgICByZXQuYmFzZSA9IHBhdGguc2xpY2UoMSwgZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5uYW1lID0gcGF0aC5zbGljZShzdGFydFBhcnQsIHN0YXJ0RG90KTtcbiAgICAgICAgcmV0LmJhc2UgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgZW5kKTtcbiAgICAgIH1cbiAgICAgIHJldC5leHQgPSBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICAgIH1cblxuICAgIGlmIChzdGFydFBhcnQgPiAwKSByZXQuZGlyID0gcGF0aC5zbGljZSgwLCBzdGFydFBhcnQgLSAxKTtlbHNlIGlmIChpc0Fic29sdXRlKSByZXQuZGlyID0gJy8nO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICBzZXA6ICcvJyxcbiAgZGVsaW1pdGVyOiAnOicsXG4gIHdpbjMyOiBudWxsLFxuICBwb3NpeDogbnVsbFxufTtcblxucG9zaXgucG9zaXggPSBwb3NpeDtcblxubW9kdWxlLmV4cG9ydHMgPSBwb3NpeDtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcHJvY2Vzc0ZuID0gKGZuLCBvcHRpb25zKSA9PiBmdW5jdGlvbiAoLi4uYXJncykge1xuXHRjb25zdCBQID0gb3B0aW9ucy5wcm9taXNlTW9kdWxlO1xuXG5cdHJldHVybiBuZXcgUCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0aWYgKG9wdGlvbnMubXVsdGlBcmdzKSB7XG5cdFx0XHRhcmdzLnB1c2goKC4uLnJlc3VsdCkgPT4ge1xuXHRcdFx0XHRpZiAob3B0aW9ucy5lcnJvckZpcnN0KSB7XG5cdFx0XHRcdFx0aWYgKHJlc3VsdFswXSkge1xuXHRcdFx0XHRcdFx0cmVqZWN0KHJlc3VsdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc3VsdC5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAob3B0aW9ucy5lcnJvckZpcnN0KSB7XG5cdFx0XHRhcmdzLnB1c2goKGVycm9yLCByZXN1bHQpID0+IHtcblx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcmdzLnB1c2gocmVzb2x2ZSk7XG5cdFx0fVxuXG5cdFx0Zm4uYXBwbHkodGhpcywgYXJncyk7XG5cdH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoaW5wdXQsIG9wdGlvbnMpID0+IHtcblx0b3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGV4Y2x1ZGU6IFsvLisoU3luY3xTdHJlYW0pJC9dLFxuXHRcdGVycm9yRmlyc3Q6IHRydWUsXG5cdFx0cHJvbWlzZU1vZHVsZTogUHJvbWlzZVxuXHR9LCBvcHRpb25zKTtcblxuXHRjb25zdCBvYmpUeXBlID0gdHlwZW9mIGlucHV0O1xuXHRpZiAoIShpbnB1dCAhPT0gbnVsbCAmJiAob2JqVHlwZSA9PT0gJ29iamVjdCcgfHwgb2JqVHlwZSA9PT0gJ2Z1bmN0aW9uJykpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgXFxgaW5wdXRcXGAgdG8gYmUgYSBcXGBGdW5jdGlvblxcYCBvciBcXGBPYmplY3RcXGAsIGdvdCBcXGAke2lucHV0ID09PSBudWxsID8gJ251bGwnIDogb2JqVHlwZX1cXGBgKTtcblx0fVxuXG5cdGNvbnN0IGZpbHRlciA9IGtleSA9PiB7XG5cdFx0Y29uc3QgbWF0Y2ggPSBwYXR0ZXJuID0+IHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJyA/IGtleSA9PT0gcGF0dGVybiA6IHBhdHRlcm4udGVzdChrZXkpO1xuXHRcdHJldHVybiBvcHRpb25zLmluY2x1ZGUgPyBvcHRpb25zLmluY2x1ZGUuc29tZShtYXRjaCkgOiAhb3B0aW9ucy5leGNsdWRlLnNvbWUobWF0Y2gpO1xuXHR9O1xuXG5cdGxldCByZXQ7XG5cdGlmIChvYmpUeXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRcdHJldHVybiBvcHRpb25zLmV4Y2x1ZGVNYWluID8gaW5wdXQoLi4uYXJncykgOiBwcm9jZXNzRm4oaW5wdXQsIG9wdGlvbnMpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpKTtcblx0fVxuXG5cdGZvciAoY29uc3Qga2V5IGluIGlucHV0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ3VhcmQtZm9yLWluXG5cdFx0Y29uc3QgcHJvcGVydHkgPSBpbnB1dFtrZXldO1xuXHRcdHJldFtrZXldID0gdHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIGZpbHRlcihrZXkpID8gcHJvY2Vzc0ZuKHByb3BlcnR5LCBvcHRpb25zKSA6IHByb3BlcnR5O1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG4iLCIvKiEgc2FmZS1idWZmZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpXG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwidmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG5cbi8vIHByb3RvdHlwZSBjbGFzcyBmb3IgaGFzaCBmdW5jdGlvbnNcbmZ1bmN0aW9uIEhhc2ggKGJsb2NrU2l6ZSwgZmluYWxTaXplKSB7XG4gIHRoaXMuX2Jsb2NrID0gQnVmZmVyLmFsbG9jKGJsb2NrU2l6ZSlcbiAgdGhpcy5fZmluYWxTaXplID0gZmluYWxTaXplXG4gIHRoaXMuX2Jsb2NrU2l6ZSA9IGJsb2NrU2l6ZVxuICB0aGlzLl9sZW4gPSAwXG59XG5cbkhhc2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhLCBlbmMpIHtcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIGVuYyA9IGVuYyB8fCAndXRmOCdcbiAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgZW5jKVxuICB9XG5cbiAgdmFyIGJsb2NrID0gdGhpcy5fYmxvY2tcbiAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuX2Jsb2NrU2l6ZVxuICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGhcbiAgdmFyIGFjY3VtID0gdGhpcy5fbGVuXG5cbiAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbGVuZ3RoOykge1xuICAgIHZhciBhc3NpZ25lZCA9IGFjY3VtICUgYmxvY2tTaXplXG4gICAgdmFyIHJlbWFpbmRlciA9IE1hdGgubWluKGxlbmd0aCAtIG9mZnNldCwgYmxvY2tTaXplIC0gYXNzaWduZWQpXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbWFpbmRlcjsgaSsrKSB7XG4gICAgICBibG9ja1thc3NpZ25lZCArIGldID0gZGF0YVtvZmZzZXQgKyBpXVxuICAgIH1cblxuICAgIGFjY3VtICs9IHJlbWFpbmRlclxuICAgIG9mZnNldCArPSByZW1haW5kZXJcblxuICAgIGlmICgoYWNjdW0gJSBibG9ja1NpemUpID09PSAwKSB7XG4gICAgICB0aGlzLl91cGRhdGUoYmxvY2spXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fbGVuICs9IGxlbmd0aFxuICByZXR1cm4gdGhpc1xufVxuXG5IYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHZhciByZW0gPSB0aGlzLl9sZW4gJSB0aGlzLl9ibG9ja1NpemVcblxuICB0aGlzLl9ibG9ja1tyZW1dID0gMHg4MFxuXG4gIC8vIHplcm8gKHJlbSArIDEpIHRyYWlsaW5nIGJpdHMsIHdoZXJlIChyZW0gKyAxKSBpcyB0aGUgc21hbGxlc3RcbiAgLy8gbm9uLW5lZ2F0aXZlIHNvbHV0aW9uIHRvIHRoZSBlcXVhdGlvbiAobGVuZ3RoICsgMSArIChyZW0gKyAxKSkgPT09IGZpbmFsU2l6ZSBtb2QgYmxvY2tTaXplXG4gIHRoaXMuX2Jsb2NrLmZpbGwoMCwgcmVtICsgMSlcblxuICBpZiAocmVtID49IHRoaXMuX2ZpbmFsU2l6ZSkge1xuICAgIHRoaXMuX3VwZGF0ZSh0aGlzLl9ibG9jaylcbiAgICB0aGlzLl9ibG9jay5maWxsKDApXG4gIH1cblxuICB2YXIgYml0cyA9IHRoaXMuX2xlbiAqIDhcblxuICAvLyB1aW50MzJcbiAgaWYgKGJpdHMgPD0gMHhmZmZmZmZmZikge1xuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUoYml0cywgdGhpcy5fYmxvY2tTaXplIC0gNClcblxuICAvLyB1aW50NjRcbiAgfSBlbHNlIHtcbiAgICB2YXIgbG93Qml0cyA9IChiaXRzICYgMHhmZmZmZmZmZikgPj4+IDBcbiAgICB2YXIgaGlnaEJpdHMgPSAoYml0cyAtIGxvd0JpdHMpIC8gMHgxMDAwMDAwMDBcblxuICAgIHRoaXMuX2Jsb2NrLndyaXRlVUludDMyQkUoaGlnaEJpdHMsIHRoaXMuX2Jsb2NrU2l6ZSAtIDgpXG4gICAgdGhpcy5fYmxvY2sud3JpdGVVSW50MzJCRShsb3dCaXRzLCB0aGlzLl9ibG9ja1NpemUgLSA0KVxuICB9XG5cbiAgdGhpcy5fdXBkYXRlKHRoaXMuX2Jsb2NrKVxuICB2YXIgaGFzaCA9IHRoaXMuX2hhc2goKVxuXG4gIHJldHVybiBlbmMgPyBoYXNoLnRvU3RyaW5nKGVuYykgOiBoYXNoXG59XG5cbkhhc2gucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3VwZGF0ZSBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoXG4iLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXG4gKiBpbiBGSVBTIFBVQiAxODAtMVxuICogVmVyc2lvbiAyLjFhIENvcHlyaWdodCBQYXVsIEpvaG5zdG9uIDIwMDAgLSAyMDAyLlxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgZGV0YWlscy5cbiAqL1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgSGFzaCA9IHJlcXVpcmUoJy4vaGFzaCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxudmFyIEsgPSBbXG4gIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMgfCAwLCAweGNhNjJjMWQ2IHwgMFxuXVxuXG52YXIgVyA9IG5ldyBBcnJheSg4MClcblxuZnVuY3Rpb24gU2hhMSAoKSB7XG4gIHRoaXMuaW5pdCgpXG4gIHRoaXMuX3cgPSBXXG5cbiAgSGFzaC5jYWxsKHRoaXMsIDY0LCA1Nilcbn1cblxuaW5oZXJpdHMoU2hhMSwgSGFzaClcblxuU2hhMS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fYSA9IDB4Njc0NTIzMDFcbiAgdGhpcy5fYiA9IDB4ZWZjZGFiODlcbiAgdGhpcy5fYyA9IDB4OThiYWRjZmVcbiAgdGhpcy5fZCA9IDB4MTAzMjU0NzZcbiAgdGhpcy5fZSA9IDB4YzNkMmUxZjBcblxuICByZXR1cm4gdGhpc1xufVxuXG5mdW5jdGlvbiByb3RsMSAobnVtKSB7XG4gIHJldHVybiAobnVtIDw8IDEpIHwgKG51bSA+Pj4gMzEpXG59XG5cbmZ1bmN0aW9uIHJvdGw1IChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgNSkgfCAobnVtID4+PiAyNylcbn1cblxuZnVuY3Rpb24gcm90bDMwIChudW0pIHtcbiAgcmV0dXJuIChudW0gPDwgMzApIHwgKG51bSA+Pj4gMilcbn1cblxuZnVuY3Rpb24gZnQgKHMsIGIsIGMsIGQpIHtcbiAgaWYgKHMgPT09IDApIHJldHVybiAoYiAmIGMpIHwgKCh+YikgJiBkKVxuICBpZiAocyA9PT0gMikgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKVxuICByZXR1cm4gYiBeIGMgXiBkXG59XG5cblNoYTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiAoTSkge1xuICB2YXIgVyA9IHRoaXMuX3dcblxuICB2YXIgYSA9IHRoaXMuX2EgfCAwXG4gIHZhciBiID0gdGhpcy5fYiB8IDBcbiAgdmFyIGMgPSB0aGlzLl9jIHwgMFxuICB2YXIgZCA9IHRoaXMuX2QgfCAwXG4gIHZhciBlID0gdGhpcy5fZSB8IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIFdbaV0gPSBNLnJlYWRJbnQzMkJFKGkgKiA0KVxuICBmb3IgKDsgaSA8IDgwOyArK2kpIFdbaV0gPSByb3RsMShXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdKVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgODA7ICsraikge1xuICAgIHZhciBzID0gfn4oaiAvIDIwKVxuICAgIHZhciB0ID0gKHJvdGw1KGEpICsgZnQocywgYiwgYywgZCkgKyBlICsgV1tqXSArIEtbc10pIHwgMFxuXG4gICAgZSA9IGRcbiAgICBkID0gY1xuICAgIGMgPSByb3RsMzAoYilcbiAgICBiID0gYVxuICAgIGEgPSB0XG4gIH1cblxuICB0aGlzLl9hID0gKGEgKyB0aGlzLl9hKSB8IDBcbiAgdGhpcy5fYiA9IChiICsgdGhpcy5fYikgfCAwXG4gIHRoaXMuX2MgPSAoYyArIHRoaXMuX2MpIHwgMFxuICB0aGlzLl9kID0gKGQgKyB0aGlzLl9kKSB8IDBcbiAgdGhpcy5fZSA9IChlICsgdGhpcy5fZSkgfCAwXG59XG5cblNoYTEucHJvdG90eXBlLl9oYXNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgSCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyMClcblxuICBILndyaXRlSW50MzJCRSh0aGlzLl9hIHwgMCwgMClcbiAgSC53cml0ZUludDMyQkUodGhpcy5fYiB8IDAsIDQpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2MgfCAwLCA4KVxuICBILndyaXRlSW50MzJCRSh0aGlzLl9kIHwgMCwgMTIpXG4gIEgud3JpdGVJbnQzMkJFKHRoaXMuX2UgfCAwLCAxNilcblxuICByZXR1cm4gSFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYTFcbiIsImV4cG9ydCB7IGRlZmF1bHQgYXMgdjEgfSBmcm9tICcuL3YxLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjMgfSBmcm9tICcuL3YzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjQgfSBmcm9tICcuL3Y0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjUgfSBmcm9tICcuL3Y1LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTklMIH0gZnJvbSAnLi9uaWwuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmFsaWRhdGUgfSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJzZSB9IGZyb20gJy4vcGFyc2UuanMnOyIsIi8qXG4gKiBCcm93c2VyLWNvbXBhdGlibGUgSmF2YVNjcmlwdCBNRDVcbiAqXG4gKiBNb2RpZmljYXRpb24gb2YgSmF2YVNjcmlwdCBNRDVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTUQ1XG4gKlxuICogQ29weXJpZ2h0IDIwMTEsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIEJhc2VkIG9uXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxuICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDA5XG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cbmZ1bmN0aW9uIG1kNShieXRlcykge1xuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIHZhciBtc2cgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYnl0ZXMpKTsgLy8gVVRGOCBlc2NhcGVcblxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobXNnLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXNbaV0gPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWQ1VG9IZXhFbmNvZGVkQXJyYXkod29yZHNUb01kNShieXRlc1RvV29yZHMoYnl0ZXMpLCBieXRlcy5sZW5ndGggKiA4KSk7XG59XG4vKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGFuIGFycmF5IG9mIGJ5dGVzXG4gKi9cblxuXG5mdW5jdGlvbiBtZDVUb0hleEVuY29kZWRBcnJheShpbnB1dCkge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIHZhciBsZW5ndGgzMiA9IGlucHV0Lmxlbmd0aCAqIDMyO1xuICB2YXIgaGV4VGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMzI7IGkgKz0gOCkge1xuICAgIHZhciB4ID0gaW5wdXRbaSA+PiA1XSA+Pj4gaSAlIDMyICYgMHhmZjtcbiAgICB2YXIgaGV4ID0gcGFyc2VJbnQoaGV4VGFiLmNoYXJBdCh4ID4+PiA0ICYgMHgwZikgKyBoZXhUYWIuY2hhckF0KHggJiAweDBmKSwgMTYpO1xuICAgIG91dHB1dC5wdXNoKGhleCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgb3V0cHV0IGxlbmd0aCB3aXRoIHBhZGRpbmcgYW5kIGJpdCBsZW5ndGhcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE91dHB1dExlbmd0aChpbnB1dExlbmd0aDgpIHtcbiAgcmV0dXJuIChpbnB1dExlbmd0aDggKyA2NCA+Pj4gOSA8PCA0KSArIDE0ICsgMTtcbn1cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuICovXG5cblxuZnVuY3Rpb24gd29yZHNUb01kNSh4LCBsZW4pIHtcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCBsZW4gJSAzMjtcbiAgeFtnZXRPdXRwdXRMZW5ndGgobGVuKSAtIDFdID0gbGVuO1xuICB2YXIgYSA9IDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAyNzE3MzM4Nzg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpXSwgNywgLTY4MDg3NjkzNik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNywgNjA2MTA1ODE5KTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA3LCAtMTc2NDE4ODk3KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgNV0sIDEyLCAxMjAwMDgwNDI2KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgOF0sIDcsIDE3NzAwMzU0MTYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNywgLTQyMDYzKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDcsIDE4MDQ2MDM2ODIpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDE1XSwgMjIsIDEyMzY1MzUzMjkpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNSwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDZdLCA5LCAtMTA2OTUwMTYzMik7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTQsIDY0MzcxNzcxMyk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaV0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgNV0sIDUsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxMF0sIDksIDM4MDE2MDgzKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDldLCA1LCA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxNF0sIDksIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgOF0sIDIwLCAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMTNdLCA1LCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDJdLCA5LCAtNTE0MDM3ODQpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTQsIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyAxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA0LCAtMzc4NTU4KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTYsIDE4MzkwMzA1NjIpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNCwgLTE1MzA5OTIwNjApO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA0XSwgMTEsIDEyNzI4OTMzNTMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNCwgNjgxMjc5MTc0KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyA2XSwgMjMsIDc2MDI5MTg5KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgOV0sIDQsIC02NDAzNjQ0ODcpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyAxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNiwgNTMwNzQyNTIwKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpXSwgNiwgLTE5ODYzMDg0NCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDddLCAxMCwgMTEyNjg5MTQxNSk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDYsIDE3MDA0ODU1NzEpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgOF0sIDYsIDE4NzMzMTMzNTkpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMTNdLCAyMSwgMTMwOTE1MTY0OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA2LCAtMTQ1NTIzMDcwKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTUsIDcxODc4NzI1OSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG4gICAgYSA9IHNhZmVBZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVBZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVBZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVBZGQoZCwgb2xkZCk7XG4gIH1cblxuICByZXR1cm4gW2EsIGIsIGMsIGRdO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgYnl0ZXMgdG8gYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBieXRlc1RvV29yZHMoaW5wdXQpIHtcbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBsZW5ndGg4ID0gaW5wdXQubGVuZ3RoICogODtcbiAgdmFyIG91dHB1dCA9IG5ldyBVaW50MzJBcnJheShnZXRPdXRwdXRMZW5ndGgobGVuZ3RoOCkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoODsgaSArPSA4KSB7XG4gICAgb3V0cHV0W2kgPj4gNV0gfD0gKGlucHV0W2kgLyA4XSAmIDB4ZmYpIDw8IGkgJSAzMjtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNhZmVBZGQoeCwgeSkge1xuICB2YXIgbHN3ID0gKHggJiAweGZmZmYpICsgKHkgJiAweGZmZmYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiBtc3cgPDwgMTYgfCBsc3cgJiAweGZmZmY7XG59XG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5cblxuZnVuY3Rpb24gYml0Um90YXRlTGVmdChudW0sIGNudCkge1xuICByZXR1cm4gbnVtIDw8IGNudCB8IG51bSA+Pj4gMzIgLSBjbnQ7XG59XG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNWNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpO1xufVxuXG5mdW5jdGlvbiBtZDVmZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGMgfCB+YiAmIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVnZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGQgfCBjICYgfmQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGMgXiAoYiB8IH5kKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1kNTsiLCJleHBvcnQgZGVmYXVsdCAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJzsiLCJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbmZ1bmN0aW9uIHBhcnNlKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICB2YXIgdjtcbiAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gUGFyc2UgIyMjIyMjIyMtLi4uLi0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNDtcbiAgYXJyWzFdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMl0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzNdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLSMjIyMtLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls0XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSg5LCAxMyksIDE2KSkgPj4+IDg7XG4gIGFycls1XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLSMjIyMtLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNl0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE4KSwgMTYpKSA+Pj4gODtcbiAgYXJyWzddID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0jIyMjLS4uLi4uLi4uLi4uLlxuXG4gIGFycls4XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxOSwgMjMpLCAxNikpID4+PiA4O1xuICBhcnJbOV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLS4uLi4tIyMjIyMjIyMjIyMjXG4gIC8vIChVc2UgXCIvXCIgdG8gYXZvaWQgMzItYml0IHRydW5jYXRpb24gd2hlbiBiaXQtc2hpZnRpbmcgaGlnaC1vcmRlciBieXRlcylcblxuICBhcnJbMTBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDI0LCAzNiksIDE2KSkgLyAweDEwMDAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzExXSA9IHYgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMl0gPSB2ID4+PiAyNCAmIDB4ZmY7XG4gIGFyclsxM10gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsxNF0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzE1XSA9IHYgJiAweGZmO1xuICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZTsiLCJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7IiwiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG52YXIgZ2V0UmFuZG9tVmFsdWVzO1xudmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uIEFsc28sXG4gICAgLy8gZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIChtc0NyeXB0bykgb24gSUUxMS5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pIHx8IHR5cGVvZiBtc0NyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG5cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufSIsIi8vIEFkYXB0ZWQgZnJvbSBDaHJpcyBWZW5lc3MnIFNIQTEgY29kZSBhdFxuLy8gaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9zaGExLmh0bWxcbmZ1bmN0aW9uIGYocywgeCwgeSwgeikge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4geCAmIHkgXiB+eCAmIHo7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHggJiB5IF4geCAmIHogXiB5ICYgejtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gIH1cbn1cblxuZnVuY3Rpb24gUk9UTCh4LCBuKSB7XG4gIHJldHVybiB4IDw8IG4gfCB4ID4+PiAzMiAtIG47XG59XG5cbmZ1bmN0aW9uIHNoYTEoYnl0ZXMpIHtcbiAgdmFyIEsgPSBbMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhjYTYyYzFkNl07XG4gIHZhciBIID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdO1xuXG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlcy5wdXNoKG1zZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgLy8gQ29udmVydCBBcnJheS1saWtlIHRvIEFycmF5XG4gICAgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcyk7XG4gIH1cblxuICBieXRlcy5wdXNoKDB4ODApO1xuICB2YXIgbCA9IGJ5dGVzLmxlbmd0aCAvIDQgKyAyO1xuICB2YXIgTiA9IE1hdGguY2VpbChsIC8gMTYpO1xuICB2YXIgTSA9IG5ldyBBcnJheShOKTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgTjsgKytfaSkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICBhcnJbal0gPSBieXRlc1tfaSAqIDY0ICsgaiAqIDRdIDw8IDI0IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgMV0gPDwgMTYgfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAyXSA8PCA4IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgM107XG4gICAgfVxuXG4gICAgTVtfaV0gPSBhcnI7XG4gIH1cblxuICBNW04gLSAxXVsxNF0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4IC8gTWF0aC5wb3coMiwgMzIpO1xuICBNW04gLSAxXVsxNF0gPSBNYXRoLmZsb29yKE1bTiAtIDFdWzE0XSk7XG4gIE1bTiAtIDFdWzE1XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggJiAweGZmZmZmZmZmO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IE47ICsrX2kyKSB7XG4gICAgdmFyIFcgPSBuZXcgVWludDMyQXJyYXkoODApO1xuXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCAxNjsgKyt0KSB7XG4gICAgICBXW3RdID0gTVtfaTJdW3RdO1xuICAgIH1cblxuICAgIGZvciAodmFyIF90ID0gMTY7IF90IDwgODA7ICsrX3QpIHtcbiAgICAgIFdbX3RdID0gUk9UTChXW190IC0gM10gXiBXW190IC0gOF0gXiBXW190IC0gMTRdIF4gV1tfdCAtIDE2XSwgMSk7XG4gICAgfVxuXG4gICAgdmFyIGEgPSBIWzBdO1xuICAgIHZhciBiID0gSFsxXTtcbiAgICB2YXIgYyA9IEhbMl07XG4gICAgdmFyIGQgPSBIWzNdO1xuICAgIHZhciBlID0gSFs0XTtcblxuICAgIGZvciAodmFyIF90MiA9IDA7IF90MiA8IDgwOyArK190Mikge1xuICAgICAgdmFyIHMgPSBNYXRoLmZsb29yKF90MiAvIDIwKTtcbiAgICAgIHZhciBUID0gUk9UTChhLCA1KSArIGYocywgYiwgYywgZCkgKyBlICsgS1tzXSArIFdbX3QyXSA+Pj4gMDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gUk9UTChiLCAzMCkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSBUO1xuICAgIH1cblxuICAgIEhbMF0gPSBIWzBdICsgYSA+Pj4gMDtcbiAgICBIWzFdID0gSFsxXSArIGIgPj4+IDA7XG4gICAgSFsyXSA9IEhbMl0gKyBjID4+PiAwO1xuICAgIEhbM10gPSBIWzNdICsgZCA+Pj4gMDtcbiAgICBIWzRdID0gSFs0XSArIGUgPj4+IDA7XG4gIH1cblxuICByZXR1cm4gW0hbMF0gPj4gMjQgJiAweGZmLCBIWzBdID4+IDE2ICYgMHhmZiwgSFswXSA+PiA4ICYgMHhmZiwgSFswXSAmIDB4ZmYsIEhbMV0gPj4gMjQgJiAweGZmLCBIWzFdID4+IDE2ICYgMHhmZiwgSFsxXSA+PiA4ICYgMHhmZiwgSFsxXSAmIDB4ZmYsIEhbMl0gPj4gMjQgJiAweGZmLCBIWzJdID4+IDE2ICYgMHhmZiwgSFsyXSA+PiA4ICYgMHhmZiwgSFsyXSAmIDB4ZmYsIEhbM10gPj4gMjQgJiAweGZmLCBIWzNdID4+IDE2ICYgMHhmZiwgSFszXSA+PiA4ICYgMHhmZiwgSFszXSAmIDB4ZmYsIEhbNF0gPj4gMjQgJiAweGZmLCBIWzRdID4+IDE2ICYgMHhmZiwgSFs0XSA+PiA4ICYgMHhmZiwgSFs0XSAmIDB4ZmZdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaGExOyIsImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuXG52YXIgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIpIHtcbiAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHZhciB1dWlkID0gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyIsImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7IC8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxudmFyIF9ub2RlSWQ7XG5cbnZhciBfY2xvY2tzZXE7IC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuXG5cbnZhciBfbGFzdE1TZWNzID0gMDtcbnZhciBfbGFzdE5TZWNzID0gMDsgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCBmb3IgQVBJIGRldGFpbHNcblxuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICB2YXIgc2VlZEJ5dGVzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbc2VlZEJ5dGVzWzBdIHwgMHgwMSwgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1dO1xuICAgIH1cblxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfSAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cblxuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBEYXRlLm5vdygpOyAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG5cbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxOyAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG5cbiAgdmFyIGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDsgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH0gLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuXG5cbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH0gLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuXG5cbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXVpZC52MSgpOiBDYW4ndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWNcIik7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7IC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwOyAvLyBgdGltZV9sb3dgXG5cbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIHZhciB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7IC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG5cbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmOyAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcblxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7IC8vIGBjbG9ja19zZXFfbG93YFxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjsgLy8gYG5vZGVgXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IHN0cmluZ2lmeShiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjE7IiwiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgbWQ1IGZyb20gJy4vbWQ1LmpzJztcbnZhciB2MyA9IHYzNSgndjMnLCAweDMwLCBtZDUpO1xuZXhwb3J0IGRlZmF1bHQgdjM7IiwiaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZS5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTsgLy8gVVRGOCBlc2NhcGVcblxuICB2YXIgYnl0ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5leHBvcnQgdmFyIEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IHZhciBVUkwgPSAnNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChuYW1lLCB2ZXJzaW9uLCBoYXNoZnVuYykge1xuICBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQodmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzcGFjZSA9IHBhcnNlKG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVzcGFjZS5sZW5ndGggIT09IDE2KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ05hbWVzcGFjZSBtdXN0IGJlIGFycmF5LWxpa2UgKDE2IGl0ZXJhYmxlIGludGVnZXIgdmFsdWVzLCAwLTI1NSknKTtcbiAgICB9IC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG5cblxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2ICsgdmFsdWUubGVuZ3RoKTtcbiAgICBieXRlcy5zZXQobmFtZXNwYWNlKTtcbiAgICBieXRlcy5zZXQodmFsdWUsIG5hbWVzcGFjZS5sZW5ndGgpO1xuICAgIGJ5dGVzID0gaGFzaGZ1bmMoYnl0ZXMpO1xuICAgIGJ5dGVzWzZdID0gYnl0ZXNbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdpZnkoYnl0ZXMpO1xuICB9IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSIsImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkocm5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHY0OyIsImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IHNoYTEgZnJvbSAnLi9zaGExLmpzJztcbnZhciB2NSA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbmV4cG9ydCBkZWZhdWx0IHY1OyIsImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyIsImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc3Vic3RyKDE0LCAxKSwgMTYpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2ZXJzaW9uOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSU1pbmltYXRjaCwgTWluaW1hdGNoIH0gZnJvbSBcIm1pbmltYXRjaFwiO1xuXG5leHBvcnQgZW51bSBFbnZlbG9wZUNvbnRlbnRUeXBlIHtcbiAgUEFUSCxcbiAgQ09OVEVOVCxcbn1cblxuZXhwb3J0IHR5cGUgRW52ZWxvcGVDb250ZW50ID1cbiAgfCB7XG4gICAgICB0eXBlOiBFbnZlbG9wZUNvbnRlbnRUeXBlLlBBVEg7XG4gICAgICBwYXRoOiBzdHJpbmc7XG4gICAgfVxuICB8IHtcbiAgICAgIHR5cGU6IEVudmVsb3BlQ29udGVudFR5cGUuQ09OVEVOVDtcbiAgICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICB9O1xuXG5leHBvcnQgY2xhc3MgRW52ZWxvcGVNYXBwaW5nIHtcbiAgcHVibGljIG1hdGNoZXI6IElNaW5pbWF0Y2g7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBhcmdzOiB7XG4gICAgICB0eXBlOiBzdHJpbmc7XG4gICAgICBmaWxlUGF0aEdsb2I6IHN0cmluZztcbiAgICAgIHJlc291cmNlc1BhdGhQcmVmaXg6IHN0cmluZztcbiAgICAgIGVudmVsb3BlQ29udGVudDogRW52ZWxvcGVDb250ZW50O1xuICAgIH1cbiAgKSB7XG4gICAgdGhpcy5tYXRjaGVyID0gbmV3IE1pbmltYXRjaChhcmdzLmZpbGVQYXRoR2xvYiwgeyBub2Nhc2U6IHRydWUsIGRvdDogdHJ1ZSB9KTtcbiAgfVxuXG4gIGdldCB0eXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy50eXBlO1xuICB9XG5cbiAgZ2V0IGZpbGVQYXRoR2xvYigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmFyZ3MuZmlsZVBhdGhHbG9iO1xuICB9XG5cbiAgZ2V0IHJlc291cmNlc1BhdGhQcmVmaXgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLnJlc291cmNlc1BhdGhQcmVmaXg7XG4gIH1cblxuICBnZXQgZW52ZWxvcGVDb250ZW50KCk6IEVudmVsb3BlQ29udGVudCB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5lbnZlbG9wZUNvbnRlbnQ7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEVkaXRvckVudmVsb3BlTG9jYXRvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSB0YXJnZXRPcmlnaW46IHN0cmluZywgcHVibGljIHJlYWRvbmx5IGVudmVsb3BlTWFwcGluZ3M6IEVudmVsb3BlTWFwcGluZ1tdKSB7fVxuXG4gIHB1YmxpYyBnZXRFbnZlbG9wZU1hcHBpbmcocGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZW52ZWxvcGVNYXBwaW5ncy5maW5kKChtYXBwaW5nKSA9PiB7XG4gICAgICByZXR1cm4gbWFwcGluZy5tYXRjaGVyLm1hdGNoKHBhdGgpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGhhc01hcHBpbmdGb3IocGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW52ZWxvcGVNYXBwaW5nKHBhdGgpICE9PSB1bmRlZmluZWQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IHR5cGUgTm90aWZpY2F0aW9uQ2FsbGJhY2s8XG4gIEFwaVRvQ29uc3VtZSBleHRlbmRzIEFwaURlZmluaXRpb248QXBpVG9Db25zdW1lPixcbiAgTSBleHRlbmRzIE5vdGlmaWNhdGlvblByb3BlcnR5TmFtZXM8QXBpVG9Db25zdW1lPlxuPiA9ICguLi5hcmdzOiBBcmdzVHlwZTxBcGlUb0NvbnN1bWVbTV0+KSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBTaGFyZWRWYWx1ZVByb3ZpZGVyUHJvcGVydHlOYW1lczxUIGV4dGVuZHMgQXBpRGVmaW5pdGlvbjxUPj4gPSB7XG4gIFtLIGluIGtleW9mIFRdOiBSZXR1cm5UeXBlPFRbS10+IGV4dGVuZHMgU2hhcmVkVmFsdWVQcm92aWRlcjxhbnk+ID8gSyA6IG5ldmVyO1xufVtrZXlvZiBUXTtcblxuZXhwb3J0IHR5cGUgTm90aWZpY2F0aW9uUHJvcGVydHlOYW1lczxUIGV4dGVuZHMgQXBpRGVmaW5pdGlvbjxUPj4gPSB7XG4gIFtLIGluIGtleW9mIFRdOiBSZXR1cm5UeXBlPFRbS10+IGV4dGVuZHMgdm9pZCA/IEsgOiBuZXZlcjtcbn1ba2V5b2YgVF07XG5cbmV4cG9ydCB0eXBlIFJlcXVlc3RQcm9wZXJ0eU5hbWVzPFQgZXh0ZW5kcyBBcGlEZWZpbml0aW9uPFQ+PiA9IHtcbiAgW0sgaW4ga2V5b2YgVF06IFJldHVyblR5cGU8VFtLXT4gZXh0ZW5kcyBQcm9taXNlPGFueT4gPyBLIDogbmV2ZXI7XG59W2tleW9mIFRdO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNoYXJlZFZhbHVlQ29uc3VtZXI8VD4ge1xuICBzdWJzY3JpYmUoY2FsbGJhY2s6IChuZXdWYWx1ZTogVCkgPT4gdm9pZCk6IChuZXdWYWx1ZTogVCkgPT4gYW55O1xuICB1bnN1YnNjcmliZShzdWJzY3JpcHRpb246IChuZXdWYWx1ZTogVCkgPT4gdm9pZCk6IHZvaWQ7XG4gIHNldCh0OiBUKTogdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaGFyZWRWYWx1ZVByb3ZpZGVyPFQ+IHtcbiAgZGVmYXVsdFZhbHVlOiBUO1xufVxuXG5leHBvcnQgdHlwZSBGdW5jdGlvblByb3BlcnR5TmFtZXM8VCBleHRlbmRzIEFwaURlZmluaXRpb248VD4+ID1cbiAgfCBTaGFyZWRWYWx1ZVByb3ZpZGVyUHJvcGVydHlOYW1lczxUPlxuICB8IE5vdGlmaWNhdGlvblByb3BlcnR5TmFtZXM8VD5cbiAgfCBSZXF1ZXN0UHJvcGVydHlOYW1lczxUPjtcblxuZXhwb3J0IHR5cGUgQXBpRGVmaW5pdGlvbjxUPiA9IHsgW1AgaW4ga2V5b2YgVF06ICguLi5hOiBhbnkpID0+IFByb21pc2U8YW55PiB8IFNoYXJlZFZhbHVlUHJvdmlkZXI8YW55PiB8IHZvaWQgfTtcblxuZXhwb3J0IHR5cGUgQXJnc1R5cGU8VD4gPSBUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIEEpID0+IGFueSA/IEEgOiBuZXZlcjtcblxuZXhwb3J0IHR5cGUgU3Vic2NyaXB0aW9uQ2FsbGJhY2s8QXBpIGV4dGVuZHMgQXBpRGVmaW5pdGlvbjxBcGk+LCBNIGV4dGVuZHMgTm90aWZpY2F0aW9uUHJvcGVydHlOYW1lczxBcGk+PiA9IChcbiAgLi4uYXJnczogQXJnc1R5cGU8QXBpW01dPlxuKSA9PiB2b2lkO1xuXG5leHBvcnQgdHlwZSBBcGlSZXF1ZXN0czxUIGV4dGVuZHMgQXBpRGVmaW5pdGlvbjxUPj4gPSBQaWNrPFQsIFJlcXVlc3RQcm9wZXJ0eU5hbWVzPFQ+PjtcblxuZXhwb3J0IHR5cGUgQXBpTm90aWZpY2F0aW9uQ29uc3VtZXJzPFQgZXh0ZW5kcyBBcGlEZWZpbml0aW9uPFQ+PiA9IFBpY2s8XG4gIFdpdGhOb3RpZmljYXRpb25Db25zdW1lcnM8VD4sXG4gIE5vdGlmaWNhdGlvblByb3BlcnR5TmFtZXM8VD5cbj47XG5cbmV4cG9ydCB0eXBlIEFwaVNoYXJlZFZhbHVlQ29uc3VtZXJzPFQgZXh0ZW5kcyBBcGlEZWZpbml0aW9uPFQ+PiA9IFBpY2s8XG4gIFdpdGhTaGFyZWRWYWx1ZUNvbnN1bWVyczxUPixcbiAgU2hhcmVkVmFsdWVQcm92aWRlclByb3BlcnR5TmFtZXM8VD5cbj47XG5cbmV4cG9ydCB0eXBlIFdpdGhTaGFyZWRWYWx1ZUNvbnN1bWVyczxUIGV4dGVuZHMgQXBpRGVmaW5pdGlvbjxUPj4gPSB7XG4gIFtLIGluIGtleW9mIFRdOiBSZXR1cm5UeXBlPFRbS10+IGV4dGVuZHMgU2hhcmVkVmFsdWVQcm92aWRlcjxpbmZlciBVPiA/IFNoYXJlZFZhbHVlQ29uc3VtZXI8VT4gOiBuZXZlcjtcbn07XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uQ29uc3VtZXI8Tj4ge1xuICBzdWJzY3JpYmUoY2FsbGJhY2s6ICguLi5uZXdWYWx1ZTogQXJnc1R5cGU8Tj4pID0+IHZvaWQpOiAoLi4ubmV3VmFsdWU6IEFyZ3NUeXBlPE4+KSA9PiBhbnk7XG4gIHVuc3Vic2NyaWJlKHN1YnNjcmlwdGlvbjogKC4uLm5ld1ZhbHVlOiBBcmdzVHlwZTxOPikgPT4gdm9pZCk6IHZvaWQ7XG4gIHNlbmQoLi4uYXJnczogQXJnc1R5cGU8Tj4pOiB2b2lkO1xufVxuZXhwb3J0IHR5cGUgV2l0aE5vdGlmaWNhdGlvbkNvbnN1bWVyczxUIGV4dGVuZHMgQXBpRGVmaW5pdGlvbjxUPj4gPSB7XG4gIFtLIGluIGtleW9mIFRdOiBSZXR1cm5UeXBlPFRbS10+IGV4dGVuZHMgdm9pZCA/IE5vdGlmaWNhdGlvbkNvbnN1bWVyPFRbS10+IDogbmV2ZXI7XG59O1xuXG5leHBvcnQgdHlwZSBXaXRoUmVxdWVzdENvbnN1bWVyczxUIGV4dGVuZHMgQXBpRGVmaW5pdGlvbjxUPj4gPSB7XG4gIFtLIGluIGtleW9mIFRdOiBSZXR1cm5UeXBlPFRbS10+IGV4dGVuZHMgdm9pZCA/IFJlcXVlc3RDb25zdW1lcjxUW0tdPiA6IG5ldmVyO1xufTtcblxuZXhwb3J0IHR5cGUgUmVxdWVzdENvbnN1bWVyPFQgZXh0ZW5kcyAoKSA9PiBhbnk+ID0gKC4uLmFyZ3M6IEFyZ3NUeXBlPFQ+KSA9PiBSZXR1cm5UeXBlPFQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VCdXNDbGllbnRBcGk8QXBpIGV4dGVuZHMgQXBpRGVmaW5pdGlvbjxBcGk+PiB7XG4gIHJlcXVlc3RzOiBBcGlSZXF1ZXN0czxBcGk+O1xuICBub3RpZmljYXRpb25zOiBBcGlOb3RpZmljYXRpb25Db25zdW1lcnM8QXBpPjtcbiAgc2hhcmVkOiBBcGlTaGFyZWRWYWx1ZUNvbnN1bWVyczxBcGk+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VCdXNTZXJ2ZXI8XG4gIEFwaVRvUHJvdmlkZSBleHRlbmRzIEFwaURlZmluaXRpb248QXBpVG9Qcm92aWRlPixcbiAgQXBpVG9Db25zdW1lIGV4dGVuZHMgQXBpRGVmaW5pdGlvbjxBcGlUb0NvbnN1bWU+XG4+IHtcbiAgcmVjZWl2ZShcbiAgICBtZXNzYWdlOiBFbnZlbG9wZUJ1c01lc3NhZ2U8dW5rbm93biwgRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPEFwaVRvUHJvdmlkZT4gfCBGdW5jdGlvblByb3BlcnR5TmFtZXM8QXBpVG9Db25zdW1lPj4sXG4gICAgYXBpSW1wbDogQXBpVG9Qcm92aWRlXG4gICk6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRW52ZWxvcGVCdXNNZXNzYWdlPEQsIFQ+IHtcbiAgZGF0YTogRDtcbiAgdHlwZTogVDtcbiAgdGFyZ2V0RW52ZWxvcGVTZXJ2ZXJJZD86IHN0cmluZzsgLy8gVXNlZCBmb3IgbWVzc2FnZXMgZ29pbmcgZnJvbSB0aGUgRW52ZWxvcGUgdG8gdGhlIEVudmVsb3BlU2VydmVyXG4gIHJlcXVlc3RJZD86IHN0cmluZzsgLy8gVXNlZCB3aGVuIHB1cnBvc2UgaXMgUkVRVUVTVCBvciBSRVNQT05TRVxuICBwdXJwb3NlOiBFbnZlbG9wZUJ1c01lc3NhZ2VQdXJwb3NlO1xuICBlcnJvcj86IHN0cmluZzsgLy8gVXNlZCBvbiBSRVNQT05TRVMgd2hlbiBhbiBleGNlcHRpb24gaGFwcGVucyB3aGVuIHByb2Nlc3NpbmcgYSByZXF1ZXN0XG4gIHRhcmdldEVudmVsb3BlSWQ/OiBzdHJpbmc7IC8vIFVzZWQgZm9yIG1lc3NhZ2VzIGdvaW5nIGZyb20gdGhlIEVudmVsb3BlU2VydmVyIHRvIHRoZSBFbnZlbG9wZVxuICBkaXJlY3RTZW5kZXI/OiBFbnZlbG9wZUJ1c01lc3NhZ2VEaXJlY3RTZW5kZXI7XG59XG5cbmV4cG9ydCBlbnVtIEVudmVsb3BlQnVzTWVzc2FnZVB1cnBvc2Uge1xuICBSRVFVRVNUID0gXCJyZXF1ZXN0XCIsXG4gIFJFU1BPTlNFID0gXCJyZXNwb25zZVwiLFxuICBOT1RJRklDQVRJT05fU1VCU0NSSVBUSU9OID0gXCJzdWJzY3JpcHRpb25cIixcbiAgTk9USUZJQ0FUSU9OX1VOU1VCU0NSSVBUSU9OID0gXCJ1bnN1YnNjcmlwdGlvblwiLFxuICBOT1RJRklDQVRJT04gPSBcIm5vdGlmaWNhdGlvblwiLFxuICBTSEFSRURfVkFMVUVfR0VUX0RFRkFVTFQgPSBcInNoYXJlZC12YWx1ZS1nZXQtZGVmYXVsdFwiLFxuICBTSEFSRURfVkFMVUVfVVBEQVRFID0gXCJzaGFyZWQtdmFsdWUtdXBkYXRlXCIsXG59XG5cbmV4cG9ydCBlbnVtIEVudmVsb3BlQnVzTWVzc2FnZURpcmVjdFNlbmRlciB7XG4gIEVOVkVMT1BFX0NMSUVOVCA9IFwiZW52ZWxvcGVDbGllbnRcIixcbiAgRU5WRUxPUEVfU0VSVkVSID0gXCJlbnZlbG9wZVNlcnZlclwiLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVudmVsb3BlQnVzIHtcbiAgcG9zdE1lc3NhZ2U8RCwgVD4obWVzc2FnZTogRW52ZWxvcGVCdXNNZXNzYWdlPEQsIFQ+LCB0YXJnZXRPcmlnaW4/OiBzdHJpbmcsIF8/OiBhbnkpOiB2b2lkO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDIwIFJlZCBIYXQsIEluYy4gYW5kL29yIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBBcGlEZWZpbml0aW9uLFxuICBBcGlTaGFyZWRWYWx1ZUNvbnN1bWVycyxcbiAgQXJnc1R5cGUsXG4gIEVudmVsb3BlQnVzTWVzc2FnZSxcbiAgRW52ZWxvcGVCdXNNZXNzYWdlUHVycG9zZSxcbiAgRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzLFxuICBNZXNzYWdlQnVzQ2xpZW50QXBpLFxuICBNZXNzYWdlQnVzU2VydmVyLFxuICBOb3RpZmljYXRpb25DYWxsYmFjayxcbiAgTm90aWZpY2F0aW9uQ29uc3VtZXIsXG4gIE5vdGlmaWNhdGlvblByb3BlcnR5TmFtZXMsXG4gIFJlcXVlc3RDb25zdW1lcixcbiAgUmVxdWVzdFByb3BlcnR5TmFtZXMsXG4gIFNoYXJlZFZhbHVlQ29uc3VtZXIsXG4gIFNoYXJlZFZhbHVlUHJvdmlkZXJQcm9wZXJ0eU5hbWVzLFxufSBmcm9tIFwiLi4vYXBpXCI7XG5cbnR5cGUgRnVuYyA9ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55O1xuaW50ZXJmYWNlIFN0b3JlZFByb21pc2Uge1xuICByZXNvbHZlOiAoYXJnOiB1bmtub3duKSA9PiB2b2lkO1xuICByZWplY3Q6IChhcmc6IHVua25vd24pID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjbGFzcyBFbnZlbG9wZUJ1c01lc3NhZ2VNYW5hZ2VyPFxuICBBcGlUb1Byb3ZpZGUgZXh0ZW5kcyBBcGlEZWZpbml0aW9uPEFwaVRvUHJvdmlkZT4sXG4gIEFwaVRvQ29uc3VtZSBleHRlbmRzIEFwaURlZmluaXRpb248QXBpVG9Db25zdW1lPlxuPiB7XG4gIHByaXZhdGUgcmVhZG9ubHkgcmVxdWVzdEhhbmRsZXJzID0gbmV3IE1hcDxzdHJpbmcsIFN0b3JlZFByb21pc2U+KCk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBsb2NhbE5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25zID0gbmV3IE1hcDxOb3RpZmljYXRpb25Qcm9wZXJ0eU5hbWVzPEFwaVRvQ29uc3VtZT4sIEZ1bmNbXT4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSByZW1vdGVOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9uczogQXJyYXk8Tm90aWZpY2F0aW9uUHJvcGVydHlOYW1lczxBcGlUb1Byb3ZpZGU+PiA9IFtdO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgbG9jYWxTaGFyZWRWYWx1ZVN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwPFxuICAgIFNoYXJlZFZhbHVlUHJvdmlkZXJQcm9wZXJ0eU5hbWVzPEFwaVRvUHJvdmlkZT4gfCBTaGFyZWRWYWx1ZVByb3ZpZGVyUHJvcGVydHlOYW1lczxBcGlUb0NvbnN1bWU+LFxuICAgIEZ1bmNbXVxuICA+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgbG9jYWxTaGFyZWRWYWx1ZXNTdG9yZSA9IG5ldyBNYXA8XG4gICAgU2hhcmVkVmFsdWVQcm92aWRlclByb3BlcnR5TmFtZXM8QXBpVG9Qcm92aWRlPiB8IFNoYXJlZFZhbHVlUHJvdmlkZXJQcm9wZXJ0eU5hbWVzPEFwaVRvQ29uc3VtZT4sXG4gICAgQXBpVG9Qcm92aWRlW2tleW9mIEFwaVRvUHJvdmlkZV0gfCBBcGlUb0NvbnN1bWVba2V5b2YgQXBpVG9Db25zdW1lXVxuICA+KCk7XG5cbiAgcHJpdmF0ZSByZXF1ZXN0SWRDb3VudGVyOiBudW1iZXI7XG4gIHB1YmxpYyBjdXJyZW50QXBpSW1wbD86IEFwaVRvUHJvdmlkZTtcblxuICBwdWJsaWMgY2xpZW50QXBpOiBNZXNzYWdlQnVzQ2xpZW50QXBpPEFwaVRvQ29uc3VtZT4gPSB7XG4gICAgcmVxdWVzdHM6IGNhY2hlZFByb3h5KFxuICAgICAgbmV3IE1hcDxSZXF1ZXN0UHJvcGVydHlOYW1lczxBcGlUb0NvbnN1bWU+LCBSZXF1ZXN0Q29uc3VtZXI8QXBpVG9Db25zdW1lW2tleW9mIEFwaVRvQ29uc3VtZV0+PigpLFxuICAgICAge1xuICAgICAgICBnZXQ6ICh0YXJnZXQsIG5hbWUpID0+IHtcbiAgICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHRoaXMucmVxdWVzdChuYW1lLCAuLi5hcmdzKTtcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICApLFxuICAgIG5vdGlmaWNhdGlvbnM6IGNhY2hlZFByb3h5KFxuICAgICAgbmV3IE1hcDxOb3RpZmljYXRpb25Qcm9wZXJ0eU5hbWVzPEFwaVRvQ29uc3VtZT4sIE5vdGlmaWNhdGlvbkNvbnN1bWVyPEFwaVRvQ29uc3VtZVtrZXlvZiBBcGlUb0NvbnN1bWVdPj4oKSxcbiAgICAgIHtcbiAgICAgICAgZ2V0OiAodGFyZ2V0LCBuYW1lKSA9PiAoe1xuICAgICAgICAgIHN1YnNjcmliZTogKGNhbGxiYWNrKSA9PiB0aGlzLnN1YnNjcmliZVRvTm90aWZpY2F0aW9uKG5hbWUsIGNhbGxiYWNrKSxcbiAgICAgICAgICB1bnN1YnNjcmliZTogKGNhbGxiYWNrKSA9PiB0aGlzLnVuc3Vic2NyaWJlRnJvbU5vdGlmaWNhdGlvbihuYW1lLCBjYWxsYmFjayksXG4gICAgICAgICAgc2VuZDogKC4uLmFyZ3MpID0+IHRoaXMubm90aWZ5KG5hbWUsIC4uLmFyZ3MpLFxuICAgICAgICB9KSxcbiAgICAgIH1cbiAgICApLFxuICAgIHNoYXJlZDogY2FjaGVkUHJveHkoXG4gICAgICBuZXcgTWFwPFNoYXJlZFZhbHVlUHJvdmlkZXJQcm9wZXJ0eU5hbWVzPEFwaVRvQ29uc3VtZT4sIFNoYXJlZFZhbHVlQ29uc3VtZXI8QXBpVG9Db25zdW1lW2tleW9mIEFwaVRvQ29uc3VtZV0+PigpLFxuICAgICAge1xuICAgICAgICBnZXQ6ICh0YXJnZXQsIG5hbWUpID0+ICh7XG4gICAgICAgICAgc2V0OiAodmFsdWUpID0+IHRoaXMuc2V0U2hhcmVkVmFsdWUobmFtZSwgdmFsdWUpLFxuICAgICAgICAgIHN1YnNjcmliZTogKGNhbGxiYWNrKSA9PiB0aGlzLnN1YnNjcmliZVRvU2hhcmVkVmFsdWUobmFtZSwgY2FsbGJhY2ssIHsgb3duZWQ6IGZhbHNlIH0pLFxuICAgICAgICAgIHVuc3Vic2NyaWJlOiAoY2FsbGJhY2spID0+IHRoaXMudW5zdWJzY3JpYmVGcm9tU2hhcmVkVmFsdWUobmFtZSwgY2FsbGJhY2spLFxuICAgICAgICB9KSxcbiAgICAgIH1cbiAgICApLFxuICB9O1xuXG4gIHB1YmxpYyBzaGFyZWQ6IEFwaVNoYXJlZFZhbHVlQ29uc3VtZXJzPEFwaVRvUHJvdmlkZT4gPSBjYWNoZWRQcm94eShcbiAgICBuZXcgTWFwPFNoYXJlZFZhbHVlUHJvdmlkZXJQcm9wZXJ0eU5hbWVzPEFwaVRvUHJvdmlkZT4sIFNoYXJlZFZhbHVlQ29uc3VtZXI8QXBpVG9Qcm92aWRlW2tleW9mIEFwaVRvUHJvdmlkZV0+PigpLFxuICAgIHtcbiAgICAgIGdldDogKHRhcmdldCwgbmFtZSkgPT4gKHtcbiAgICAgICAgc2V0OiAodmFsdWUpID0+IHRoaXMuc2V0U2hhcmVkVmFsdWUobmFtZSwgdmFsdWUpLFxuICAgICAgICBzdWJzY3JpYmU6IChjYWxsYmFjaykgPT4gdGhpcy5zdWJzY3JpYmVUb1NoYXJlZFZhbHVlKG5hbWUsIGNhbGxiYWNrLCB7IG93bmVkOiB0cnVlIH0pLFxuICAgICAgICB1bnN1YnNjcmliZTogKGNhbGxiYWNrKSA9PiB0aGlzLnVuc3Vic2NyaWJlRnJvbVNoYXJlZFZhbHVlKG5hbWUsIGNhbGxiYWNrKSxcbiAgICAgIH0pLFxuICAgIH1cbiAgKTtcblxuICBwdWJsaWMgZ2V0IHNlcnZlcigpOiBNZXNzYWdlQnVzU2VydmVyPEFwaVRvUHJvdmlkZSwgQXBpVG9Db25zdW1lPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VpdmU6IChtLCBhcGlJbXBsKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcobSk7XG4gICAgICAgIHRoaXMucmVjZWl2ZShtLCBhcGlJbXBsKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2VuZDogKFxuICAgICAgLy8gV2UgY2FuIHNlbmQgbWVzc2FnZXMgZm9yIGJvdGggdGhlIEFQSXMgd2UgcHJvdmlkZSBhbmQgY29uc3VtZVxuICAgICAgbWVzc2FnZTogRW52ZWxvcGVCdXNNZXNzYWdlPHVua25vd24sIEZ1bmN0aW9uUHJvcGVydHlOYW1lczxBcGlUb0NvbnN1bWU+IHwgRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPEFwaVRvUHJvdmlkZT4+XG4gICAgKSA9PiB2b2lkLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbmFtZTogc3RyaW5nID0gYCR7bmV3IERhdGUoKS5nZXRNaWxsaXNlY29uZHMoKX1gXG4gICkge1xuICAgIHRoaXMucmVxdWVzdElkQ291bnRlciA9IDA7XG4gIH1cblxuICBwcml2YXRlIHNldFNoYXJlZFZhbHVlPFxuICAgIE0gZXh0ZW5kcyBTaGFyZWRWYWx1ZVByb3ZpZGVyUHJvcGVydHlOYW1lczxBcGlUb1Byb3ZpZGU+IHwgU2hhcmVkVmFsdWVQcm92aWRlclByb3BlcnR5TmFtZXM8QXBpVG9Db25zdW1lPlxuICA+KG1ldGhvZDogTSwgdmFsdWU6IGFueSkge1xuICAgIHRoaXMubG9jYWxTaGFyZWRWYWx1ZXNTdG9yZS5zZXQobWV0aG9kLCB2YWx1ZSk7XG4gICAgdGhpcy5sb2NhbFNoYXJlZFZhbHVlU3Vic2NyaXB0aW9ucy5nZXQobWV0aG9kKT8uZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKHZhbHVlKSk7XG4gICAgdGhpcy5zZW5kKHtcbiAgICAgIHR5cGU6IG1ldGhvZCxcbiAgICAgIHB1cnBvc2U6IEVudmVsb3BlQnVzTWVzc2FnZVB1cnBvc2UuU0hBUkVEX1ZBTFVFX1VQREFURSxcbiAgICAgIGRhdGE6IHZhbHVlLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpYmVUb1NoYXJlZFZhbHVlPFxuICAgIE0gZXh0ZW5kcyBTaGFyZWRWYWx1ZVByb3ZpZGVyUHJvcGVydHlOYW1lczxBcGlUb1Byb3ZpZGU+IHwgU2hhcmVkVmFsdWVQcm92aWRlclByb3BlcnR5TmFtZXM8QXBpVG9Db25zdW1lPlxuICA+KG1ldGhvZDogTSwgY2FsbGJhY2s6IEZ1bmMsIGNvbmZpZzogeyBvd25lZDogYm9vbGVhbiB9KSB7XG4gICAgY29uc3QgYWN0aXZlU3Vic2NyaXB0aW9ucyA9IHRoaXMubG9jYWxTaGFyZWRWYWx1ZVN1YnNjcmlwdGlvbnMuZ2V0KG1ldGhvZCkgPz8gW107XG4gICAgdGhpcy5sb2NhbFNoYXJlZFZhbHVlU3Vic2NyaXB0aW9ucy5zZXQobWV0aG9kLCBbLi4uYWN0aXZlU3Vic2NyaXB0aW9ucywgY2FsbGJhY2tdKTtcbiAgICBpZiAoY29uZmlnLm93bmVkIHx8IHRoaXMubG9jYWxTaGFyZWRWYWx1ZXNTdG9yZS5nZXQobWV0aG9kKSkge1xuICAgICAgY2FsbGJhY2sodGhpcy5nZXRDdXJyZW50U3RvcmVkU2hhcmVkVmFsdWVPckRlZmF1bHQobWV0aG9kLCB0aGlzLmN1cnJlbnRBcGlJbXBsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZCh7XG4gICAgICAgIHR5cGU6IG1ldGhvZCxcbiAgICAgICAgcHVycG9zZTogRW52ZWxvcGVCdXNNZXNzYWdlUHVycG9zZS5TSEFSRURfVkFMVUVfR0VUX0RFRkFVTFQsXG4gICAgICAgIGRhdGE6IFtdLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjYWxsYmFjaztcbiAgfVxuXG4gIHByaXZhdGUgdW5zdWJzY3JpYmVGcm9tU2hhcmVkVmFsdWU8XG4gICAgTSBleHRlbmRzIFNoYXJlZFZhbHVlUHJvdmlkZXJQcm9wZXJ0eU5hbWVzPEFwaVRvUHJvdmlkZT4gfCBTaGFyZWRWYWx1ZVByb3ZpZGVyUHJvcGVydHlOYW1lczxBcGlUb0NvbnN1bWU+XG4gID4obmFtZTogTSwgY2FsbGJhY2s6IGFueSkge1xuICAgIGNvbnN0IGFjdGl2ZVN1YnNjcmlwdGlvbnMgPSB0aGlzLmxvY2FsU2hhcmVkVmFsdWVTdWJzY3JpcHRpb25zLmdldChuYW1lKTtcbiAgICBpZiAoIWFjdGl2ZVN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IGFjdGl2ZVN1YnNjcmlwdGlvbnMuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Q3VycmVudFN0b3JlZFNoYXJlZFZhbHVlT3JEZWZhdWx0PFxuICAgIE0gZXh0ZW5kcyBTaGFyZWRWYWx1ZVByb3ZpZGVyUHJvcGVydHlOYW1lczxBcGlUb1Byb3ZpZGU+IHwgU2hhcmVkVmFsdWVQcm92aWRlclByb3BlcnR5TmFtZXM8QXBpVG9Db25zdW1lPlxuICA+KG1ldGhvZDogTSwgYXBpSW1wbD86IEFwaVRvUHJvdmlkZSkge1xuICAgIGNvbnN0IG0gPSBtZXRob2QgYXMgU2hhcmVkVmFsdWVQcm92aWRlclByb3BlcnR5TmFtZXM8QXBpVG9Qcm92aWRlPjtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5sb2NhbFNoYXJlZFZhbHVlc1N0b3JlLmdldChtKSA/P1xuICAgICAgdGhpcy5sb2NhbFNoYXJlZFZhbHVlc1N0b3JlLnNldChtLCBhcGlJbXBsPy5bbV0/LmFwcGx5KGFwaUltcGwpLmRlZmF1bHRWYWx1ZSkuZ2V0KG1ldGhvZClcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdWJzY3JpYmVUb05vdGlmaWNhdGlvbjxNIGV4dGVuZHMgTm90aWZpY2F0aW9uUHJvcGVydHlOYW1lczxBcGlUb0NvbnN1bWU+PihcbiAgICBtZXRob2Q6IE0sXG4gICAgY2FsbGJhY2s6ICguLi5hcmdzOiBBcmdzVHlwZTxBcGlUb0NvbnN1bWVbTV0+KSA9PiB2b2lkXG4gICkge1xuICAgIGNvbnN0IGFjdGl2ZVN1YnNjcmlwdGlvbnMgPSB0aGlzLmxvY2FsTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbnMuZ2V0KG1ldGhvZCkgPz8gW107XG4gICAgdGhpcy5sb2NhbE5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25zLnNldChtZXRob2QsIFsuLi5hY3RpdmVTdWJzY3JpcHRpb25zLCBjYWxsYmFja10pO1xuICAgIHRoaXMuc2VuZCh7XG4gICAgICB0eXBlOiBtZXRob2QsXG4gICAgICBwdXJwb3NlOiBFbnZlbG9wZUJ1c01lc3NhZ2VQdXJwb3NlLk5PVElGSUNBVElPTl9TVUJTQ1JJUFRJT04sXG4gICAgICBkYXRhOiBbXSxcbiAgICB9KTtcbiAgICByZXR1cm4gY2FsbGJhY2s7XG4gIH1cblxuICBwcml2YXRlIHVuc3Vic2NyaWJlRnJvbU5vdGlmaWNhdGlvbjxNIGV4dGVuZHMgTm90aWZpY2F0aW9uUHJvcGVydHlOYW1lczxBcGlUb0NvbnN1bWU+PihcbiAgICBtZXRob2Q6IE0sXG4gICAgY2FsbGJhY2s6IE5vdGlmaWNhdGlvbkNhbGxiYWNrPEFwaVRvQ29uc3VtZSwgTT5cbiAgKSB7XG4gICAgY29uc3QgYWN0aXZlU3Vic2NyaXB0aW9ucyA9IHRoaXMubG9jYWxOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9ucy5nZXQobWV0aG9kKTtcbiAgICBpZiAoIWFjdGl2ZVN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IGFjdGl2ZVN1YnNjcmlwdGlvbnMuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFjdGl2ZVN1YnNjcmlwdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLnNlbmQoe1xuICAgICAgdHlwZTogbWV0aG9kLFxuICAgICAgcHVycG9zZTogRW52ZWxvcGVCdXNNZXNzYWdlUHVycG9zZS5OT1RJRklDQVRJT05fVU5TVUJTQ1JJUFRJT04sXG4gICAgICBkYXRhOiBbXSxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcmVxdWVzdDxNIGV4dGVuZHMgUmVxdWVzdFByb3BlcnR5TmFtZXM8QXBpVG9Db25zdW1lPj4obWV0aG9kOiBNLCAuLi5hcmdzOiBBcmdzVHlwZTxBcGlUb0NvbnN1bWVbTV0+KSB7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdGhpcy5nZXROZXh0UmVxdWVzdElkKCk7XG5cbiAgICB0aGlzLnNlbmQoe1xuICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQsXG4gICAgICB0eXBlOiBtZXRob2QsXG4gICAgICBkYXRhOiBhcmdzLFxuICAgICAgcHVycG9zZTogRW52ZWxvcGVCdXNNZXNzYWdlUHVycG9zZS5SRVFVRVNULFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPGFueT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXF1ZXN0SGFuZGxlcnMuc2V0KHJlcXVlc3RJZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSkgYXMgUmV0dXJuVHlwZTxBcGlUb0NvbnN1bWVbTV0+O1xuXG4gICAgLy9UT0RPOiBTZXR1cCB0aW1lb3V0IHRvIGF2b2lkIG1lbW9yeSBsZWFrc1xuICB9XG5cbiAgcHJpdmF0ZSBub3RpZnk8TSBleHRlbmRzIE5vdGlmaWNhdGlvblByb3BlcnR5TmFtZXM8QXBpVG9Db25zdW1lPj4obWV0aG9kOiBNLCAuLi5hcmdzOiBBcmdzVHlwZTxBcGlUb0NvbnN1bWVbTV0+KSB7XG4gICAgdGhpcy5zZW5kKHtcbiAgICAgIHR5cGU6IG1ldGhvZCxcbiAgICAgIGRhdGE6IGFyZ3MsXG4gICAgICBwdXJwb3NlOiBFbnZlbG9wZUJ1c01lc3NhZ2VQdXJwb3NlLk5PVElGSUNBVElPTixcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzcG9uZDxUPihcbiAgICByZXF1ZXN0OiBFbnZlbG9wZUJ1c01lc3NhZ2U8dW5rbm93biwgRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPEFwaVRvUHJvdmlkZT4+LFxuICAgIGRhdGE6IFQsXG4gICAgZXJyb3I/OiBhbnlcbiAgKTogdm9pZCB7XG4gICAgaWYgKHJlcXVlc3QucHVycG9zZSAhPT0gRW52ZWxvcGVCdXNNZXNzYWdlUHVycG9zZS5SRVFVRVNUKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzcG9uZCBhIG1lc3NhZ2UgdGhhdCBpcyBub3QgYSByZXF1ZXN0XCIpO1xuICAgIH1cblxuICAgIGlmICghcmVxdWVzdC5yZXF1ZXN0SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNwb25kIGEgcmVxdWVzdCB3aXRob3V0IGEgcmVxdWVzdElkXCIpO1xuICAgIH1cblxuICAgIHRoaXMuc2VuZCh7XG4gICAgICByZXF1ZXN0SWQ6IHJlcXVlc3QucmVxdWVzdElkLFxuICAgICAgcHVycG9zZTogRW52ZWxvcGVCdXNNZXNzYWdlUHVycG9zZS5SRVNQT05TRSxcbiAgICAgIHR5cGU6IHJlcXVlc3QudHlwZSBhcyBGdW5jdGlvblByb3BlcnR5TmFtZXM8QXBpVG9Qcm92aWRlPixcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShlcnJvciksXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGNhbGxiYWNrKHJlc3BvbnNlOiBFbnZlbG9wZUJ1c01lc3NhZ2U8dW5rbm93biwgRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPEFwaVRvQ29uc3VtZT4+KSB7XG4gICAgaWYgKHJlc3BvbnNlLnB1cnBvc2UgIT09IEVudmVsb3BlQnVzTWVzc2FnZVB1cnBvc2UuUkVTUE9OU0UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBpbnZva2UgY2FsbGJhY2sgd2l0aCBhIG1lc3NhZ2UgdGhhdCBpcyBub3QgYSByZXNwb25zZVwiKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5yZXF1ZXN0SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhY2tub3dsZWRnZSBhIHJlc3BvbnNlIHdpdGhvdXQgYSByZXF1ZXN0SWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLnJlcXVlc3RIYW5kbGVycy5nZXQocmVzcG9uc2UucmVxdWVzdElkKTtcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFjayBub3QgZm91bmQgZm9yIFwiICsgcmVzcG9uc2UpO1xuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdEhhbmRsZXJzLmRlbGV0ZShyZXNwb25zZS5yZXF1ZXN0SWQpO1xuXG4gICAgaWYgKCFyZXNwb25zZS5lcnJvcikge1xuICAgICAgY2FsbGJhY2sucmVzb2x2ZShyZXNwb25zZS5kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sucmVqZWN0KG5ldyBFcnJvcihyZXNwb25zZS5lcnJvcikpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVjZWl2ZShcbiAgICAvLyBXZSBjYW4gcmVjZWl2ZSBtZXNzYWdlcyBmcm9tIGJvdGggdGhlIEFQSXMgd2UgcHJvdmlkZSBhbmQgY29uc3VtZS5cbiAgICBtZXNzYWdlOiBFbnZlbG9wZUJ1c01lc3NhZ2U8dW5rbm93biwgRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPEFwaVRvQ29uc3VtZT4gfCBGdW5jdGlvblByb3BlcnR5TmFtZXM8QXBpVG9Qcm92aWRlPj4sXG4gICAgYXBpSW1wbDogQXBpVG9Qcm92aWRlXG4gICkge1xuICAgIHRoaXMuY3VycmVudEFwaUltcGwgPSBhcGlJbXBsO1xuXG4gICAgaWYgKG1lc3NhZ2UucHVycG9zZSA9PT0gRW52ZWxvcGVCdXNNZXNzYWdlUHVycG9zZS5SRVNQT05TRSkge1xuICAgICAgLy8gV2UgY2FuIG9ubHkgcmVjZWl2ZSByZXNwb25zZXMgZm9yIHRoZSBBUEkgd2UgY29uc3VtZS5cbiAgICAgIHRoaXMuY2FsbGJhY2sobWVzc2FnZSBhcyBFbnZlbG9wZUJ1c01lc3NhZ2U8dW5rbm93biwgUmVxdWVzdFByb3BlcnR5TmFtZXM8QXBpVG9Db25zdW1lPj4pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLnB1cnBvc2UgPT09IEVudmVsb3BlQnVzTWVzc2FnZVB1cnBvc2UuUkVRVUVTVCkge1xuICAgICAgLy8gV2UgY2FuIG9ubHkgcmVjZWl2ZSByZXF1ZXN0cyBmb3IgdGhlIEFQSSB3ZSBwcm92aWRlLlxuICAgICAgY29uc3QgcmVxdWVzdCA9IG1lc3NhZ2UgYXMgRW52ZWxvcGVCdXNNZXNzYWdlPHVua25vd24sIFJlcXVlc3RQcm9wZXJ0eU5hbWVzPEFwaVRvUHJvdmlkZT4+O1xuXG4gICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICB0cnkge1xuICAgICAgICByZXNwb25zZSA9IGFwaUltcGxbcmVxdWVzdC50eXBlXS5hcHBseShhcGlJbXBsLCByZXF1ZXN0LmRhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy5yZXNwb25kKHJlcXVlc3QsIHVuZGVmaW5lZCwgZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIShyZXNwb25zZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG1ha2UgYSByZXF1ZXN0IHRvICcke3JlcXVlc3QudHlwZX0nIGJlY2F1c2UgaXQgZG9lcyBub3QgcmV0dXJuIGEgUHJvbWlzZWApO1xuICAgICAgfVxuXG4gICAgICByZXNwb25zZVxuICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzcG9uZChyZXF1ZXN0LCBkYXRhKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgdGhpcy5yZXNwb25kKHJlcXVlc3QsIHVuZGVmaW5lZCwgZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWVzc2FnZS5wdXJwb3NlID09PSBFbnZlbG9wZUJ1c01lc3NhZ2VQdXJwb3NlLk5PVElGSUNBVElPTikge1xuICAgICAgLy8gV2UgY2FuIG9ubHkgcmVjZWl2ZSBub3RpZmljYXRpb25zIGZvciBtZXRob2RzIG9mIHRoZSBBUEkgd2UgcHJvdmlkZS5cbiAgICAgIGNvbnN0IG1ldGhvZCA9IG1lc3NhZ2UudHlwZSBhcyBOb3RpZmljYXRpb25Qcm9wZXJ0eU5hbWVzPEFwaVRvUHJvdmlkZT47XG4gICAgICBhcGlJbXBsW21ldGhvZF0/LmFwcGx5KGFwaUltcGwsIG1lc3NhZ2UuZGF0YSk7XG5cbiAgICAgIGlmICh0aGlzLnJlbW90ZU5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25zLmluZGV4T2YobWV0aG9kKSA+PSAwKSB7XG4gICAgICAgIHRoaXMuc2VuZCh7XG4gICAgICAgICAgdHlwZTogbWV0aG9kLFxuICAgICAgICAgIHB1cnBvc2U6IEVudmVsb3BlQnVzTWVzc2FnZVB1cnBvc2UuTk9USUZJQ0FUSU9OLFxuICAgICAgICAgIGRhdGE6IG1lc3NhZ2UuZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGNhbiBvbmx5IHJlY2VpdmUgbm90aWZpY2F0aW9ucyBmcm9tIHN1YnNjcmlwdGlvbnMgb2YgdGhlIEFQSSB3ZSBjb25zdW1lLlxuICAgICAgY29uc3QgbG9jYWxTdWJzY3JpcHRpb25NZXRob2QgPSBtZXNzYWdlLnR5cGUgYXMgTm90aWZpY2F0aW9uUHJvcGVydHlOYW1lczxBcGlUb0NvbnN1bWU+O1xuICAgICAgdGhpcy5sb2NhbE5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25zLmdldChsb2NhbFN1YnNjcmlwdGlvbk1ldGhvZCk/LmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKC4uLihtZXNzYWdlLmRhdGEgYXMgYW55W10pKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UucHVycG9zZSA9PT0gRW52ZWxvcGVCdXNNZXNzYWdlUHVycG9zZS5OT1RJRklDQVRJT05fU1VCU0NSSVBUSU9OKSB7XG4gICAgICAvLyBXZSBjYW4gb25seSByZWNlaXZlIHN1YnNjcmlwdGlvbnMgZm9yIG1ldGhvZHMgb2YgdGhlIEFQSSB3ZSBwcm92aWRlLlxuICAgICAgY29uc3QgbWV0aG9kID0gbWVzc2FnZS50eXBlIGFzIE5vdGlmaWNhdGlvblByb3BlcnR5TmFtZXM8QXBpVG9Qcm92aWRlPjtcbiAgICAgIGlmICh0aGlzLnJlbW90ZU5vdGlmaWNhdGlvbnNTdWJzY3JpcHRpb25zLmluZGV4T2YobWV0aG9kKSA8IDApIHtcbiAgICAgICAgdGhpcy5yZW1vdGVOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9ucy5wdXNoKG1ldGhvZCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UucHVycG9zZSA9PT0gRW52ZWxvcGVCdXNNZXNzYWdlUHVycG9zZS5OT1RJRklDQVRJT05fVU5TVUJTQ1JJUFRJT04pIHtcbiAgICAgIC8vIFdlIGNhbiBvbmx5IHJlY2VpdmUgdW5zdWJzY3JpcHRpb25zIGZvciBtZXRob2RzIG9mIHRoZSBBUEkgd2UgcHJvdmlkZS5cbiAgICAgIGNvbnN0IG1ldGhvZCA9IG1lc3NhZ2UudHlwZSBhcyBOb3RpZmljYXRpb25Qcm9wZXJ0eU5hbWVzPEFwaVRvUHJvdmlkZT47XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMucmVtb3RlTm90aWZpY2F0aW9uc1N1YnNjcmlwdGlvbnMuaW5kZXhPZihtZXRob2QpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgdGhpcy5yZW1vdGVOb3RpZmljYXRpb25zU3Vic2NyaXB0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtZXNzYWdlLnB1cnBvc2UgPT09IEVudmVsb3BlQnVzTWVzc2FnZVB1cnBvc2UuU0hBUkVEX1ZBTFVFX0dFVF9ERUZBVUxUKSB7XG4gICAgICBjb25zdCBtZXRob2QgPSBtZXNzYWdlLnR5cGUgYXMgU2hhcmVkVmFsdWVQcm92aWRlclByb3BlcnR5TmFtZXM8QXBpVG9Qcm92aWRlPjtcbiAgICAgIHRoaXMuc2VuZCh7XG4gICAgICAgIHR5cGU6IG1ldGhvZCxcbiAgICAgICAgcHVycG9zZTogRW52ZWxvcGVCdXNNZXNzYWdlUHVycG9zZS5TSEFSRURfVkFMVUVfVVBEQVRFLFxuICAgICAgICBkYXRhOiB0aGlzLmdldEN1cnJlbnRTdG9yZWRTaGFyZWRWYWx1ZU9yRGVmYXVsdChtZXRob2QsIGFwaUltcGwpLFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UucHVycG9zZSA9PT0gRW52ZWxvcGVCdXNNZXNzYWdlUHVycG9zZS5TSEFSRURfVkFMVUVfVVBEQVRFKSB7XG4gICAgICBjb25zdCBtZXRob2QgPSBtZXNzYWdlLnR5cGUgYXMgU2hhcmVkVmFsdWVQcm92aWRlclByb3BlcnR5TmFtZXM8QXBpVG9Qcm92aWRlPjtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLmxvY2FsU2hhcmVkVmFsdWVTdWJzY3JpcHRpb25zLmdldChtZXRob2QpO1xuICAgICAgdGhpcy5sb2NhbFNoYXJlZFZhbHVlc1N0b3JlLnNldChtZXRob2QsIG1lc3NhZ2UuZGF0YSBhcyBhbnkpO1xuICAgICAgc3Vic2NyaXB0aW9ucz8uZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKG1lc3NhZ2UuZGF0YSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBnZXROZXh0UmVxdWVzdElkKCkge1xuICAgIHJldHVybiBgJHt0aGlzLm5hbWV9XyR7dGhpcy5yZXF1ZXN0SWRDb3VudGVyKyt9YDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWNoZWRQcm94eTxUIGV4dGVuZHMgb2JqZWN0LCBLIGV4dGVuZHMga2V5b2YgVCwgVj4oY2FjaGU6IE1hcDxLLCBWPiwgcDogeyBnZXQodGFyZ2V0OiBULCBwOiBrZXlvZiBUKTogViB9KSB7XG4gIHJldHVybiBuZXcgUHJveHk8VD4oe30gYXMgVCwge1xuICAgIHNldDogKHRhcmdldCwgbmFtZSwgdmFsdWUpID0+IHtcbiAgICAgIGNhY2hlLnNldChuYW1lIGFzIEssIHZhbHVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0OiAodGFyZ2V0LCBuYW1lKSA9PiB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KG5hbWUgYXMgSykgPz8gY2FjaGUuc2V0KG5hbWUgYXMgSywgcC5nZXQ/Lih0YXJnZXQsIG5hbWUgYXMgSykpLmdldChuYW1lIGFzIEspO1xuICAgIH0sXG4gIH0pO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDIwIFJlZCBIYXQsIEluYy4gYW5kL29yIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgKiBmcm9tIFwiLi9FbnZlbG9wZUJ1c01lc3NhZ2VNYW5hZ2VyXCI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjAgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCBlbnVtIENvbnRlbnRUeXBlIHtcbiAgVEVYVCA9IFwidGV4dFwiLFxuICBCSU5BUlkgPSBcImJpbmFyeVwiLFxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDIwIFJlZCBIYXQsIEluYy4gYW5kL29yIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IENvbnRlbnRUeXBlIH0gZnJvbSBcIi4vQ29udGVudFR5cGVcIjtcblxuZXhwb3J0IGNsYXNzIFJlc291cmNlQ29udGVudCB7XG4gIHB1YmxpYyByZWFkb25seSBwYXRoOiBzdHJpbmc7XG4gIHB1YmxpYyByZWFkb25seSBjb250ZW50Pzogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgdHlwZTogQ29udGVudFR5cGU7XG5cbiAgY29uc3RydWN0b3IocGF0aDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcgfCB1bmRlZmluZWQsIHR5cGU/OiBDb250ZW50VHlwZSkge1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IENvbnRlbnRUeXBlLlRFWFQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29udGVudFR5cGUgfSBmcm9tIFwiLi9Db250ZW50VHlwZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJlc291cmNlQ29udGVudE9wdGlvbnMge1xuICB0eXBlOiBDb250ZW50VHlwZTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgUmVzb3VyY2VDb250ZW50T3B0aW9ucyB9IGZyb20gXCIuL1Jlc291cmNlQ29udGVudE9wdGlvbnNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBSZXNvdXJjZUNvbnRlbnRSZXF1ZXN0IHtcbiAgcGF0aDogc3RyaW5nO1xuICBvcHRzPzogUmVzb3VyY2VDb250ZW50T3B0aW9ucztcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBSZXNvdXJjZUNvbnRlbnQgfSBmcm9tIFwiLi9SZXNvdXJjZUNvbnRlbnRcIjtcbmltcG9ydCB7IFJlc291cmNlc0xpc3QgfSBmcm9tIFwiLi9SZXNvdXJjZXNMaXN0XCI7XG5pbXBvcnQgeyBSZXNvdXJjZUNvbnRlbnRPcHRpb25zIH0gZnJvbSBcIi4vUmVzb3VyY2VDb250ZW50T3B0aW9uc1wiO1xuaW1wb3J0IHsgUmVzb3VyY2VMaXN0T3B0aW9ucyB9IGZyb20gXCIuL1Jlc291cmNlTGlzdE9wdGlvbnNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBSZXNvdXJjZUNvbnRlbnRTZXJ2aWNlIHtcbiAgZ2V0KHBhdGg6IHN0cmluZywgb3B0cz86IFJlc291cmNlQ29udGVudE9wdGlvbnMpOiBQcm9taXNlPFJlc291cmNlQ29udGVudCB8IHVuZGVmaW5lZD47XG5cbiAgbGlzdChnbG9iUGF0dGVybjogc3RyaW5nLCBvcHRzPzogUmVzb3VyY2VMaXN0T3B0aW9ucyk6IFByb21pc2U8UmVzb3VyY2VzTGlzdD47XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjAgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFNlYXJjaFR5cGUgfSBmcm9tIFwiLi9TZWFyY2hUeXBlXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VMaXN0T3B0aW9ucyB7XG4gIHR5cGU6IFNlYXJjaFR5cGU7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjAgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFJlc291cmNlTGlzdE9wdGlvbnMgfSBmcm9tIFwiLi9SZXNvdXJjZUxpc3RPcHRpb25zXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVzb3VyY2VMaXN0UmVxdWVzdCB7XG4gIHBhdHRlcm46IHN0cmluZztcbiAgb3B0cz86IFJlc291cmNlTGlzdE9wdGlvbnM7XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTkgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNsYXNzIFJlc291cmNlc0xpc3Qge1xuICBwdWJsaWMgcmVhZG9ubHkgcGF0dGVybjogc3RyaW5nO1xuICBwdWJsaWMgcmVhZG9ubHkgcGF0aHM6IHN0cmluZ1tdO1xuXG4gIGNvbnN0cnVjdG9yKHBhdHRlcm46IHN0cmluZywgcGF0aHM6IHN0cmluZ1tdKSB7XG4gICAgdGhpcy5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICB0aGlzLnBhdGhzID0gcGF0aHM7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGVudW0gU2VhcmNoVHlwZSB7XG4gIFRSQVZFUlNBTCA9IFwidHJhdmVyc2FsXCIsXG4gIEFTU0VUX0ZPTERFUiA9IFwiYXNzZXQtZm9sZGVyXCIsXG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjAgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgV29ya3NwYWNlRWRpdCwgUmVzb3VyY2VDb250ZW50LCBSZXNvdXJjZUNvbnRlbnRSZXF1ZXN0LCBSZXNvdXJjZUxpc3RSZXF1ZXN0LCBSZXNvdXJjZXNMaXN0IH0gZnJvbSBcIi4uL2FwaVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtzcGFjZUNoYW5uZWxBcGkge1xuICBrb2dpdG9Xb3Jrc3BhY2VfbmV3RWRpdChlZGl0OiBXb3Jrc3BhY2VFZGl0KTogdm9pZDtcbiAga29naXRvV29ya3NwYWNlX29wZW5GaWxlKHBhdGg6IHN0cmluZyk6IHZvaWQ7XG4gIGtvZ2l0b1dvcmtzcGFjZV9yZXNvdXJjZUNvbnRlbnRSZXF1ZXN0KHJlcXVlc3Q6IFJlc291cmNlQ29udGVudFJlcXVlc3QpOiBQcm9taXNlPFJlc291cmNlQ29udGVudCB8IHVuZGVmaW5lZD47XG4gIGtvZ2l0b1dvcmtzcGFjZV9yZXNvdXJjZUxpc3RSZXF1ZXN0KHJlcXVlc3Q6IFJlc291cmNlTGlzdFJlcXVlc3QpOiBQcm9taXNlPFJlc291cmNlc0xpc3Q+O1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDIwIFJlZCBIYXQsIEluYy4gYW5kL29yIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY2xhc3MgV29ya3NwYWNlRWRpdCB7XG4gIHB1YmxpYyByZWFkb25seSBpZDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGlkOiBzdHJpbmcpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgKiBmcm9tIFwiLi9Xb3Jrc3BhY2VDaGFubmVsQXBpXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9SZXNvdXJjZUNvbnRlbnRPcHRpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9SZXNvdXJjZUxpc3RPcHRpb25zXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9TZWFyY2hUeXBlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9SZXNvdXJjZUNvbnRlbnRSZXF1ZXN0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9SZXNvdXJjZUNvbnRlbnRTZXJ2aWNlXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9Xb3Jrc3BhY2VFZGl0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9SZXNvdXJjZXNMaXN0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9SZXNvdXJjZUxpc3RSZXF1ZXN0XCI7XG5leHBvcnQgKiBmcm9tIFwiLi9SZXNvdXJjZUNvbnRlbnRcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0NvbnRlbnRUeXBlXCI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjIgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IEdJU1RfT1JJR0lOX1JFTU9URV9OQU1FID0gXCJvcmlnaW5cIjtcbmV4cG9ydCBjb25zdCBHSVRfT1JJR0lOX1JFTU9URV9OQU1FID0gXCJvcmlnaW5cIjtcbmV4cG9ydCBjb25zdCBHSVRfREVGQVVMVF9CUkFOQ0ggPSBcIm1haW5cIjtcbmV4cG9ydCBjb25zdCBHSVNUX0RFRkFVTFRfQlJBTkNIID0gXCJtYWluXCI7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjIgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmV4cG9ydCBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjIgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYmFzZW5hbWUsIGV4dG5hbWUsIHBhcnNlIH0gZnJvbSBcInBhdGhcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlV29ya3NwYWNlRmlsZVJlbGF0aXZlUGF0aChyZWxhdGl2ZVBhdGg6IHN0cmluZykge1xuICBjb25zdCBleHRlbnNpb24gPSBleHRyYWN0RXh0ZW5zaW9uKHJlbGF0aXZlUGF0aCk7XG4gIHJldHVybiB7XG4gICAgcmVsYXRpdmVQYXRoV2l0aG91dEV4dGVuc2lvbjogcmVsYXRpdmVQYXRoLnJlcGxhY2UoYC4ke2V4dGVuc2lvbn1gLCBcIlwiKSxcbiAgICByZWxhdGl2ZURpclBhdGg6IHBhcnNlKHJlbGF0aXZlUGF0aCkuZGlyLFxuICAgIGV4dGVuc2lvbjogZXh0ZW5zaW9uLFxuICAgIG5hbWVXaXRob3V0RXh0ZW5zaW9uOiBiYXNlbmFtZShyZWxhdGl2ZVBhdGgsIGAuJHtleHRlbnNpb259YCksXG4gICAgbmFtZTogYmFzZW5hbWUocmVsYXRpdmVQYXRoKSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RFeHRlbnNpb24ocmVsYXRpdmVQYXRoOiBzdHJpbmcpIHtcbiAgY29uc3QgZmlsZU5hbWUgPSBiYXNlbmFtZShyZWxhdGl2ZVBhdGgpO1xuICBpZiAoZmlsZU5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICByZXR1cm4gZmlsZU5hbWUuc2xpY2UoMSk7XG4gIH1cblxuICBjb25zdCBtYXRjaERvdHMgPSBmaWxlTmFtZS5tYXRjaCgvXFwuL2cpO1xuICBpZiAobWF0Y2hEb3RzICYmIG1hdGNoRG90cy5sZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGZpbGVOYW1lXG4gICAgICAuc3BsaXQoL1xcLiguKikvcylcbiAgICAgIC5zbGljZSgxKVxuICAgICAgLmpvaW4oXCJcIik7XG4gIH1cblxuICByZXR1cm4gZXh0bmFtZShyZWxhdGl2ZVBhdGgpLnJlcGxhY2UoXCIuXCIsIFwiXCIpO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDIxIFJlZCBIYXQsIEluYy4gYW5kL29yIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBqb2luIH0gZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7IGVuY29kZXIgfSBmcm9tIFwiLi4vZW5jb2RlcmRlY29kZXIvRW5jb2RlckRlY29kZXJcIjtcbmltcG9ydCB7IEVtc2NyaXB0ZW5GcywgS2llU2FuZGJveFdvcmtzcGFjZXNGcywgTGZzU3RhdCB9IGZyb20gXCIuL0tpZVNhbmRib3hXb3Jrc3BhY2VGc1wiO1xuXG4vLyBjb21lcyBmcm9tIGZzTWFpbi5mc1xuZGVjbGFyZSBsZXQgRlM6IEVtc2NyaXB0ZW5GcztcblxuLy8gY29tZXMgZnJvbSBmc01haW4uZnNcbmRlY2xhcmUgbGV0IElEQkZTOiBFbXNjcmlwdGVuRnMgJiB7XG4gIHN5bmNmcyhtb3VudDogeyBtb3VudHBvaW50OiBzdHJpbmcgfSwgbW9kZTogYm9vbGVhbiwgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCk6IHZvaWQ7XG59O1xuXG5leHBvcnQgdHlwZSBGc1NjaGVtYSA9IE1hcDxcbiAgc3RyaW5nLFxuICB7XG4gICAgaW5vOiBudW1iZXI7XG4gICAgbW9kZTogbnVtYmVyO1xuICB9XG4+O1xuXG4vLyBXZSBleHBlY3QgdGhhdCBwZW9wbGUgd2lsbCBub3QgdXNlIG1vcmUgdGhhbiB0aHJlZSB0YWJzIHNpbXVsdGFuZW91c2x5LlxuY29uc3QgTUFYX05VTUJFUl9PRl9DQUNIRURfRlNfSU5TVEFOQ0VTID0gMztcblxuZXhwb3J0IGNsYXNzIEZzQ2FjaGUge1xuICBwcml2YXRlIHJlYWRvbmx5IHNjaGVtYXNDYWNoZTogUmVjb3JkPHN0cmluZywgUHJvbWlzZTxGc1NjaGVtYT4+ID0ge307XG4gIHByaXZhdGUgcmVhZG9ubHkgY2FjaGUgPSBuZXcgTWFwPHN0cmluZywgeyBmczogUHJvbWlzZTxLaWVTYW5kYm94V29ya3NwYWNlc0ZzPjsgbGFzdEhpdDogRGF0ZSB9PigpO1xuXG4gIC8vIGNvbnRyb2xcblxuICBwdWJsaWMgaGFzU3BhY2VGb3IoZnNNb3VudFBvaW50OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZS5oYXMoZnNNb3VudFBvaW50KSB8fCB0aGlzLmNhY2hlLnNpemUgPCBNQVhfTlVNQkVSX09GX0NBQ0hFRF9GU19JTlNUQU5DRVM7XG4gIH1cblxuICBwdWJsaWMgZ2V0TGFzdFJlY2VudGx5VXNlZCgpOiBzdHJpbmcge1xuICAgIGNvbnN0IFtscnVGc01vdW50UG9pbnQsIF9dID0gWy4uLnRoaXMuY2FjaGUuZW50cmllcygpXS5zb3J0KFxuICAgICAgKFtfLCBhXSwgW19fLCBiXSkgPT4gYS5sYXN0SGl0LnZhbHVlT2YoKSAtIGIubGFzdEhpdC52YWx1ZU9mKClcbiAgICApWzBdO1xuICAgIHJldHVybiBscnVGc01vdW50UG9pbnQ7XG4gIH1cblxuICAvLyBnZXQgb3IgbG9hZFxuXG4gIHB1YmxpYyBnZXRPckxvYWRGc1NjaGVtYShmc01vdW50UG9pbnQ6IHN0cmluZykge1xuICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuc2NoZW1hc0NhY2hlW2ZzTW91bnRQb2ludF07XG4gICAgaWYgKHNjaGVtYSkge1xuICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG5cbiAgICBjb25zdCBuZXdGc1NjaGVtYVByb21pc2UgPSB0aGlzLmxvYWRGc1NjaGVtYShmc01vdW50UG9pbnQpO1xuICAgIHRoaXMuc2NoZW1hc0NhY2hlW2ZzTW91bnRQb2ludF0gPSBuZXdGc1NjaGVtYVByb21pc2U7XG4gICAgcmV0dXJuIG5ld0ZzU2NoZW1hUHJvbWlzZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRPckxvYWRGcyhmc01vdW50UG9pbnQ6IHN0cmluZykge1xuICAgIGNvbnN0IGhpdCA9IHRoaXMuY2FjaGUuZ2V0KGZzTW91bnRQb2ludCk7XG4gICAgaWYgKGhpdCkge1xuICAgICAgdGhpcy5jYWNoZS5zZXQoZnNNb3VudFBvaW50LCB7IGZzOiBoaXQuZnMsIGxhc3RIaXQ6IG5ldyBEYXRlKCkgfSk7XG4gICAgICByZXR1cm4gaGl0LmZzO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0ZzUHJvbWlzZSA9IHRoaXMubG9hZEZzKGZzTW91bnRQb2ludCk7XG4gICAgdGhpcy5jYWNoZS5zZXQoZnNNb3VudFBvaW50LCB7IGZzOiBuZXdGc1Byb21pc2UsIGxhc3RIaXQ6IG5ldyBEYXRlKCkgfSk7XG4gICAgcmV0dXJuIG5ld0ZzUHJvbWlzZTtcbiAgfVxuXG4gIC8vIGZzIHNjaGVtYVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZEZzU2NoZW1hKGZzTW91bnRQb2ludDogc3RyaW5nKTogUHJvbWlzZTxGc1NjaGVtYT4ge1xuICAgIGNvbnNvbGUuZGVidWcoYExvYWRpbmcgRlMgU2NoZW1hIGZvciAke2ZzTW91bnRQb2ludH1gKTtcbiAgICBjb25zb2xlLnRpbWUoYExvYWQgRlMgU2NoZW1hIGZvciAke2ZzTW91bnRQb2ludH1gKTtcblxuICAgIHRoaXMuY3JlYXRlRnNTY2hlbWFTdHJ1Y3R1cmUoZnNNb3VudFBvaW50KTtcbiAgICBhd2FpdCB0aGlzLnN5bmNGc1NjaGVtYSh0cnVlLCBmc01vdW50UG9pbnQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZzU2NoZW1hSW5kZXhKc29uID0gRlMucmVhZEZpbGUoXG4gICAgICAgIGZzU2NoZW1hSnNvblBhdGgoZnNNb3VudFBvaW50KSxcbiAgICAgICAgdG9SZWFkV3JpdGVGaWxlT3B0aW9ucyh7IGVuY29kaW5nOiBcInV0ZjhcIiB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgTWFwKEpTT04ucGFyc2UoZnNTY2hlbWFJbmRleEpzb24gYXMgc3RyaW5nKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3dXYXNpRXJyb3JUb05vZGVFcnJvcihcIlJlYWRpbmcgRlMgU2NoZW1hIEpTT05cIiwgZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBKU09OIHRvIHJlYWQsIGl0IG1lYW5zIHRoYXQgdGhpcyBpcyBhIG5ldyBGUy5cbiAgICAgICAgICByZXR1cm4gbmV3IE1hcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBjb25zb2xlLnRpbWVFbmQoYExvYWQgRlMgU2NoZW1hIGZvciAke2ZzTW91bnRQb2ludH1gKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHN5bmNGc1NjaGVtYShpc1Jlc3RvcmU6IGJvb2xlYW4sIGZzTW91bnRQb2ludDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIElEQkZTLnN5bmNmcyh7IG1vdW50cG9pbnQ6IGZzU2NoZW1hRGlyKGZzTW91bnRQb2ludCkgfSwgaXNSZXN0b3JlLCByZXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRocm93V2FzaUVycm9yVG9Ob2RlRXJyb3IoYFN5bmMgRlMgU2NoZW1hICcke2ZzTW91bnRQb2ludH0nICgke2lzUmVzdG9yZX0pYCwgZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRnNTY2hlbWFTdHJ1Y3R1cmUoZnNNb3VudFBvaW50OiBzdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgRlMuc3RhdChmc1NjaGVtYURpcihmc01vdW50UG9pbnQpKTtcbiAgICAgIGNvbnNvbGUuZGVidWcoYEZTIFNjaGVtYSBhbHJlYWR5IGxvYWRlZCBmb3IgJHtmc01vdW50UG9pbnR9YCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgRlMubWtkaXIoZnNTY2hlbWFEaXIoZnNNb3VudFBvaW50KSk7XG4gICAgICBGUy5tb3VudChJREJGUywge30sIGZzU2NoZW1hRGlyKGZzTW91bnRQb2ludCkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmx1c2hGc1NjaGVtYShmc01vdW50UG9pbnQ6IHN0cmluZykge1xuICAgIGNvbnN0IGZzU2NoZW1hVG9GbHVzaCA9IGVuY29kZXIuZW5jb2RlKFxuICAgICAgSlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbSgoYXdhaXQgdGhpcy5nZXRPckxvYWRGc1NjaGVtYShmc01vdW50UG9pbnQpKS5lbnRyaWVzKCkpKVxuICAgICk7XG5cbiAgICB0cnkge1xuICAgICAgRlMud3JpdGVGaWxlKGZzU2NoZW1hSnNvblBhdGgoZnNNb3VudFBvaW50KSwgZnNTY2hlbWFUb0ZsdXNoLCB0b1JlYWRXcml0ZUZpbGVPcHRpb25zKHsgZW5jb2Rpbmc6IFwidXRmOFwiIH0pKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvd1dhc2lFcnJvclRvTm9kZUVycm9yKFwiV3JpdGluZyBGUyBTY2hlbWEgSlNPTlwiLCBlKTtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLnN5bmNGc1NjaGVtYShmYWxzZSwgZnNNb3VudFBvaW50KTtcbiAgfVxuXG4gIC8vIGZzXG5cbiAgcHJpdmF0ZSBhc3luYyBsb2FkRnMoZnNNb3VudFBvaW50OiBzdHJpbmcpIHtcbiAgICBjb25zdCBuZXdGczogS2llU2FuZGJveFdvcmtzcGFjZXNGcyA9IHtcbiAgICAgIHByb21pc2VzOiB7XG4gICAgICAgIHJlbmFtZTogYXN5bmMgKHBhdGg6IHN0cmluZywgbmV3UGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcoXCJyZW5hbWVcIiwgcGF0aCwgbmV3UGF0aCk7XG4gICAgICAgICAgICBGUy5yZW5hbWUocGF0aCwgbmV3UGF0aCk7XG4gICAgICAgICAgICAoYXdhaXQgdGhpcy5nZXRPckxvYWRGc1NjaGVtYShmc01vdW50UG9pbnQpKS5kZWxldGUocGF0aCk7XG4gICAgICAgICAgICBhd2FpdCBuZXdGcy5wcm9taXNlcy5sc3RhdChuZXdQYXRoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvd1dhc2lFcnJvclRvTm9kZUVycm9yKFwicmVuYW1lXCIsIGUsIHBhdGgsIG5ld1BhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhZEZpbGU6IGFzeW5jIChwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IGFueSkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmRlYnVnKFwicmVhZEZpbGVcIiwgcGF0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gRlMucmVhZEZpbGUocGF0aCwgdG9SZWFkV3JpdGVGaWxlT3B0aW9ucyhvcHRpb25zKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3dXYXNpRXJyb3JUb05vZGVFcnJvcihcInJlYWRGaWxlXCIsIGUsIHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGVGaWxlOiBhc3luYyAocGF0aDogc3RyaW5nLCBkYXRhOiBVaW50OEFycmF5IHwgc3RyaW5nLCBvcHRpb25zOiBhbnkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhcIndyaXRlRmlsZVwiLCBwYXRoLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgICAgIEZTLndyaXRlRmlsZShwYXRoLCBkYXRhLCB0b1JlYWRXcml0ZUZpbGVPcHRpb25zKG9wdGlvbnMpKTtcbiAgICAgICAgICAgIGF3YWl0IG5ld0ZzLnByb21pc2VzLmxzdGF0KHBhdGgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93V2FzaUVycm9yVG9Ob2RlRXJyb3IoXCJ3cml0ZUZpbGVcIiwgZSwgcGF0aCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmxpbms6IGFzeW5jIChwYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhcInVubGlua1wiLCBwYXRoKTtcbiAgICAgICAgICAgIEZTLnVubGluayhwYXRoKTtcbiAgICAgICAgICAgIChhd2FpdCB0aGlzLmdldE9yTG9hZEZzU2NoZW1hKGZzTW91bnRQb2ludCkpLmRlbGV0ZShwYXRoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvd1dhc2lFcnJvclRvTm9kZUVycm9yKFwidW5saW5rXCIsIGUsIHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVhZGRpcjogYXN5bmMgKHBhdGg6IHN0cmluZywgb3B0aW9uczogYW55KSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcoXCJyZWFkZGlyXCIsIHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZURvdFBhdGhzKEZTLnJlYWRkaXIocGF0aCwgb3B0aW9ucykpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93V2FzaUVycm9yVG9Ob2RlRXJyb3IoXCJyZWFkZGlyXCIsIGUsIHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWtkaXI6IGFzeW5jIChwYXRoOiBzdHJpbmcsIG1vZGU/OiBudW1iZXIpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhcIm1rZGlyXCIsIHBhdGgsIG1vZGUpO1xuICAgICAgICAgICAgRlMubWtkaXIocGF0aCwgbW9kZSk7XG4gICAgICAgICAgICBhd2FpdCBuZXdGcy5wcm9taXNlcy5sc3RhdChwYXRoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvd1dhc2lFcnJvclRvTm9kZUVycm9yKFwibWtkaXJcIiwgZSwgcGF0aCwgbW9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBybWRpcjogYXN5bmMgKHBhdGg6IHN0cmluZykgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmRlYnVnKFwicm1kaXJcIiwgcGF0aCk7XG4gICAgICAgICAgICBGUy5ybWRpcihwYXRoKTtcbiAgICAgICAgICAgIChhd2FpdCB0aGlzLmdldE9yTG9hZEZzU2NoZW1hKGZzTW91bnRQb2ludCkpLmRlbGV0ZShwYXRoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvd1dhc2lFcnJvclRvTm9kZUVycm9yKFwicm1kaXJcIiwgZSwgcGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdGF0OiBhc3luYyAocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcoXCJzdGF0XCIsIHBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRvTGZzU3RhdCh0aGlzLCBmc01vdW50UG9pbnQsIHBhdGgsIEZTLnN0YXQocGF0aCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93V2FzaUVycm9yVG9Ob2RlRXJyb3IoXCJzdGF0XCIsIGUsIHBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbHN0YXQ6IGFzeW5jIChwYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhcImxzdGF0XCIsIHBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRvTGZzU3RhdCh0aGlzLCBmc01vdW50UG9pbnQsIHBhdGgsIEZTLnN0YXQocGF0aCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93V2FzaUVycm9yVG9Ob2RlRXJyb3IoXCJsc3RhdFwiLCBlLCBwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRsaW5rOiBhc3luYyAocGF0aDogc3RyaW5nLCBvcHRpb25zOiBhbnkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhcInJlYWRsaW5rXCIsIHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIEZTLnJlYWRsaW5rKHBhdGgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93V2FzaUVycm9yVG9Ob2RlRXJyb3IoXCJyZWFkbGlua1wiLCBlLCBwYXRoLCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN5bWxpbms6IGFzeW5jICh0YXJnZXQ6IHN0cmluZywgcGF0aDogc3RyaW5nLCB0eXBlOiBhbnkpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5kZWJ1ZyhcInN5bWxpbmtcIiwgdGFyZ2V0LCBwYXRoLCB0eXBlKTtcbiAgICAgICAgICAgIEZTLnN5bWxpbmsodGFyZ2V0LCBwYXRoKTtcbiAgICAgICAgICAgIGF3YWl0IG5ld0ZzLnByb21pc2VzLmxzdGF0KHBhdGgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93V2FzaUVycm9yVG9Ob2RlRXJyb3IoXCJzeW1saW5rXCIsIGUsIHRhcmdldCwgcGF0aCwgdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjaG1vZDogYXN5bmMgKHBhdGg6IHN0cmluZywgbW9kZTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZGVidWcoXCJjaG1vZFwiLCBwYXRoLCBtb2RlKTtcbiAgICAgICAgICAgIEZTLmNobW9kKHBhdGgsIG1vZGUpO1xuICAgICAgICAgICAgYXdhaXQgbmV3RnMucHJvbWlzZXMubHN0YXQocGF0aCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3dXYXNpRXJyb3JUb05vZGVFcnJvcihcImNobW9kXCIsIGUsIHBhdGgsIG1vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnNvbGUudGltZShgTG9hZCBGUyB0byBtZW1vcnkgLSAke2ZzTW91bnRQb2ludH1gKTtcbiAgICBjb25zb2xlLmRlYnVnKGBMb2FkaW5nIEZTIHRvIG1lbW9yeSAtICR7ZnNNb3VudFBvaW50fWApO1xuICAgIGF3YWl0IHRoaXMuY3JlYXRlRnNTdHJ1Y3R1cmUoZnNNb3VudFBvaW50KTtcbiAgICBhd2FpdCB0aGlzLnN5bmNGcyh0cnVlLCBmc01vdW50UG9pbnQpO1xuICAgIGF3YWl0IHRoaXMuZ2V0T3JMb2FkRnNTY2hlbWEoZnNNb3VudFBvaW50KTtcbiAgICBjb25zb2xlLnRpbWVFbmQoYExvYWQgRlMgdG8gbWVtb3J5IC0gJHtmc01vdW50UG9pbnR9YCk7XG5cbiAgICByZXR1cm4gbmV3RnM7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHN5bmNGcyhpc1Jlc3RvcmU6IGJvb2xlYW4sIGZzTW91bnRQb2ludDogc3RyaW5nKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlcykgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgSURCRlMuc3luY2ZzKHsgbW91bnRwb2ludDogZnNNb3VudFBvaW50IH0sIGlzUmVzdG9yZSwgcmVzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvd1dhc2lFcnJvclRvTm9kZUVycm9yKGBTeW5jIEZTICcke2ZzTW91bnRQb2ludH0nICgke2lzUmVzdG9yZX0pYCwgZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlRnNTdHJ1Y3R1cmUoZnNNb3VudFBvaW50OiBzdHJpbmcpIHtcbiAgICBjb25zb2xlLnRpbWUoYExvYWQgRlMgLSAke2ZzTW91bnRQb2ludH1gKTtcbiAgICBjb25zb2xlLmRlYnVnKGBMb2FkaW5nIEZTIC0gJHtmc01vdW50UG9pbnR9YCk7XG4gICAgdHJ5IHtcbiAgICAgIEZTLm1rZGlyKGZzTW91bnRQb2ludCk7XG4gICAgICBGUy5tb3VudChJREJGUywge30sIGZzTW91bnRQb2ludCk7XG4gICAgICB0aGlzLmNyZWF0ZUZzU2NoZW1hU3RydWN0dXJlKGZzTW91bnRQb2ludCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3dXYXNpRXJyb3JUb05vZGVFcnJvcihgTG9hZCBGUyAke2ZzTW91bnRQb2ludH1gLCBlLCBmc01vdW50UG9pbnQpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGxvYWRpbmcgRlMgLSAke2ZzTW91bnRQb2ludH1gKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBjb25zb2xlLnRpbWVFbmQoYExvYWQgRlMgLSAke2ZzTW91bnRQb2ludH1gKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdW5sb2FkRnMoZnNNb3VudFBvaW50OiBzdHJpbmcpIHtcbiAgICBjb25zb2xlLmRlYnVnKGBVbmxvYWRpbmcgRlMgLSAke2ZzTW91bnRQb2ludH1gKTtcbiAgICBjb25zb2xlLnRpbWUoYFVubG9hZCBGUyAtICR7ZnNNb3VudFBvaW50fWApO1xuICAgIHRoaXMuY2FjaGUuZGVsZXRlKGZzTW91bnRQb2ludCk7XG4gICAgdHJ5IHtcbiAgICAgIEZTLnVubW91bnQoZnNNb3VudFBvaW50KTtcbiAgICAgIEZTLnJtZGlyKGZzTW91bnRQb2ludCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3dXYXNpRXJyb3JUb05vZGVFcnJvcihgVW5sb2FkIEZTICR7ZnNNb3VudFBvaW50fWAsIGUsIGZzTW91bnRQb2ludCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgdW5sb2FkaW5nIEZTIC0gJHtmc01vdW50UG9pbnR9YCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgY29uc29sZS50aW1lRW5kKGBVbmxvYWQgRlMgLSAke2ZzTW91bnRQb2ludH1gKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZmx1c2hGcyhmc01vdW50UG9pbnQ6IHN0cmluZykge1xuICAgIGNvbnNvbGUudGltZShgRmx1c2ggRlMgLSAke2ZzTW91bnRQb2ludH1gKTtcbiAgICBjb25zb2xlLmRlYnVnKGBGbHVzaGluZyBGUyAtICR7ZnNNb3VudFBvaW50fWApO1xuICAgIGF3YWl0IHRoaXMuc3luY0ZzKGZhbHNlLCBmc01vdW50UG9pbnQpO1xuICAgIGF3YWl0IHRoaXMuZmx1c2hGc1NjaGVtYShmc01vdW50UG9pbnQpO1xuICAgIGNvbnNvbGUudGltZUVuZChgRmx1c2ggRlMgLSAke2ZzTW91bnRQb2ludH1gKTtcbiAgfVxufVxuXG4vLyBzY2hlbWEgc3RydWN0dXJlXG5cbmV4cG9ydCBmdW5jdGlvbiBmc1NjaGVtYURpcihmc01vdW50UG9pbnQ6IHN0cmluZykge1xuICByZXR1cm4gYCR7ZnNNb3VudFBvaW50fV9zY2hlbWFgO1xufVxuXG5mdW5jdGlvbiBmc1NjaGVtYUpzb25QYXRoKGZzTW91bnRQb2ludDogc3RyaW5nKSB7XG4gIHJldHVybiBqb2luKGZzU2NoZW1hRGlyKGZzTW91bnRQb2ludCksIFwic2NoZW1hLmpzb25cIik7XG59XG5cbi8vIGVtc2NyaXB0ZW4tZnMgYWRhcHRhdGlvbiB0byBsaWdodG5pbmctZnNcblxuLy8gUmVmZXJlbmNlOiBodHRwczovL2dpdGh1Yi5jb20vaXNvbW9ycGhpYy1naXQvbGlnaHRuaW5nLWZzI2Zzd3JpdGVmaWxlZmlsZXBhdGgtZGF0YS1vcHRzLWNiXG5mdW5jdGlvbiB0b1JlYWRXcml0ZUZpbGVPcHRpb25zKG9wdGlvbnM6IGFueSkge1xuICByZXR1cm4gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgPyB7IGVuY29kaW5nOiBvcHRpb25zIH0gOiBvcHRpb25zO1xufVxuXG4vLyBOb3QgZG9pbmcgdGhhdCBjYXVzZXMgYSBsb29wIGR1cmluZyBgY2xvbmVgcy5cbmZ1bmN0aW9uIHJlbW92ZURvdFBhdGhzKHBhdGhzOiBzdHJpbmdbXSkge1xuICByZXR1cm4gcGF0aHMuc2xpY2UoMik7IC8vIFJlbW92ZSBcIi5cIiBhbmQgXCIuLlwiIGVudHJpZXNcbn1cblxuLy8gUmVmZXJlbmNlOiBodHRwczovL2dpdGh1Yi5jb20vaXNvbW9ycGhpYy1naXQvbGlnaHRuaW5nLWZzI2Zzc3RhdGZpbGVwYXRoLW9wdHMtY2JcbmFzeW5jIGZ1bmN0aW9uIHRvTGZzU3RhdChmc0NhY2hlOiBGc0NhY2hlLCBmc01vdW50UG9pbnQ6IHN0cmluZywgcGF0aDogc3RyaW5nLCBzdGF0OiBhbnkpOiBQcm9taXNlPExmc1N0YXQ+IHtcbiAgLy8gaXNvbW9ycGhpYy1naXQgZXhwZWN0cyB0aGF0IGBpbm9gIGFuZCBgbW9kZWAgbmV2ZXIgY2hhbmdlIG9uY2UgdGhleSBhcmUgY3JlYXRlZCxcbiAgLy8gaG93ZXZlciwgSURCRlMgZG9lcyBub3Qga2VlcCBgaW5vYHMgY29uc2lzdGVudCBiZXR3ZWVuIHN5bmNmcyBjYWxscy5cbiAgLy8gV2UgbmVlZCB0byBwZXJzaXN0IGFuIGluZGV4IGNvbnRhaW5pbmcgdGhlIGBpbm9gcyBhbmQgYG1vZGVgcyBmb3IgYWxsIGZpbGVzLlxuICAvLyBMdWNraWx5IHRoaXMgaXMgdmVyeSBjaGVhcCB0byBkbywgYXMgbG9uZyBhcyB3ZSBrZWVwIHRoZSBgc2NoZW1hc0NhY2hlW2ZzTW91bnRQb2ludF1gIG1hcCB1cC10by1kYXRlLlxuICBjb25zdCBzY2hlbWEgPSBhd2FpdCBmc0NhY2hlLmdldE9yTG9hZEZzU2NoZW1hKGZzTW91bnRQb2ludCk7XG4gIGNvbnN0IHBlcnBldHVhbFN0YXQgPSBzY2hlbWEuc2V0KHBhdGgsIHNjaGVtYS5nZXQocGF0aCkgPz8geyBpbm86IHN0YXQuaW5vLCBtb2RlOiBzdGF0Lm1vZGUgfSkuZ2V0KHBhdGgpITtcblxuICBjb25zdCBpc0RpciA9IEZTLmlzRGlyKHBlcnBldHVhbFN0YXQubW9kZSk7XG4gIGNvbnN0IGlzRmlsZSA9IEZTLmlzRmlsZShwZXJwZXR1YWxTdGF0Lm1vZGUpO1xuICBjb25zdCBpc0xpbmsgPSBGUy5pc0xpbmsocGVycGV0dWFsU3RhdC5tb2RlKTtcblxuICByZXR1cm4ge1xuICAgIG1vZGU6IHBlcnBldHVhbFN0YXQubW9kZSxcbiAgICBzaXplOiBzdGF0LnNpemUsXG4gICAgaW5vOiBwZXJwZXR1YWxTdGF0LmlubyxcbiAgICBtdGltZU1zOiBzdGF0Lm10aW1lLFxuICAgIGN0aW1lTXM6IHN0YXQuY3RpbWUsXG4gICAgdWlkOiAxLFxuICAgIGdpZDogMSxcbiAgICBkZXY6IDEsXG4gICAgaXNEaXJlY3Rvcnk6ICgpID0+IGlzRGlyLFxuICAgIGlzRmlsZTogKCkgPT4gaXNGaWxlLFxuICAgIGlzU3ltYm9saWNMaW5rOiAoKSA9PiBpc0xpbmssXG4gIH07XG59XG5cbi8vIFJlZmVyZW5jZTogaHR0cHM6Ly9naXRodWIuY29tL2Vtc2NyaXB0ZW4tY29yZS9lbXNjcmlwdGVuL2Jsb2IvbWFpbi9zeXN0ZW0vaW5jbHVkZS93YXNpL2FwaS5oXG5mdW5jdGlvbiB0aHJvd1dhc2lFcnJvclRvTm9kZUVycm9yKGlkOiBzdHJpbmcsIGU6IGFueSwgLi4uYXJnczogYW55W10pOiBuZXZlciB7XG4gIHN3aXRjaCAoZS5lcnJubykge1xuICAgIGNhc2UgMjA6XG4gICAgICB0aHJvdyB7IGlkLCBjb2RlOiBcIkVFWElTVFwiLCBtZXNzYWdlOiBcIkVFWElTVFwiLCBhcmdzIH07XG4gICAgY2FzZSA0NDpcbiAgICAgIHRocm93IHsgaWQsIGNvZGU6IFwiRU5PRU5UXCIsIG1lc3NhZ2U6IFwiRU5PRU5UXCIsIGFyZ3MgfTtcbiAgICBjYXNlIDU0OlxuICAgICAgdGhyb3cgeyBpZCwgY29kZTogXCJFTk9URElSXCIsIG1lc3NhZ2U6IFwiRU5PVERJUlwiLCBhcmdzIH07XG4gICAgY2FzZSA1NTpcbiAgICAgIHRocm93IHsgaWQsIGNvZGU6IFwiRU5PVEVNUFRZXCIsIG1lc3NhZ2U6IFwiRU5PVEVNUFRZXCIsIGFyZ3MgfTtcbiAgICBjYXNlIDczOlxuICAgICAgdGhyb3cgeyBpZCwgY29kZTogXCJFVElNRURPVVRcIiwgbWVzc2FnZTogXCJFVElNRURPVVRcIiwgYXJncyB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyB7IGlkLCBlLCBjb2RlOiBcIlVOS05PV05cIiwgYXJncyB9O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjIgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRnNDYWNoZSB9IGZyb20gXCIuL0ZzQ2FjaGVcIjtcbmltcG9ydCB7IFN1YnNjcmliYWJsZSB9IGZyb20gXCIuL1N1YnNjcmliYWJsZVwiO1xuXG5leHBvcnQgZW51bSBGbHVzaFN0YXRlU3RhdHVzIHtcbiAgRkxVU0hfSU5fUFJPR1JFU1MsXG4gIEZMVVNIX1NDSEVEVUxFRCxcbiAgRkxVU0hfUEFVU0VELFxufVxuXG5leHBvcnQgdHlwZSBGbHVzaFN0YXRlID1cbiAgfCB7IHNjaGVkdWxlZEZsdXNoOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0Pjsgc3RhdHVzOiBGbHVzaFN0YXRlU3RhdHVzLkZMVVNIX1NDSEVEVUxFRCB9XG4gIHwgeyBmbHVzaFByb21pc2U6IFByb21pc2U8dm9pZD47IHN0YXR1czogRmx1c2hTdGF0ZVN0YXR1cy5GTFVTSF9JTl9QUk9HUkVTUyB9XG4gIHwgeyBzdGF0dXM6IEZsdXNoU3RhdGVTdGF0dXMuRkxVU0hfUEFVU0VEIH07XG5cbmV4cG9ydCBjbGFzcyBGc0ZsdXNoTWFuYWdlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhdGVDb250cm9sID0gbmV3IE1hcDxzdHJpbmcsIEZsdXNoU3RhdGU+KCk7XG5cbiAgcHVibGljIHJlYWRvbmx5IHN1YnNjcmliYWJsZSA9IG5ldyBTdWJzY3JpYmFibGU8c3RyaW5nW10+KHtcbiAgICBuZXdWYWx1ZVN1cHBsaWVyOiAoKSA9PiBbLi4udGhpcy5zdGF0ZUNvbnRyb2wua2V5cygpXSxcbiAgfSk7XG5cbiAgcHVibGljIHBhdXNlU2NoZWR1bGVkRmx1c2hJZlNjaGVkdWxlZChmc01vdW50UG9pbnQ6IHN0cmluZykge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZUNvbnRyb2wuZ2V0KGZzTW91bnRQb2ludCk7XG4gICAgaWYgKHN0YXRlPy5zdGF0dXMgPT09IEZsdXNoU3RhdGVTdGF0dXMuRkxVU0hfU0NIRURVTEVEKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKGBQYXVzaW5nIHNjaGVkdWxlZCBmbHVzaCBmb3IgJHtmc01vdW50UG9pbnR9YCk7XG4gICAgICBjbGVhclRpbWVvdXQoc3RhdGUuc2NoZWR1bGVkRmx1c2gpO1xuICAgICAgdGhpcy5zdGF0ZUNvbnRyb2wuc2V0KGZzTW91bnRQb2ludCwgeyBzdGF0dXM6IEZsdXNoU3RhdGVTdGF0dXMuRkxVU0hfUEFVU0VEIH0pO1xuICAgICAgdGhpcy5zdWJzY3JpYmFibGUuX25vdGlmeVN1YnNjcmliZXJzKCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlcXVlc3RGc0ZsdXNoKGZzQ2FjaGU6IEZzQ2FjaGUsIGZzTW91bnRQb2ludDogc3RyaW5nLCBkZWJvdW5jZUFyZ3M6IHsgZGVib3VuY2VUaW1lb3V0SW5NczogbnVtYmVyIH0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGVDb250cm9sLmdldChmc01vdW50UG9pbnQpO1xuXG4gICAgLy8gTm8gZmx1c2ggc2NoZWR1bGVkIHlldCwgc2ltcGx5IHNjaGVkdWxlIGl0LlxuICAgIGlmICghc3RhdGUpIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoYFNjaGVkdWxpbmcgZmx1c2ggZm9yICR7ZnNNb3VudFBvaW50fWApO1xuICAgICAgdGhpcy5zY2hlZHVsZUZzRmx1c2goZnNDYWNoZSwgZnNNb3VudFBvaW50LCBkZWJvdW5jZUFyZ3MpO1xuICAgIH1cblxuICAgIC8vIElmIGZsdXNoIGlzIHNjaGVkdWxlZCwgd2UgY2FuY2VsIHRoZSBzY2hlZHVsZWQgZmx1c2ggYW5kIHNjaGVkdWxlIGEgbmV3IG9uZS5cbiAgICBlbHNlIGlmIChzdGF0ZS5zdGF0dXMgPT09IEZsdXNoU3RhdGVTdGF0dXMuRkxVU0hfU0NIRURVTEVEKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKGBEZWJvdW5jaW5nIGZsdXNoIHJlcXVlc3QgZm9yICR7ZnNNb3VudFBvaW50fWApO1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnNjaGVkdWxlZEZsdXNoKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVGc0ZsdXNoKGZzQ2FjaGUsIGZzTW91bnRQb2ludCwgZGVib3VuY2VBcmdzKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhIGZsdXNoIGlzIHBhdXNlZCwgaXQgbWVhbnMgaXQgd2FzIHNjaGVkdWxlZCwgYnV0IHdlIGtub3cgdGhhdCBpdCB3aWxsIGJlIHNjaGVkdWxlZCBhZ2FpbiBmb3Igc3VyZS5cbiAgICBlbHNlIGlmIChzdGF0ZS5zdGF0dXMgPT09IEZsdXNoU3RhdGVTdGF0dXMuRkxVU0hfUEFVU0VEKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKGBSZXN1bWluZyBwYXVzZWQgZmx1c2ggZm9yICR7ZnNNb3VudFBvaW50fWApO1xuICAgICAgdGhpcy5zY2hlZHVsZUZzRmx1c2goZnNDYWNoZSwgZnNNb3VudFBvaW50LCBkZWJvdW5jZUFyZ3MpO1xuICAgIH1cblxuICAgIC8vIEluZGVwZW5kZW50IG9mIHRoZSBuZXcgcmVxdWVzdCwgaWYgYSBmbHVzaCBpcyBpbiBwcm9ncmVzcywgd2UgbmVlZCB0byB3YWl0IGZvciBpdCB0byBmaW5pc2hcbiAgICAvLyBTbyB3ZSBjYW4gcHJvY2VzcyB0aGUgbmV3IGZsdXNoIHJlcXVlc3QuXG4gICAgZWxzZSBpZiAoc3RhdGUuc3RhdHVzID09PSBGbHVzaFN0YXRlU3RhdHVzLkZMVVNIX0lOX1BST0dSRVNTKSB7XG4gICAgICBjb25zb2xlLmRlYnVnKGBGbHVzaCByZXF1ZXN0ZWQgd2hpbGUgaW4gcHJvZ3Jlc3MgZm9yICR7ZnNNb3VudFBvaW50fS4gUmVxdWVzdGluZyBhbm90aGVyIGZsdXNoIGFmdGVyIGNvbXBsZXRlZC5gKTtcbiAgICAgIGF3YWl0IHN0YXRlLmZsdXNoUHJvbWlzZTtcbiAgICAgIGNvbnNvbGUuZGVidWcoYEZsdXNoIHJlcXVlc3RlZCByaWdodCBhZnRlciBvbmUgY29tcGxldGVkIGZvciAke2ZzTW91bnRQb2ludH0uYCk7XG4gICAgICBhd2FpdCB0aGlzLnJlcXVlc3RGc0ZsdXNoKGZzQ2FjaGUsIGZzTW91bnRQb2ludCwgZGVib3VuY2VBcmdzKTtcbiAgICB9XG5cbiAgICAvLyBFeGVjdXRpb24gc2hvdWxkIG5ldmVyLCBldmVyIHJlYWNoIHRoaXMgcG9pbnQuXG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE9vcHMhIEltcG9zc2libGUgc2NlbmFyaW8gZm9yIGZsdXNoaW5nICcke2ZzTW91bnRQb2ludH0nYCk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGV4ZWN1dGVGbHVzaChmc0NhY2hlOiBGc0NhY2hlLCBmc01vdW50UG9pbnQ6IHN0cmluZykge1xuICAgIGNvbnN0IGZsdXNoID0gZnNDYWNoZS5mbHVzaEZzKGZzTW91bnRQb2ludCkudGhlbigoKSA9PiB7XG4gICAgICBjb25zb2xlLmRlYnVnKGBGbHVzaCBjb21wbGV0ZSBmb3IgJHtmc01vdW50UG9pbnR9YCk7XG4gICAgICB0aGlzLnN0YXRlQ29udHJvbC5kZWxldGUoZnNNb3VudFBvaW50KTtcbiAgICAgIHRoaXMuc3Vic2NyaWJhYmxlLl9ub3RpZnlTdWJzY3JpYmVycygpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zdGF0ZUNvbnRyb2wuc2V0KGZzTW91bnRQb2ludCwge1xuICAgICAgc3RhdHVzOiBGbHVzaFN0YXRlU3RhdHVzLkZMVVNIX0lOX1BST0dSRVNTLFxuICAgICAgZmx1c2hQcm9taXNlOiBmbHVzaCxcbiAgICB9KTtcblxuICAgIHRoaXMuc3Vic2NyaWJhYmxlLl9ub3RpZnlTdWJzY3JpYmVycygpO1xuXG4gICAgcmV0dXJuIGZsdXNoO1xuICB9XG5cbiAgcHJpdmF0ZSBzY2hlZHVsZUZzRmx1c2goZnNDYWNoZTogRnNDYWNoZSwgZnNNb3VudFBvaW50OiBzdHJpbmcsIGRlYm91bmNlQXJnczogeyBkZWJvdW5jZVRpbWVvdXRJbk1zOiBudW1iZXIgfSkge1xuICAgIGNvbnN0IGZsdXNoU2NoZWR1bGVkVGFzayA9IHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB0aGlzLmV4ZWN1dGVGbHVzaChmc0NhY2hlLCBmc01vdW50UG9pbnQpLFxuICAgICAgZGVib3VuY2VBcmdzLmRlYm91bmNlVGltZW91dEluTXNcbiAgICApO1xuXG4gICAgdGhpcy5zdGF0ZUNvbnRyb2wuc2V0KGZzTW91bnRQb2ludCwge1xuICAgICAgc3RhdHVzOiBGbHVzaFN0YXRlU3RhdHVzLkZMVVNIX1NDSEVEVUxFRCxcbiAgICAgIHNjaGVkdWxlZEZsdXNoOiBmbHVzaFNjaGVkdWxlZFRhc2ssXG4gICAgfSk7XG5cbiAgICB0aGlzLnN1YnNjcmliYWJsZS5fbm90aWZ5U3Vic2NyaWJlcnMoKTtcblxuICAgIHJldHVybiBmbHVzaFNjaGVkdWxlZFRhc2s7XG4gIH1cblxuICBhc3luYyBleHBlZGl0ZUZsdXNoKGZzQ2FjaGU6IEZzQ2FjaGUsIGZzTW91bnRQb2ludDogc3RyaW5nLCBmbHVzaEFyZ3M6IHsgZXhlY3V0ZUV2ZW5JZk5vdFNjaGVkdWxlZDogYm9vbGVhbiB9KSB7XG4gICAgY29uc3QgZmx1c2hTdGF0ZSA9IHRoaXMuc3RhdGVDb250cm9sLmdldChmc01vdW50UG9pbnQpO1xuXG4gICAgLy8gbm90IHJlcXVlc3RlZCwgbm90IHBhdXNlZCwgbm90IGluIHByb2dyZXNzOyBmbHVzaCByaWdodCBhd2F5IGlmIHNwZWNpZmllZCBieSBmbHVzaEFyZ3NcbiAgICBpZiAoIWZsdXNoU3RhdGUpIHtcbiAgICAgIGlmIChmbHVzaEFyZ3MuZXhlY3V0ZUV2ZW5JZk5vdFNjaGVkdWxlZCkge1xuICAgICAgICBhd2FpdCB0aGlzLmV4ZWN1dGVGbHVzaChmc0NhY2hlLCBmc01vdW50UG9pbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHdhaXQgZm9yIG9uZ29pbmcgZmx1c2gsIHRoZW4gZmx1c2ggYWdhaW4gaWYgc3BlY2lmaWVkIGJ5IGZsdXNoQXJnc1xuICAgIGVsc2UgaWYgKGZsdXNoU3RhdGU/LnN0YXR1cyA9PT0gRmx1c2hTdGF0ZVN0YXR1cy5GTFVTSF9JTl9QUk9HUkVTUykge1xuICAgICAgYXdhaXQgZmx1c2hTdGF0ZS5mbHVzaFByb21pc2U7XG4gICAgICBpZiAoZmx1c2hBcmdzLmV4ZWN1dGVFdmVuSWZOb3RTY2hlZHVsZWQpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5leGVjdXRlRmx1c2goZnNDYWNoZSwgZnNNb3VudFBvaW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkZXNjaGVkdWxlIHRoZW4gZXhlY3V0ZSBmbHVzaFxuICAgIGVsc2UgaWYgKGZsdXNoU3RhdGU/LnN0YXR1cyA9PT0gRmx1c2hTdGF0ZVN0YXR1cy5GTFVTSF9TQ0hFRFVMRUQpIHtcbiAgICAgIGNsZWFyVGltZW91dChmbHVzaFN0YXRlLnNjaGVkdWxlZEZsdXNoKTtcbiAgICAgIGF3YWl0IHRoaXMuZXhlY3V0ZUZsdXNoKGZzQ2FjaGUsIGZzTW91bnRQb2ludCk7XG4gICAgfVxuXG4gICAgLy8gc2ltcGx5IGV4ZWN1dGUgcmlnaHQgYXdheSwgd2l0aG91dCBzY2hlZHVsaW5nXG4gICAgZWxzZSBpZiAoZmx1c2hTdGF0ZT8uc3RhdHVzID09PSBGbHVzaFN0YXRlU3RhdHVzLkZMVVNIX1BBVVNFRCkge1xuICAgICAgYXdhaXQgdGhpcy5leGVjdXRlRmx1c2goZnNDYWNoZSwgZnNNb3VudFBvaW50KTtcbiAgICB9XG5cbiAgICAvLyBzaG91bGQgbmV2ZXIgcmVhY2ggdGhpcyBwb2ludFxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYXRhc3Ryb3BoaWMgZXJyb3Igd2hpbGUgZXhwZWRpdGluZyBmbHVzaCBvZiAke2ZzTW91bnRQb2ludH0uYCk7XG4gICAgfVxuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjEgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEZzQ2FjaGUsIEZzU2NoZW1hIH0gZnJvbSBcIi4vRnNDYWNoZVwiO1xuaW1wb3J0IHsgS2llU2FuZGJveFdvcmtzcGFjZXNGcyB9IGZyb20gXCIuL0tpZVNhbmRib3hXb3Jrc3BhY2VGc1wiO1xuaW1wb3J0IHsgRnNGbHVzaE1hbmFnZXIgfSBmcm9tIFwiLi9Gc0ZsdXNoTWFuYWdlclwiO1xuaW1wb3J0IHsgRnNVc2FnZUNvdW50ZXIgfSBmcm9tIFwiLi9Gc1VzYWdlQ291bnRlclwiO1xuaW1wb3J0IHsgRnNVbmxvYWRNYW5hZ2VyIH0gZnJvbSBcIi4vRnNVbmxvYWRNYW5hZ2VyXCI7XG5pbXBvcnQgeyBXb3Jrc3BhY2VCcm9hZGNhc3RFdmVudHMgfSBmcm9tIFwiLi4vd29ya2VyL2FwaS9Xb3Jrc3BhY2VCcm9hZGNhc3RFdmVudHNcIjtcbmltcG9ydCB7IFdvcmtzcGFjZUZpbGVCcm9hZGNhc3RFdmVudHMgfSBmcm9tIFwiLi4vd29ya2VyL2FwaS9Xb3Jrc3BhY2VGaWxlQnJvYWRjYXN0RXZlbnRzXCI7XG5pbXBvcnQge1xuICBXT1JLU1BBQ0VTX0JST0FEQ0FTVF9DSEFOTkVMLFxuICBXT1JLU1BBQ0VTX0ZJTEVTX0JST0FEQ0FTVF9DSEFOTkVMLFxuICBXb3Jrc3BhY2VzQnJvYWRjYXN0RXZlbnRzLFxuICBXb3Jrc3BhY2VzRmlsZXNCcm9hZGNhc3RFdmVudHMsXG59IGZyb20gXCIuLi93b3JrZXIvYXBpL1dvcmtzcGFjZXNCcm9hZGNhc3RFdmVudHNcIjtcblxuZXhwb3J0IHR5cGUgQnJvYWRjYXN0ZXJXYXRjaEV2ZW50ID1cbiAgfCB7XG4gICAgICBjaGFubmVsOiB0eXBlb2YgV09SS1NQQUNFU19CUk9BRENBU1RfQ0hBTk5FTDtcbiAgICAgIG9uTWVzc2FnZTogKG1lc3NhZ2U6IFdvcmtzcGFjZXNCcm9hZGNhc3RFdmVudHMpID0+IHZvaWQ7XG4gICAgfVxuICB8IHtcbiAgICAgIGNoYW5uZWw6IHR5cGVvZiBXT1JLU1BBQ0VTX0ZJTEVTX0JST0FEQ0FTVF9DSEFOTkVMO1xuICAgICAgb25NZXNzYWdlOiAobWVzc2FnZTogV29ya3NwYWNlc0ZpbGVzQnJvYWRjYXN0RXZlbnRzKSA9PiB2b2lkO1xuICAgIH1cbiAgfCB7XG4gICAgICBjaGFubmVsOiBzdHJpbmc7XG4gICAgICBvbk1lc3NhZ2U6IChtZXNzYWdlOiBXb3Jrc3BhY2VCcm9hZGNhc3RFdmVudHMgfCBXb3Jrc3BhY2VGaWxlQnJvYWRjYXN0RXZlbnRzKSA9PiB2b2lkO1xuICAgIH07XG5cbmV4cG9ydCBjbGFzcyBCcm9hZGNhc3RlZSB7XG4gIHdhdGNoKGFyZ3M6IEJyb2FkY2FzdGVyV2F0Y2hFdmVudCk6IHZvaWQge31cbiAgZGlzcG9zZSgpIHt9XG59XG5cbmV4cG9ydCB0eXBlIEJyb2FkY2FzdGVyRXZlbnQgPVxuICB8IHtcbiAgICAgIGNoYW5uZWw6IHR5cGVvZiBXT1JLU1BBQ0VTX0JST0FEQ0FTVF9DSEFOTkVMO1xuICAgICAgbWVzc2FnZTogKCkgPT4gUHJvbWlzZTxXb3Jrc3BhY2VzQnJvYWRjYXN0RXZlbnRzPjtcbiAgICB9XG4gIHwge1xuICAgICAgY2hhbm5lbDogdHlwZW9mIFdPUktTUEFDRVNfRklMRVNfQlJPQURDQVNUX0NIQU5ORUw7XG4gICAgICBtZXNzYWdlOiAoKSA9PiBQcm9taXNlPFdvcmtzcGFjZXNGaWxlc0Jyb2FkY2FzdEV2ZW50cz47XG4gICAgfVxuICB8IHtcbiAgICAgIGNoYW5uZWw6IHN0cmluZztcbiAgICAgIG1lc3NhZ2U6ICgpID0+IFByb21pc2U8V29ya3NwYWNlQnJvYWRjYXN0RXZlbnRzIHwgV29ya3NwYWNlRmlsZUJyb2FkY2FzdEV2ZW50cz47XG4gICAgfTtcblxuZXhwb3J0IGludGVyZmFjZSBCcm9hZGNhc3RlckRpc3BhdGNoIHtcbiAgYnJvYWRjYXN0KGFyZ3M6IEJyb2FkY2FzdGVyRXZlbnQpOiB2b2lkO1xufVxuXG5leHBvcnQgY2xhc3MgQnJvYWRjYXN0ZXIgaW1wbGVtZW50cyBCcm9hZGNhc3RlckRpc3BhdGNoIHtcbiAgYXN5bmMgYnJvYWRjYXN0KGFyZ3M6IEJyb2FkY2FzdGVyRXZlbnQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKGFyZ3MuY2hhbm5lbCk7XG4gICAgYmMucG9zdE1lc3NhZ2UoYXdhaXQgYXJncy5tZXNzYWdlKCkpO1xuICAgIGJjLmNsb3NlKCk7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9GU19GTFVTSF9ERUJPVU5DRV9USU1FT1VUX0lOX01TID0gMTAwO1xuY29uc3QgQklHX0ZTX0ZMVVNIX0RFQk9VTkNFX1RJTUVPVVRfSU5fTVMgPSA1MDA7XG5jb25zdCBCSUdfRlNfU0laRV9JTl9FTlRSSUVTX0NPVU5UID0gMTAwMDtcblxuZXhwb3J0IGNsYXNzIEZzU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXJnczogeyBuYW1lOiBzdHJpbmcgfSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZzRmx1c2hNYW5hZ2VyOiBGc0ZsdXNoTWFuYWdlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJlYWRXcml0ZUZzVXNhZ2VDb3VudGVyID0gbmV3IEZzVXNhZ2VDb3VudGVyKCksXG4gICAgcHJpdmF0ZSByZWFkb25seSByZWFkb25seUZzVXNhZ2VDb3VudGVyID0gbmV3IEZzVXNhZ2VDb3VudGVyKCksXG4gICAgcHJpdmF0ZSByZWFkb25seSBmc0NhY2hlID0gbmV3IEZzQ2FjaGUoKSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZzVW5sb2FkTWFuYWdlciA9IG5ldyBGc1VubG9hZE1hbmFnZXIoXG4gICAgICBmc0NhY2hlLFxuICAgICAgcmVhZFdyaXRlRnNVc2FnZUNvdW50ZXIsXG4gICAgICByZWFkb25seUZzVXNhZ2VDb3VudGVyLFxuICAgICAgZnNGbHVzaE1hbmFnZXJcbiAgICApXG4gICkge31cblxuICBwdWJsaWMgYXN5bmMgd2l0aFJlYWRvbmx5RnNTY2hlbWE8VD4oZnNNb3VudFBvaW50OiBzdHJpbmcsIGNhbGxiYWNrOiAoYXJnczogeyBzY2hlbWE6IEZzU2NoZW1hIH0pID0+IFByb21pc2U8VD4pIHtcbiAgICAvLyBGUyBTY2hlbWFzIGFyZSBuZXZlciB0YWtlbiBvdXQgb2YgbWVtb3J5LCBzbyBvbmx5IGdldHRpbmcgaXMgZW5vdWdoIDopXG4gICAgY29uc3Qgc2NoZW1hID0gYXdhaXQgdGhpcy5mc0NhY2hlLmdldE9yTG9hZEZzU2NoZW1hKGZzTW91bnRQb2ludCk7XG4gICAgcmV0dXJuIGF3YWl0IGNhbGxiYWNrKHsgc2NoZW1hIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHdpdGhSZWFkV3JpdGVJbk1lbW9yeUZzPFQ+KFxuICAgIGZzTW91bnRQb2ludDogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiAoYXJnczogeyBmczogS2llU2FuZGJveFdvcmtzcGFjZXNGczsgc2NoZW1hOiBGc1NjaGVtYTsgYnJvYWRjYXN0ZXI6IEJyb2FkY2FzdGVyRGlzcGF0Y2ggfSkgPT4gUHJvbWlzZTxUPlxuICApIHtcbiAgICAvLyBJZiB0aGVyZSdzIGFuIHVubG9hZGluZyBpbiBwcm9ncmVzcywgdGhlcmUncyBub3QgbXVjaCB3ZSBjYW4gZG8gb3RoZXIgdGhhbiB3YWl0IGZvciBpdCB0byBmaW5pc2hcbiAgICAvLyBhbmQgcmVxdWVzdCBhIG5ldyBGUyBhZ2Fpbi5cbiAgICBhd2FpdCB0aGlzLmZzVW5sb2FkTWFuYWdlci5tYWtlU3BhY2VGb3JPcldhaXRVbmxvYWRPZihmc01vdW50UG9pbnQpO1xuXG4gICAgLy8gQ291bnQgdGhpcyB1c2FnZSBpbi5cbiAgICB0aGlzLnJlYWRXcml0ZUZzVXNhZ2VDb3VudGVyLmFkZFVzYWdlKGZzTW91bnRQb2ludCk7XG5cbiAgICAvLyBHZXQgdGhlIHNjaGVtYSBhbmQgdGhlIEZTLCBsb2FkaW5nIGl0IGlmIG5lY2Vzc2FyeS5cbiAgICBjb25zdCBzY2hlbWEgPSBhd2FpdCB0aGlzLmZzQ2FjaGUuZ2V0T3JMb2FkRnNTY2hlbWEoZnNNb3VudFBvaW50KTtcbiAgICBjb25zdCBmcyA9IGF3YWl0IHRoaXMuZnNDYWNoZS5nZXRPckxvYWRGcyhmc01vdW50UG9pbnQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIElmIHRoZXJlJ3MgYSBmbHVzaCBzY2hlZHVsZWQsIG5vIG5lZWQgdG8ga2VlcCBpdCB0aGVyZSwgYXMgd2UnbGwgc2NoZWR1bGUgb25lIHJpZ2h0IGFmdGVyIHVzaW5nIHRoZSBGUy5cbiAgICAgIHRoaXMuZnNGbHVzaE1hbmFnZXIucGF1c2VTY2hlZHVsZWRGbHVzaElmU2NoZWR1bGVkKGZzTW91bnRQb2ludCk7XG4gICAgICByZXR1cm4gYXdhaXQgY2FsbGJhY2soeyBmcywgc2NoZW1hLCBicm9hZGNhc3RlcjogbmV3IEJyb2FkY2FzdGVyKCkgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIEFmdGVyIHVzaW5nIHRoZSBGUywgd2UgbmVlZCB0byBkZWNpZGUgaWYgd2UncmUgZ29pbmcgdG8gZmx1c2gvdW5sb2FkIGl0IG9yIG5vdC5cbiAgICAgIC8vIFJlZ2FyZGxlc3Mgb2YgZXhjZXB0aW9ucyB0aGF0IG1heSBoYXZlIG9jY3VycmVkLlxuXG4gICAgICAvLyBJZiB0aGVyZSdzIHN0aWxsIHNvbWVvbmUgdXNpbmcgdGhlIEZTLCBsZXQgdGhlbSByZXF1ZXN0IHRoZSBmbHVzaC91bmxvYWQgd2hlbiB0aGV5J3JlIGRvbmUuXG4gICAgICBjb25zdCB7IHVzYWdlc0xlZnQgfSA9IHRoaXMucmVhZFdyaXRlRnNVc2FnZUNvdW50ZXIucmVsZWFzZVVzYWdlKGZzTW91bnRQb2ludCk7XG4gICAgICBpZiAodXNhZ2VzTGVmdCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYFske3RoaXMuYXJncy5uYW1lfV0gU2tpcHBpbmcgZmx1c2gvdW5sb2FkIGZvciAke2ZzTW91bnRQb2ludH0uICgke3VzYWdlc0xlZnR9IHVzYWdlcyBsZWZ0LilgKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhpcyB1c2FnZSBpcyB0aGUgbGFzdCBvbmUgdXNpbmcgdGhlIEZTLCBpdCdzIGl0cyBqb2IgdG8gcmVxdWVzdCB0aGUgZmx1c2guXG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBkaWRUcmlnZ2VyVW5sb2FkIH0gPSB0aGlzLmZzVW5sb2FkTWFuYWdlci51bmxvYWRGc0lmTWFya2VkQW5kTm90SW5Vc2UoZnNNb3VudFBvaW50KTtcbiAgICAgICAgaWYgKGRpZFRyaWdnZXJVbmxvYWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7dGhpcy5hcmdzLm5hbWV9XSBVbmxvYWQgdHJpZ2dlcmVkIGZvciAke2ZzTW91bnRQb2ludH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgWyR7dGhpcy5hcmdzLm5hbWV9XSBSZXF1ZXN0aW5nIGZsdXNoIGZvciAke2ZzTW91bnRQb2ludH1gKTtcbiAgICAgICAgICBjb25zdCBkZWJvdW5jZVRpbWVvdXRJbk1zID0gYXdhaXQgdGhpcy5nZXRGbHVzaERlYm91bmNlVGltZW91dEluTXModGhpcy5mc0NhY2hlLCBmc01vdW50UG9pbnQpO1xuICAgICAgICAgIGF3YWl0IHRoaXMuZnNGbHVzaE1hbmFnZXIucmVxdWVzdEZzRmx1c2godGhpcy5mc0NhY2hlLCBmc01vdW50UG9pbnQsIHsgZGVib3VuY2VUaW1lb3V0SW5NcyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB3aXRoUmVhZG9ubHlJbk1lbW9yeUZzPFQ+KFxuICAgIGZzTW91bnRQb2ludDogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiAoYXJnczogeyBmczogS2llU2FuZGJveFdvcmtzcGFjZXNGczsgc2NoZW1hOiBGc1NjaGVtYSB9KSA9PiBQcm9taXNlPFQ+XG4gICkge1xuICAgIGF3YWl0IHRoaXMuZnNVbmxvYWRNYW5hZ2VyLm1ha2VTcGFjZUZvck9yV2FpdFVubG9hZE9mKGZzTW91bnRQb2ludCk7XG5cbiAgICB0aGlzLnJlYWRvbmx5RnNVc2FnZUNvdW50ZXIuYWRkVXNhZ2UoZnNNb3VudFBvaW50KTtcbiAgICBjb25zdCBzY2hlbWEgPSBhd2FpdCB0aGlzLmZzQ2FjaGUuZ2V0T3JMb2FkRnNTY2hlbWEoZnNNb3VudFBvaW50KTtcbiAgICBjb25zdCBmcyA9IGF3YWl0IHRoaXMuZnNDYWNoZS5nZXRPckxvYWRGcyhmc01vdW50UG9pbnQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBjYWxsYmFjayh7IGZzOiB0aGlzLmdldFJlYWRvbmx5RnMoZnNNb3VudFBvaW50LCBmcyksIHNjaGVtYSB9KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5yZWFkb25seUZzVXNhZ2VDb3VudGVyLnJlbGVhc2VVc2FnZShmc01vdW50UG9pbnQpO1xuICAgICAgdGhpcy5mc1VubG9hZE1hbmFnZXIudW5sb2FkRnNJZk1hcmtlZEFuZE5vdEluVXNlKGZzTW91bnRQb2ludCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBnZXRSZWFkb25seUZzKGZzTW91bnRQb2ludDogc3RyaW5nLCByZWFkV3JpdGVGczogS2llU2FuZGJveFdvcmtzcGFjZXNGcykge1xuICAgIGNvbnN0IHRocm93Q2FudE11dGF0ZVJlYWRvbmx5RnNFeGNlcHRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFske3RoaXMuYXJncy5uYW1lfV0gQ2FuJ3QgbXV0YXRlIHJlYWQtb25seSBGUyAtICR7ZnNNb3VudFBvaW50fWApO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb21pc2VzOiB7XG4gICAgICAgIHdyaXRlRmlsZTogdGhyb3dDYW50TXV0YXRlUmVhZG9ubHlGc0V4Y2VwdGlvbixcbiAgICAgICAgdW5saW5rOiB0aHJvd0NhbnRNdXRhdGVSZWFkb25seUZzRXhjZXB0aW9uLFxuICAgICAgICBta2RpcjogdGhyb3dDYW50TXV0YXRlUmVhZG9ubHlGc0V4Y2VwdGlvbixcbiAgICAgICAgcm1kaXI6IHRocm93Q2FudE11dGF0ZVJlYWRvbmx5RnNFeGNlcHRpb24sXG4gICAgICAgIHN5bWxpbms6IHRocm93Q2FudE11dGF0ZVJlYWRvbmx5RnNFeGNlcHRpb24sXG4gICAgICAgIGNobW9kOiB0aHJvd0NhbnRNdXRhdGVSZWFkb25seUZzRXhjZXB0aW9uLFxuICAgICAgICByZW5hbWU6IHRocm93Q2FudE11dGF0ZVJlYWRvbmx5RnNFeGNlcHRpb24sXG4gICAgICAgIHJlYWRGaWxlOiBhc3luYyAocGF0aDogc3RyaW5nLCBvcHRpb25zOiBhbnkpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVhZFdyaXRlRnMucHJvbWlzZXMucmVhZEZpbGUocGF0aCwgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWRkaXI6IGFzeW5jIChwYXRoOiBzdHJpbmcsIG9wdGlvbnM6IGFueSkgPT4ge1xuICAgICAgICAgIHJldHVybiByZWFkV3JpdGVGcy5wcm9taXNlcy5yZWFkZGlyKHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBzdGF0OiBhc3luYyAocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRXcml0ZUZzLnByb21pc2VzLnN0YXQocGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxzdGF0OiBhc3luYyAocGF0aDogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRXcml0ZUZzLnByb21pc2VzLmxzdGF0KHBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICByZWFkbGluazogYXN5bmMgKHBhdGg6IHN0cmluZywgb3B0aW9uczogYW55KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlYWRXcml0ZUZzLnByb21pc2VzLnJlYWRsaW5rKHBhdGgsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRGbHVzaERlYm91bmNlVGltZW91dEluTXMoZnNDYWNoZTogRnNDYWNoZSwgZnNNb3VudFBvaW50OiBzdHJpbmcpIHtcbiAgICBpZiAoKGF3YWl0IGZzQ2FjaGUuZ2V0T3JMb2FkRnNTY2hlbWEoZnNNb3VudFBvaW50KSkuc2l6ZSA+IEJJR19GU19TSVpFX0lOX0VOVFJJRVNfQ09VTlQpIHtcbiAgICAgIHJldHVybiBCSUdfRlNfRkxVU0hfREVCT1VOQ0VfVElNRU9VVF9JTl9NUztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIERFRkFVTFRfRlNfRkxVU0hfREVCT1VOQ0VfVElNRU9VVF9JTl9NUztcbiAgICB9XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBGc1VzYWdlQ291bnRlciB9IGZyb20gXCIuL0ZzVXNhZ2VDb3VudGVyXCI7XG5pbXBvcnQgeyBGc0ZsdXNoTWFuYWdlciB9IGZyb20gXCIuL0ZzRmx1c2hNYW5hZ2VyXCI7XG5pbXBvcnQgeyBGc0NhY2hlIH0gZnJvbSBcIi4vRnNDYWNoZVwiO1xuXG5pbnRlcmZhY2UgUHJvbWlzZUltcGVyYXRpdmVIYW5kbGU8VD4ge1xuICBwcm9taXNlOiBQcm9taXNlPFQ+O1xuICByZXNvbHZlOiAodmFsdWU6IFQpID0+IHZvaWQ7XG4gIHJlamVjdDogKGVycjogdW5rbm93bikgPT4gdm9pZDtcbn1cblxuZnVuY3Rpb24gaW1wZXJhdGl2ZVByb21pc2VIYW5kbGU8VD4oKTogUHJvbWlzZUltcGVyYXRpdmVIYW5kbGU8VD4ge1xuICBsZXQgcmVzb2x2ZTogUHJvbWlzZUltcGVyYXRpdmVIYW5kbGU8VD5bXCJyZXNvbHZlXCJdIHwgdW5kZWZpbmVkO1xuICBsZXQgcmVqZWN0OiBQcm9taXNlSW1wZXJhdGl2ZUhhbmRsZTxUPltcInJlamVjdFwiXSB8IHVuZGVmaW5lZDtcblxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VD4oKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuXG4gIC8vIFByb21pc2UgY29uc3RydWN0b3JzIHJ1biBzeW5jaHJvbm91c2x5LCBzbyByZXNvbHZlIGFuZCByZWplY3Qgd2lsbCBhbHdheXMgYmUgYXNzaWduZWQuXG4gIHJldHVybiB7IHByb21pc2UsIHJlc29sdmU6IHJlc29sdmUhLCByZWplY3Q6IHJlamVjdCEgfTtcbn1cblxuZXhwb3J0IGNsYXNzIEZzVW5sb2FkTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZnNDYWNoZTogRnNDYWNoZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJlYWRXcml0ZUZzVXNhZ2VDb3VudGVyOiBGc1VzYWdlQ291bnRlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJlYWRvbmx5RnNVc2FnZUNvdW50ZXI6IEZzVXNhZ2VDb3VudGVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZnNGbHVzaE1hbmFnZXI6IEZzRmx1c2hNYW5hZ2VyXG4gICkge31cblxuICBwcml2YXRlIHJlYWRvbmx5IG9uZ29pbmdVbmxvYWRzID0gbmV3IE1hcDxzdHJpbmcsIFByb21pc2VJbXBlcmF0aXZlSGFuZGxlPHZvaWQ+PigpO1xuXG4gIHB1YmxpYyBhc3luYyBtYWtlU3BhY2VGb3JPcldhaXRVbmxvYWRPZihmc01vdW50UG9pbnQ6IHN0cmluZykge1xuICAgIGlmICghdGhpcy5mc0NhY2hlLmhhc1NwYWNlRm9yKGZzTW91bnRQb2ludCkpIHtcbiAgICAgIHRoaXMubWFrZVNwYWNlRm9yKGZzTW91bnRQb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoYE5vIG5lZWQgdG8gbWFrZSBzcGFjZSBmb3IgJHtmc01vdW50UG9pbnR9LmApO1xuICAgIH1cblxuICAgIC8vIENhbid0IGZvcmdldCB0byB3YWl0IGZvciBhbiB1bmxvYWRpbmcgdGhhdCBtaWdodCBiZSBoYXBwZW5pbmcgZm9yIHRoZSByZXF1ZXN0ZWQgRlMuXG4gICAgYXdhaXQgdGhpcy5vbmdvaW5nVW5sb2Fkcy5nZXQoZnNNb3VudFBvaW50KT8ucHJvbWlzZTtcbiAgfVxuXG4gIHB1YmxpYyB1bmxvYWRGc0lmTWFya2VkQW5kTm90SW5Vc2UoZnNNb3VudFBvaW50OiBzdHJpbmcpIHtcbiAgICBjb25zdCB1bmxvYWRQcm9taXNlSGFuZGxlID0gdGhpcy5vbmdvaW5nVW5sb2Fkcy5nZXQoZnNNb3VudFBvaW50KTtcblxuICAgIC8vIElmIG5vdCBtYXJrZWQgdG8gdW5sb2FkLCBkbyBub3RoaW5nLlxuICAgIGlmICghdW5sb2FkUHJvbWlzZUhhbmRsZSkge1xuICAgICAgcmV0dXJuIHsgZGlkVHJpZ2dlclVubG9hZDogZmFsc2UgfTtcbiAgICB9XG5cbiAgICAvLyBDYW4ndCB1bmxvYWQgaWYgaXMgaW4gdXNlXG4gICAgaWYgKHRoaXMucmVhZFdyaXRlRnNVc2FnZUNvdW50ZXIuaXNJblVzZShmc01vdW50UG9pbnQpIHx8IHRoaXMucmVhZG9ubHlGc1VzYWdlQ291bnRlci5pc0luVXNlKGZzTW91bnRQb2ludCkpIHtcbiAgICAgIHJldHVybiB7IGRpZFRyaWdnZXJVbmxvYWQ6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgLy8gUmVhZC13cml0ZSBGUyB1c2FnZXMgbXVzdCBhbHdheXMgdHJpZ2dlciBhIGZsdXNoLiBJZiB0aGVyZSdzIG5vIG1vcmUgdXNhZ2VzIG9mIHJlYWQtd3JpdGUgRlMsIHRoZW5cbiAgICAvLyBXZSBjZXJ0YWlubHkgbmVlZCB0byB0cmlnZ2VyIGEgZmx1c2guXG4gICAgY29uc3QgZmx1c2hBcmdzID0geyBleGVjdXRlRXZlbklmTm90U2NoZWR1bGVkOiAhdGhpcy5yZWFkV3JpdGVGc1VzYWdlQ291bnRlci5pc0luVXNlKGZzTW91bnRQb2ludCkgfTtcblxuICAgIC8vIE5vIG5lZWQgdG8gYmxvY2sgdGhlIGNhbGxlciBieSBhbiB1bmxvYWRpbmcuXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmZsdXNoQW5kVW5sb2FkRnMoZnNNb3VudFBvaW50LCB1bmxvYWRQcm9taXNlSGFuZGxlLCBmbHVzaEFyZ3MpLCAwKTtcbiAgICByZXR1cm4geyBkaWRUcmlnZ2VyVW5sb2FkOiB0cnVlIH07XG4gIH1cblxuICBwcml2YXRlIG1ha2VTcGFjZUZvcihmc01vdW50UG9pbnQ6IHN0cmluZykge1xuICAgIGNvbnN0IGZzTW91bnRQb2ludFRvVW5sb2FkID0gdGhpcy5mc0NhY2hlLmdldExhc3RSZWNlbnRseVVzZWQoKTtcbiAgICBpZiAodGhpcy5vbmdvaW5nVW5sb2Fkcy5oYXMoZnNNb3VudFBvaW50VG9VbmxvYWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5kZWJ1ZyhgTWFraW5nIHNwYWNlIGZvciAke2ZzTW91bnRQb2ludH0gYnkgdW5sb2FkaW5nICR7ZnNNb3VudFBvaW50VG9VbmxvYWR9LmApO1xuXG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9IGltcGVyYXRpdmVQcm9taXNlSGFuZGxlPHZvaWQ+KCk7XG4gICAgY29uc3QgdW5sb2FkUHJvbWlzZUhhbmRsZSA9IHtcbiAgICAgIHByb21pc2U6IHByb21pc2UuZmluYWxseSgoKSA9PiB0aGlzLm9uZ29pbmdVbmxvYWRzLmRlbGV0ZShmc01vdW50UG9pbnRUb1VubG9hZCkpLFxuICAgICAgcmVzb2x2ZSxcbiAgICAgIHJlamVjdCxcbiAgICB9O1xuXG4gICAgdGhpcy5vbmdvaW5nVW5sb2Fkcy5zZXQoZnNNb3VudFBvaW50VG9VbmxvYWQsIHVubG9hZFByb21pc2VIYW5kbGUpO1xuICAgIHRoaXMudW5sb2FkRnNJZk1hcmtlZEFuZE5vdEluVXNlKGZzTW91bnRQb2ludFRvVW5sb2FkKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmx1c2hBbmRVbmxvYWRGcyhcbiAgICBmc01vdW50UG9pbnQ6IHN0cmluZyxcbiAgICB1bmxvYWRQcm9taXNlSGFuZGxlOiBQcm9taXNlSW1wZXJhdGl2ZUhhbmRsZTx2b2lkPixcbiAgICBmbHVzaEFyZ3M6IHsgZXhlY3V0ZUV2ZW5JZk5vdFNjaGVkdWxlZDogYm9vbGVhbiB9XG4gICkge1xuICAgIGF3YWl0IHRoaXMuZnNGbHVzaE1hbmFnZXIuZXhwZWRpdGVGbHVzaCh0aGlzLmZzQ2FjaGUsIGZzTW91bnRQb2ludCwgZmx1c2hBcmdzKTtcbiAgICB0aGlzLmZzQ2FjaGUudW5sb2FkRnMoZnNNb3VudFBvaW50KTtcbiAgICB1bmxvYWRQcm9taXNlSGFuZGxlLnJlc29sdmUoKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDIyIFJlZCBIYXQsIEluYy4gYW5kL29yIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjbGFzcyBGc1VzYWdlQ291bnRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgY291bnRlciA9IG5ldyBNYXA8c3RyaW5nLCBudW1iZXI+KCk7XG5cbiAgcHVibGljIGlzSW5Vc2UoZnNNb3VudFBvaW50OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5jb3VudGVyLmhhcyhmc01vdW50UG9pbnQpO1xuICB9XG5cbiAgcHVibGljIGFkZFVzYWdlKGZzTW91bnRQb2ludDogc3RyaW5nKSB7XG4gICAgY29uc29sZS5sb2coYEFkZGluZyB0byB1c2FnZSBjb3VudGVyICR7ZnNNb3VudFBvaW50fWApO1xuICAgIHRoaXMuY291bnRlci5zZXQoZnNNb3VudFBvaW50LCAodGhpcy5jb3VudGVyLmdldChmc01vdW50UG9pbnQpID8/IDApICsgMSk7XG4gIH1cblxuICBwdWJsaWMgcmVsZWFzZVVzYWdlKGZzTW91bnRQb2ludDogc3RyaW5nKSB7XG4gICAgY29uc3QgY3VycmVudENvdW50ID0gdGhpcy5jb3VudGVyLmdldChmc01vdW50UG9pbnQpO1xuICAgIGlmICghY3VycmVudENvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhdGFzdHJvcGhpYyBlcnJvciByZWxlYXNpbmcgdXNhZ2Ugb2YgJHtmc01vdW50UG9pbnR9LiBObyBhY2sgY291bnRlcnBhcnQuYCk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFN1YnRyYWN0aW5nIGZyb20gdXNhZ2UgY291bnRlciAke2ZzTW91bnRQb2ludH1gKTtcblxuICAgIGNvbnN0IG5leHRDb3VudCA9IGN1cnJlbnRDb3VudCAtIDE7XG4gICAgaWYgKG5leHRDb3VudCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2F0YXN0cm9waGljIGVycm9yIHJlbGVhc2luZyB1c2FnZSBvZiAke2ZzTW91bnRQb2ludH0uIE5lZ2F0aXZlIHVzYWdlIGNvdW50LmApO1xuICAgIH0gZWxzZSBpZiAobmV4dENvdW50ID09PSAwKSB7XG4gICAgICB0aGlzLmNvdW50ZXIuZGVsZXRlKGZzTW91bnRQb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY291bnRlci5zZXQoZnNNb3VudFBvaW50LCBuZXh0Q291bnQpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHVzYWdlc0xlZnQ6IG5leHRDb3VudCB9O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjIgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IGdpdCwgeyBTVEFHRSwgV09SS0RJUiB9IGZyb20gXCJpc29tb3JwaGljLWdpdFwiO1xuaW1wb3J0IGh0dHAgZnJvbSBcImlzb21vcnBoaWMtZ2l0L2h0dHAvd2ViXCI7XG5pbXBvcnQgeyBHSVRfREVGQVVMVF9CUkFOQ0ggfSBmcm9tIFwiLi4vY29uc3RhbnRzL0dpdENvbnN0YW50c1wiO1xuaW1wb3J0IHsgS2llU2FuZGJveFdvcmtzcGFjZXNGcyB9IGZyb20gXCIuL0tpZVNhbmRib3hXb3Jrc3BhY2VGc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIENsb25lQXJncyB7XG4gIGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzO1xuICByZXBvc2l0b3J5VXJsOiBVUkw7XG4gIHNvdXJjZUJyYW5jaDogc3RyaW5nO1xuICBkaXI6IHN0cmluZztcbiAgZ2l0Q29uZmlnPzoge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBlbWFpbDogc3RyaW5nO1xuICB9O1xuICBhdXRoSW5mbz86IHtcbiAgICB1c2VybmFtZTogc3RyaW5nO1xuICAgIHBhc3N3b3JkOiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tbWl0QXJncyB7XG4gIGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzO1xuICBtZXNzYWdlOiBzdHJpbmc7XG4gIHRhcmdldEJyYW5jaDogc3RyaW5nO1xuICBkaXI6IHN0cmluZztcbiAgYXV0aG9yOiB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGVtYWlsOiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHVzaEFyZ3Mge1xuICBmczogS2llU2FuZGJveFdvcmtzcGFjZXNGcztcbiAgZGlyOiBzdHJpbmc7XG4gIHJlZjogc3RyaW5nO1xuICByZW1vdGVSZWY/OiBzdHJpbmc7XG4gIHJlbW90ZTogc3RyaW5nO1xuICBmb3JjZTogYm9vbGVhbjtcbiAgYXV0aEluZm86IHtcbiAgICB1c2VybmFtZTogc3RyaW5nO1xuICAgIHBhc3N3b3JkOiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVtb3RlUmVmQXJncyB7XG4gIGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzO1xuICBkaXI6IHN0cmluZztcbiAgcmVtb3RlUmVmPzogc3RyaW5nO1xuICBhdXRoSW5mbz86IHtcbiAgICB1c2VybmFtZTogc3RyaW5nO1xuICAgIHBhc3N3b3JkOiBzdHJpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBjbGFzcyBHaXRTZXJ2aWNlIHtcbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgY29yc1Byb3h5OiBQcm9taXNlPHN0cmluZz4pIHt9XG5cbiAgcHVibGljIGFzeW5jIGxpc3RTZXJ2ZXJSZWZzKGFyZ3M6IHtcbiAgICB1cmw6IHN0cmluZztcbiAgICBhdXRoSW5mbz86IHtcbiAgICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gICAgICBwYXNzd29yZDogc3RyaW5nO1xuICAgIH07XG4gIH0pIHtcbiAgICByZXR1cm4gZ2l0Lmxpc3RTZXJ2ZXJSZWZzKHtcbiAgICAgIGh0dHAsXG4gICAgICBjb3JzUHJveHk6IGF3YWl0IHRoaXMuY29yc1Byb3h5LFxuICAgICAgb25BdXRoOiAoKSA9PiBhcmdzLmF1dGhJbmZvLFxuICAgICAgdXJsOiBhcmdzLnVybCxcbiAgICAgIHN5bXJlZnM6IHRydWUsXG4gICAgICBwcm90b2NvbFZlcnNpb246IDEsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2xvbmUoYXJnczogQ2xvbmVBcmdzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS50aW1lKFwiR2l0U2VydmljZSNjbG9uZVwiKTtcbiAgICBhd2FpdCBnaXQuY2xvbmUoe1xuICAgICAgZnM6IGFyZ3MuZnMsXG4gICAgICBodHRwOiBodHRwLFxuICAgICAgY29yc1Byb3h5OiBhd2FpdCB0aGlzLmNvcnNQcm94eSxcbiAgICAgIGRpcjogYXJncy5kaXIsXG4gICAgICB1cmw6IGFyZ3MucmVwb3NpdG9yeVVybC5ocmVmLFxuICAgICAgc2luZ2xlQnJhbmNoOiB0cnVlLFxuICAgICAgbm9UYWdzOiB0cnVlLFxuICAgICAgZGVwdGg6IDEsXG4gICAgICByZWY6IGFyZ3Muc291cmNlQnJhbmNoLFxuICAgICAgb25BdXRoOiAoKSA9PiBhcmdzLmF1dGhJbmZvLFxuICAgIH0pO1xuXG4gICAgaWYgKGFyZ3MuZ2l0Q29uZmlnKSB7XG4gICAgICBhd2FpdCB0aGlzLnNldHVwR2l0Q29uZmlnKGFyZ3MuZnMsIGFyZ3MuZGlyLCBhcmdzLmdpdENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnNvbGUudGltZUVuZChcIkdpdFNlcnZpY2UjY2xvbmVcIik7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYnJhbmNoKGFyZ3M6IHsgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnM7IGRpcjogc3RyaW5nOyBuYW1lOiBzdHJpbmc7IGNoZWNrb3V0OiBib29sZWFuIH0pIHtcbiAgICBhd2FpdCBnaXQuYnJhbmNoKHtcbiAgICAgIGZzOiBhcmdzLmZzLFxuICAgICAgZGlyOiBhcmdzLmRpcixcbiAgICAgIHJlZjogYXJncy5uYW1lLFxuICAgICAgY2hlY2tvdXQ6IGFyZ3MuY2hlY2tvdXQsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYWRkUmVtb3RlKGFyZ3M6IHsgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnM7IGRpcjogc3RyaW5nOyBuYW1lOiBzdHJpbmc7IHVybDogc3RyaW5nOyBmb3JjZTogYm9vbGVhbiB9KSB7XG4gICAgYXdhaXQgZ2l0LmFkZFJlbW90ZSh7XG4gICAgICBmczogYXJncy5mcyxcbiAgICAgIGRpcjogYXJncy5kaXIsXG4gICAgICByZW1vdGU6IGFyZ3MubmFtZSxcbiAgICAgIHVybDogYXJncy51cmwsXG4gICAgICBmb3JjZTogYXJncy5mb3JjZSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGVSZW1vdGUoYXJnczogeyBmczogS2llU2FuZGJveFdvcmtzcGFjZXNGczsgZGlyOiBzdHJpbmc7IG5hbWU6IHN0cmluZyB9KSB7XG4gICAgYXdhaXQgZ2l0LmRlbGV0ZVJlbW90ZSh7XG4gICAgICBmczogYXJncy5mcyxcbiAgICAgIGRpcjogYXJncy5kaXIsXG4gICAgICByZW1vdGU6IGFyZ3MubmFtZSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBmZXRjaChhcmdzOiB7IGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzOyBkaXI6IHN0cmluZzsgcmVtb3RlOiBzdHJpbmc7IHJlZjogc3RyaW5nIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCBnaXQuZmV0Y2goe1xuICAgICAgZnM6IGFyZ3MuZnMsXG4gICAgICBodHRwOiBodHRwLFxuICAgICAgY29yc1Byb3h5OiBhd2FpdCB0aGlzLmNvcnNQcm94eSxcbiAgICAgIGRpcjogYXJncy5kaXIsXG4gICAgICByZW1vdGU6IGFyZ3MucmVtb3RlLFxuICAgICAgcmVmOiBhcmdzLnJlZixcbiAgICAgIHNpbmdsZUJyYW5jaDogdHJ1ZSxcbiAgICAgIGRlcHRoOiAxLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNoZWNrb3V0KGFyZ3M6IHsgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnM7IGRpcjogc3RyaW5nOyByZWY6IHN0cmluZzsgcmVtb3RlOiBzdHJpbmcgfSkge1xuICAgIGF3YWl0IGdpdC5jaGVja291dCh7XG4gICAgICBmczogYXJncy5mcyxcbiAgICAgIGRpcjogYXJncy5kaXIsXG4gICAgICByZWY6IGFyZ3MucmVmLFxuICAgICAgcmVtb3RlOiBhcmdzLnJlbW90ZSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBjb21taXQoYXJnczogQ29tbWl0QXJncyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChhcmdzLmF1dGhvcikge1xuICAgICAgYXdhaXQgdGhpcy5zZXR1cEdpdENvbmZpZyhhcmdzLmZzLCBhcmdzLmRpciwgYXJncy5hdXRob3IpO1xuICAgIH1cblxuICAgIGF3YWl0IGdpdC5jb21taXQoe1xuICAgICAgZnM6IGFyZ3MuZnMsXG4gICAgICBkaXI6IGFyZ3MuZGlyLFxuICAgICAgbWVzc2FnZTogYXJncy5tZXNzYWdlLFxuICAgICAgYXV0aG9yOiB7XG4gICAgICAgIG5hbWU6IGFyZ3MuYXV0aG9yLm5hbWUsXG4gICAgICAgIGVtYWlsOiBhcmdzLmF1dGhvci5lbWFpbCxcbiAgICAgIH0sXG4gICAgICByZWY6IGFyZ3MudGFyZ2V0QnJhbmNoLFxuICAgIH0pO1xuXG4gICAgYXdhaXQgZ2l0LndyaXRlUmVmKHtcbiAgICAgIGZzOiBhcmdzLmZzLFxuICAgICAgZGlyOiBhcmdzLmRpcixcbiAgICAgIHJlZjogXCJIRUFEXCIsXG4gICAgICBmb3JjZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBhcmdzLnRhcmdldEJyYW5jaCxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwdWxsKGFyZ3M6IHtcbiAgICBmczogS2llU2FuZGJveFdvcmtzcGFjZXNGcztcbiAgICBkaXI6IHN0cmluZztcbiAgICByZWY6IHN0cmluZztcbiAgICBhdXRob3I6IHtcbiAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgIGVtYWlsOiBzdHJpbmc7XG4gICAgfTtcbiAgICBhdXRoSW5mbz86IHtcbiAgICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gICAgICBwYXNzd29yZDogc3RyaW5nO1xuICAgIH07XG4gIH0pIHtcbiAgICBhd2FpdCBnaXQucHVsbCh7XG4gICAgICBmczogYXJncy5mcyxcbiAgICAgIGh0dHA6IGh0dHAsXG4gICAgICBjb3JzUHJveHk6IGF3YWl0IHRoaXMuY29yc1Byb3h5LFxuICAgICAgZGlyOiBhcmdzLmRpcixcbiAgICAgIHJlZjogYXJncy5yZWYsXG4gICAgICBzaW5nbGVCcmFuY2g6IHRydWUsXG4gICAgICBhdXRob3I6IGFyZ3MuYXV0aG9yLFxuICAgICAgb25BdXRoOiAoKSA9PiBhcmdzLmF1dGhJbmZvLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldFJlbW90ZVJlZihhcmdzOiBSZW1vdGVSZWZBcmdzKSB7XG4gICAgY29uc3QgdXJsID0gYXdhaXQgZ2l0LmdldENvbmZpZyh7IGZzOiBhcmdzLmZzLCBwYXRoOiBcInJlbW90ZS5vcmlnaW4udXJsXCIsIGRpcjogYXJncy5kaXIgfSk7XG5cbiAgICBjb25zdCBzZXJ2ZXJSZWZzID0gYXdhaXQgZ2l0Lmxpc3RTZXJ2ZXJSZWZzKHtcbiAgICAgIGh0dHA6IGh0dHAsXG4gICAgICB1cmwsXG4gICAgICBjb3JzUHJveHk6IGF3YWl0IHRoaXMuY29yc1Byb3h5LFxuICAgICAgb25BdXRoOiAoKSA9PiBhcmdzLmF1dGhJbmZvLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlcnZlclJlZnMuZmluZCgoc2VydmVyUmVmKSA9PlxuICAgICAgYXJncy5yZW1vdGVSZWYgPyBzZXJ2ZXJSZWYucmVmID09PSBhcmdzLnJlbW90ZVJlZiA6IHNlcnZlclJlZi5yZWYgPT09IFwiSEVBRFwiXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwdXNoKGFyZ3M6IFB1c2hBcmdzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKChhd2FpdCBnaXQubGlzdFJlbW90ZXMoYXJncykpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVtb3RlIHJlcG9zaXRvcnkgZm91bmRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaGVhZCA9IGF3YWl0IHRoaXMucmVzb2x2ZVJlZih7XG4gICAgICBmczogYXJncy5mcyxcbiAgICAgIGRpcjogYXJncy5kaXIsXG4gICAgICByZWY6IFwiSEVBRFwiLFxuICAgIH0pO1xuXG4gICAgY29uc3Qgc2VydmVyUmVtb3RlUmVmID0gYXdhaXQgdGhpcy5nZXRSZW1vdGVSZWYoe1xuICAgICAgZnM6IGFyZ3MuZnMsXG4gICAgICBkaXI6IGFyZ3MuZGlyLFxuICAgICAgcmVtb3RlUmVmOiBhcmdzLnJlbW90ZVJlZixcbiAgICAgIGF1dGhJbmZvOiBhcmdzLmF1dGhJbmZvLFxuICAgIH0pO1xuXG4gICAgaWYgKHNlcnZlclJlbW90ZVJlZj8ub2lkICYmIGhlYWQgPT09IHNlcnZlclJlbW90ZVJlZi5vaWQpIHJldHVybjtcblxuICAgIGF3YWl0IGdpdC5wdXNoKHtcbiAgICAgIGZzOiBhcmdzLmZzLFxuICAgICAgaHR0cDogaHR0cCxcbiAgICAgIGNvcnNQcm94eTogYXdhaXQgdGhpcy5jb3JzUHJveHksXG4gICAgICBkaXI6IGFyZ3MuZGlyLFxuICAgICAgcmVmOiBhcmdzLnJlZixcbiAgICAgIHJlbW90ZVJlZjogYXJncy5yZW1vdGVSZWYsXG4gICAgICByZW1vdGU6IGFyZ3MucmVtb3RlLFxuICAgICAgZm9yY2U6IGFyZ3MuZm9yY2UsXG4gICAgICBvbkF1dGg6ICgpID0+IGFyZ3MuYXV0aEluZm8sXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYWRkKGFyZ3M6IHsgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnM7IGRpcjogc3RyaW5nOyByZWxhdGl2ZVBhdGg6IHN0cmluZyB9KSB7XG4gICAgYXdhaXQgZ2l0LmFkZCh7XG4gICAgICBmczogYXJncy5mcyxcbiAgICAgIGRpcjogYXJncy5kaXIsXG4gICAgICBmaWxlcGF0aDogYXJncy5yZWxhdGl2ZVBhdGgsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc2V0dXBHaXRDb25maWcoXG4gICAgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnMsXG4gICAgZGlyOiBzdHJpbmcsXG4gICAgY29uZmlnOiB7IG5hbWU6IHN0cmluZzsgZW1haWw6IHN0cmluZyB9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IGdpdC5zZXRDb25maWcoe1xuICAgICAgZnM6IGZzLFxuICAgICAgZGlyOiBkaXIsXG4gICAgICBwYXRoOiBcInVzZXIubmFtZVwiLFxuICAgICAgdmFsdWU6IGNvbmZpZy5uYW1lLFxuICAgIH0pO1xuXG4gICAgYXdhaXQgZ2l0LnNldENvbmZpZyh7XG4gICAgICBmczogZnMsXG4gICAgICBkaXI6IGRpcixcbiAgICAgIHBhdGg6IFwidXNlci5lbWFpbFwiLFxuICAgICAgdmFsdWU6IGNvbmZpZy5lbWFpbCxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGluaXQoYXJnczogeyBmczogS2llU2FuZGJveFdvcmtzcGFjZXNGczsgZGlyOiBzdHJpbmcgfSkge1xuICAgIGF3YWl0IGdpdC5pbml0KHtcbiAgICAgIGZzOiBhcmdzLmZzLFxuICAgICAgZGlyOiBhcmdzLmRpcixcbiAgICAgIGJhcmU6IGZhbHNlLFxuICAgICAgZGVmYXVsdEJyYW5jaDogR0lUX0RFRkFVTFRfQlJBTkNILFxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgaXNJZ25vcmVkKGFyZ3M6IHsgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnM7IGRpcjogc3RyaW5nOyBmaWxlcGF0aDogc3RyaW5nIH0pIHtcbiAgICByZXR1cm4gZ2l0LmlzSWdub3JlZCh7XG4gICAgICBmczogYXJncy5mcyxcbiAgICAgIGRpcjogYXJncy5kaXIsXG4gICAgICBmaWxlcGF0aDogYXJncy5maWxlcGF0aCxcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIHJtKGFyZ3M6IHsgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnM7IGRpcjogc3RyaW5nOyByZWxhdGl2ZVBhdGg6IHN0cmluZyB9KSB7XG4gICAgYXdhaXQgZ2l0LnJlbW92ZSh7XG4gICAgICBmczogYXJncy5mcyxcbiAgICAgIGRpcjogYXJncy5kaXIsXG4gICAgICBmaWxlcGF0aDogYXJncy5yZWxhdGl2ZVBhdGgsXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBpc01vZGlmaWVkKGFyZ3M6IHsgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnM7IGRpcjogc3RyaW5nOyByZWxhdGl2ZVBhdGg6IHN0cmluZyB9KSB7XG4gICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgZ2l0LnN0YXR1cyh7XG4gICAgICBmczogYXJncy5mcyxcbiAgICAgIGRpcjogYXJncy5kaXIsXG4gICAgICBmaWxlcGF0aDogYXJncy5yZWxhdGl2ZVBhdGgsXG4gICAgfSk7XG4gICAgcmV0dXJuIHN0YXR1cyAhPT0gXCJ1bm1vZGlmaWVkXCI7XG4gIH1cblxuICBhc3luYyBoYXNMb2NhbENoYW5nZXMoYXJnczogeyBmczogS2llU2FuZGJveFdvcmtzcGFjZXNGczsgZGlyOiBzdHJpbmc7IGV4Y2x1ZGU6IChmaWxlcGF0aDogc3RyaW5nKSA9PiBib29sZWFuIH0pIHtcbiAgICBjb25zdCBmaWxlcyA9IGF3YWl0IHRoaXMudW5zdGFnZWRNb2RpZmllZEZpbGVSZWxhdGl2ZVBhdGhzKGFyZ3MpO1xuICAgIHJldHVybiBmaWxlcy5sZW5ndGggPiAwO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHVuc3RhZ2VkTW9kaWZpZWRGaWxlUmVsYXRpdmVQYXRocyhhcmdzOiB7XG4gICAgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnM7XG4gICAgZGlyOiBzdHJpbmc7XG4gICAgZXhjbHVkZTogKGZpbGVwYXRoOiBzdHJpbmcpID0+IGJvb2xlYW47XG4gIH0pOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3Qgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc29sZS50aW1lKGAke25vd306IGhhc0xvY2FsQ2hhbmdlc2ApO1xuICAgIGNvbnN0IHBzZXVkb1N0YXR1c01hdHJpeCA9IGF3YWl0IGdpdC53YWxrKHtcbiAgICAgIGZzOiBhcmdzLmZzLFxuICAgICAgZGlyOiBhcmdzLmRpcixcbiAgICAgIHRyZWVzOiBbV09SS0RJUigpLCBTVEFHRSgpXSxcbiAgICAgIG1hcDogYXN5bmMgKGZpbGVwYXRoLCBbd29ya2Rpciwgc3RhZ2VdKSA9PiB7XG4gICAgICAgIGlmICghc3RhZ2UgJiYgd29ya2RpciAmJiAoYXdhaXQgZ2l0LmlzSWdub3JlZCh7IGZzOiBhcmdzLmZzLCBkaXI6IGFyZ3MuZGlyLCBmaWxlcGF0aCB9KSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1hdGNoIGFnYWluc3QgYmFzZSBwYXRoc1xuICAgICAgICBpZiAoZmlsZXBhdGguc3RhcnRzV2l0aChcIi5naXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmV4Y2x1ZGUoZmlsZXBhdGgpKSByZXR1cm47XG5cbiAgICAgICAgLy8gRm9yIG5vdywganVzdCBiYWlsIG9uIGRpcmVjdG9yaWVzXG4gICAgICAgIGNvbnN0IHdvcmtkaXJUeXBlID0gd29ya2RpciAmJiAoYXdhaXQgd29ya2Rpci50eXBlKCkpO1xuICAgICAgICBpZiAod29ya2RpclR5cGUgPT09IFwidHJlZVwiIHx8IHdvcmtkaXJUeXBlID09PSBcInNwZWNpYWxcIikgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IHN0YWdlVHlwZSA9IHN0YWdlICYmIChhd2FpdCBzdGFnZS50eXBlKCkpO1xuICAgICAgICBpZiAoc3RhZ2VUeXBlID09PSBcImNvbW1pdFwiKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHN0YWdlVHlwZSA9PT0gXCJ0cmVlXCIgfHwgc3RhZ2VUeXBlID09PSBcInNwZWNpYWxcIikgcmV0dXJuO1xuXG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIG9pZHMsIHVzaW5nIHRoZSBzdGFnZWQgb2lkIGZvciB0aGUgd29ya2luZyBkaXIgb2lkIGlmIHRoZSBzdGF0cyBtYXRjaC5cbiAgICAgICAgY29uc3Qgc3RhZ2VPaWQgPSBzdGFnZSA/IGF3YWl0IHN0YWdlLm9pZCgpIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgd29ya2Rpck9pZDtcbiAgICAgICAgaWYgKHdvcmtkaXIgJiYgIXN0YWdlKSB7XG4gICAgICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgTkVFRCB0aGUgc2hhLiBBbnkgc2hhIHdpbGwgZG9cbiAgICAgICAgICAvLyBUT0RPOiB1cGRhdGUgdGhpcyBsb2dpYyB0byBoYW5kbGUgTiB0cmVlcyBpbnN0ZWFkIG9mIGp1c3QgMy5cbiAgICAgICAgICB3b3JrZGlyT2lkID0gXCI0MlwiO1xuICAgICAgICB9IGVsc2UgaWYgKHdvcmtkaXIpIHtcbiAgICAgICAgICB3b3JrZGlyT2lkID0gYXdhaXQgd29ya2Rpci5vaWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyeSA9IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgd29ya2Rpck9pZCwgc3RhZ2VPaWRdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBlbnRyeS5tYXAoKHZhbHVlKSA9PiBlbnRyeS5pbmRleE9mKHZhbHVlKSk7XG4gICAgICAgIHJlc3VsdC5zaGlmdCgpOyAvLyByZW1vdmUgbGVhZGluZyB1bmRlZmluZWQgZW50cnlcbiAgICAgICAgcmV0dXJuIFtmaWxlcGF0aCwgLi4ucmVzdWx0XTtcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCBfV09SS0RJUiA9IDI7XG4gICAgY29uc3QgX1NUQUdFID0gMztcbiAgICBjb25zdCBfRklMRSA9IDA7XG4gICAgY29uc3QgcmV0ID0gcHNldWRvU3RhdHVzTWF0cml4LmZpbHRlcigocm93OiBhbnkpID0+IHJvd1tfV09SS0RJUl0gIT09IHJvd1tfU1RBR0VdKS5tYXAoKHJvdzogYW55KSA9PiByb3dbX0ZJTEVdKTtcbiAgICBjb25zb2xlLnRpbWVFbmQoYCR7bm93fTogaGFzTG9jYWxDaGFuZ2VzYCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyByZXNvbHZlUmVmKGFyZ3M6IHsgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnM7IGRpcjogc3RyaW5nOyByZWY6IHN0cmluZyB9KSB7XG4gICAgcmV0dXJuIGdpdC5yZXNvbHZlUmVmKHtcbiAgICAgIGZzOiBhcmdzLmZzLFxuICAgICAgZGlyOiBhcmdzLmRpcixcbiAgICAgIHJlZjogYXJncy5yZWYsXG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgYmFzZW5hbWUsIGRpcm5hbWUsIGV4dG5hbWUsIGpvaW4sIHJlbGF0aXZlIH0gZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7IEVtc2NyaXB0ZW5GcywgS2llU2FuZGJveFdvcmtzcGFjZXNGcyB9IGZyb20gXCIuL0tpZVNhbmRib3hXb3Jrc3BhY2VGc1wiO1xuaW1wb3J0IHsgRnNTY2hlbWEgfSBmcm9tIFwiLi9Gc0NhY2hlXCI7XG5pbXBvcnQgeyBleHRyYWN0RXh0ZW5zaW9uIH0gZnJvbSBcIi4uL3JlbGF0aXZlUGF0aC9Xb3Jrc3BhY2VGaWxlUmVsYXRpdmVQYXRoUGFyc2VyXCI7XG5cbi8vIGNvbWVzIGZyb20gZnNNYWluLmZzXG5kZWNsYXJlIGxldCBGUzogRW1zY3JpcHRlbkZzO1xuXG5leHBvcnQgY2xhc3MgU3RvcmFnZUZpbGUge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGFyZ3M6IHsgcGF0aDogc3RyaW5nOyBnZXRGaWxlQ29udGVudHM6ICgpID0+IFByb21pc2U8VWludDhBcnJheT4gfSkge31cblxuICBnZXQgcGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLnBhdGg7XG4gIH1cblxuICBnZXQgZ2V0RmlsZUNvbnRlbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmFyZ3MuZ2V0RmlsZUNvbnRlbnRzO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTdG9yYWdlU2VydmljZSB7XG4gIHB1YmxpYyBhc3luYyBjcmVhdGVPck92ZXJ3cml0ZUZpbGUoZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnMsIGZpbGU6IFN0b3JhZ2VGaWxlKSB7XG4gICAgY29uc3QgY29udGVudHMgPSBhd2FpdCBmaWxlLmdldEZpbGVDb250ZW50cygpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBmcy5wcm9taXNlcy53cml0ZUZpbGUoZmlsZS5wYXRoLCBjb250ZW50cyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBhd2FpdCB0aGlzLm1rZGlyRGVlcChmcywgZGlybmFtZShmaWxlLnBhdGgpKTtcbiAgICAgIGF3YWl0IGZzLnByb21pc2VzLndyaXRlRmlsZShmaWxlLnBhdGgsIGNvbnRlbnRzKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgdXBkYXRlRmlsZShcbiAgICBmczogS2llU2FuZGJveFdvcmtzcGFjZXNGcyxcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgZ2V0RmlsZUNvbnRlbnRzOiAoKSA9PiBQcm9taXNlPFVpbnQ4QXJyYXk+XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghKGF3YWl0IHRoaXMuZXhpc3RzKGZzLCBwYXRoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSAke3BhdGh9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgfVxuXG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IGdldEZpbGVDb250ZW50cygpO1xuICAgIGF3YWl0IGZzLnByb21pc2VzLndyaXRlRmlsZShwYXRoLCBjb250ZW50KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkZWxldGVGaWxlKGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzLCBwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCBmcy5wcm9taXNlcy51bmxpbmsocGF0aCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcmVuYW1lRmlsZShmczogS2llU2FuZGJveFdvcmtzcGFjZXNGcywgZmlsZTogU3RvcmFnZUZpbGUsIG5ld0ZpbGVOYW1lOiBzdHJpbmcpOiBQcm9taXNlPFN0b3JhZ2VGaWxlPiB7XG4gICAgaWYgKCEoYXdhaXQgdGhpcy5leGlzdHMoZnMsIGZpbGUucGF0aCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpbGUgJHtmaWxlLnBhdGh9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgfVxuXG4gICAgaWYgKGJhc2VuYW1lKGZpbGUucGF0aCkgPT09IG5ld0ZpbGVOYW1lKSB7XG4gICAgICByZXR1cm4gZmlsZTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRlbnNpb24gPSBleHRyYWN0RXh0ZW5zaW9uKGZpbGUucGF0aCk7XG4gICAgY29uc3QgbmV3UGF0aCA9IGpvaW4oZGlybmFtZShmaWxlLnBhdGgpLCBgJHtuZXdGaWxlTmFtZX0ke2V4dGVuc2lvbiA/IFwiLlwiICsgZXh0ZW5zaW9uIDogXCJcIn1gKTtcblxuICAgIGlmIChhd2FpdCB0aGlzLmV4aXN0cyhmcywgbmV3UGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSAke25ld1BhdGh9IGFscmVhZHkgZXhpc3RzYCk7XG4gICAgfVxuXG4gICAgY29uc3QgbmV3RmlsZSA9IG5ldyBTdG9yYWdlRmlsZSh7XG4gICAgICBwYXRoOiBuZXdQYXRoLFxuICAgICAgZ2V0RmlsZUNvbnRlbnRzOiAoKSA9PiB0aGlzLmdldEZpbGVDb250ZW50KGZzLCBuZXdQYXRoKSxcbiAgICB9KTtcblxuICAgIGF3YWl0IGZzLnByb21pc2VzLnJlbmFtZShmaWxlLnBhdGgsIG5ld0ZpbGUucGF0aCk7XG5cbiAgICByZXR1cm4gbmV3RmlsZTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBtb3ZlRmlsZShmczogS2llU2FuZGJveFdvcmtzcGFjZXNGcywgZmlsZTogU3RvcmFnZUZpbGUsIG5ld0RpclBhdGg6IHN0cmluZyk6IFByb21pc2U8U3RvcmFnZUZpbGU+IHtcbiAgICBpZiAoIShhd2FpdCB0aGlzLmV4aXN0cyhmcywgZmlsZS5wYXRoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSAke2ZpbGUucGF0aH0gZG9lcyBub3QgZXhpc3RgKTtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLm1rZGlyRGVlcChmcywgbmV3RGlyUGF0aCk7XG4gICAgY29uc3QgbmV3UGF0aCA9IGpvaW4obmV3RGlyUGF0aCwgYmFzZW5hbWUoZmlsZS5wYXRoKSk7XG4gICAgY29uc3QgZmlsZVRvTW92ZSA9IG5ldyBTdG9yYWdlRmlsZSh7XG4gICAgICBnZXRGaWxlQ29udGVudHM6IGZpbGUuZ2V0RmlsZUNvbnRlbnRzLFxuICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLmNyZWF0ZU9yT3ZlcndyaXRlRmlsZShmcywgZmlsZVRvTW92ZSk7XG4gICAgYXdhaXQgdGhpcy5kZWxldGVGaWxlKGZzLCBmaWxlLnBhdGgpO1xuXG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRmlsZSh7XG4gICAgICBnZXRGaWxlQ29udGVudHM6ICgpID0+IHRoaXMuZ2V0RmlsZUNvbnRlbnQoZnMsIG5ld1BhdGgpLFxuICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBtb3ZlRmlsZXMoXG4gICAgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnMsXG4gICAgZmlsZXM6IFN0b3JhZ2VGaWxlW10sXG4gICAgbmV3RGlyUGF0aDogc3RyaW5nXG4gICk6IFByb21pc2U8TWFwPHN0cmluZywgc3RyaW5nPj4ge1xuICAgIGNvbnN0IHBhdGhzID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcbiAgICBmb3IgKGNvbnN0IGZpbGVUb01vdmUgb2YgZmlsZXMpIHtcbiAgICAgIGNvbnN0IG1vdmVkRmlsZSA9IGF3YWl0IHRoaXMubW92ZUZpbGUoZnMsIGZpbGVUb01vdmUsIG5ld0RpclBhdGgpO1xuICAgICAgcGF0aHMuc2V0KGZpbGVUb01vdmUucGF0aCwgbW92ZWRGaWxlLnBhdGgpO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aHM7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0RmlsZUNvbnRlbnQoZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnMsIHBhdGg6IHN0cmluZyk6IFByb21pc2U8VWludDhBcnJheT4ge1xuICAgIGlmICghKGF3YWl0IHRoaXMuZXhpc3RzKGZzLCBwYXRoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmlsZSAnJHtwYXRofScgZG9lc24ndCBleGlzdGApO1xuICAgIH1cblxuICAgIHJldHVybiAoYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUocGF0aCkpIGFzIFVpbnQ4QXJyYXk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZ2V0RmlsZShmczogS2llU2FuZGJveFdvcmtzcGFjZXNGcywgcGF0aDogc3RyaW5nKTogUHJvbWlzZTxTdG9yYWdlRmlsZSB8IHVuZGVmaW5lZD4ge1xuICAgIGlmICghKGF3YWl0IHRoaXMuZXhpc3RzKGZzLCBwYXRoKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VGaWxlKHtcbiAgICAgIHBhdGgsXG4gICAgICBnZXRGaWxlQ29udGVudHM6ICgpID0+IGZzLnByb21pc2VzLnJlYWRGaWxlKHBhdGgpIGFzIFByb21pc2U8VWludDhBcnJheT4sXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBta2RpckRlZXAoZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnMsIGRpclBhdGg6IHN0cmluZywgX3NlbGZDYWxsID0gZmFsc2UpIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZnMucHJvbWlzZXMubWtkaXIoZGlyUGF0aCk7XG4gICAgICByZXR1cm47XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJZiBlcnIgaXMgbnVsbCB0aGVuIG9wZXJhdGlvbiBzdWNjZWVkZWQhXG4gICAgICBpZiAoZXJyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgdGhlIGRpcmVjdG9yeSBhbHJlYWR5IGV4aXN0cywgdGhhdCdzIE9LIVxuICAgICAgaWYgKGVyci5jb2RlID09PSBcIkVFWElTVFwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQXZvaWQgaW5maW5pdGUgbG9vcHMgb2YgZmFpbHVyZVxuICAgICAgaWYgKF9zZWxmQ2FsbCkge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGdvdCBhIFwibm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBlcnJvclwiIGJhY2t1cCBhbmQgdHJ5IGFnYWluLlxuICAgICAgaWYgKGVyci5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGRpcm5hbWUoZGlyUGF0aCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlJ3ZlIGdvbmUgdG9vIGZhclxuICAgICAgICBpZiAocGFyZW50ID09PSBcIi5cIiB8fCBwYXJlbnQgPT09IFwiL1wiIHx8IHBhcmVudCA9PT0gZGlyUGF0aCkge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluZmluaXRlIHJlY3Vyc2lvbiwgd2hhdCBjb3VsZCBnbyB3cm9uZz9cbiAgICAgICAgYXdhaXQgdGhpcy5ta2RpckRlZXAoZnMsIHBhcmVudCk7XG4gICAgICAgIGF3YWl0IHRoaXMubWtkaXJEZWVwKGZzLCBkaXJQYXRoLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZXhpc3RzKGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzLCBwYXRoOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZnMucHJvbWlzZXMuc3RhdChwYXRoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSBcIkVOT0VOVFwiIHx8IGVyci5jb2RlID09PSBcIkVOT1RESVJcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVuZXhwZWN0ZWQgZXJyb3Igd2hlbiB0cnlpbmcgdG8gY2hlY2sgaWYgZmlsZSBleGlzdHNcIiwgZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB3YWxrPFQgPSBzdHJpbmc+KGFyZ3M6IHtcbiAgICBzY2hlbWE6IEZzU2NoZW1hO1xuICAgIGJhc2VBYnNvbHV0ZVBhdGg6IHN0cmluZztcbiAgICBzaG91bGRFeGNsdWRlQWJzb2x1dGVQYXRoOiAoZGlyUGF0aDogc3RyaW5nKSA9PiBib29sZWFuO1xuICAgIG9uVmlzaXQ6IChhcmdzOiB7IGFic29sdXRlUGF0aDogc3RyaW5nOyByZWxhdGl2ZVBhdGg6IHN0cmluZyB9KSA9PiBQcm9taXNlPFQgfCB1bmRlZmluZWQ+O1xuICB9KTogUHJvbWlzZTxUW10+IHtcbiAgICBjb25zdCBmaWxlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgWy4uLmFyZ3Muc2NoZW1hLmVudHJpZXMoKV0uZmxhdE1hcChhc3luYyAoW2Fic29sdXRlUGF0aCwgeyBpbm8sIG1vZGUgfV0pID0+IHtcbiAgICAgICAgaWYgKEZTLmlzRGlyKG1vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3Muc2hvdWxkRXhjbHVkZUFic29sdXRlUGF0aChhYnNvbHV0ZVBhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gcmVsYXRpdmUoYXJncy5iYXNlQWJzb2x1dGVQYXRoLCBhYnNvbHV0ZVBhdGgpO1xuICAgICAgICBjb25zdCB2aXNpdCA9IGF3YWl0IGFyZ3Mub25WaXNpdCh7IGFic29sdXRlUGF0aCwgcmVsYXRpdmVQYXRoIH0pO1xuICAgICAgICByZXR1cm4gdmlzaXQgPyBbdmlzaXRdIDogW107XG4gICAgICB9KVxuICAgICk7XG5cbiAgICByZXR1cm4gZmlsZXMucmVkdWNlKChyZXM6IFRbXSwgYWNjKSA9PiAoYWNjID8gcmVzLmNvbmNhdChhY2MpIDogcmVzKSwgW10pIGFzIFRbXTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDIyIFJlZCBIYXQsIEluYy4gYW5kL29yIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjbGFzcyBTdWJzY3JpYmFibGU8VD4ge1xuICBwdWJsaWMgcmVhZG9ubHkgc3Vic2NyaXB0aW9ucyA9IG5ldyBTZXQ8KHZhbHVlOiBUKSA9PiB2b2lkPigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYXJnczogeyBuZXdWYWx1ZVN1cHBsaWVyOiAoKSA9PiBUIH0pIHt9XG5cbiAgcHVibGljIHN1YnNjcmliZShzdWJzY3JpcHRpb246ICh2YWx1ZTogVCkgPT4gdm9pZCkge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoc3Vic2NyaXB0aW9uKTtcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9XG5cbiAgcHVibGljIHVuc3Vic2NyaWJlKHN1YnNjcmlwdGlvbjogKHZhbHVlOiBUKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmRlbGV0ZShzdWJzY3JpcHRpb24pO1xuICB9XG5cbiAgcHVibGljIF9ub3RpZnlTdWJzY3JpYmVycygpIHtcbiAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuYXJncy5uZXdWYWx1ZVN1cHBsaWVyKCk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goKHN1YnNjcmlwdGlvbikgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uKG5ld1ZhbHVlKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDIxIFJlZCBIYXQsIEluYy4gYW5kL29yIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBLaWVTYW5kYm94V29ya3NwYWNlc0ZzIH0gZnJvbSBcIi4vS2llU2FuZGJveFdvcmtzcGFjZUZzXCI7XG5pbXBvcnQgeyBCcm9hZGNhc3RlckRpc3BhdGNoLCBGc1NlcnZpY2UgfSBmcm9tIFwiLi9Gc1NlcnZpY2VcIjtcbmltcG9ydCB7IEZzRmx1c2hNYW5hZ2VyIH0gZnJvbSBcIi4vRnNGbHVzaE1hbmFnZXJcIjtcbmltcG9ydCB7IEZzU2NoZW1hIH0gZnJvbSBcIi4vRnNDYWNoZVwiO1xuXG5leHBvcnQgY2xhc3MgV29ya3NwYWNlRGVzY3JpcHRvckZzU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZnNGbHVzaE1hbmFnZXI6IEZzRmx1c2hNYW5hZ2VyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZnNTZXJ2aWNlID0gbmV3IEZzU2VydmljZSh7IG5hbWU6IFwiRGVzY3JpcHRvcnNcIiB9LCBmc0ZsdXNoTWFuYWdlcilcbiAgKSB7fVxuXG4gIHB1YmxpYyBhc3luYyB3aXRoUmVhZFdyaXRlSW5NZW1vcnlGczxUPihcbiAgICBjYWxsYmFjazogKGFyZ3M6IHsgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnM7IHNjaGVtYTogRnNTY2hlbWE7IGJyb2FkY2FzdGVyOiBCcm9hZGNhc3RlckRpc3BhdGNoIH0pID0+IFByb21pc2U8VD5cbiAgKSB7XG4gICAgcmV0dXJuIHRoaXMuZnNTZXJ2aWNlLndpdGhSZWFkV3JpdGVJbk1lbW9yeUZzKHRoaXMuZ2V0TW91bnRQb2ludCgpLCBjYWxsYmFjayk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgd2l0aFJlYWRvbmx5SW5NZW1vcnlGczxUPihcbiAgICBjYWxsYmFjazogKGFyZ3M6IHsgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnM7IHNjaGVtYTogRnNTY2hlbWEgfSkgPT4gUHJvbWlzZTxUPlxuICApIHtcbiAgICByZXR1cm4gdGhpcy5mc1NlcnZpY2Uud2l0aFJlYWRvbmx5SW5NZW1vcnlGcyh0aGlzLmdldE1vdW50UG9pbnQoKSwgY2FsbGJhY2spO1xuICB9XG5cbiAgcHVibGljIGdldE1vdW50UG9pbnQoKSB7XG4gICAgcmV0dXJuIGBmc192MV9fd29ya3NwYWNlc2A7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgTkVXX1dPUktTUEFDRV9ERUZBVUxUX05BTUUsIFdvcmtzcGFjZURlc2NyaXB0b3IgfSBmcm9tIFwiLi4vd29ya2VyL2FwaS9Xb3Jrc3BhY2VEZXNjcmlwdG9yXCI7XG5pbXBvcnQgeyB2NCBhcyB1dWlkIH0gZnJvbSBcInV1aWRcIjtcbmltcG9ydCB7IFN0b3JhZ2VGaWxlLCBTdG9yYWdlU2VydmljZSB9IGZyb20gXCIuL1N0b3JhZ2VTZXJ2aWNlXCI7XG5pbXBvcnQgeyBkZWNvZGVyLCBlbmNvZGVyIH0gZnJvbSBcIi4uL2VuY29kZXJkZWNvZGVyL0VuY29kZXJEZWNvZGVyXCI7XG5pbXBvcnQgeyBXb3Jrc3BhY2VLaW5kLCBXb3Jrc3BhY2VPcmlnaW4gfSBmcm9tIFwiLi4vd29ya2VyL2FwaS9Xb3Jrc3BhY2VPcmlnaW5cIjtcbmltcG9ydCB7IEdJVF9ERUZBVUxUX0JSQU5DSCB9IGZyb20gXCIuLi9jb25zdGFudHMvR2l0Q29uc3RhbnRzXCI7XG5pbXBvcnQgeyBLaWVTYW5kYm94V29ya3NwYWNlc0ZzIH0gZnJvbSBcIi4vS2llU2FuZGJveFdvcmtzcGFjZUZzXCI7XG5pbXBvcnQgeyBXb3Jrc3BhY2VEZXNjcmlwdG9yRnNTZXJ2aWNlIH0gZnJvbSBcIi4vV29ya3NwYWNlRGVzY3JpcHRvckZzU2VydmljZVwiO1xuaW1wb3J0IHsgam9pbiB9IGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgeyBGc1NjaGVtYSB9IGZyb20gXCIuL0ZzQ2FjaGVcIjtcbmltcG9ydCB7IEJyb2FkY2FzdGVyIH0gZnJvbSBcIi4vRnNTZXJ2aWNlXCI7XG5pbXBvcnQgeyBXT1JLU1BBQ0VTX0JST0FEQ0FTVF9DSEFOTkVMIH0gZnJvbSBcIi4uL3dvcmtlci9hcGkvV29ya3NwYWNlc0Jyb2FkY2FzdEV2ZW50c1wiO1xuXG5leHBvcnQgY2xhc3MgV29ya3NwYWNlRGVzY3JpcHRvclNlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRlc2NyaXB0b3JGc1NlcnZpY2U6IFdvcmtzcGFjZURlc2NyaXB0b3JGc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzdG9yYWdlU2VydmljZTogU3RvcmFnZVNlcnZpY2VcbiAgKSB7fVxuXG4gIHB1YmxpYyBhc3luYyBsaXN0QWxsKGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzLCBzY2hlbWE6IEZzU2NoZW1hKTogUHJvbWlzZTxXb3Jrc3BhY2VEZXNjcmlwdG9yW10+IHtcbiAgICBjb25zdCB3b3Jrc3BhY2VEZXNjcmlwdG9yc0ZpbGVQYXRocyA9IGF3YWl0IHRoaXMuc3RvcmFnZVNlcnZpY2Uud2Fsayh7XG4gICAgICBzY2hlbWEsXG4gICAgICBiYXNlQWJzb2x1dGVQYXRoOiB0aGlzLmdldEFic29sdXRlUGF0aChcIlwiKSxcbiAgICAgIHNob3VsZEV4Y2x1ZGVBYnNvbHV0ZVBhdGg6ICgpID0+IGZhbHNlLFxuICAgICAgb25WaXNpdDogYXN5bmMgKHsgYWJzb2x1dGVQYXRoIH0pID0+IGFic29sdXRlUGF0aCxcbiAgICB9KTtcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChcbiAgICAgIHdvcmtzcGFjZURlc2NyaXB0b3JzRmlsZVBhdGhzLm1hcChhc3luYyAocCkgPT4ge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5zdG9yYWdlU2VydmljZS5nZXRGaWxlQ29udGVudChmcywgcCk7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRlY29kZXIuZGVjb2RlKGNvbnRlbnQpKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBidW1wTGFzdFVwZGF0ZWREYXRlKGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzLCB3b3Jrc3BhY2VJZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMudG9TdG9yYWdlRmlsZSh7XG4gICAgICAuLi4oYXdhaXQgdGhpcy5nZXQoZnMsIHdvcmtzcGFjZUlkKSksXG4gICAgICBsYXN0VXBkYXRlZERhdGVJU086IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLnN0b3JhZ2VTZXJ2aWNlLnVwZGF0ZUZpbGUoZnMsIGZpbGUucGF0aCwgZmlsZS5nZXRGaWxlQ29udGVudHMpO1xuXG4gICAgbmV3IEJyb2FkY2FzdGVyKCkuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IHdvcmtzcGFjZUlkLFxuICAgICAgbWVzc2FnZTogYXN5bmMgKCkgPT4gKHsgdHlwZTogXCJXU19VUERBVEVfREVTQ1JJUFRPUlwiIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldChmczogS2llU2FuZGJveFdvcmtzcGFjZXNGcywgd29ya3NwYWNlSWQ6IHN0cmluZyk6IFByb21pc2U8V29ya3NwYWNlRGVzY3JpcHRvcj4ge1xuICAgIGNvbnN0IHdvcmtzcGFjZURlc2NyaXB0b3JGaWxlID0gYXdhaXQgdGhpcy5zdG9yYWdlU2VydmljZS5nZXRGaWxlKGZzLCB0aGlzLmdldEFic29sdXRlUGF0aCh3b3Jrc3BhY2VJZCkpO1xuXG4gICAgaWYgKCF3b3Jrc3BhY2VEZXNjcmlwdG9yRmlsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBXb3Jrc3BhY2Ugbm90IGZvdW5kICgke3dvcmtzcGFjZUlkfSlgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVyLmRlY29kZShhd2FpdCB3b3Jrc3BhY2VEZXNjcmlwdG9yRmlsZS5nZXRGaWxlQ29udGVudHMoKSkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGNyZWF0ZShhcmdzOiB7XG4gICAgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnM7XG4gICAgb3JpZ2luOiBXb3Jrc3BhY2VPcmlnaW47XG4gICAgcHJlZmVycmVkTmFtZT86IHN0cmluZztcbiAgICBnaXRBdXRoU2Vzc2lvbklkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIH0pIHtcbiAgICBjb25zdCB3b3Jrc3BhY2U6IFdvcmtzcGFjZURlc2NyaXB0b3IgPSB7XG4gICAgICB3b3Jrc3BhY2VJZDogdGhpcy5uZXdXb3Jrc3BhY2VJZCgpLFxuICAgICAgbmFtZTogYXJncy5wcmVmZXJyZWROYW1lPy50cmltKCkgfHwgTkVXX1dPUktTUEFDRV9ERUZBVUxUX05BTUUsXG4gICAgICBvcmlnaW46IGFyZ3Mub3JpZ2luLFxuICAgICAgY3JlYXRlZERhdGVJU086IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGxhc3RVcGRhdGVkRGF0ZUlTTzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgZ2l0QXV0aFNlc3Npb25JZDogYXJncy5naXRBdXRoU2Vzc2lvbklkLFxuICAgIH07XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlU2VydmljZS5jcmVhdGVPck92ZXJ3cml0ZUZpbGUoYXJncy5mcywgdGhpcy50b1N0b3JhZ2VGaWxlKHdvcmtzcGFjZSkpO1xuICAgIHJldHVybiB3b3Jrc3BhY2U7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVsZXRlKGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzLCB3b3Jrc3BhY2VJZDogc3RyaW5nKSB7XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlU2VydmljZS5kZWxldGVGaWxlKGZzLCB0aGlzLmdldEFic29sdXRlUGF0aCh3b3Jrc3BhY2VJZCkpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlbmFtZShmczogS2llU2FuZGJveFdvcmtzcGFjZXNGcywgd29ya3NwYWNlSWQ6IHN0cmluZywgbmV3TmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMudG9TdG9yYWdlRmlsZSh7XG4gICAgICAuLi4oYXdhaXQgdGhpcy5nZXQoZnMsIHdvcmtzcGFjZUlkKSksXG4gICAgICBuYW1lOiBuZXdOYW1lLFxuICAgIH0pO1xuICAgIGF3YWl0IHRoaXMuc3RvcmFnZVNlcnZpY2UudXBkYXRlRmlsZShmcywgZmlsZS5wYXRoLCBmaWxlLmdldEZpbGVDb250ZW50cyk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgdHVybkludG9HaXN0KGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzLCB3b3Jrc3BhY2VJZDogc3RyaW5nLCBnaXN0VXJsOiBVUkwsIGJyYW5jaDogc3RyaW5nKSB7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMudG9TdG9yYWdlRmlsZSh7XG4gICAgICAuLi4oYXdhaXQgdGhpcy5nZXQoZnMsIHdvcmtzcGFjZUlkKSksXG4gICAgICBvcmlnaW46IHtcbiAgICAgICAga2luZDogV29ya3NwYWNlS2luZC5HSVRIVUJfR0lTVCxcbiAgICAgICAgdXJsOiBnaXN0VXJsLnRvU3RyaW5nKCksXG4gICAgICAgIGJyYW5jaCxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlU2VydmljZS51cGRhdGVGaWxlKGZzLCBmaWxlLnBhdGgsIGZpbGUuZ2V0RmlsZUNvbnRlbnRzKTtcblxuICAgIG5ldyBCcm9hZGNhc3RlcigpLmJyb2FkY2FzdCh7XG4gICAgICBjaGFubmVsOiB3b3Jrc3BhY2VJZCxcbiAgICAgIG1lc3NhZ2U6IGFzeW5jICgpID0+ICh7IHR5cGU6IFwiV1NfVVBEQVRFX0RFU0NSSVBUT1JcIiB9KSxcbiAgICB9KTtcblxuICAgIG5ldyBCcm9hZGNhc3RlcigpLmJyb2FkY2FzdCh7XG4gICAgICBjaGFubmVsOiBXT1JLU1BBQ0VTX0JST0FEQ0FTVF9DSEFOTkVMLFxuICAgICAgbWVzc2FnZTogYXN5bmMgKCkgPT4gKHsgdHlwZTogXCJXU1NfVVBEQVRFXCIsIHdvcmtzcGFjZUlkIH0pLFxuICAgIH0pO1xuICB9XG4gIHB1YmxpYyBhc3luYyB0dXJuSW50b1NuaXBwZXQoZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnMsIHdvcmtzcGFjZUlkOiBzdHJpbmcsIHNuaXBwZXRVcmw6IFVSTCwgYnJhbmNoOiBzdHJpbmcpIHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy50b1N0b3JhZ2VGaWxlKHtcbiAgICAgIC4uLihhd2FpdCB0aGlzLmdldChmcywgd29ya3NwYWNlSWQpKSxcbiAgICAgIG9yaWdpbjoge1xuICAgICAgICBraW5kOiBXb3Jrc3BhY2VLaW5kLkJJVEJVQ0tFVF9TTklQUEVULFxuICAgICAgICB1cmw6IHNuaXBwZXRVcmwudG9TdHJpbmcoKSxcbiAgICAgICAgYnJhbmNoLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLnN0b3JhZ2VTZXJ2aWNlLnVwZGF0ZUZpbGUoZnMsIGZpbGUucGF0aCwgZmlsZS5nZXRGaWxlQ29udGVudHMpO1xuXG4gICAgbmV3IEJyb2FkY2FzdGVyKCkuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IHdvcmtzcGFjZUlkLFxuICAgICAgbWVzc2FnZTogYXN5bmMgKCkgPT4gKHsgdHlwZTogXCJXU19VUERBVEVfREVTQ1JJUFRPUlwiIH0pLFxuICAgIH0pO1xuXG4gICAgbmV3IEJyb2FkY2FzdGVyKCkuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IFdPUktTUEFDRVNfQlJPQURDQVNUX0NIQU5ORUwsXG4gICAgICBtZXNzYWdlOiBhc3luYyAoKSA9PiAoeyB0eXBlOiBcIldTU19VUERBVEVcIiwgd29ya3NwYWNlSWQgfSksXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgdHVybkludG9HaXQoZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnMsIHdvcmtzcGFjZUlkOiBzdHJpbmcsIHVybDogVVJMLCBicmFuY2g/OiBzdHJpbmcpIHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy50b1N0b3JhZ2VGaWxlKHtcbiAgICAgIC4uLihhd2FpdCB0aGlzLmdldChmcywgd29ya3NwYWNlSWQpKSxcbiAgICAgIG9yaWdpbjoge1xuICAgICAgICBraW5kOiBXb3Jrc3BhY2VLaW5kLkdJVCxcbiAgICAgICAgdXJsOiB1cmwudG9TdHJpbmcoKSxcbiAgICAgICAgYnJhbmNoOiBicmFuY2ggPz8gR0lUX0RFRkFVTFRfQlJBTkNILFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBhd2FpdCB0aGlzLnN0b3JhZ2VTZXJ2aWNlLnVwZGF0ZUZpbGUoZnMsIGZpbGUucGF0aCwgZmlsZS5nZXRGaWxlQ29udGVudHMpO1xuXG4gICAgbmV3IEJyb2FkY2FzdGVyKCkuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IHdvcmtzcGFjZUlkLFxuICAgICAgbWVzc2FnZTogYXN5bmMgKCkgPT4gKHsgdHlwZTogXCJXU19VUERBVEVfREVTQ1JJUFRPUlwiIH0pLFxuICAgIH0pO1xuXG4gICAgbmV3IEJyb2FkY2FzdGVyKCkuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IFdPUktTUEFDRVNfQlJPQURDQVNUX0NIQU5ORUwsXG4gICAgICBtZXNzYWdlOiBhc3luYyAoKSA9PiAoeyB0eXBlOiBcIldTU19VUERBVEVcIiwgd29ya3NwYWNlSWQgfSksXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY2hhbmdlR2l0QXV0aFNlc3Npb25JZChcbiAgICBmczogS2llU2FuZGJveFdvcmtzcGFjZXNGcyxcbiAgICB3b3Jrc3BhY2VJZDogc3RyaW5nLFxuICAgIGdpdEF1dGhTZXNzaW9uSWQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICApIHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy50b1N0b3JhZ2VGaWxlKHtcbiAgICAgIC4uLihhd2FpdCB0aGlzLmdldChmcywgd29ya3NwYWNlSWQpKSxcbiAgICAgIGdpdEF1dGhTZXNzaW9uSWQsXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlU2VydmljZS51cGRhdGVGaWxlKGZzLCBmaWxlLnBhdGgsIGZpbGUuZ2V0RmlsZUNvbnRlbnRzKTtcblxuICAgIG5ldyBCcm9hZGNhc3RlcigpLmJyb2FkY2FzdCh7XG4gICAgICBjaGFubmVsOiB3b3Jrc3BhY2VJZCxcbiAgICAgIG1lc3NhZ2U6IGFzeW5jICgpID0+ICh7IHR5cGU6IFwiV1NfVVBEQVRFX0RFU0NSSVBUT1JcIiB9KSxcbiAgICB9KTtcblxuICAgIG5ldyBCcm9hZGNhc3RlcigpLmJyb2FkY2FzdCh7XG4gICAgICBjaGFubmVsOiBXT1JLU1BBQ0VTX0JST0FEQ0FTVF9DSEFOTkVMLFxuICAgICAgbWVzc2FnZTogYXN5bmMgKCkgPT4gKHsgdHlwZTogXCJXU1NfVVBEQVRFXCIsIHdvcmtzcGFjZUlkIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHR1cm5JbnRvTG9jYWwoZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnMsIHdvcmtzcGFjZUlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy50b1N0b3JhZ2VGaWxlKHtcbiAgICAgIC4uLihhd2FpdCB0aGlzLmdldChmcywgd29ya3NwYWNlSWQpKSxcbiAgICAgIG9yaWdpbjoge1xuICAgICAgICBraW5kOiBXb3Jrc3BhY2VLaW5kLkxPQ0FMLFxuICAgICAgICBicmFuY2g6IEdJVF9ERUZBVUxUX0JSQU5DSCxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlU2VydmljZS51cGRhdGVGaWxlKGZzLCBmaWxlLnBhdGgsIGZpbGUuZ2V0RmlsZUNvbnRlbnRzKTtcblxuICAgIG5ldyBCcm9hZGNhc3RlcigpLmJyb2FkY2FzdCh7XG4gICAgICBjaGFubmVsOiB3b3Jrc3BhY2VJZCxcbiAgICAgIG1lc3NhZ2U6IGFzeW5jICgpID0+ICh7IHR5cGU6IFwiV1NfVVBEQVRFX0RFU0NSSVBUT1JcIiB9KSxcbiAgICB9KTtcblxuICAgIG5ldyBCcm9hZGNhc3RlcigpLmJyb2FkY2FzdCh7XG4gICAgICBjaGFubmVsOiBXT1JLU1BBQ0VTX0JST0FEQ0FTVF9DSEFOTkVMLFxuICAgICAgbWVzc2FnZTogYXN5bmMgKCkgPT4gKHsgdHlwZTogXCJXU1NfVVBEQVRFXCIsIHdvcmtzcGFjZUlkIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRBYnNvbHV0ZVBhdGgocmVsYXRpdmVQYXRoOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gam9pbihcIi9cIiwgdGhpcy5kZXNjcmlwdG9yRnNTZXJ2aWNlLmdldE1vdW50UG9pbnQoKSwgcmVsYXRpdmVQYXRoID8/IFwiXCIpO1xuICB9XG5cbiAgcHJpdmF0ZSB0b1N0b3JhZ2VGaWxlKGRlc2NyaXB0b3I6IFdvcmtzcGFjZURlc2NyaXB0b3IpIHtcbiAgICByZXR1cm4gbmV3IFN0b3JhZ2VGaWxlKHtcbiAgICAgIHBhdGg6IHRoaXMuZ2V0QWJzb2x1dGVQYXRoKGRlc2NyaXB0b3Iud29ya3NwYWNlSWQpLFxuICAgICAgZ2V0RmlsZUNvbnRlbnRzOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoZW5jb2Rlci5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoZGVzY3JpcHRvcikpKSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBuZXdXb3Jrc3BhY2VJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB1dWlkKCk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgS2llU2FuZGJveFdvcmtzcGFjZXNGcyB9IGZyb20gXCIuL0tpZVNhbmRib3hXb3Jrc3BhY2VGc1wiO1xuaW1wb3J0IHsgQnJvYWRjYXN0ZXJEaXNwYXRjaCwgRnNTZXJ2aWNlIH0gZnJvbSBcIi4vRnNTZXJ2aWNlXCI7XG5pbXBvcnQgeyBGc1NjaGVtYSwgZnNTY2hlbWFEaXIgfSBmcm9tIFwiLi9Gc0NhY2hlXCI7XG5pbXBvcnQgeyBGc0ZsdXNoTWFuYWdlciB9IGZyb20gXCIuL0ZzRmx1c2hNYW5hZ2VyXCI7XG5cbmV4cG9ydCBjbGFzcyBXb3Jrc3BhY2VGc1NlcnZpY2Uge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZzRmx1c2hNYW5hZ2VyOiBGc0ZsdXNoTWFuYWdlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZzU2VydmljZSA9IG5ldyBGc1NlcnZpY2UoeyBuYW1lOiBcIldvcmtzcGFjZXNcIiB9LCBmc0ZsdXNoTWFuYWdlcilcbiAgKSB7fVxuXG4gIHB1YmxpYyBhc3luYyB3aXRoUmVhZFdyaXRlSW5NZW1vcnlGczxUPihcbiAgICB3b3Jrc3BhY2VJZDogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiAoYXJnczogeyBmczogS2llU2FuZGJveFdvcmtzcGFjZXNGczsgc2NoZW1hOiBGc1NjaGVtYTsgYnJvYWRjYXN0ZXI6IEJyb2FkY2FzdGVyRGlzcGF0Y2ggfSkgPT4gUHJvbWlzZTxUPlxuICApIHtcbiAgICByZXR1cm4gdGhpcy5mc1NlcnZpY2Uud2l0aFJlYWRXcml0ZUluTWVtb3J5RnModGhpcy5nZXRGc01vdW50UG9pbnQod29ya3NwYWNlSWQpLCBjYWxsYmFjayk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgd2l0aFJlYWRvbmx5SW5NZW1vcnlGczxUPihcbiAgICB3b3Jrc3BhY2VJZDogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiAoYXJnczogeyBmczogS2llU2FuZGJveFdvcmtzcGFjZXNGczsgc2NoZW1hOiBGc1NjaGVtYSB9KSA9PiBQcm9taXNlPFQ+XG4gICkge1xuICAgIHJldHVybiB0aGlzLmZzU2VydmljZS53aXRoUmVhZG9ubHlJbk1lbW9yeUZzKHRoaXMuZ2V0RnNNb3VudFBvaW50KHdvcmtzcGFjZUlkKSwgY2FsbGJhY2spO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHdpdGhSZWFkb25seUZzU2NoZW1hPFQ+KHdvcmtzcGFjZUlkOiBzdHJpbmcsIGNhbGxiYWNrOiAoYXJnczogeyBzY2hlbWE6IEZzU2NoZW1hIH0pID0+IFByb21pc2U8VD4pIHtcbiAgICByZXR1cm4gdGhpcy5mc1NlcnZpY2Uud2l0aFJlYWRvbmx5RnNTY2hlbWEodGhpcy5nZXRGc01vdW50UG9pbnQod29ya3NwYWNlSWQpLCBjYWxsYmFjayk7XG4gIH1cblxuICBwdWJsaWMgZ2V0RnNNb3VudFBvaW50KHdvcmtzcGFjZUlkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYGZzX3YxX18ke3dvcmtzcGFjZUlkfWA7XG4gIH1cblxuICBwdWJsaWMgZ2V0RnNTY2hlbWFNb3VudFBvaW50KHdvcmtzcGFjZUlkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gZnNTY2hlbWFEaXIodGhpcy5nZXRGc01vdW50UG9pbnQod29ya3NwYWNlSWQpKTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDIxIFJlZCBIYXQsIEluYy4gYW5kL29yIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBlbmNvZGVyIH0gZnJvbSBcIi4uL2VuY29kZXJkZWNvZGVyL0VuY29kZXJEZWNvZGVyXCI7XG5pbXBvcnQgSlNaaXAgZnJvbSBcImpzemlwXCI7XG5pbXBvcnQgeyBXb3Jrc3BhY2VEZXNjcmlwdG9yIH0gZnJvbSBcIi4uL3dvcmtlci9hcGkvV29ya3NwYWNlRGVzY3JpcHRvclwiO1xuaW1wb3J0IHsgU3RvcmFnZUZpbGUsIFN0b3JhZ2VTZXJ2aWNlIH0gZnJvbSBcIi4vU3RvcmFnZVNlcnZpY2VcIjtcbmltcG9ydCB7IGJhc2VuYW1lLCBqb2luLCByZWxhdGl2ZSB9IGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgeyBNaW5pbWF0Y2ggfSBmcm9tIFwibWluaW1hdGNoXCI7XG5pbXBvcnQgeyBXb3Jrc3BhY2VEZXNjcmlwdG9yU2VydmljZSB9IGZyb20gXCIuL1dvcmtzcGFjZURlc2NyaXB0b3JTZXJ2aWNlXCI7XG5pbXBvcnQgeyBCcm9hZGNhc3RlckRpc3BhdGNoIH0gZnJvbSBcIi4vRnNTZXJ2aWNlXCI7XG5pbXBvcnQgeyBXb3Jrc3BhY2VPcmlnaW4gfSBmcm9tIFwiLi4vd29ya2VyL2FwaS9Xb3Jrc3BhY2VPcmlnaW5cIjtcbmltcG9ydCB7IFdvcmtzcGFjZVdvcmtlckZpbGVEZXNjcmlwdG9yIH0gZnJvbSBcIi4uL3dvcmtlci9hcGkvV29ya3NwYWNlV29ya2VyRmlsZURlc2NyaXB0b3JcIjtcbmltcG9ydCB7IFdvcmtzcGFjZVdvcmtlckZpbGUgfSBmcm9tIFwiLi4vd29ya2VyL2FwaS9Xb3Jrc3BhY2VXb3JrZXJGaWxlXCI7XG5pbXBvcnQgeyBLaWVTYW5kYm94V29ya3NwYWNlc0ZzIH0gZnJvbSBcIi4vS2llU2FuZGJveFdvcmtzcGFjZUZzXCI7XG5pbXBvcnQgeyBXb3Jrc3BhY2VEZXNjcmlwdG9yRnNTZXJ2aWNlIH0gZnJvbSBcIi4vV29ya3NwYWNlRGVzY3JpcHRvckZzU2VydmljZVwiO1xuaW1wb3J0IHsgV29ya3NwYWNlRnNTZXJ2aWNlIH0gZnJvbSBcIi4vV29ya3NwYWNlRnNTZXJ2aWNlXCI7XG5pbXBvcnQge1xuICBXT1JLU1BBQ0VTX0JST0FEQ0FTVF9DSEFOTkVMLFxuICBXT1JLU1BBQ0VTX0ZJTEVTX0JST0FEQ0FTVF9DSEFOTkVMLFxufSBmcm9tIFwiLi4vd29ya2VyL2FwaS9Xb3Jrc3BhY2VzQnJvYWRjYXN0RXZlbnRzXCI7XG5pbXBvcnQgeyBGc1NjaGVtYSB9IGZyb20gXCIuL0ZzQ2FjaGVcIjtcbmltcG9ydCB7IGV4dHJhY3RFeHRlbnNpb24gfSBmcm9tIFwiLi4vcmVsYXRpdmVQYXRoL1dvcmtzcGFjZUZpbGVSZWxhdGl2ZVBhdGhQYXJzZXJcIjtcblxuZXhwb3J0IGNsYXNzIFdvcmtzcGFjZVNlcnZpY2Uge1xuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IHN0b3JhZ2VTZXJ2aWNlOiBTdG9yYWdlU2VydmljZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRlc2NyaXB0b3JzRnNTZXJ2aWNlOiBXb3Jrc3BhY2VEZXNjcmlwdG9yRnNTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgd29ya3NwYWNlRGVzY3JpcHRvclNlcnZpY2U6IFdvcmtzcGFjZURlc2NyaXB0b3JTZXJ2aWNlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZnNTZXJ2aWNlOiBXb3Jrc3BhY2VGc1NlcnZpY2VcbiAgKSB7fVxuXG4gIHB1YmxpYyBhc3luYyBjcmVhdGUoYXJnczoge1xuICAgIHN0b3JlRmlsZXM6IChcbiAgICAgIGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzLFxuICAgICAgc2NoZW1hOiBGc1NjaGVtYSxcbiAgICAgIHdvcmtzcGFjZTogV29ya3NwYWNlRGVzY3JpcHRvclxuICAgICkgPT4gUHJvbWlzZTxXb3Jrc3BhY2VXb3JrZXJGaWxlRGVzY3JpcHRvcltdPjtcbiAgICBvcmlnaW46IFdvcmtzcGFjZU9yaWdpbjtcbiAgICBwcmVmZXJyZWROYW1lPzogc3RyaW5nO1xuICAgIGdpdEF1dGhTZXNzaW9uSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgfSkge1xuICAgIGNvbnN0IHdvcmtzcGFjZSA9IGF3YWl0IHRoaXMuZGVzY3JpcHRvcnNGc1NlcnZpY2Uud2l0aFJlYWRXcml0ZUluTWVtb3J5RnMoKHsgZnMgfSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMud29ya3NwYWNlRGVzY3JpcHRvclNlcnZpY2UuY3JlYXRlKHtcbiAgICAgICAgZnMsXG4gICAgICAgIG9yaWdpbjogYXJncy5vcmlnaW4sXG4gICAgICAgIHByZWZlcnJlZE5hbWU6IGFyZ3MucHJlZmVycmVkTmFtZSxcbiAgICAgICAgZ2l0QXV0aFNlc3Npb25JZDogYXJncy5naXRBdXRoU2Vzc2lvbklkLFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZnNTZXJ2aWNlLndpdGhSZWFkV3JpdGVJbk1lbW9yeUZzKFxuICAgICAgICB3b3Jrc3BhY2Uud29ya3NwYWNlSWQsXG4gICAgICAgIGFzeW5jICh7IGZzLCBzY2hlbWEsIGJyb2FkY2FzdGVyIH0pID0+IHtcbiAgICAgICAgICBjb25zdCBmaWxlcyA9IGF3YWl0IGFyZ3Muc3RvcmVGaWxlcyhmcywgc2NoZW1hLCB3b3Jrc3BhY2UpO1xuXG4gICAgICAgICAgYnJvYWRjYXN0ZXIuYnJvYWRjYXN0KHtcbiAgICAgICAgICAgIGNoYW5uZWw6IFdPUktTUEFDRVNfQlJPQURDQVNUX0NIQU5ORUwsXG4gICAgICAgICAgICBtZXNzYWdlOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgICB0eXBlOiBcIldTU19BRERfV09SS1NQQUNFXCIsXG4gICAgICAgICAgICAgIHdvcmtzcGFjZUlkOiB3b3Jrc3BhY2Uud29ya3NwYWNlSWQsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGJyb2FkY2FzdGVyLmJyb2FkY2FzdCh7XG4gICAgICAgICAgICBjaGFubmVsOiB3b3Jrc3BhY2Uud29ya3NwYWNlSWQsXG4gICAgICAgICAgICBtZXNzYWdlOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgICB0eXBlOiBcIldTX0FERFwiLFxuICAgICAgICAgICAgICB3b3Jrc3BhY2VJZDogd29ya3NwYWNlLndvcmtzcGFjZUlkLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4geyB3b3Jrc3BhY2UsIGZpbGVzIH07XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgYXdhaXQgdGhpcy5kZWxldGUod29ya3NwYWNlLndvcmtzcGFjZUlkKTtcbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldEZpbHRlcmVkV29ya3NwYWNlRmlsZURlc2NyaXB0b3JzKFxuICAgIHNjaGVtYTogRnNTY2hlbWEsXG4gICAgd29ya3NwYWNlSWQ6IHN0cmluZyxcbiAgICBnbG9iUGF0dGVybj86IHN0cmluZ1xuICApOiBQcm9taXNlPFdvcmtzcGFjZVdvcmtlckZpbGVEZXNjcmlwdG9yW10+IHtcbiAgICBjb25zdCBtYXRjaGVyID0gZ2xvYlBhdHRlcm4gPyBuZXcgTWluaW1hdGNoKGdsb2JQYXR0ZXJuLCB7IGRvdDogdHJ1ZSB9KSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBnaXREaXJBYnNvbHV0ZVBhdGggPSB0aGlzLmdldEFic29sdXRlUGF0aCh7IHdvcmtzcGFjZUlkLCByZWxhdGl2ZVBhdGg6IFwiLmdpdFwiIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZVNlcnZpY2Uud2Fsayh7XG4gICAgICBzY2hlbWEsXG4gICAgICBiYXNlQWJzb2x1dGVQYXRoOiB0aGlzLmdldEFic29sdXRlUGF0aCh7IHdvcmtzcGFjZUlkIH0pLFxuICAgICAgc2hvdWxkRXhjbHVkZUFic29sdXRlUGF0aDogKGFic29sdXRlUGF0aCkgPT4gYWJzb2x1dGVQYXRoLnN0YXJ0c1dpdGgoZ2l0RGlyQWJzb2x1dGVQYXRoKSxcbiAgICAgIG9uVmlzaXQ6IGFzeW5jICh7IHJlbGF0aXZlUGF0aCB9KSA9PiB7XG4gICAgICAgIGlmIChtYXRjaGVyICYmICFtYXRjaGVyLm1hdGNoKGJhc2VuYW1lKHJlbGF0aXZlUGF0aCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geyB3b3Jrc3BhY2VJZCwgcmVsYXRpdmVQYXRoIH07XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZGVsZXRlKHdvcmtzcGFjZUlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLmRlc2NyaXB0b3JzRnNTZXJ2aWNlLndpdGhSZWFkV3JpdGVJbk1lbW9yeUZzKGFzeW5jICh7IGZzLCBicm9hZGNhc3RlciB9KSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLndvcmtzcGFjZURlc2NyaXB0b3JTZXJ2aWNlLmRlbGV0ZShmcywgd29ya3NwYWNlSWQpO1xuXG4gICAgICBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UodGhpcy5mc1NlcnZpY2UuZ2V0RnNNb3VudFBvaW50KHdvcmtzcGFjZUlkKSk7XG4gICAgICBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UodGhpcy5mc1NlcnZpY2UuZ2V0RnNTY2hlbWFNb3VudFBvaW50KHdvcmtzcGFjZUlkKSk7XG5cbiAgICAgIGJyb2FkY2FzdGVyLmJyb2FkY2FzdCh7XG4gICAgICAgIGNoYW5uZWw6IFdPUktTUEFDRVNfQlJPQURDQVNUX0NIQU5ORUwsXG4gICAgICAgIG1lc3NhZ2U6IGFzeW5jICgpID0+ICh7IHR5cGU6IFwiV1NTX0RFTEVURV9XT1JLU1BBQ0VcIiwgd29ya3NwYWNlSWQgfSksXG4gICAgICB9KTtcblxuICAgICAgYnJvYWRjYXN0ZXIuYnJvYWRjYXN0KHtcbiAgICAgICAgY2hhbm5lbDogd29ya3NwYWNlSWQsXG4gICAgICAgIG1lc3NhZ2U6IGFzeW5jICgpID0+ICh7IHR5cGU6IFwiV1NfREVMRVRFXCIsIHdvcmtzcGFjZUlkIH0pLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcmVuYW1lKHdvcmtzcGFjZUlkOiBzdHJpbmcsIG5ld05hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuZGVzY3JpcHRvcnNGc1NlcnZpY2Uud2l0aFJlYWRXcml0ZUluTWVtb3J5RnMoYXN5bmMgKHsgZnMsIGJyb2FkY2FzdGVyIH0pID0+IHtcbiAgICAgIGF3YWl0IHRoaXMud29ya3NwYWNlRGVzY3JpcHRvclNlcnZpY2UucmVuYW1lKGZzLCB3b3Jrc3BhY2VJZCwgbmV3TmFtZSk7XG4gICAgICBhd2FpdCB0aGlzLndvcmtzcGFjZURlc2NyaXB0b3JTZXJ2aWNlLmJ1bXBMYXN0VXBkYXRlZERhdGUoZnMsIHdvcmtzcGFjZUlkKTtcblxuICAgICAgYnJvYWRjYXN0ZXIuYnJvYWRjYXN0KHtcbiAgICAgICAgY2hhbm5lbDogV09SS1NQQUNFU19CUk9BRENBU1RfQ0hBTk5FTCxcbiAgICAgICAgbWVzc2FnZTogYXN5bmMgKCkgPT4gKHsgdHlwZTogXCJXU1NfUkVOQU1FX1dPUktTUEFDRVwiLCB3b3Jrc3BhY2VJZCB9KSxcbiAgICAgIH0pO1xuXG4gICAgICBicm9hZGNhc3Rlci5icm9hZGNhc3Qoe1xuICAgICAgICBjaGFubmVsOiB3b3Jrc3BhY2VJZCxcbiAgICAgICAgbWVzc2FnZTogYXN5bmMgKCkgPT4gKHsgdHlwZTogXCJXU19SRU5BTUVcIiwgd29ya3NwYWNlSWQgfSksXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwcmVwYXJlWmlwKFxuICAgIGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzLFxuICAgIHNjaGVtYTogRnNTY2hlbWEsXG4gICAgd29ya3NwYWNlSWQ6IHN0cmluZyxcbiAgICBvbmx5RXh0ZW5zaW9ucz86IHN0cmluZ1tdXG4gICk6IFByb21pc2U8QmxvYj4ge1xuICAgIGNvbnN0IHd3ZmRzID0gYXdhaXQgdGhpcy5nZXRGaWx0ZXJlZFdvcmtzcGFjZUZpbGVEZXNjcmlwdG9ycyhzY2hlbWEsIHdvcmtzcGFjZUlkKTtcblxuICAgIGNvbnN0IGZpbGVzVG9aaXAgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHd3ZmRzXG4gICAgICAgIC5maWx0ZXIoKHd3ZmQpID0+ICFvbmx5RXh0ZW5zaW9ucyB8fCBvbmx5RXh0ZW5zaW9ucy5pbmNsdWRlcyhleHRyYWN0RXh0ZW5zaW9uKHd3ZmQucmVsYXRpdmVQYXRoKSkpXG4gICAgICAgIC5tYXAoYXN5bmMgKHd3ZmQpID0+ICh7XG4gICAgICAgICAgcmVsYXRpdmVQYXRoOiB3d2ZkLnJlbGF0aXZlUGF0aCxcbiAgICAgICAgICBjb250ZW50OiBhd2FpdCB0aGlzLnN0b3JhZ2VTZXJ2aWNlLmdldEZpbGVDb250ZW50KGZzLCB0aGlzLmdldEFic29sdXRlUGF0aCh3d2ZkKSksXG4gICAgICAgIH0pKVxuICAgICk7XG5cbiAgICBjb25zdCB6aXAgPSBuZXcgSlNaaXAoKTtcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXNUb1ppcCkge1xuICAgICAgemlwLmZpbGUoZmlsZS5yZWxhdGl2ZVBhdGgsIGZpbGUuY29udGVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHppcC5nZW5lcmF0ZUFzeW5jKHsgdHlwZTogXCJibG9iXCIgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgY3JlYXRlT3JPdmVyd3JpdGVGaWxlKFxuICAgIGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzLFxuICAgIGZpbGU6IFdvcmtzcGFjZVdvcmtlckZpbGUsXG4gICAgYnJvYWRjYXN0ZXI6IEJyb2FkY2FzdGVyRGlzcGF0Y2hcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlU2VydmljZS5jcmVhdGVPck92ZXJ3cml0ZUZpbGUoXG4gICAgICBmcyxcbiAgICAgIHRoaXMudG9TdG9yYWdlRmlsZShmaWxlLCBhc3luYyAoKSA9PiBmaWxlLmNvbnRlbnQpXG4gICAgKTtcbiAgICBhd2FpdCB0aGlzLmRlc2NyaXB0b3JzRnNTZXJ2aWNlLndpdGhSZWFkV3JpdGVJbk1lbW9yeUZzKGFzeW5jICh7IGZzIH0pID0+IHtcbiAgICAgIGF3YWl0IHRoaXMud29ya3NwYWNlRGVzY3JpcHRvclNlcnZpY2UuYnVtcExhc3RVcGRhdGVkRGF0ZShmcywgZmlsZS53b3Jrc3BhY2VJZCk7XG4gICAgfSk7XG5cbiAgICBicm9hZGNhc3Rlci5icm9hZGNhc3Qoe1xuICAgICAgY2hhbm5lbDogZmlsZS53b3Jrc3BhY2VJZCxcbiAgICAgIG1lc3NhZ2U6IGFzeW5jICgpID0+ICh7XG4gICAgICAgIHR5cGU6IFwiV1NfQUREX0ZJTEVcIixcbiAgICAgICAgcmVsYXRpdmVQYXRoOiBmaWxlLnJlbGF0aXZlUGF0aCxcbiAgICAgIH0pLFxuICAgIH0pO1xuXG4gICAgYnJvYWRjYXN0ZXIuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IHRoaXMuZ2V0VW5pcXVlRmlsZUlkZW50aWZpZXIoZmlsZSksXG4gICAgICBtZXNzYWdlOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIldTRl9BRERcIixcbiAgICAgICAgcmVsYXRpdmVQYXRoOiBmaWxlLnJlbGF0aXZlUGF0aCxcbiAgICAgIH0pLFxuICAgIH0pO1xuXG4gICAgYnJvYWRjYXN0ZXIuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IFdPUktTUEFDRVNfRklMRVNfQlJPQURDQVNUX0NIQU5ORUwsXG4gICAgICBtZXNzYWdlOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIldTU0ZTX0FERFwiLFxuICAgICAgICB3b3Jrc3BhY2VJZDogZmlsZS53b3Jrc3BhY2VJZCxcbiAgICAgICAgcmVsYXRpdmVQYXRoOiBmaWxlLnJlbGF0aXZlUGF0aCxcbiAgICAgIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldEZpbGUoYXJnczoge1xuICAgIGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzO1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgcmVsYXRpdmVQYXRoOiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPFdvcmtzcGFjZVdvcmtlckZpbGUgfCB1bmRlZmluZWQ+IHtcbiAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSB0aGlzLmdldEFic29sdXRlUGF0aChhcmdzKTtcbiAgICBjb25zdCBzdG9yYWdlRmlsZSA9IGF3YWl0IHRoaXMuc3RvcmFnZVNlcnZpY2UuZ2V0RmlsZShhcmdzLmZzLCBhYnNvbHV0ZVBhdGgpO1xuICAgIGlmICghc3RvcmFnZUZpbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudG9Xb3Jrc3BhY2VGaWxlKGFyZ3Mud29ya3NwYWNlSWQsIHN0b3JhZ2VGaWxlKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB1cGRhdGVGaWxlKFxuICAgIGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzLFxuICAgIHd3ZmQ6IFdvcmtzcGFjZVdvcmtlckZpbGVEZXNjcmlwdG9yLFxuICAgIGdldE5ld0NvbnRlbnRzOiAoKSA9PiBQcm9taXNlPHN0cmluZz4sXG4gICAgYnJvYWRjYXN0ZXI6IEJyb2FkY2FzdGVyRGlzcGF0Y2hcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlU2VydmljZS51cGRhdGVGaWxlKGZzLCB0aGlzLmdldEFic29sdXRlUGF0aCh3d2ZkKSwgKCkgPT5cbiAgICAgIGdldE5ld0NvbnRlbnRzKCkudGhlbigoYykgPT4gZW5jb2Rlci5lbmNvZGUoYykpXG4gICAgKTtcbiAgICBhd2FpdCB0aGlzLmRlc2NyaXB0b3JzRnNTZXJ2aWNlLndpdGhSZWFkV3JpdGVJbk1lbW9yeUZzKGFzeW5jICh7IGZzIH0pID0+IHtcbiAgICAgIGF3YWl0IHRoaXMud29ya3NwYWNlRGVzY3JpcHRvclNlcnZpY2UuYnVtcExhc3RVcGRhdGVkRGF0ZShmcywgd3dmZC53b3Jrc3BhY2VJZCk7XG4gICAgfSk7XG5cbiAgICBicm9hZGNhc3Rlci5icm9hZGNhc3Qoe1xuICAgICAgY2hhbm5lbDogdGhpcy5nZXRVbmlxdWVGaWxlSWRlbnRpZmllcih3d2ZkKSxcbiAgICAgIG1lc3NhZ2U6IGFzeW5jICgpID0+ICh7XG4gICAgICAgIHR5cGU6IFwiV1NGX1VQREFURVwiLFxuICAgICAgICByZWxhdGl2ZVBhdGg6IHd3ZmQucmVsYXRpdmVQYXRoLFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBicm9hZGNhc3Rlci5icm9hZGNhc3Qoe1xuICAgICAgY2hhbm5lbDogd3dmZC53b3Jrc3BhY2VJZCxcbiAgICAgIG1lc3NhZ2U6IGFzeW5jICgpID0+ICh7XG4gICAgICAgIHR5cGU6IFwiV1NfVVBEQVRFX0ZJTEVcIixcbiAgICAgICAgcmVsYXRpdmVQYXRoOiB3d2ZkLnJlbGF0aXZlUGF0aCxcbiAgICAgIH0pLFxuICAgIH0pO1xuXG4gICAgYnJvYWRjYXN0ZXIuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IFdPUktTUEFDRVNfRklMRVNfQlJPQURDQVNUX0NIQU5ORUwsXG4gICAgICBtZXNzYWdlOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIldTU0ZTX1VQREFURVwiLFxuICAgICAgICB3b3Jrc3BhY2VJZDogd3dmZC53b3Jrc3BhY2VJZCxcbiAgICAgICAgcmVsYXRpdmVQYXRoOiB3d2ZkLnJlbGF0aXZlUGF0aCxcbiAgICAgIH0pLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlbGV0ZUZpbGUoXG4gICAgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnMsXG4gICAgd3dmZDogV29ya3NwYWNlV29ya2VyRmlsZURlc2NyaXB0b3IsXG4gICAgYnJvYWRjYXN0ZXI6IEJyb2FkY2FzdGVyRGlzcGF0Y2hcbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5zdG9yYWdlU2VydmljZS5kZWxldGVGaWxlKGZzLCB0aGlzLnRvRXhpc3RpbmdTdG9yYWdlRmlsZShmcywgd3dmZCkucGF0aCk7XG4gICAgYXdhaXQgdGhpcy5kZXNjcmlwdG9yc0ZzU2VydmljZS53aXRoUmVhZFdyaXRlSW5NZW1vcnlGcyhhc3luYyAoeyBmcyB9KSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLndvcmtzcGFjZURlc2NyaXB0b3JTZXJ2aWNlLmJ1bXBMYXN0VXBkYXRlZERhdGUoZnMsIHd3ZmQud29ya3NwYWNlSWQpO1xuICAgIH0pO1xuXG4gICAgYnJvYWRjYXN0ZXIuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IHRoaXMuZ2V0VW5pcXVlRmlsZUlkZW50aWZpZXIod3dmZCksXG4gICAgICBtZXNzYWdlOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIldTRl9ERUxFVEVcIixcbiAgICAgICAgcmVsYXRpdmVQYXRoOiB3d2ZkLnJlbGF0aXZlUGF0aCxcbiAgICAgIH0pLFxuICAgIH0pO1xuXG4gICAgYnJvYWRjYXN0ZXIuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IHd3ZmQud29ya3NwYWNlSWQsXG4gICAgICBtZXNzYWdlOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIldTX0RFTEVURV9GSUxFXCIsXG4gICAgICAgIHJlbGF0aXZlUGF0aDogd3dmZC5yZWxhdGl2ZVBhdGgsXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGJyb2FkY2FzdGVyLmJyb2FkY2FzdCh7XG4gICAgICBjaGFubmVsOiBXT1JLU1BBQ0VTX0ZJTEVTX0JST0FEQ0FTVF9DSEFOTkVMLFxuICAgICAgbWVzc2FnZTogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJXU1NGU19ERUxFVEVcIixcbiAgICAgICAgd29ya3NwYWNlSWQ6IHd3ZmQud29ya3NwYWNlSWQsXG4gICAgICAgIHJlbGF0aXZlUGF0aDogd3dmZC5yZWxhdGl2ZVBhdGgsXG4gICAgICB9KSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyByZW5hbWVGaWxlKGFyZ3M6IHtcbiAgICBmczogS2llU2FuZGJveFdvcmtzcGFjZXNGcztcbiAgICB3d2ZkOiBXb3Jrc3BhY2VXb3JrZXJGaWxlRGVzY3JpcHRvcjtcbiAgICBuZXdGaWxlTmFtZVdpdGhvdXRFeHRlbnNpb246IHN0cmluZztcbiAgICBicm9hZGNhc3RlcjogQnJvYWRjYXN0ZXJEaXNwYXRjaDtcbiAgfSk6IFByb21pc2U8V29ya3NwYWNlV29ya2VyRmlsZURlc2NyaXB0b3I+IHtcbiAgICBjb25zdCByZW5hbWVkU3RvcmFnZUZpbGUgPSBhd2FpdCB0aGlzLnN0b3JhZ2VTZXJ2aWNlLnJlbmFtZUZpbGUoXG4gICAgICBhcmdzLmZzLFxuICAgICAgdGhpcy50b0V4aXN0aW5nU3RvcmFnZUZpbGUoYXJncy5mcywgYXJncy53d2ZkKSxcbiAgICAgIGFyZ3MubmV3RmlsZU5hbWVXaXRob3V0RXh0ZW5zaW9uXG4gICAgKTtcbiAgICBjb25zdCByZW5hbWVkV29ya3NwYWNlRmlsZSA9IGF3YWl0IHRoaXMudG9Xb3Jrc3BhY2VGaWxlKGFyZ3Mud3dmZC53b3Jrc3BhY2VJZCwgcmVuYW1lZFN0b3JhZ2VGaWxlKTtcblxuICAgIGF3YWl0IHRoaXMuZGVzY3JpcHRvcnNGc1NlcnZpY2Uud2l0aFJlYWRXcml0ZUluTWVtb3J5RnMoYXN5bmMgKHsgZnMgfSkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy53b3Jrc3BhY2VEZXNjcmlwdG9yU2VydmljZS5idW1wTGFzdFVwZGF0ZWREYXRlKGZzLCBhcmdzLnd3ZmQud29ya3NwYWNlSWQpO1xuICAgIH0pO1xuXG4gICAgYXJncy5icm9hZGNhc3Rlci5icm9hZGNhc3Qoe1xuICAgICAgY2hhbm5lbDogdGhpcy5nZXRVbmlxdWVGaWxlSWRlbnRpZmllcihhcmdzLnd3ZmQpLFxuICAgICAgbWVzc2FnZTogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJXU0ZfUkVOQU1FXCIsXG4gICAgICAgIG9sZFJlbGF0aXZlUGF0aDogYXJncy53d2ZkLnJlbGF0aXZlUGF0aCxcbiAgICAgICAgbmV3UmVsYXRpdmVQYXRoOiByZW5hbWVkV29ya3NwYWNlRmlsZS5yZWxhdGl2ZVBhdGgsXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGFyZ3MuYnJvYWRjYXN0ZXIuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IHRoaXMuZ2V0VW5pcXVlRmlsZUlkZW50aWZpZXIocmVuYW1lZFdvcmtzcGFjZUZpbGUpLFxuICAgICAgbWVzc2FnZTogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJXU0ZfQUREXCIsXG4gICAgICAgIHJlbGF0aXZlUGF0aDogcmVuYW1lZFdvcmtzcGFjZUZpbGUucmVsYXRpdmVQYXRoLFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBhcmdzLmJyb2FkY2FzdGVyLmJyb2FkY2FzdCh7XG4gICAgICBjaGFubmVsOiBhcmdzLnd3ZmQud29ya3NwYWNlSWQsXG4gICAgICBtZXNzYWdlOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIldTX1JFTkFNRV9GSUxFXCIsXG4gICAgICAgIG9sZFJlbGF0aXZlUGF0aDogYXJncy53d2ZkLnJlbGF0aXZlUGF0aCxcbiAgICAgICAgbmV3UmVsYXRpdmVQYXRoOiByZW5hbWVkV29ya3NwYWNlRmlsZS5yZWxhdGl2ZVBhdGgsXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGFyZ3MuYnJvYWRjYXN0ZXIuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IFdPUktTUEFDRVNfRklMRVNfQlJPQURDQVNUX0NIQU5ORUwsXG4gICAgICBtZXNzYWdlOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICB0eXBlOiBcIldTU0ZTX1JFTkFNRVwiLFxuICAgICAgICB3b3Jrc3BhY2VJZDogYXJncy53d2ZkLndvcmtzcGFjZUlkLFxuICAgICAgICBvbGRSZWxhdGl2ZVBhdGg6IGFyZ3Mud3dmZC5yZWxhdGl2ZVBhdGgsXG4gICAgICAgIG5ld1JlbGF0aXZlUGF0aDogcmVuYW1lZFdvcmtzcGFjZUZpbGUucmVsYXRpdmVQYXRoLFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBhcmdzLmJyb2FkY2FzdGVyLmJyb2FkY2FzdCh7XG4gICAgICBjaGFubmVsOiBXT1JLU1BBQ0VTX0ZJTEVTX0JST0FEQ0FTVF9DSEFOTkVMLFxuICAgICAgbWVzc2FnZTogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJXU1NGU19BRERcIixcbiAgICAgICAgd29ya3NwYWNlSWQ6IGFyZ3Mud3dmZC53b3Jrc3BhY2VJZCxcbiAgICAgICAgcmVsYXRpdmVQYXRoOiByZW5hbWVkV29ya3NwYWNlRmlsZS5yZWxhdGl2ZVBhdGgsXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIHJldHVybiByZW5hbWVkV29ya3NwYWNlRmlsZTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBtb3ZlRmlsZShhcmdzOiB7XG4gICAgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnM7XG4gICAgd3dmZDogV29ya3NwYWNlV29ya2VyRmlsZURlc2NyaXB0b3I7XG4gICAgbmV3RGlyUGF0aDogc3RyaW5nO1xuICAgIGJyb2FkY2FzdGVyOiBCcm9hZGNhc3RlckRpc3BhdGNoO1xuICB9KTogUHJvbWlzZTxXb3Jrc3BhY2VXb3JrZXJGaWxlPiB7XG4gICAgY29uc3QgbW92ZWRTdG9yYWdlRmlsZSA9IGF3YWl0IHRoaXMuc3RvcmFnZVNlcnZpY2UubW92ZUZpbGUoXG4gICAgICBhcmdzLmZzLFxuICAgICAgdGhpcy50b0V4aXN0aW5nU3RvcmFnZUZpbGUoYXJncy5mcywgYXJncy53d2ZkKSxcbiAgICAgIHRoaXMuZ2V0QWJzb2x1dGVQYXRoKHsgd29ya3NwYWNlSWQ6IGFyZ3Mud3dmZC53b3Jrc3BhY2VJZCwgcmVsYXRpdmVQYXRoOiBhcmdzLm5ld0RpclBhdGggfSlcbiAgICApO1xuICAgIGNvbnN0IG1vdmVkV29ya3NwYWNlRmlsZSA9IGF3YWl0IHRoaXMudG9Xb3Jrc3BhY2VGaWxlKGFyZ3Mud3dmZC53b3Jrc3BhY2VJZCwgbW92ZWRTdG9yYWdlRmlsZSk7XG5cbiAgICBhd2FpdCB0aGlzLmRlc2NyaXB0b3JzRnNTZXJ2aWNlLndpdGhSZWFkV3JpdGVJbk1lbW9yeUZzKGFzeW5jICh7IGZzIH0pID0+IHtcbiAgICAgIGF3YWl0IHRoaXMud29ya3NwYWNlRGVzY3JpcHRvclNlcnZpY2UuYnVtcExhc3RVcGRhdGVkRGF0ZShmcywgYXJncy53d2ZkLndvcmtzcGFjZUlkKTtcbiAgICB9KTtcblxuICAgIGFyZ3MuYnJvYWRjYXN0ZXIuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IHRoaXMuZ2V0VW5pcXVlRmlsZUlkZW50aWZpZXIoYXJncy53d2ZkKSxcbiAgICAgIG1lc3NhZ2U6IGFzeW5jICgpID0+ICh7XG4gICAgICAgIHR5cGU6IFwiV1NGX01PVkVcIixcbiAgICAgICAgb2xkUmVsYXRpdmVQYXRoOiBhcmdzLnd3ZmQucmVsYXRpdmVQYXRoLFxuICAgICAgICBuZXdSZWxhdGl2ZVBhdGg6IG1vdmVkV29ya3NwYWNlRmlsZS5yZWxhdGl2ZVBhdGgsXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGFyZ3MuYnJvYWRjYXN0ZXIuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IHRoaXMuZ2V0VW5pcXVlRmlsZUlkZW50aWZpZXIobW92ZWRXb3Jrc3BhY2VGaWxlKSxcbiAgICAgIG1lc3NhZ2U6IGFzeW5jICgpID0+ICh7XG4gICAgICAgIHR5cGU6IFwiV1NGX0FERFwiLFxuICAgICAgICByZWxhdGl2ZVBhdGg6IG1vdmVkV29ya3NwYWNlRmlsZS5yZWxhdGl2ZVBhdGgsXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGFyZ3MuYnJvYWRjYXN0ZXIuYnJvYWRjYXN0KHtcbiAgICAgIGNoYW5uZWw6IGFyZ3Mud3dmZC53b3Jrc3BhY2VJZCxcbiAgICAgIG1lc3NhZ2U6IGFzeW5jICgpID0+ICh7XG4gICAgICAgIHR5cGU6IFwiV1NfTU9WRV9GSUxFXCIsXG4gICAgICAgIG9sZFJlbGF0aXZlUGF0aDogYXJncy53d2ZkLnJlbGF0aXZlUGF0aCxcbiAgICAgICAgbmV3UmVsYXRpdmVQYXRoOiBtb3ZlZFdvcmtzcGFjZUZpbGUucmVsYXRpdmVQYXRoLFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBhcmdzLmJyb2FkY2FzdGVyLmJyb2FkY2FzdCh7XG4gICAgICBjaGFubmVsOiBXT1JLU1BBQ0VTX0ZJTEVTX0JST0FEQ0FTVF9DSEFOTkVMLFxuICAgICAgbWVzc2FnZTogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJXU1NGU19NT1ZFXCIsXG4gICAgICAgIHdvcmtzcGFjZUlkOiBhcmdzLnd3ZmQud29ya3NwYWNlSWQsXG4gICAgICAgIG9sZFJlbGF0aXZlUGF0aDogYXJncy53d2ZkLnJlbGF0aXZlUGF0aCxcbiAgICAgICAgbmV3UmVsYXRpdmVQYXRoOiBtb3ZlZFdvcmtzcGFjZUZpbGUucmVsYXRpdmVQYXRoLFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBhcmdzLmJyb2FkY2FzdGVyLmJyb2FkY2FzdCh7XG4gICAgICBjaGFubmVsOiBXT1JLU1BBQ0VTX0ZJTEVTX0JST0FEQ0FTVF9DSEFOTkVMLFxuICAgICAgbWVzc2FnZTogYXN5bmMgKCkgPT4gKHtcbiAgICAgICAgdHlwZTogXCJXU1NGU19BRERcIixcbiAgICAgICAgd29ya3NwYWNlSWQ6IGFyZ3Mud3dmZC53b3Jrc3BhY2VJZCxcbiAgICAgICAgcmVsYXRpdmVQYXRoOiBtb3ZlZFdvcmtzcGFjZUZpbGUucmVsYXRpdmVQYXRoLFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbW92ZWRXb3Jrc3BhY2VGaWxlO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGV4aXN0c0ZpbGUoYXJnczoge1xuICAgIGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzO1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgcmVsYXRpdmVQYXRoOiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlU2VydmljZS5leGlzdHMoYXJncy5mcywgdGhpcy5nZXRBYnNvbHV0ZVBhdGgoYXJncykpO1xuICB9XG5cbiAgcHVibGljIGdldEFic29sdXRlUGF0aChhcmdzOiB7IHdvcmtzcGFjZUlkOiBzdHJpbmc7IHJlbGF0aXZlUGF0aD86IHN0cmluZyB9KSB7XG4gICAgcmV0dXJuIGpvaW4oXCIvXCIsIHRoaXMuZnNTZXJ2aWNlLmdldEZzTW91bnRQb2ludChhcmdzLndvcmtzcGFjZUlkKSwgYXJncy5yZWxhdGl2ZVBhdGggPz8gXCJcIik7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgdG9Xb3Jrc3BhY2VGaWxlKHdvcmtzcGFjZUlkOiBzdHJpbmcsIHN0b3JhZ2VGaWxlOiBTdG9yYWdlRmlsZSk6IFByb21pc2U8V29ya3NwYWNlV29ya2VyRmlsZT4ge1xuICAgIHJldHVybiB7XG4gICAgICB3b3Jrc3BhY2VJZCxcbiAgICAgIGNvbnRlbnQ6IGF3YWl0IHN0b3JhZ2VGaWxlLmdldEZpbGVDb250ZW50cygpLFxuICAgICAgcmVsYXRpdmVQYXRoOiByZWxhdGl2ZSh0aGlzLmdldEFic29sdXRlUGF0aCh7IHdvcmtzcGFjZUlkIH0pLCBzdG9yYWdlRmlsZS5wYXRoKSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSB0b1N0b3JhZ2VGaWxlKHd3ZmQ6IFdvcmtzcGFjZVdvcmtlckZpbGVEZXNjcmlwdG9yLCBnZXRGaWxlQ29udGVudHM6ICgpID0+IFByb21pc2U8VWludDhBcnJheT4pOiBTdG9yYWdlRmlsZSB7XG4gICAgcmV0dXJuIG5ldyBTdG9yYWdlRmlsZSh7XG4gICAgICBwYXRoOiB0aGlzLmdldEFic29sdXRlUGF0aCh3d2ZkKSxcbiAgICAgIGdldEZpbGVDb250ZW50cyxcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgdG9FeGlzdGluZ1N0b3JhZ2VGaWxlKGZzOiBLaWVTYW5kYm94V29ya3NwYWNlc0ZzLCB3d2ZkOiBXb3Jrc3BhY2VXb3JrZXJGaWxlRGVzY3JpcHRvcik6IFN0b3JhZ2VGaWxlIHtcbiAgICByZXR1cm4gdGhpcy50b1N0b3JhZ2VGaWxlKHd3ZmQsIGFzeW5jICgpID0+IHRoaXMuc3RvcmFnZVNlcnZpY2UuZ2V0RmlsZUNvbnRlbnQoZnMsIHRoaXMuZ2V0QWJzb2x1dGVQYXRoKHd3ZmQpKSk7XG4gIH1cblxuICBwdWJsaWMgZ2V0VW5pcXVlRmlsZUlkZW50aWZpZXIoYXJnczogeyB3b3Jrc3BhY2VJZDogc3RyaW5nOyByZWxhdGl2ZVBhdGg6IHN0cmluZyB9KSB7XG4gICAgcmV0dXJuIGAke2FyZ3Mud29ya3NwYWNlSWR9X18ke3RoaXMuZ2V0QWJzb2x1dGVQYXRoKGFyZ3MpfWA7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICBSZXNvdXJjZUxpc3RPcHRpb25zLFxuICBSZXNvdXJjZXNMaXN0LFxuICBSZXNvdXJjZUNvbnRlbnRPcHRpb25zLFxuICBSZXNvdXJjZUNvbnRlbnQsXG4gIENvbnRlbnRUeXBlLFxufSBmcm9tIFwiQGtpZS10b29scy1jb3JlL3dvcmtzcGFjZS9kaXN0L2FwaVwiO1xuaW1wb3J0IHsgam9pbiB9IGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgeyBHSVRfREVGQVVMVF9CUkFOQ0ggfSBmcm9tIFwiLi4vY29uc3RhbnRzL0dpdENvbnN0YW50c1wiO1xuaW1wb3J0IHsgZGVjb2RlciwgZW5jb2RlciB9IGZyb20gXCIuLi9lbmNvZGVyZGVjb2Rlci9FbmNvZGVyRGVjb2RlclwiO1xuaW1wb3J0IHsgRnNTY2hlbWEgfSBmcm9tIFwiLi4vc2VydmljZXMvRnNDYWNoZVwiO1xuaW1wb3J0IHsgS2llU2FuZGJveFdvcmtzcGFjZXNGcyB9IGZyb20gXCIuLi9zZXJ2aWNlcy9LaWVTYW5kYm94V29ya3NwYWNlRnNcIjtcbmltcG9ydCB7IFN0b3JhZ2VGaWxlIH0gZnJvbSBcIi4uL3NlcnZpY2VzL1N0b3JhZ2VTZXJ2aWNlXCI7XG5pbXBvcnQgeyBHaXRTZXJ2ZXJSZWYgfSBmcm9tIFwiLi9hcGkvR2l0U2VydmVyUmVmXCI7XG5pbXBvcnQgeyBMb2NhbEZpbGUgfSBmcm9tIFwiLi9hcGkvTG9jYWxGaWxlXCI7XG5pbXBvcnQgeyBXb3Jrc3BhY2VEZXNjcmlwdG9yIH0gZnJvbSBcIi4vYXBpL1dvcmtzcGFjZURlc2NyaXB0b3JcIjtcbmltcG9ydCB7XG4gIEJpdGJ1Y2tldE9yaWdpbixcbiAgR2lzdE9yaWdpbixcbiAgR2l0SHViT3JpZ2luLFxuICBTbmlwcGV0T3JpZ2luLFxuICBXb3Jrc3BhY2VLaW5kLFxuICBXb3Jrc3BhY2VPcmlnaW4sXG59IGZyb20gXCIuL2FwaS9Xb3Jrc3BhY2VPcmlnaW5cIjtcbmltcG9ydCB7IFdvcmtzcGFjZXNXb3JrZXJBcGkgfSBmcm9tIFwiLi9hcGkvV29ya3NwYWNlc1dvcmtlckFwaVwiO1xuaW1wb3J0IHsgV29ya3NwYWNlV29ya2VyRmlsZSB9IGZyb20gXCIuL2FwaS9Xb3Jrc3BhY2VXb3JrZXJGaWxlXCI7XG5pbXBvcnQgeyBXb3Jrc3BhY2VXb3JrZXJGaWxlRGVzY3JpcHRvciB9IGZyb20gXCIuL2FwaS9Xb3Jrc3BhY2VXb3JrZXJGaWxlRGVzY3JpcHRvclwiO1xuaW1wb3J0IHsgV29ya3NwYWNlU2VydmljZXMgfSBmcm9tIFwiLi9jcmVhdGVXb3Jrc3BhY2VTZXJ2aWNlc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVGaWx0ZXIge1xuICAvLyBGaWxlcyB3aXRoIHRoZSBoaWdoZXN0IHByaW9yaXR5XG4gIGlzTW9kZWw6IChwYXRoOiBzdHJpbmcpID0+IGJvb2xlYW47XG4gIC8vIEFueSBzdXBwb3J0ZWQgZmlsZSB0aGF0IGlzIGVkaXRhYmxlXG4gIGlzRWRpdGFibGU6IChwYXRoOiBzdHJpbmcpID0+IGJvb2xlYW47XG4gIC8vIEFueSBzdXBwb3J0ZWQgZmlsZSBpbmNsdWRpbmcgZWRpdGFibGUgYW5kIHJlYWRvbmx5IG9uZXNcbiAgaXNTdXBwb3J0ZWQ6IChwYXRoOiBzdHJpbmcpID0+IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBXb3Jrc3BhY2VzV29ya2VyQXBpSW1wbCBpbXBsZW1lbnRzIFdvcmtzcGFjZXNXb3JrZXJBcGkge1xuICBwcml2YXRlIHJlYWRvbmx5IE1BWF9ORVdfRklMRV9JTkRFWF9BVFRFTVBUUyA9IDEwO1xuICBwcml2YXRlIHJlYWRvbmx5IE5FV19GSUxFX0RFRkFVTFRfTkFNRSA9IFwiVW50aXRsZWRcIjtcbiAgcHJpdmF0ZSByZWFkb25seSBHSVRfREVGQVVMVF9VU0VSID0ge1xuICAgIG5hbWU6IHRoaXMuYXJncy5hcHBOYW1lLFxuICAgIGVtYWlsOiBcIlwiLFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXJnczoge1xuICAgICAgYXBwTmFtZTogc3RyaW5nO1xuICAgICAgZmlsZUZpbHRlcjogRmlsZUZpbHRlcjtcbiAgICAgIHNlcnZpY2VzOiBXb3Jrc3BhY2VTZXJ2aWNlcztcbiAgICB9XG4gICkge31cblxuICBwdWJsaWMgYXN5bmMga2llU2FuZGJveFdvcmtzcGFjZXNHaXRfY2hhbmdlR2l0QXV0aFNlc3Npb25JZChhcmdzOiB7XG4gICAgd29ya3NwYWNlSWQ6IHN0cmluZztcbiAgICBnaXRBdXRoU2Vzc2lvbklkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLnNlcnZpY2VzLmRlc2NyaXB0b3JzRnNTZXJ2aWNlLndpdGhSZWFkV3JpdGVJbk1lbW9yeUZzKCh7IGZzIH0pID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMuZGVzY3JpcHRvclNlcnZpY2UuY2hhbmdlR2l0QXV0aFNlc3Npb25JZChmcywgYXJncy53b3Jrc3BhY2VJZCwgYXJncy5naXRBdXRoU2Vzc2lvbklkKTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBraWVTYW5kYm94V29ya3NwYWNlc0dpdF9pbml0R2lzdE9uRXhpc3RpbmdXb3Jrc3BhY2UoYXJnczoge1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgcmVtb3RlVXJsOiBzdHJpbmc7XG4gICAgYnJhbmNoOiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLnNlcnZpY2VzLmRlc2NyaXB0b3JzRnNTZXJ2aWNlLndpdGhSZWFkV3JpdGVJbk1lbW9yeUZzKCh7IGZzIH0pID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMuZGVzY3JpcHRvclNlcnZpY2UudHVybkludG9HaXN0KFxuICAgICAgICBmcyxcbiAgICAgICAgYXJncy53b3Jrc3BhY2VJZCxcbiAgICAgICAgbmV3IFVSTChhcmdzLnJlbW90ZVVybCksXG4gICAgICAgIGFyZ3MuYnJhbmNoXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtpZVNhbmRib3hXb3Jrc3BhY2VzR2l0X2luaXRTbmlwcGV0T25FeGlzdGluZ1dvcmtzcGFjZShhcmdzOiB7XG4gICAgd29ya3NwYWNlSWQ6IHN0cmluZztcbiAgICByZW1vdGVVcmw6IHN0cmluZztcbiAgICBicmFuY2g6IHN0cmluZztcbiAgfSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMuZGVzY3JpcHRvcnNGc1NlcnZpY2Uud2l0aFJlYWRXcml0ZUluTWVtb3J5RnMoKHsgZnMgfSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy5kZXNjcmlwdG9yU2VydmljZS50dXJuSW50b1NuaXBwZXQoXG4gICAgICAgIGZzLFxuICAgICAgICBhcmdzLndvcmtzcGFjZUlkLFxuICAgICAgICBuZXcgVVJMKGFyZ3MucmVtb3RlVXJsKSxcbiAgICAgICAgYXJncy5icmFuY2hcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2llU2FuZGJveFdvcmtzcGFjZXNHaXRfaW5pdEdpdE9uRXhpc3RpbmdXb3Jrc3BhY2UoYXJnczoge1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgcmVtb3RlVXJsOiBzdHJpbmc7XG4gICAgYnJhbmNoPzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy5kZXNjcmlwdG9yc0ZzU2VydmljZS53aXRoUmVhZFdyaXRlSW5NZW1vcnlGcygoeyBmcyB9KSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5hcmdzLnNlcnZpY2VzLmRlc2NyaXB0b3JTZXJ2aWNlLnR1cm5JbnRvR2l0KFxuICAgICAgICBmcyxcbiAgICAgICAgYXJncy53b3Jrc3BhY2VJZCxcbiAgICAgICAgbmV3IFVSTChhcmdzLnJlbW90ZVVybCksXG4gICAgICAgIGFyZ3MuYnJhbmNoXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtpZVNhbmRib3hXb3Jrc3BhY2VzR2l0X2luaXRMb2NhbE9uRXhpc3RpbmdXb3Jrc3BhY2UoYXJnczogeyB3b3Jrc3BhY2VJZDogc3RyaW5nIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLnNlcnZpY2VzLmRlc2NyaXB0b3JzRnNTZXJ2aWNlLndpdGhSZWFkV3JpdGVJbk1lbW9yeUZzKCh7IGZzIH0pID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMuZGVzY3JpcHRvclNlcnZpY2UudHVybkludG9Mb2NhbChmcywgYXJncy53b3Jrc3BhY2VJZCk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2llU2FuZGJveFdvcmtzcGFjZXNTdG9yYWdlX2dldFdvcmtzcGFjZShhcmdzOiB7IHdvcmtzcGFjZUlkOiBzdHJpbmcgfSk6IFByb21pc2U8V29ya3NwYWNlRGVzY3JpcHRvcj4ge1xuICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMuZGVzY3JpcHRvcnNGc1NlcnZpY2Uud2l0aFJlYWRvbmx5SW5NZW1vcnlGcygoeyBmcyB9KSA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5hcmdzLnNlcnZpY2VzLmRlc2NyaXB0b3JTZXJ2aWNlLmdldChmcywgYXJncy53b3Jrc3BhY2VJZCk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2llU2FuZGJveFdvcmtzcGFjZXNTdG9yYWdlX2xpc3RBbGxXb3Jrc3BhY2VzKCk6IFByb21pc2U8V29ya3NwYWNlRGVzY3JpcHRvcltdPiB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy5kZXNjcmlwdG9yc0ZzU2VydmljZS53aXRoUmVhZG9ubHlJbk1lbW9yeUZzKCh7IGZzLCBzY2hlbWEgfSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy5kZXNjcmlwdG9yU2VydmljZS5saXN0QWxsKGZzLCBzY2hlbWEpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtpZVNhbmRib3hXb3Jrc3BhY2VzU3RvcmFnZV9yZXNvdXJjZUNvbnRlbnRHZXQoYXJnczoge1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgcmVsYXRpdmVQYXRoOiBzdHJpbmc7XG4gICAgb3B0cz86IFJlc291cmNlQ29udGVudE9wdGlvbnM7XG4gIH0pOiBQcm9taXNlPFJlc291cmNlQ29udGVudCB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlRnNTZXJ2aWNlLndpdGhSZWFkb25seUluTWVtb3J5RnMoYXJncy53b3Jrc3BhY2VJZCwgYXN5bmMgKHsgZnMgfSkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VTZXJ2aWNlLmdldEZpbGUoe1xuICAgICAgICBmczogZnMsXG4gICAgICAgIHdvcmtzcGFjZUlkOiBhcmdzLndvcmtzcGFjZUlkLFxuICAgICAgICByZWxhdGl2ZVBhdGg6IGFyZ3MucmVsYXRpdmVQYXRoLFxuICAgICAgfSk7XG5cbiAgICAgIGlmICghZmlsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpbGUgJyR7YXJncy5yZWxhdGl2ZVBhdGh9JyBub3QgZm91bmQgaW4gV29ya3NwYWNlICR7YXJncy53b3Jrc3BhY2VJZH1gKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGFyZ3Mub3B0cz8udHlwZSA9PT0gXCJiaW5hcnlcIikge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VDb250ZW50KFxuICAgICAgICAgICAgYXJncy5yZWxhdGl2ZVBhdGgsXG4gICAgICAgICAgICBmaWxlLmNvbnRlbnQgPyBCdWZmZXIuZnJvbShmaWxlLmNvbnRlbnQpLnRvU3RyaW5nKFwiYmFzZTY0XCIpIDogXCJcIixcbiAgICAgICAgICAgIENvbnRlbnRUeXBlLkJJTkFSWVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBcInRleHRcIiBpcyB0aGUgZGVmYXVsdFxuICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlQ29udGVudChhcmdzLnJlbGF0aXZlUGF0aCwgZGVjb2Rlci5kZWNvZGUoZmlsZS5jb250ZW50KSwgQ29udGVudFR5cGUuVEVYVCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2llU2FuZGJveFdvcmtzcGFjZXNTdG9yYWdlX3Jlc291cmNlQ29udGVudExpc3QoYXJnczoge1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgZ2xvYlBhdHRlcm46IHN0cmluZztcbiAgICBvcHRzPzogUmVzb3VyY2VMaXN0T3B0aW9ucztcbiAgfSk6IFByb21pc2U8UmVzb3VyY2VzTGlzdD4ge1xuICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlRnNTZXJ2aWNlLndpdGhSZWFkb25seUZzU2NoZW1hKGFyZ3Mud29ya3NwYWNlSWQsIGFzeW5jICh7IHNjaGVtYSB9KSA9PiB7XG4gICAgICBjb25zdCBmaWxlcyA9IGF3YWl0IHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VTZXJ2aWNlLmdldEZpbHRlcmVkV29ya3NwYWNlRmlsZURlc2NyaXB0b3JzKFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGFyZ3Mud29ya3NwYWNlSWQsXG4gICAgICAgIGFyZ3MuZ2xvYlBhdHRlcm5cbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IFJlc291cmNlc0xpc3QoXG4gICAgICAgIGFyZ3MuZ2xvYlBhdHRlcm4sXG4gICAgICAgIGZpbGVzLm1hcCgoZmlsZSkgPT4gZmlsZS5yZWxhdGl2ZVBhdGgpXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtpZVNhbmRib3hXb3Jrc3BhY2VzU3RvcmFnZV9hZGRFbXB0eUZpbGUoYXJnczoge1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgZGVzdGluYXRpb25EaXJSZWxhdGl2ZVBhdGg6IHN0cmluZztcbiAgICBleHRlbnNpb246IHN0cmluZztcbiAgfSk6IFByb21pc2U8V29ya3NwYWNlV29ya2VyRmlsZURlc2NyaXB0b3I+IHtcbiAgICByZXR1cm4gdGhpcy5raWVTYW5kYm94V29ya3NwYWNlc1N0b3JhZ2VfYWRkRmlsZSh7IC4uLmFyZ3MsIG5hbWU6IHRoaXMuTkVXX0ZJTEVfREVGQVVMVF9OQU1FLCBjb250ZW50OiBcIlwiIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtpZVNhbmRib3hXb3Jrc3BhY2VzU3RvcmFnZV9hZGRGaWxlKGFyZ3M6IHtcbiAgICB3b3Jrc3BhY2VJZDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBkZXN0aW5hdGlvbkRpclJlbGF0aXZlUGF0aDogc3RyaW5nO1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICBleHRlbnNpb246IHN0cmluZztcbiAgfSk6IFByb21pc2U8V29ya3NwYWNlV29ya2VyRmlsZT4ge1xuICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlRnNTZXJ2aWNlLndpdGhSZWFkV3JpdGVJbk1lbW9yeUZzKFxuICAgICAgYXJncy53b3Jrc3BhY2VJZCxcbiAgICAgIGFzeW5jICh7IGZzLCBicm9hZGNhc3RlciB9KSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5NQVhfTkVXX0ZJTEVfSU5ERVhfQVRURU1QVFM7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gaSA9PT0gMCA/IFwiXCIgOiBgLSR7aX1gO1xuICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7YXJncy5uYW1lfSR7aW5kZXh9LiR7YXJncy5leHRlbnNpb259YDtcbiAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBqb2luKGFyZ3MuZGVzdGluYXRpb25EaXJSZWxhdGl2ZVBhdGgsIGZpbGVOYW1lKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlU2VydmljZS5leGlzdHNGaWxlKHsgZnMsIHdvcmtzcGFjZUlkOiBhcmdzLndvcmtzcGFjZUlkLCByZWxhdGl2ZVBhdGggfSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG5ld0ZpbGU6IFdvcmtzcGFjZVdvcmtlckZpbGUgPSB7XG4gICAgICAgICAgICB3b3Jrc3BhY2VJZDogYXJncy53b3Jrc3BhY2VJZCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGVuY29kZXIuZW5jb2RlKGFyZ3MuY29udGVudCksXG4gICAgICAgICAgICByZWxhdGl2ZVBhdGgsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBhd2FpdCB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlU2VydmljZS5jcmVhdGVPck92ZXJ3cml0ZUZpbGUoZnMsIG5ld0ZpbGUsIGJyb2FkY2FzdGVyKTtcbiAgICAgICAgICByZXR1cm4gbmV3RmlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1heCBhdHRlbXB0cyBvZiBuZXcgZW1wdHkgZmlsZSBleGNlZWRlZC5cIik7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBraWVTYW5kYm94V29ya3NwYWNlc1N0b3JhZ2VfZGVsZXRlRmlsZShhcmdzOiB7IHd3ZmQ6IFdvcmtzcGFjZVdvcmtlckZpbGVEZXNjcmlwdG9yIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZUZzU2VydmljZS53aXRoUmVhZFdyaXRlSW5NZW1vcnlGcyhcbiAgICAgIGFyZ3Mud3dmZC53b3Jrc3BhY2VJZCxcbiAgICAgIGFzeW5jICh7IGZzLCBicm9hZGNhc3RlciB9KSA9PiB7XG4gICAgICAgIGF3YWl0IHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VTZXJ2aWNlLmRlbGV0ZUZpbGUoZnMsIGFyZ3Mud3dmZCwgYnJvYWRjYXN0ZXIpO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2llU2FuZGJveFdvcmtzcGFjZXNTdG9yYWdlX21vdmVGaWxlKGFyZ3M6IHtcbiAgICB3d2ZkOiBXb3Jrc3BhY2VXb3JrZXJGaWxlRGVzY3JpcHRvcjtcbiAgICBuZXdEaXJQYXRoOiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPFdvcmtzcGFjZVdvcmtlckZpbGVEZXNjcmlwdG9yPiB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VGc1NlcnZpY2Uud2l0aFJlYWRXcml0ZUluTWVtb3J5RnMoXG4gICAgICBhcmdzLnd3ZmQud29ya3NwYWNlSWQsXG4gICAgICBhc3luYyAoeyBmcywgYnJvYWRjYXN0ZXIgfSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZVNlcnZpY2UubW92ZUZpbGUoe1xuICAgICAgICAgIGZzLFxuICAgICAgICAgIHd3ZmQ6IGFyZ3Mud3dmZCxcbiAgICAgICAgICBuZXdEaXJQYXRoOiBhcmdzLm5ld0RpclBhdGgsXG4gICAgICAgICAgYnJvYWRjYXN0ZXIsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2llU2FuZGJveFdvcmtzcGFjZXNTdG9yYWdlX2RlbGV0ZVdvcmtzcGFjZShhcmdzOiB7IHdvcmtzcGFjZUlkOiBzdHJpbmcgfSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGF3YWl0IHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VTZXJ2aWNlLmRlbGV0ZShhcmdzLndvcmtzcGFjZUlkKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBraWVTYW5kYm94V29ya3NwYWNlc1N0b3JhZ2VfZXhpc3RzRmlsZShhcmdzOiB7XG4gICAgd29ya3NwYWNlSWQ6IHN0cmluZztcbiAgICByZWxhdGl2ZVBhdGg6IHN0cmluZztcbiAgfSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlRnNTZXJ2aWNlLndpdGhSZWFkb25seUZzU2NoZW1hKGFyZ3Mud29ya3NwYWNlSWQsIGFzeW5jICh7IHNjaGVtYSB9KSA9PiB7XG4gICAgICByZXR1cm4gISFzY2hlbWEuZ2V0KHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VTZXJ2aWNlLmdldEFic29sdXRlUGF0aChhcmdzKSk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMga2llU2FuZGJveFdvcmtzcGFjZXNTdG9yYWdlX2dldEZpbGUoYXJnczoge1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgcmVsYXRpdmVQYXRoOiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPFdvcmtzcGFjZVdvcmtlckZpbGVEZXNjcmlwdG9yIHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VGc1NlcnZpY2Uud2l0aFJlYWRvbmx5RnNTY2hlbWEoYXJncy53b3Jrc3BhY2VJZCwgYXN5bmMgKHsgc2NoZW1hIH0pID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHNjaGVtYS5nZXQodGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZVNlcnZpY2UuZ2V0QWJzb2x1dGVQYXRoKGFyZ3MpKSAmJiB7XG4gICAgICAgICAgd29ya3NwYWNlSWQ6IGFyZ3Mud29ya3NwYWNlSWQsXG4gICAgICAgICAgcmVsYXRpdmVQYXRoOiBhcmdzLnJlbGF0aXZlUGF0aCxcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBraWVTYW5kYm94V29ya3NwYWNlc1N0b3JhZ2VfZ2V0RmlsZUNvbnRlbnQoYXJnczoge1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgcmVsYXRpdmVQYXRoOiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPFVpbnQ4QXJyYXk+IHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZUZzU2VydmljZS53aXRoUmVhZG9ubHlJbk1lbW9yeUZzKGFyZ3Mud29ya3NwYWNlSWQsIGFzeW5jICh7IGZzIH0pID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMuc3RvcmFnZVNlcnZpY2UuZ2V0RmlsZUNvbnRlbnQoXG4gICAgICAgIGZzLFxuICAgICAgICB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlU2VydmljZS5nZXRBYnNvbHV0ZVBhdGgoYXJncylcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMga2llU2FuZGJveFdvcmtzcGFjZXNTdG9yYWdlX2dldEZpbGVzKGFyZ3M6IHtcbiAgICB3b3Jrc3BhY2VJZDogc3RyaW5nO1xuICAgIGdsb2JQYXR0ZXJuPzogc3RyaW5nO1xuICB9KTogUHJvbWlzZTxXb3Jrc3BhY2VXb3JrZXJGaWxlRGVzY3JpcHRvcltdPiB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VGc1NlcnZpY2Uud2l0aFJlYWRvbmx5RnNTY2hlbWEoYXJncy53b3Jrc3BhY2VJZCwgYXN5bmMgKHsgc2NoZW1hIH0pID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlU2VydmljZS5nZXRGaWx0ZXJlZFdvcmtzcGFjZUZpbGVEZXNjcmlwdG9ycyhcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBhcmdzLndvcmtzcGFjZUlkLFxuICAgICAgICBhcmdzLmdsb2JQYXR0ZXJuXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtpZVNhbmRib3hXb3Jrc3BhY2VzU3RvcmFnZV9nZXRVbmlxdWVGaWxlSWRlbnRpZmllcihhcmdzOiB7XG4gICAgd29ya3NwYWNlSWQ6IHN0cmluZztcbiAgICByZWxhdGl2ZVBhdGg6IHN0cmluZztcbiAgfSkge1xuICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlU2VydmljZS5nZXRVbmlxdWVGaWxlSWRlbnRpZmllcihhcmdzKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBraWVTYW5kYm94V29ya3NwYWNlc1N0b3JhZ2VfcHJlcGFyZVppcChhcmdzOiB7XG4gICAgd29ya3NwYWNlSWQ6IHN0cmluZztcbiAgICBvbmx5RXh0ZW5zaW9ucz86IHN0cmluZ1tdO1xuICB9KTogUHJvbWlzZTxCbG9iPiB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VGc1NlcnZpY2Uud2l0aFJlYWRvbmx5SW5NZW1vcnlGcyhhcmdzLndvcmtzcGFjZUlkLCBhc3luYyAoeyBmcywgc2NoZW1hIH0pID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlU2VydmljZS5wcmVwYXJlWmlwKGZzLCBzY2hlbWEsIGFyZ3Mud29ya3NwYWNlSWQsIGFyZ3Mub25seUV4dGVuc2lvbnMpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtpZVNhbmRib3hXb3Jrc3BhY2VzU3RvcmFnZV9yZW5hbWVGaWxlKGFyZ3M6IHtcbiAgICB3d2ZkOiBXb3Jrc3BhY2VXb3JrZXJGaWxlRGVzY3JpcHRvcjtcbiAgICBuZXdGaWxlTmFtZVdpdGhvdXRFeHRlbnNpb246IHN0cmluZztcbiAgfSk6IFByb21pc2U8V29ya3NwYWNlV29ya2VyRmlsZURlc2NyaXB0b3I+IHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZUZzU2VydmljZS53aXRoUmVhZFdyaXRlSW5NZW1vcnlGcyhcbiAgICAgIGFyZ3Mud3dmZC53b3Jrc3BhY2VJZCxcbiAgICAgIGFzeW5jICh7IGZzLCBicm9hZGNhc3RlciB9KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlU2VydmljZS5yZW5hbWVGaWxlKHtcbiAgICAgICAgICBmczogZnMsXG4gICAgICAgICAgd3dmZDogYXJncy53d2ZkLFxuICAgICAgICAgIG5ld0ZpbGVOYW1lV2l0aG91dEV4dGVuc2lvbjogYXJncy5uZXdGaWxlTmFtZVdpdGhvdXRFeHRlbnNpb24sXG4gICAgICAgICAgYnJvYWRjYXN0ZXIsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgcHVibGljIGFzeW5jIGtpZVNhbmRib3hXb3Jrc3BhY2VzU3RvcmFnZV9yZW5hbWVXb3Jrc3BhY2UoYXJnczoge1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgbmV3TmFtZTogc3RyaW5nO1xuICB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgYXdhaXQgdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZVNlcnZpY2UucmVuYW1lKGFyZ3Mud29ya3NwYWNlSWQsIGFyZ3MubmV3TmFtZSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2llU2FuZGJveFdvcmtzcGFjZXNTdG9yYWdlX3VwZGF0ZUZpbGUoYXJnczoge1xuICAgIHd3ZmQ6IFdvcmtzcGFjZVdvcmtlckZpbGVEZXNjcmlwdG9yO1xuICAgIG5ld0NvbnRlbnQ6IHN0cmluZztcbiAgfSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlRnNTZXJ2aWNlLndpdGhSZWFkV3JpdGVJbk1lbW9yeUZzKFxuICAgICAgYXJncy53d2ZkLndvcmtzcGFjZUlkLFxuICAgICAgYXN5bmMgKHsgZnMsIGJyb2FkY2FzdGVyIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VTZXJ2aWNlLnVwZGF0ZUZpbGUoZnMsIGFyZ3Mud3dmZCwgYXN5bmMgKCkgPT4gYXJncy5uZXdDb250ZW50LCBicm9hZGNhc3Rlcik7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8vZ2l0XG5cbiAgcHVibGljIGFzeW5jIGtpZVNhbmRib3hXb3Jrc3BhY2VzR2l0X2FkZFJlbW90ZShhcmdzOiB7XG4gICAgd29ya3NwYWNlSWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgdXJsOiBzdHJpbmc7XG4gICAgZm9yY2U6IGJvb2xlYW47XG4gIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZUZzU2VydmljZS53aXRoUmVhZFdyaXRlSW5NZW1vcnlGcyhcbiAgICAgIGFyZ3Mud29ya3NwYWNlSWQsXG4gICAgICBhc3luYyAoeyBmcywgYnJvYWRjYXN0ZXIgfSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdzLnNlcnZpY2VzLmdpdFNlcnZpY2UuYWRkUmVtb3RlKHtcbiAgICAgICAgICBmczogZnMsXG4gICAgICAgICAgZGlyOiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlU2VydmljZS5nZXRBYnNvbHV0ZVBhdGgoeyB3b3Jrc3BhY2VJZDogYXJncy53b3Jrc3BhY2VJZCB9KSxcbiAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtpZVNhbmRib3hXb3Jrc3BhY2VzR2l0X2RlbGV0ZVJlbW90ZShhcmdzOiB7IHdvcmtzcGFjZUlkOiBzdHJpbmc7IG5hbWU6IHN0cmluZyB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VGc1NlcnZpY2Uud2l0aFJlYWRXcml0ZUluTWVtb3J5RnMoXG4gICAgICBhcmdzLndvcmtzcGFjZUlkLFxuICAgICAgYXN5bmMgKHsgZnMsIGJyb2FkY2FzdGVyIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy5naXRTZXJ2aWNlLmRlbGV0ZVJlbW90ZSh7XG4gICAgICAgICAgZnM6IGZzLFxuICAgICAgICAgIGRpcjogdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZVNlcnZpY2UuZ2V0QWJzb2x1dGVQYXRoKHsgd29ya3NwYWNlSWQ6IGFyZ3Mud29ya3NwYWNlSWQgfSksXG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBraWVTYW5kYm94V29ya3NwYWNlc0dpdF9icmFuY2goYXJnczoge1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGNoZWNrb3V0OiBib29sZWFuO1xuICB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VGc1NlcnZpY2Uud2l0aFJlYWRXcml0ZUluTWVtb3J5RnMoXG4gICAgICBhcmdzLndvcmtzcGFjZUlkLFxuICAgICAgYXN5bmMgKHsgZnMsIGJyb2FkY2FzdGVyIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy5naXRTZXJ2aWNlLmJyYW5jaCh7XG4gICAgICAgICAgZnM6IGZzLFxuICAgICAgICAgIGRpcjogdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZVNlcnZpY2UuZ2V0QWJzb2x1dGVQYXRoKHsgd29ya3NwYWNlSWQ6IGFyZ3Mud29ya3NwYWNlSWQgfSksXG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBraWVTYW5kYm94V29ya3NwYWNlc0dpdF9jaGVja291dChhcmdzOiB7XG4gICAgd29ya3NwYWNlSWQ6IHN0cmluZztcbiAgICByZWY6IHN0cmluZztcbiAgICByZW1vdGU6IHN0cmluZztcbiAgfSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlRnNTZXJ2aWNlLndpdGhSZWFkV3JpdGVJbk1lbW9yeUZzKFxuICAgICAgYXJncy53b3Jrc3BhY2VJZCxcbiAgICAgIGFzeW5jICh7IGZzLCBicm9hZGNhc3RlciB9KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMuZ2l0U2VydmljZS5jaGVja291dCh7XG4gICAgICAgICAgZnM6IGZzLFxuICAgICAgICAgIGRpcjogdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZVNlcnZpY2UuZ2V0QWJzb2x1dGVQYXRoKHsgd29ya3NwYWNlSWQ6IGFyZ3Mud29ya3NwYWNlSWQgfSksXG4gICAgICAgICAgLi4uYXJncyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBraWVTYW5kYm94V29ya3NwYWNlc0dpdF9nZXRHaXRTZXJ2ZXJSZWZzKGFyZ3M6IHtcbiAgICB1cmw6IHN0cmluZztcbiAgICBhdXRoSW5mbz86IHtcbiAgICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gICAgICBwYXNzd29yZDogc3RyaW5nO1xuICAgIH07XG4gIH0pOiBQcm9taXNlPEdpdFNlcnZlclJlZltdPiB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy5naXRTZXJ2aWNlLmxpc3RTZXJ2ZXJSZWZzKGFyZ3MpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtpZVNhbmRib3hXb3Jrc3BhY2VzR2l0X2Nsb25lKGFyZ3M6IHtcbiAgICBvcmlnaW46IEdpc3RPcmlnaW4gfCBHaXRIdWJPcmlnaW4gfCBCaXRidWNrZXRPcmlnaW4gfCBTbmlwcGV0T3JpZ2luO1xuICAgIGdpdENvbmZpZz86IHsgZW1haWw6IHN0cmluZzsgbmFtZTogc3RyaW5nIH07XG4gICAgYXV0aEluZm8/OiB7IHVzZXJuYW1lOiBzdHJpbmc7IHBhc3N3b3JkOiBzdHJpbmcgfTtcbiAgICBnaXRBdXRoU2Vzc2lvbklkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIH0pOiBQcm9taXNlPHsgd29ya3NwYWNlOiBXb3Jrc3BhY2VEZXNjcmlwdG9yOyBzdWdnZXN0ZWRGaXJzdEZpbGU/OiBXb3Jrc3BhY2VXb3JrZXJGaWxlRGVzY3JpcHRvciB9PiB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlV29ya3NwYWNlKHtcbiAgICAgIHByZWZlcnJlZE5hbWU6IG5ldyBVUkwoYXJncy5vcmlnaW4udXJsKS5wYXRobmFtZS5zdWJzdHJpbmcoMSksIC8vIFJlbW92ZSBzbGFzaFxuICAgICAgb3JpZ2luOiBhcmdzLm9yaWdpbixcbiAgICAgIGdpdEF1dGhTZXNzaW9uSWQ6IGFyZ3MuZ2l0QXV0aFNlc3Npb25JZCxcbiAgICAgIHN0b3JlRmlsZXM6IGFzeW5jIChmcywgc2NoZW1hLCB3b3Jrc3BhY2UpID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5hcmdzLnNlcnZpY2VzLmdpdFNlcnZpY2UuY2xvbmUoe1xuICAgICAgICAgIGZzLFxuICAgICAgICAgIGRpcjogdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZVNlcnZpY2UuZ2V0QWJzb2x1dGVQYXRoKHsgd29ya3NwYWNlSWQ6IHdvcmtzcGFjZS53b3Jrc3BhY2VJZCB9KSxcbiAgICAgICAgICByZXBvc2l0b3J5VXJsOiBuZXcgVVJMKGFyZ3Mub3JpZ2luLnVybCksXG4gICAgICAgICAgZ2l0Q29uZmlnOiBhcmdzLmdpdENvbmZpZyxcbiAgICAgICAgICBhdXRoSW5mbzogYXJncy5hdXRoSW5mbyxcbiAgICAgICAgICBzb3VyY2VCcmFuY2g6IGFyZ3Mub3JpZ2luLmJyYW5jaCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlU2VydmljZS5nZXRGaWx0ZXJlZFdvcmtzcGFjZUZpbGVEZXNjcmlwdG9ycyhzY2hlbWEsIHdvcmtzcGFjZS53b3Jrc3BhY2VJZCk7XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtpZVNhbmRib3hXb3Jrc3BhY2VzR2l0X2dldFVuc3RhZ2VkTW9kaWZpZWRGaWxlUmVsYXRpdmVQYXRocyhhcmdzOiB7XG4gICAgd29ya3NwYWNlSWQ6IHN0cmluZztcbiAgfSk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICBjb25zdCB3b3Jrc3BhY2VSb290RGlyUGF0aCA9IHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VTZXJ2aWNlLmdldEFic29sdXRlUGF0aCh7IHdvcmtzcGFjZUlkOiBhcmdzLndvcmtzcGFjZUlkIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VGc1NlcnZpY2Uud2l0aFJlYWRXcml0ZUluTWVtb3J5RnMoYXJncy53b3Jrc3BhY2VJZCwgYXN5bmMgKHsgZnMgfSkgPT4ge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuYXJncy5zZXJ2aWNlcy5naXRTZXJ2aWNlLnVuc3RhZ2VkTW9kaWZpZWRGaWxlUmVsYXRpdmVQYXRocyh7XG4gICAgICAgIGZzLFxuICAgICAgICBkaXI6IHdvcmtzcGFjZVJvb3REaXJQYXRoLFxuICAgICAgICBleGNsdWRlOiAoZmlsZXBhdGgpID0+ICF0aGlzLmFyZ3MuZmlsZUZpbHRlci5pc0VkaXRhYmxlKGZpbGVwYXRoKSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtpZVNhbmRib3hXb3Jrc3BhY2VzR2l0X2NvbW1pdChhcmdzOiB7XG4gICAgd29ya3NwYWNlSWQ6IHN0cmluZztcbiAgICBnaXRDb25maWc/OiB7IGVtYWlsOiBzdHJpbmc7IG5hbWU6IHN0cmluZyB9O1xuICAgIGNvbW1pdE1lc3NhZ2U/OiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBkZXNjcmlwdG9yID0gYXdhaXQgdGhpcy5hcmdzLnNlcnZpY2VzLmRlc2NyaXB0b3JzRnNTZXJ2aWNlLndpdGhSZWFkV3JpdGVJbk1lbW9yeUZzKCh7IGZzIH0pID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMuZGVzY3JpcHRvclNlcnZpY2UuZ2V0KGZzLCBhcmdzLndvcmtzcGFjZUlkKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHdvcmtzcGFjZVJvb3REaXJQYXRoID0gdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZVNlcnZpY2UuZ2V0QWJzb2x1dGVQYXRoKHsgd29ya3NwYWNlSWQ6IGFyZ3Mud29ya3NwYWNlSWQgfSk7XG5cbiAgICBjb25zdCBkZWZhdWx0Q29tbWl0TWVzc2FnZSA9IGBDaGFuZ2VzIGZyb20gJHt0aGlzLmFyZ3MuYXBwTmFtZX1gO1xuXG4gICAgY29uc3QgZmlsZVJlbGF0aXZlUGF0aHMgPSBhd2FpdCB0aGlzLmtpZVNhbmRib3hXb3Jrc3BhY2VzR2l0X2dldFVuc3RhZ2VkTW9kaWZpZWRGaWxlUmVsYXRpdmVQYXRocyh7XG4gICAgICB3b3Jrc3BhY2VJZDogYXJncy53b3Jrc3BhY2VJZCxcbiAgICB9KTtcblxuICAgIGlmIChmaWxlUmVsYXRpdmVQYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoXCJOb3RoaW5nIHRvIGNvbW1pdC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VGc1NlcnZpY2Uud2l0aFJlYWRXcml0ZUluTWVtb3J5RnMoXG4gICAgICBhcmdzLndvcmtzcGFjZUlkLFxuICAgICAgYXN5bmMgKHsgZnMsIGJyb2FkY2FzdGVyIH0pID0+IHtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgZmlsZVJlbGF0aXZlUGF0aHMubWFwKGFzeW5jIChyZWxhdGl2ZVBhdGgpID0+IHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZVNlcnZpY2UuZXhpc3RzRmlsZSh7XG4gICAgICAgICAgICAgICAgZnMsXG4gICAgICAgICAgICAgICAgd29ya3NwYWNlSWQ6IGFyZ3Mud29ya3NwYWNlSWQsXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXJncy5zZXJ2aWNlcy5naXRTZXJ2aWNlLmFkZCh7XG4gICAgICAgICAgICAgICAgZnMsXG4gICAgICAgICAgICAgICAgZGlyOiB3b3Jrc3BhY2VSb290RGlyUGF0aCxcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGgsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcmdzLnNlcnZpY2VzLmdpdFNlcnZpY2Uucm0oe1xuICAgICAgICAgICAgICAgIGZzLFxuICAgICAgICAgICAgICAgIGRpcjogd29ya3NwYWNlUm9vdERpclBhdGgsXG4gICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuYXJncy5zZXJ2aWNlcy5naXRTZXJ2aWNlLmNvbW1pdCh7XG4gICAgICAgICAgZnMsXG4gICAgICAgICAgZGlyOiB3b3Jrc3BhY2VSb290RGlyUGF0aCxcbiAgICAgICAgICB0YXJnZXRCcmFuY2g6IGRlc2NyaXB0b3Iub3JpZ2luLmJyYW5jaCxcbiAgICAgICAgICBtZXNzYWdlOiBhcmdzLmNvbW1pdE1lc3NhZ2UgPz8gZGVmYXVsdENvbW1pdE1lc3NhZ2UsXG4gICAgICAgICAgYXV0aG9yOiB7XG4gICAgICAgICAgICBuYW1lOiBhcmdzLmdpdENvbmZpZz8ubmFtZSA/PyB0aGlzLkdJVF9ERUZBVUxUX1VTRVIubmFtZSxcbiAgICAgICAgICAgIGVtYWlsOiBhcmdzLmdpdENvbmZpZz8uZW1haWwgPz8gdGhpcy5HSVRfREVGQVVMVF9VU0VSLmVtYWlsLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJyb2FkY2FzdGVyLmJyb2FkY2FzdCh7XG4gICAgICAgICAgY2hhbm5lbDogYXJncy53b3Jrc3BhY2VJZCxcbiAgICAgICAgICBtZXNzYWdlOiBhc3luYyAoKSA9PiAoe1xuICAgICAgICAgICAgdHlwZTogXCJXU19DUkVBVEVfU0FWRV9QT0lOVFwiLFxuICAgICAgICAgICAgd29ya3NwYWNlSWQ6IGFyZ3Mud29ya3NwYWNlSWQsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2llU2FuZGJveFdvcmtzcGFjZXNHaXRfZmV0Y2goYXJnczoge1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgcmVtb3RlOiBzdHJpbmc7XG4gICAgcmVmOiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZUZzU2VydmljZS53aXRoUmVhZFdyaXRlSW5NZW1vcnlGcyhcbiAgICAgIGFyZ3Mud29ya3NwYWNlSWQsXG4gICAgICBhc3luYyAoeyBmcywgYnJvYWRjYXN0ZXIgfSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdzLnNlcnZpY2VzLmdpdFNlcnZpY2UuZmV0Y2goe1xuICAgICAgICAgIGZzOiBmcyxcbiAgICAgICAgICBkaXI6IHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VTZXJ2aWNlLmdldEFic29sdXRlUGF0aCh7IHdvcmtzcGFjZUlkOiBhcmdzLndvcmtzcGFjZUlkIH0pLFxuICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2llU2FuZGJveFdvcmtzcGFjZXNHaXRfaW5pdChhcmdzOiB7XG4gICAgbG9jYWxGaWxlczogTG9jYWxGaWxlW107XG4gICAgcHJlZmVycmVkTmFtZT86IHN0cmluZztcbiAgICBnaXRBdXRoU2Vzc2lvbklkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgZ2l0Q29uZmlnPzogeyBlbWFpbDogc3RyaW5nOyBuYW1lOiBzdHJpbmcgfTtcbiAgfSk6IFByb21pc2U8eyB3b3Jrc3BhY2U6IFdvcmtzcGFjZURlc2NyaXB0b3I7IHN1Z2dlc3RlZEZpcnN0RmlsZT86IFdvcmtzcGFjZVdvcmtlckZpbGVEZXNjcmlwdG9yIH0+IHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVXb3Jrc3BhY2Uoe1xuICAgICAgcHJlZmVycmVkTmFtZTogYXJncy5wcmVmZXJyZWROYW1lLFxuICAgICAgb3JpZ2luOiB7IGtpbmQ6IFdvcmtzcGFjZUtpbmQuTE9DQUwsIGJyYW5jaDogR0lUX0RFRkFVTFRfQlJBTkNIIH0sXG4gICAgICBnaXRBdXRoU2Vzc2lvbklkOiBhcmdzLmdpdEF1dGhTZXNzaW9uSWQsXG4gICAgICBzdG9yZUZpbGVzOiBhc3luYyAoZnMsIHNjaGVtYSwgd29ya3NwYWNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVzID0gYXJncy5sb2NhbEZpbGVzXG4gICAgICAgICAgLmZpbHRlcigoZmlsZSkgPT4gIWZpbGUucGF0aC5zdGFydHNXaXRoKFwiLmdpdC9cIikpXG4gICAgICAgICAgLm1hcChcbiAgICAgICAgICAgIChsb2NhbEZpbGUpID0+XG4gICAgICAgICAgICAgIG5ldyBTdG9yYWdlRmlsZSh7XG4gICAgICAgICAgICAgICAgcGF0aDogdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZVNlcnZpY2UuZ2V0QWJzb2x1dGVQYXRoKHtcbiAgICAgICAgICAgICAgICAgIHdvcmtzcGFjZUlkOiB3b3Jrc3BhY2Uud29ya3NwYWNlSWQsXG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGg6IGxvY2FsRmlsZS5wYXRoLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGdldEZpbGVDb250ZW50czogYXN5bmMgKCkgPT4gbG9jYWxGaWxlLmZpbGVDb250ZW50cyxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIGZpbGVzLm1hcChhc3luYyAoZikgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcmdzLnNlcnZpY2VzLnN0b3JhZ2VTZXJ2aWNlLmNyZWF0ZU9yT3ZlcndyaXRlRmlsZShmcywgZik7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCB3b3Jrc3BhY2VSb290RGlyQWJzb2x1dGVQYXRoID0gdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZVNlcnZpY2UuZ2V0QWJzb2x1dGVQYXRoKHtcbiAgICAgICAgICB3b3Jrc3BhY2VJZDogd29ya3NwYWNlLndvcmtzcGFjZUlkLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBpZ25vcmVkUGF0aHMgPSBhd2FpdCB0aGlzLmFyZ3Muc2VydmljZXMuc3RvcmFnZVNlcnZpY2Uud2Fsayh7XG4gICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgIHNob3VsZEV4Y2x1ZGVBYnNvbHV0ZVBhdGg6ICgpID0+IGZhbHNlLFxuICAgICAgICAgIGJhc2VBYnNvbHV0ZVBhdGg6IHdvcmtzcGFjZVJvb3REaXJBYnNvbHV0ZVBhdGgsXG4gICAgICAgICAgb25WaXNpdDogYXN5bmMgKHsgYWJzb2x1dGVQYXRoLCByZWxhdGl2ZVBhdGggfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNJZ25vcmVkID0gYXdhaXQgdGhpcy5hcmdzLnNlcnZpY2VzLmdpdFNlcnZpY2UuaXNJZ25vcmVkKHtcbiAgICAgICAgICAgICAgZnMsXG4gICAgICAgICAgICAgIGRpcjogd29ya3NwYWNlUm9vdERpckFic29sdXRlUGF0aCxcbiAgICAgICAgICAgICAgZmlsZXBhdGg6IHJlbGF0aXZlUGF0aCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGlzSWdub3JlZCA/IGFic29sdXRlUGF0aCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBpZ25vcmVkUGF0aHMubWFwKGFzeW5jIChwYXRoKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFyZ3Muc2VydmljZXMuc3RvcmFnZVNlcnZpY2UuZGVsZXRlRmlsZShmcywgcGF0aCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICBhd2FpdCB0aGlzLmFyZ3Muc2VydmljZXMuZ2l0U2VydmljZS5pbml0KHtcbiAgICAgICAgICBmcyxcbiAgICAgICAgICBkaXI6IHdvcmtzcGFjZVJvb3REaXJBYnNvbHV0ZVBhdGgsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuYXJncy5zZXJ2aWNlcy5naXRTZXJ2aWNlLmFkZCh7XG4gICAgICAgICAgZnMsXG4gICAgICAgICAgZGlyOiB3b3Jrc3BhY2VSb290RGlyQWJzb2x1dGVQYXRoLFxuICAgICAgICAgIHJlbGF0aXZlUGF0aDogXCIuXCIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGF3YWl0IHRoaXMuYXJncy5zZXJ2aWNlcy5naXRTZXJ2aWNlLmNvbW1pdCh7XG4gICAgICAgICAgZnMsXG4gICAgICAgICAgZGlyOiB3b3Jrc3BhY2VSb290RGlyQWJzb2x1dGVQYXRoLFxuICAgICAgICAgIG1lc3NhZ2U6IGBJbml0aWFsIGNvbW1pdCBmcm9tICR7dGhpcy5hcmdzLmFwcE5hbWV9YCxcbiAgICAgICAgICB0YXJnZXRCcmFuY2g6IEdJVF9ERUZBVUxUX0JSQU5DSCxcbiAgICAgICAgICBhdXRob3I6IHtcbiAgICAgICAgICAgIG5hbWU6IGFyZ3MuZ2l0Q29uZmlnPy5uYW1lID8/IHRoaXMuR0lUX0RFRkFVTFRfVVNFUi5uYW1lLFxuICAgICAgICAgICAgZW1haWw6IGFyZ3MuZ2l0Q29uZmlnPy5lbWFpbCA/PyB0aGlzLkdJVF9ERUZBVUxUX1VTRVIuZW1haWwsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VTZXJ2aWNlLmdldEZpbHRlcmVkV29ya3NwYWNlRmlsZURlc2NyaXB0b3JzKHNjaGVtYSwgd29ya3NwYWNlLndvcmtzcGFjZUlkKTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2llU2FuZGJveFdvcmtzcGFjZXNHaXRfcHVsbChhcmdzOiB7XG4gICAgd29ya3NwYWNlSWQ6IHN0cmluZztcbiAgICBnaXRDb25maWc/OiB7IGVtYWlsOiBzdHJpbmc7IG5hbWU6IHN0cmluZyB9O1xuICAgIGF1dGhJbmZvPzogeyB1c2VybmFtZTogc3RyaW5nOyBwYXNzd29yZDogc3RyaW5nIH07XG4gIH0pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB3b3Jrc3BhY2UgPSBhd2FpdCB0aGlzLmFyZ3Muc2VydmljZXMuZGVzY3JpcHRvcnNGc1NlcnZpY2Uud2l0aFJlYWRXcml0ZUluTWVtb3J5RnMoKHsgZnMgfSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy5kZXNjcmlwdG9yU2VydmljZS5nZXQoZnMsIGFyZ3Mud29ya3NwYWNlSWQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VGc1NlcnZpY2Uud2l0aFJlYWRXcml0ZUluTWVtb3J5RnMoXG4gICAgICBhcmdzLndvcmtzcGFjZUlkLFxuICAgICAgYXN5bmMgKHsgZnMsIGJyb2FkY2FzdGVyIH0pID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5hcmdzLnNlcnZpY2VzLmdpdFNlcnZpY2UucHVsbCh7XG4gICAgICAgICAgZnM6IGZzLFxuICAgICAgICAgIGRpcjogdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZVNlcnZpY2UuZ2V0QWJzb2x1dGVQYXRoKHsgd29ya3NwYWNlSWQ6IGFyZ3Mud29ya3NwYWNlSWQgfSksXG4gICAgICAgICAgcmVmOiB3b3Jrc3BhY2Uub3JpZ2luLmJyYW5jaCxcbiAgICAgICAgICBhdXRob3I6IHtcbiAgICAgICAgICAgIG5hbWU6IGFyZ3MuZ2l0Q29uZmlnPy5uYW1lID8/IHRoaXMuR0lUX0RFRkFVTFRfVVNFUi5uYW1lLFxuICAgICAgICAgICAgZW1haWw6IGFyZ3MuZ2l0Q29uZmlnPy5lbWFpbCA/PyB0aGlzLkdJVF9ERUZBVUxUX1VTRVIuZW1haWwsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdXRoSW5mbzogYXJncy5hdXRoSW5mbyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYnJvYWRjYXN0ZXIuYnJvYWRjYXN0KHtcbiAgICAgICAgICBjaGFubmVsOiBhcmdzLndvcmtzcGFjZUlkLFxuICAgICAgICAgIG1lc3NhZ2U6IGFzeW5jICgpID0+ICh7XG4gICAgICAgICAgICB0eXBlOiBcIldTX1BVTExcIixcbiAgICAgICAgICAgIHdvcmtzcGFjZUlkOiBhcmdzLndvcmtzcGFjZUlkLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGtpZVNhbmRib3hXb3Jrc3BhY2VzR2l0X3B1c2goYXJnczoge1xuICAgIHdvcmtzcGFjZUlkOiBzdHJpbmc7XG4gICAgcmVmOiBzdHJpbmc7XG4gICAgcmVtb3RlUmVmPzogc3RyaW5nO1xuICAgIHJlbW90ZTogc3RyaW5nO1xuICAgIGZvcmNlOiBib29sZWFuO1xuICAgIGF1dGhJbmZvOiB7XG4gICAgICB1c2VybmFtZTogc3RyaW5nO1xuICAgICAgcGFzc3dvcmQ6IHN0cmluZztcbiAgICB9O1xuICB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VGc1NlcnZpY2Uud2l0aFJlYWRXcml0ZUluTWVtb3J5RnMoXG4gICAgICBhcmdzLndvcmtzcGFjZUlkLFxuICAgICAgYXN5bmMgKHsgZnMsIGJyb2FkY2FzdGVyIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy5naXRTZXJ2aWNlLnB1c2goe1xuICAgICAgICAgIGZzOiBmcyxcbiAgICAgICAgICBkaXI6IHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VTZXJ2aWNlLmdldEFic29sdXRlUGF0aCh7IHdvcmtzcGFjZUlkOiBhcmdzLndvcmtzcGFjZUlkIH0pLFxuICAgICAgICAgIC4uLmFyZ3MsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2llU2FuZGJveFdvcmtzcGFjZXNHaXRfcmVzb2x2ZVJlZihhcmdzOiB7IHdvcmtzcGFjZUlkOiBzdHJpbmc7IHJlZjogc3RyaW5nIH0pOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlRnNTZXJ2aWNlLndpdGhSZWFkb25seUluTWVtb3J5RnMoYXJncy53b3Jrc3BhY2VJZCwgYXN5bmMgKHsgZnMgfSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy5naXRTZXJ2aWNlLnJlc29sdmVSZWYoe1xuICAgICAgICBmczogZnMsXG4gICAgICAgIGRpcjogdGhpcy5hcmdzLnNlcnZpY2VzLndvcmtzcGFjZVNlcnZpY2UuZ2V0QWJzb2x1dGVQYXRoKHsgd29ya3NwYWNlSWQ6IGFyZ3Mud29ya3NwYWNlSWQgfSksXG4gICAgICAgIHJlZjogYXJncy5yZWYsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBraWVTYW5kYm94V29ya3NwYWNlc0dpdF9pc01vZGlmaWVkKGFyZ3M6IHsgd29ya3NwYWNlSWQ6IHN0cmluZzsgcmVsYXRpdmVQYXRoOiBzdHJpbmcgfSkge1xuICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlRnNTZXJ2aWNlLndpdGhSZWFkV3JpdGVJbk1lbW9yeUZzKGFyZ3Mud29ya3NwYWNlSWQsIGFzeW5jICh7IGZzIH0pID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmFyZ3Muc2VydmljZXMuZ2l0U2VydmljZS5pc01vZGlmaWVkKHtcbiAgICAgICAgZnM6IGZzLFxuICAgICAgICBkaXI6IHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VTZXJ2aWNlLmdldEFic29sdXRlUGF0aCh7IHdvcmtzcGFjZUlkOiBhcmdzLndvcmtzcGFjZUlkIH0pLFxuICAgICAgICByZWxhdGl2ZVBhdGg6IGFyZ3MucmVsYXRpdmVQYXRoLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMga2llU2FuZGJveFdvcmtzcGFjZXNHaXRfaGFzTG9jYWxDaGFuZ2VzKGFyZ3M6IHsgd29ya3NwYWNlSWQ6IHN0cmluZyB9KSB7XG4gICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy53b3Jrc3BhY2VGc1NlcnZpY2Uud2l0aFJlYWRXcml0ZUluTWVtb3J5RnMoYXJncy53b3Jrc3BhY2VJZCwgYXN5bmMgKHsgZnMgfSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuYXJncy5zZXJ2aWNlcy5naXRTZXJ2aWNlLmhhc0xvY2FsQ2hhbmdlcyh7XG4gICAgICAgIGZzOiBmcyxcbiAgICAgICAgZGlyOiB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlU2VydmljZS5nZXRBYnNvbHV0ZVBhdGgoeyB3b3Jrc3BhY2VJZDogYXJncy53b3Jrc3BhY2VJZCB9KSxcbiAgICAgICAgZXhjbHVkZTogKGZpbGVwYXRoKSA9PiAhdGhpcy5hcmdzLmZpbGVGaWx0ZXIuaXNFZGl0YWJsZShmaWxlcGF0aCksXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBraWVTYW5kYm94V29ya3NwYWNlc1N0b3JhZ2VfZmx1c2hlcygpIHtcbiAgICByZXR1cm4geyBkZWZhdWx0VmFsdWU6IFtdIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNyZWF0ZVdvcmtzcGFjZShhcmdzOiB7XG4gICAgc3RvcmVGaWxlczogKFxuICAgICAgZnM6IEtpZVNhbmRib3hXb3Jrc3BhY2VzRnMsXG4gICAgICBzY2hlbWE6IEZzU2NoZW1hLFxuICAgICAgd29ya3NwYWNlOiBXb3Jrc3BhY2VEZXNjcmlwdG9yXG4gICAgKSA9PiBQcm9taXNlPFdvcmtzcGFjZVdvcmtlckZpbGVEZXNjcmlwdG9yW10+O1xuICAgIG9yaWdpbjogV29ya3NwYWNlT3JpZ2luO1xuICAgIHByZWZlcnJlZE5hbWU/OiBzdHJpbmc7XG4gICAgZ2l0QXV0aFNlc3Npb25JZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICB9KSB7XG4gICAgY29uc3QgeyB3b3Jrc3BhY2UsIGZpbGVzIH0gPSBhd2FpdCB0aGlzLmFyZ3Muc2VydmljZXMud29ya3NwYWNlU2VydmljZS5jcmVhdGUoe1xuICAgICAgc3RvcmVGaWxlczogYXJncy5zdG9yZUZpbGVzLFxuICAgICAgb3JpZ2luOiBhcmdzLm9yaWdpbixcbiAgICAgIHByZWZlcnJlZE5hbWU6IGFyZ3MucHJlZmVycmVkTmFtZSxcbiAgICAgIGdpdEF1dGhTZXNzaW9uSWQ6IGFyZ3MuZ2l0QXV0aFNlc3Npb25JZCxcbiAgICB9KTtcblxuICAgIGlmIChmaWxlcy5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuIHsgd29ya3NwYWNlLCBzdWdnZXN0ZWRGaXJzdEZpbGU6IHVuZGVmaW5lZCB9O1xuICAgIH1cblxuICAgIGxldCBmaWx0ZXJlZEZpbGVzID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiB0aGlzLmFyZ3MuZmlsZUZpbHRlci5pc01vZGVsKGZpbGUucmVsYXRpdmVQYXRoKSk7XG4gICAgaWYgKCFmaWx0ZXJlZEZpbGVzLmxlbmd0aCkge1xuICAgICAgZmlsdGVyZWRGaWxlcyA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4gdGhpcy5hcmdzLmZpbGVGaWx0ZXIuaXNFZGl0YWJsZShmaWxlLnJlbGF0aXZlUGF0aCkpO1xuICAgIH1cbiAgICBpZiAoIWZpbHRlcmVkRmlsZXMubGVuZ3RoKSB7XG4gICAgICBmaWx0ZXJlZEZpbGVzID0gZmlsZXMuZmlsdGVyKChmaWxlKSA9PiB0aGlzLmFyZ3MuZmlsZUZpbHRlci5pc1N1cHBvcnRlZChmaWxlLnJlbGF0aXZlUGF0aCkpO1xuICAgIH1cblxuICAgIGZpbHRlcmVkRmlsZXMuc29ydCgoYSwgYikgPT4gYS5yZWxhdGl2ZVBhdGgubG9jYWxlQ29tcGFyZShiLnJlbGF0aXZlUGF0aCkpO1xuXG4gICAgY29uc3Qgc3VnZ2VzdGVkRmlyc3RGaWxlID0gZmlsdGVyZWRGaWxlcy5sZW5ndGggPyBmaWx0ZXJlZEZpbGVzWzBdIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdvcmtzcGFjZSxcbiAgICAgIHN1Z2dlc3RlZEZpcnN0RmlsZSxcbiAgICB9O1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjIgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgV29ya3NwYWNlT3JpZ2luIH0gZnJvbSBcIi4vV29ya3NwYWNlT3JpZ2luXCI7XG5cbmV4cG9ydCBjb25zdCBORVdfV09SS1NQQUNFX0RFRkFVTFRfTkFNRSA9IGBVbnRpdGxlZCBGb2xkZXJgO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtzcGFjZURlc2NyaXB0b3Ige1xuICB3b3Jrc3BhY2VJZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIG9yaWdpbjogV29ya3NwYWNlT3JpZ2luO1xuICBjcmVhdGVkRGF0ZUlTTzogc3RyaW5nO1xuICBsYXN0VXBkYXRlZERhdGVJU086IHN0cmluZztcbiAgZ2l0QXV0aFNlc3Npb25JZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDIyIFJlZCBIYXQsIEluYy4gYW5kL29yIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEdJVF9ERUZBVUxUX0JSQU5DSCB9IGZyb20gXCIuLi8uLi9jb25zdGFudHMvR2l0Q29uc3RhbnRzXCI7XG5cbmV4cG9ydCBlbnVtIFdvcmtzcGFjZUtpbmQge1xuICBHSVRIVUJfR0lTVCA9IFwiR0lUSFVCX0dJU1RcIixcbiAgR0lUID0gXCJHSVRcIixcbiAgTE9DQUwgPSBcIkxPQ0FMXCIsXG4gIEJJVEJVQ0tFVF9TTklQUEVUID0gXCJCSVRCVUNLRVRfU05JUFBFVFwiLFxufVxuXG5jb25zdCBnaXRCYXNlZFR5cGVLZXlzID0gW1dvcmtzcGFjZUtpbmQuR0lULCBXb3Jrc3BhY2VLaW5kLkJJVEJVQ0tFVF9TTklQUEVULCBXb3Jrc3BhY2VLaW5kLkdJVEhVQl9HSVNUXSBhcyBjb25zdDtcbmV4cG9ydCB0eXBlIFdvcmtzcGFjZUtpbmRHaXRCYXNlZCA9IHR5cGVvZiBnaXRCYXNlZFR5cGVLZXlzW251bWJlcl07XG5cbmV4cG9ydCBjb25zdCBpc0dpdEJhc2VkV29ya3NwYWNlS2luZCA9IChcbiAgbWF5YmVHaXRCYXNlZFR5cGU6IFdvcmtzcGFjZUtpbmQgfCB1bmRlZmluZWRcbik6IG1heWJlR2l0QmFzZWRUeXBlIGlzIFdvcmtzcGFjZUtpbmRHaXRCYXNlZCA9PiB7XG4gIHJldHVybiBnaXRCYXNlZFR5cGVLZXlzLnNvbWUoKGspID0+IGsgPT09IG1heWJlR2l0QmFzZWRUeXBlKTtcbn07XG5cbmNvbnN0IGdpc3RMaWtlVHlwZUtleXMgPSBbV29ya3NwYWNlS2luZC5HSVRIVUJfR0lTVCwgV29ya3NwYWNlS2luZC5CSVRCVUNLRVRfU05JUFBFVF0gYXMgY29uc3Q7XG5leHBvcnQgdHlwZSBXb3Jrc3BhY2VLaW5kR2lzdExpa2UgPSB0eXBlb2YgZ2lzdExpa2VUeXBlS2V5c1tudW1iZXJdO1xuXG5leHBvcnQgY29uc3QgaXNHaXN0TGlrZVdvcmtzcGFjZUtpbmQgPSAoXG4gIG1heWJlR2lzdExpa2VUeXBlOiBXb3Jrc3BhY2VLaW5kIHwgdW5kZWZpbmVkXG4pOiBtYXliZUdpc3RMaWtlVHlwZSBpcyBXb3Jrc3BhY2VLaW5kR2lzdExpa2UgPT4ge1xuICByZXR1cm4gZ2lzdExpa2VUeXBlS2V5cy5zb21lKChrKSA9PiBrID09PSBtYXliZUdpc3RMaWtlVHlwZSk7XG59O1xuXG5leHBvcnQgdHlwZSBXb3Jrc3BhY2VPcmlnaW4gPSBMb2NhbE9yaWdpbiB8IEdpc3RPcmlnaW4gfCBHaXRIdWJPcmlnaW4gfCBCaXRidWNrZXRPcmlnaW4gfCBTbmlwcGV0T3JpZ2luO1xuXG5leHBvcnQgaW50ZXJmYWNlIExvY2FsT3JpZ2luIHtcbiAga2luZDogV29ya3NwYWNlS2luZC5MT0NBTDtcbiAgYnJhbmNoOiB0eXBlb2YgR0lUX0RFRkFVTFRfQlJBTkNIO1xuICB1cmw/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2l0SHViT3JpZ2luIHtcbiAga2luZDogV29ya3NwYWNlS2luZC5HSVQ7XG4gIHVybDogc3RyaW5nO1xuICBicmFuY2g6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCaXRidWNrZXRPcmlnaW4ge1xuICBraW5kOiBXb3Jrc3BhY2VLaW5kLkdJVDtcbiAgdXJsOiBzdHJpbmc7XG4gIGJyYW5jaDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdpc3RPcmlnaW4ge1xuICBraW5kOiBXb3Jrc3BhY2VLaW5kLkdJVEhVQl9HSVNUO1xuICB1cmw6IHN0cmluZztcbiAgYnJhbmNoOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU25pcHBldE9yaWdpbiB7XG4gIGtpbmQ6IFdvcmtzcGFjZUtpbmQuQklUQlVDS0VUX1NOSVBQRVQ7XG4gIHVybDogc3RyaW5nO1xuICBicmFuY2g6IHN0cmluZztcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgV09SS1NQQUNFU19CUk9BRENBU1RfQ0hBTk5FTCA9IFwid29ya3NwYWNlc1wiIGFzIGNvbnN0O1xuZXhwb3J0IGNvbnN0IFdPUktTUEFDRVNfRklMRVNfQlJPQURDQVNUX0NIQU5ORUwgPSBcIndvcmtzcGFjZXNfZmlsZXNcIiBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgV29ya3NwYWNlc0Jyb2FkY2FzdEV2ZW50cyA9XG4gIHwgeyB0eXBlOiBcIldTU19ERUxFVEVfQUxMXCIgfVxuICB8IHsgdHlwZTogXCJXU1NfQUREX1dPUktTUEFDRVwiOyB3b3Jrc3BhY2VJZDogc3RyaW5nIH1cbiAgfCB7IHR5cGU6IFwiV1NTX1JFTkFNRV9XT1JLU1BBQ0VcIjsgd29ya3NwYWNlSWQ6IHN0cmluZyB9XG4gIHwgeyB0eXBlOiBcIldTU19ERUxFVEVfV09SS1NQQUNFXCI7IHdvcmtzcGFjZUlkOiBzdHJpbmcgfVxuICB8IHsgdHlwZTogXCJXU1NfVVBEQVRFXCI7IHdvcmtzcGFjZUlkOiBzdHJpbmcgfTtcblxuZXhwb3J0IHR5cGUgV29ya3NwYWNlc0ZpbGVzQnJvYWRjYXN0RXZlbnRzID1cbiAgfCB7IHR5cGU6IFwiV1NTRlNfQUREXCI7IHdvcmtzcGFjZUlkOiBzdHJpbmc7IHJlbGF0aXZlUGF0aDogc3RyaW5nIH1cbiAgfCB7IHR5cGU6IFwiV1NTRlNfTU9WRVwiOyB3b3Jrc3BhY2VJZDogc3RyaW5nOyBuZXdSZWxhdGl2ZVBhdGg6IHN0cmluZzsgb2xkUmVsYXRpdmVQYXRoOiBzdHJpbmcgfVxuICB8IHsgdHlwZTogXCJXU1NGU19SRU5BTUVcIjsgd29ya3NwYWNlSWQ6IHN0cmluZzsgbmV3UmVsYXRpdmVQYXRoOiBzdHJpbmc7IG9sZFJlbGF0aXZlUGF0aDogc3RyaW5nIH1cbiAgfCB7IHR5cGU6IFwiV1NTRlNfVVBEQVRFXCI7IHdvcmtzcGFjZUlkOiBzdHJpbmc7IHJlbGF0aXZlUGF0aDogc3RyaW5nIH1cbiAgfCB7IHR5cGU6IFwiV1NTRlNfREVMRVRFXCI7IHdvcmtzcGFjZUlkOiBzdHJpbmc7IHJlbGF0aXZlUGF0aDogc3RyaW5nIH07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjIgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRnNGbHVzaE1hbmFnZXIgfSBmcm9tIFwiLi4vc2VydmljZXMvRnNGbHVzaE1hbmFnZXJcIjtcbmltcG9ydCB7IEdpdFNlcnZpY2UgfSBmcm9tIFwiLi4vc2VydmljZXMvR2l0U2VydmljZVwiO1xuaW1wb3J0IHsgU3RvcmFnZVNlcnZpY2UgfSBmcm9tIFwiLi4vc2VydmljZXMvU3RvcmFnZVNlcnZpY2VcIjtcbmltcG9ydCB7IFdvcmtzcGFjZURlc2NyaXB0b3JGc1NlcnZpY2UgfSBmcm9tIFwiLi4vc2VydmljZXMvV29ya3NwYWNlRGVzY3JpcHRvckZzU2VydmljZVwiO1xuaW1wb3J0IHsgV29ya3NwYWNlRGVzY3JpcHRvclNlcnZpY2UgfSBmcm9tIFwiLi4vc2VydmljZXMvV29ya3NwYWNlRGVzY3JpcHRvclNlcnZpY2VcIjtcbmltcG9ydCB7IFdvcmtzcGFjZUZzU2VydmljZSB9IGZyb20gXCIuLi9zZXJ2aWNlcy9Xb3Jrc3BhY2VGc1NlcnZpY2VcIjtcbmltcG9ydCB7IFdvcmtzcGFjZVNlcnZpY2UgfSBmcm9tIFwiLi4vc2VydmljZXMvV29ya3NwYWNlU2VydmljZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFdvcmtzcGFjZVNlcnZpY2VzIHtcbiAgZnNGbHVzaE1hbmFnZXI6IEZzRmx1c2hNYW5hZ2VyO1xuICBzdG9yYWdlU2VydmljZTogU3RvcmFnZVNlcnZpY2U7XG4gIHdvcmtzcGFjZVNlcnZpY2U6IFdvcmtzcGFjZVNlcnZpY2U7XG4gIHdvcmtzcGFjZUZzU2VydmljZTogV29ya3NwYWNlRnNTZXJ2aWNlO1xuICBkZXNjcmlwdG9yU2VydmljZTogV29ya3NwYWNlRGVzY3JpcHRvclNlcnZpY2U7XG4gIGRlc2NyaXB0b3JzRnNTZXJ2aWNlOiBXb3Jrc3BhY2VEZXNjcmlwdG9yRnNTZXJ2aWNlO1xuICBnaXRTZXJ2aWNlOiBHaXRTZXJ2aWNlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZVNlcnZpY2VzQXJncyB7XG4gIGdpdENvcnNQcm94eVVybDogUHJvbWlzZTxzdHJpbmc+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlV29ya3NwYWNlU2VydmljZXMoYXJnczogQ3JlYXRlU2VydmljZXNBcmdzKTogV29ya3NwYWNlU2VydmljZXMge1xuICBjb25zdCBmc0ZsdXNoTWFuYWdlciA9IG5ldyBGc0ZsdXNoTWFuYWdlcigpO1xuICBjb25zdCBzdG9yYWdlU2VydmljZSA9IG5ldyBTdG9yYWdlU2VydmljZSgpO1xuICBjb25zdCB3b3Jrc3BhY2VGc1NlcnZpY2UgPSBuZXcgV29ya3NwYWNlRnNTZXJ2aWNlKGZzRmx1c2hNYW5hZ2VyKTtcbiAgY29uc3QgZGVzY3JpcHRvcnNGc1NlcnZpY2UgPSBuZXcgV29ya3NwYWNlRGVzY3JpcHRvckZzU2VydmljZShmc0ZsdXNoTWFuYWdlcik7XG4gIGNvbnN0IGRlc2NyaXB0b3JTZXJ2aWNlID0gbmV3IFdvcmtzcGFjZURlc2NyaXB0b3JTZXJ2aWNlKGRlc2NyaXB0b3JzRnNTZXJ2aWNlLCBzdG9yYWdlU2VydmljZSk7XG4gIGNvbnN0IGdpdFNlcnZpY2UgPSBuZXcgR2l0U2VydmljZShhcmdzLmdpdENvcnNQcm94eVVybCk7XG4gIGNvbnN0IHdvcmtzcGFjZVNlcnZpY2UgPSBuZXcgV29ya3NwYWNlU2VydmljZShcbiAgICBzdG9yYWdlU2VydmljZSxcbiAgICBkZXNjcmlwdG9yc0ZzU2VydmljZSxcbiAgICBkZXNjcmlwdG9yU2VydmljZSxcbiAgICB3b3Jrc3BhY2VGc1NlcnZpY2VcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIGZzRmx1c2hNYW5hZ2VyLFxuICAgIHN0b3JhZ2VTZXJ2aWNlLFxuICAgIHdvcmtzcGFjZUZzU2VydmljZSxcbiAgICBkZXNjcmlwdG9yc0ZzU2VydmljZSxcbiAgICBkZXNjcmlwdG9yU2VydmljZSxcbiAgICB3b3Jrc3BhY2VTZXJ2aWNlLFxuICAgIGdpdFNlcnZpY2UsXG4gIH07XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjIgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRW52ZWxvcGVCdXNNZXNzYWdlTWFuYWdlciB9IGZyb20gXCJAa2llLXRvb2xzLWNvcmUvZW52ZWxvcGUtYnVzL2Rpc3QvY29tbW9uXCI7XG5pbXBvcnQgeyBGc0ZsdXNoTWFuYWdlciB9IGZyb20gXCIuLi9zZXJ2aWNlcy9Gc0ZsdXNoTWFuYWdlclwiO1xuaW1wb3J0IHsgV29ya3NwYWNlc1dvcmtlckFwaSB9IGZyb20gXCIuL2FwaS9Xb3Jrc3BhY2VzV29ya2VyQXBpXCI7XG5pbXBvcnQgeyBXb3Jrc3BhY2VzV29ya2VyQ2hhbm5lbEFwaSB9IGZyb20gXCIuL2FwaS9Xb3Jrc3BhY2VzV29ya2VyQ2hhbm5lbEFwaVwiO1xuaW1wb3J0IHsgV29ya3NwYWNlc1dvcmtlckFwaUltcGwgfSBmcm9tIFwiLi9Xb3Jrc3BhY2VzV29ya2VyQXBpSW1wbFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBXb3JrZXJDb25uZWN0aW9uKGFyZ3M6IHtcbiAgYXBpSW1wbDogV29ya3NwYWNlc1dvcmtlckFwaUltcGw7XG4gIHBvcnQ6IE1lc3NhZ2VQb3J0O1xuICBmc0ZsdXNoTWFuYWdlcjogRnNGbHVzaE1hbmFnZXI7XG59KSB7XG4gIGNvbnN0IGJ1cyA9IG5ldyBFbnZlbG9wZUJ1c01lc3NhZ2VNYW5hZ2VyPFdvcmtzcGFjZXNXb3JrZXJBcGksIFdvcmtzcGFjZXNXb3JrZXJDaGFubmVsQXBpPigobSkgPT5cbiAgICBhcmdzLnBvcnQucG9zdE1lc3NhZ2UobSlcbiAgKTtcbiAgYXJncy5wb3J0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChtZXNzYWdlKSA9PiBidXMuc2VydmVyLnJlY2VpdmUobWVzc2FnZS5kYXRhLCBhcmdzLmFwaUltcGwpKTtcbiAgYXJncy5wb3J0LnN0YXJ0KCk7IC8vIFJlcXVpcmVkIHdoZW4gdXNpbmcgYWRkRXZlbnRMaXN0ZW5lci4gT3RoZXJ3aXNlLCBjYWxsZWQgaW1wbGljaXRseSBieSBvbm1lc3NhZ2Ugc2V0dGVyLlxuICBidXMuY2xpZW50QXBpLm5vdGlmaWNhdGlvbnMua2llVG9vbHNXb3Jrc3BhY2VzV29ya2VyX3JlYWR5LnNlbmQoKTtcblxuICBjb25zdCBmbHVzaE1hbmFnZXJTdWJzY3JpcHRpb24gPSBhcmdzLmZzRmx1c2hNYW5hZ2VyLnN1YnNjcmliYWJsZS5zdWJzY3JpYmUoKGZsdXNoZXMpID0+IHtcbiAgICBidXMuc2hhcmVkLmtpZVNhbmRib3hXb3Jrc3BhY2VzU3RvcmFnZV9mbHVzaGVzLnNldChmbHVzaGVzKTtcbiAgfSk7XG5cbiAgY29uc3Qga2VlcGFsaXZlID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIGxldCBwaW5nOiBcInBpbmdcIiB8IFwicG9uZ1wiID0gXCJwaW5nXCI7XG4gICAgYnVzLmNsaWVudEFwaS5yZXF1ZXN0cy5raWVUb29sc1dvcmtzcGFjZXNXb3JrZXJfcGluZygpLnRoZW4oKHBvbmcpID0+IChwaW5nID0gcG9uZykpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHBpbmcgIT09IFwicG9uZ1wiKSB7XG4gICAgICAgIC8vIFRoaXMgY29ubmVjdGlvbiBpcyBubyBsb25nZXIgYWN0aXZlLCBhcyB0aGUgY29ycmVzcG9uZGluZyBidXMgZGlkIG5vdCByZXNwb25kIGluIDIwMG1zLiBUZWFyIGl0IGRvd24uXG4gICAgICAgIGNvbnNvbGUubG9nKFwiRGlzY29ubmVjdGluZyBmcm9tIFdvcmtzcGFjZXMgU2hhcmVkIFdvcmtlclwiKTtcbiAgICAgICAgYXJncy5wb3J0LmNsb3NlKCk7XG4gICAgICAgIGFyZ3MuZnNGbHVzaE1hbmFnZXIuc3Vic2NyaWJhYmxlLnVuc3Vic2NyaWJlKGZsdXNoTWFuYWdlclN1YnNjcmlwdGlvbik7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoa2VlcGFsaXZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJDb25uZWN0aW9uIGlzIHN0aWxsIGFsaXZlLlwiKTtcbiAgICAgIH1cbiAgICB9LCAyMDApOyAvLyBwb25nIHRpbWVvdXRcbiAgfSwgNjAwMDApOyAvLyBpbnRlcnZhbCBmb3Iga2VlcGFsaXZlIGNoZWNrXG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjIgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IEFQUF9OQU1FID0gXCJTZXJ2ZXJsZXNzIExvZ2ljIFdlYiBUb29sc1wiO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDIyIFJlZCBIYXQsIEluYy4gYW5kL29yIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBFTlZfRklMRV9QQVRIID0gXCJlbnYuanNvblwiO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDIyIFJlZCBIYXQsIEluYy4gYW5kL29yIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gIEVkaXRvckVudmVsb3BlTG9jYXRvcixcbiAgRW52ZWxvcGVDb250ZW50VHlwZSxcbiAgRW52ZWxvcGVNYXBwaW5nLFxufSBmcm9tIFwiQGtpZS10b29scy1jb3JlL2VkaXRvci9kaXN0L2FwaS9FZGl0b3JFbnZlbG9wZUxvY2F0b3JcIjtcbmltcG9ydCB7IEdMT0JfUEFUVEVSTiB9IGZyb20gXCIuLi9leHRlbnNpb25cIjtcblxuZXhwb3J0IGNsYXNzIEVkaXRvckVudmVsb3BlTG9jYXRvckZhY3Rvcnkge1xuICBwdWJsaWMgY3JlYXRlKGFyZ3M6IHsgdGFyZ2V0T3JpZ2luOiBzdHJpbmcgfSkge1xuICAgIHJldHVybiBuZXcgRWRpdG9yRW52ZWxvcGVMb2NhdG9yKGFyZ3MudGFyZ2V0T3JpZ2luLCBbXG4gICAgICBuZXcgRW52ZWxvcGVNYXBwaW5nKHtcbiAgICAgICAgdHlwZTogXCJzd2ZcIixcbiAgICAgICAgZmlsZVBhdGhHbG9iOiBHTE9CX1BBVFRFUk4uc3csXG4gICAgICAgIHJlc291cmNlc1BhdGhQcmVmaXg6IFwiLlwiLFxuICAgICAgICBlbnZlbG9wZUNvbnRlbnQ6IHsgdHlwZTogRW52ZWxvcGVDb250ZW50VHlwZS5QQVRILCBwYXRoOiBcInNlcnZlcmxlc3Mtd29ya2Zsb3ctY29tYmluZWQtZWRpdG9yLWVudmVsb3BlLmh0bWxcIiB9LFxuICAgICAgfSksXG4gICAgICBuZXcgRW52ZWxvcGVNYXBwaW5nKHtcbiAgICAgICAgdHlwZTogXCJkYXNoXCIsXG4gICAgICAgIGZpbGVQYXRoR2xvYjogR0xPQl9QQVRURVJOLmRhc2gsXG4gICAgICAgIHJlc291cmNlc1BhdGhQcmVmaXg6IFwiXCIsXG4gICAgICAgIGVudmVsb3BlQ29udGVudDogeyB0eXBlOiBFbnZlbG9wZUNvbnRlbnRUeXBlLlBBVEgsIHBhdGg6IFwiZGFzaGJ1aWxkZXItZWRpdG9yLWVudmVsb3BlLmh0bWxcIiB9LFxuICAgICAgfSksXG4gICAgICBuZXcgRW52ZWxvcGVNYXBwaW5nKHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgIGZpbGVQYXRoR2xvYjogR0xPQl9QQVRURVJOLmFsbCxcbiAgICAgICAgcmVzb3VyY2VzUGF0aFByZWZpeDogXCJcIixcbiAgICAgICAgZW52ZWxvcGVDb250ZW50OiB7IHR5cGU6IEVudmVsb3BlQ29udGVudFR5cGUuUEFUSCwgcGF0aDogXCJ0ZXh0LWVkaXRvci1lbnZlbG9wZS5odG1sXCIgfSxcbiAgICAgIH0pLFxuICAgIF0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMjIgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFdvcmtzcGFjZUZpbGUgfSBmcm9tIFwiQGtpZS10b29scy1jb3JlL3dvcmtzcGFjZXMtZ2l0LWZzL2Rpc3QvY29udGV4dC9Xb3Jrc3BhY2VzQ29udGV4dFwiO1xuaW1wb3J0IHsgYmFzZW5hbWUgfSBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgUFJPSkVDVF9GSUxFUyB9IGZyb20gXCIuLi9wcm9qZWN0XCI7XG5cbmNvbnN0IEVESVRfTk9OX01PREVMX0FMTE9XX0xJU1QgPSBbUFJPSkVDVF9GSUxFUy5hcHBsaWNhdGlvblByb3BlcnRpZXNdO1xuXG5jb25zdCBSRUdFWCA9IHtcbiAgc3VwcG9ydGVkOiAvKFxcLnN3XFwuanNvbnxcXC5zd1xcLnlhbWx8XFwuc3dcXC55bWx8XFwueWFyZFxcLmpzb258XFwueWFyZFxcLnlhbWx8XFwueWFyZFxcLnltbHxcXC5kYXNoXFwueW1sfFxcLmRhc2hcXC55YW1sKSQvaSxcbiAgc3c6IC9eLipcXC5zd1xcLihqc29ufHltbHx5YW1sKSQvaSxcbiAgc3dKc29uOiAvXi4qXFwuc3dcXC5qc29uJC9pLFxuICBzd1lhbWw6IC9eLipcXC5zd1xcLih5bWx8eWFtbCkkL2ksXG4gIHlhcmQ6IC9eLipcXC55YXJkXFwuKGpzb258eW1sfHlhbWwpJC9pLFxuICBkYXNoOiAvXi4qXFwuZGFzaFxcLih5bWx8eWFtbCkkL2ksXG4gIGpzb246IC9eLipcXC5qc29uJC9pLFxuICB5YW1sOiAvXi4qXFwuKHltbHx5YW1sKSQvaSxcbiAgc3BlYzogL14uKihcXC5zcGVjfFxcLnNwZWNzfHNwZWN8c3BlY3MpXFwuKGpzb258eW1sfHlhbWwpJC9pLFxufTtcblxuZXhwb3J0IGNvbnN0IEdMT0JfUEFUVEVSTiA9IHtcbiAgYWxsOiBcIioqLypcIixcbiAgYWxsRXhjZXB0RG9ja2VyZmlsZXM6IFwiKiovIShEb2NrZXJmaWxlfC5kb2NrZXJpZ25vcmUpXCIsXG4gIHN3OiBcIioqLyouc3cuKyhqc29ufHltbHx5YW1sKVwiLFxuICB5YXJkOiBcIioqLyoueWFyZC4rKGpzb258eW1sfHlhbWwpXCIsXG4gIGRhc2g6IFwiKiovKi5kYXNoLisoeW1sfHlhbWwpXCIsXG4gIHNwZWM6IFwiKiovKygqLnNwZWM/KHMpfHNwZWM/KHMpKS4rKHltbHx5YW1sfGpzb24pXCIsXG4gIHN3X3NwZWM6IFwiKiovKygqLnN3fCouc3BlYz8ocyl8c3BlYz8ocykpLisoeW1sfHlhbWx8anNvbilcIixcbn07XG5cbmV4cG9ydCBlbnVtIEZpbGVUeXBlcyB7XG4gIFNXX0pTT04gPSBcInN3Lmpzb25cIixcbiAgU1dfWU1MID0gXCJzdy55bWxcIixcbiAgU1dfWUFNTCA9IFwic3cueWFtbFwiLFxuICBZQVJEX0pTT04gPSBcInlhcmQuanNvblwiLFxuICBZQVJEX1lNTCA9IFwieWFyZC55bWxcIixcbiAgWUFSRF9ZQU1MID0gXCJ5YXJkLnlhbWxcIixcbiAgREFTSF9ZQU1MID0gXCJkYXNoLnlhbWxcIixcbiAgREFTSF9ZTUwgPSBcImRhc2gueW1sXCIsXG59XG5cbmV4cG9ydCBjb25zdCBzdXBwb3J0ZWRGaWxlRXh0ZW5zaW9uQXJyYXkgPSBbXG4gIEZpbGVUeXBlcy5TV19KU09OLFxuICBGaWxlVHlwZXMuU1dfWU1MLFxuICBGaWxlVHlwZXMuU1dfWUFNTCxcbiAgRmlsZVR5cGVzLllBUkRfSlNPTixcbiAgRmlsZVR5cGVzLllBUkRfWU1MLFxuICBGaWxlVHlwZXMuWUFSRF9ZQU1MLFxuICBGaWxlVHlwZXMuREFTSF9ZQU1MLFxuICBGaWxlVHlwZXMuREFTSF9ZTUwsXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTZXJ2ZXJsZXNzV29ya2Zsb3cocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBSRUdFWC5zdy50ZXN0KHBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTZXJ2ZXJsZXNzV29ya2Zsb3dKc29uKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gUkVHRVguc3dKc29uLnRlc3QocGF0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NlcnZlcmxlc3NXb3JrZmxvd1lhbWwocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBSRUdFWC5zd1lhbWwudGVzdChwYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2VydmVybGVzc0RlY2lzaW9uKHBhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gUkVHRVgueWFyZC50ZXN0KHBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEYXNoYnVpbGRlcihwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIFJFR0VYLmRhc2gudGVzdChwYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTW9kZWwocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBpc1NlcnZlcmxlc3NXb3JrZmxvdyhwYXRoKSB8fCBpc1NlcnZlcmxlc3NEZWNpc2lvbihwYXRoKSB8fCBpc0Rhc2hidWlsZGVyKHBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFZGl0YWJsZShwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzTW9kZWwocGF0aCkgfHwgRURJVF9OT05fTU9ERUxfQUxMT1dfTElTVC5pbmNsdWRlcyhiYXNlbmFtZShwYXRoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N1cHBvcnRlZEJ5VmlydHVhbFNlcnZpY2VSZWdpc3RyeShwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIGlzU2VydmVybGVzc1dvcmtmbG93KHBhdGgpIHx8IGlzU3BlYyhwYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU3BlYyhwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIFJFR0VYLnNwZWMudGVzdChwYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSnNvbihwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIFJFR0VYLmpzb24udGVzdChwYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzWWFtbChwYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIFJFR0VYLnlhbWwudGVzdChwYXRoKTtcbn1cblxuZXhwb3J0IHR5cGUgU3VwcG9ydGVkRmlsZUV4dGVuc2lvbnMgPSB0eXBlb2Ygc3VwcG9ydGVkRmlsZUV4dGVuc2lvbkFycmF5W251bWJlcl07XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdEZpbGVzKGZpbGVzOiBXb3Jrc3BhY2VGaWxlW10pOiB7XG4gIGVkaXRhYmxlRmlsZXM6IFdvcmtzcGFjZUZpbGVbXTtcbiAgcmVhZG9ubHlGaWxlczogV29ya3NwYWNlRmlsZVtdO1xufSB7XG4gIGNvbnN0IFtlZGl0YWJsZUZpbGVzLCByZWFkb25seUZpbGVzXSA9IGZpbGVzLnJlZHVjZShcbiAgICAoW2VkaXRhYmxlRmlsZXMsIHJlYWRvbmx5RmlsZXNdLCBmOiBXb3Jrc3BhY2VGaWxlKSA9PlxuICAgICAgaXNFZGl0YWJsZShmLnJlbGF0aXZlUGF0aCkgPyBbWy4uLmVkaXRhYmxlRmlsZXMsIGZdLCByZWFkb25seUZpbGVzXSA6IFtlZGl0YWJsZUZpbGVzLCBbLi4ucmVhZG9ubHlGaWxlcywgZl1dLFxuICAgIFtbXSwgW11dXG4gICk7XG4gIHJldHVybiB7IGVkaXRhYmxlRmlsZXMsIHJlYWRvbmx5RmlsZXMgfTtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgV29ya3NwYWNlRmlsZSB9IGZyb20gXCJAa2llLXRvb2xzLWNvcmUvd29ya3NwYWNlcy1naXQtZnMvZGlzdC9jb250ZXh0L1dvcmtzcGFjZXNDb250ZXh0XCI7XG5cbmV4cG9ydCBjb25zdCBQUk9KRUNUX0ZJTEVTID0ge1xuICBwb21YbWw6IFwicG9tLnhtbFwiLFxuICBhcHBsaWNhdGlvblByb3BlcnRpZXM6IFwiYXBwbGljYXRpb24ucHJvcGVydGllc1wiLFxuICBkb2NrZXJGaWxlOiBcIkRvY2tlcmZpbGVcIixcbiAgZG9ja2VySWdub3JlOiBcIi5kb2NrZXJpZ25vcmVcIixcbiAga29naXRvWW1sOiBcImtvZ2l0by55bWxcIixcbiAgcXVhcmt1c1J1bkphcjogXCJxdWFya3VzLXJ1bi5qYXJcIixcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Byb2plY3QoZmlsZXM6IFdvcmtzcGFjZUZpbGVbXSk6IGJvb2xlYW4ge1xuICByZXR1cm4gISFmaWxlcy5zb21lKChmKSA9PiBmLnJlbGF0aXZlUGF0aCA9PT0gUFJPSkVDVF9GSUxFUy5wb21YbWwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTaW5nbGVNb2R1bGVQcm9qZWN0KGZpbGVzOiBXb3Jrc3BhY2VGaWxlW10pOiBib29sZWFuIHtcbiAgY29uc3QgcG9tRmlsZXMgPSBmaWxlcy5maWx0ZXIoKGYpID0+IGYubmFtZSA9PT0gUFJPSkVDVF9GSUxFUy5wb21YbWwpO1xuICByZXR1cm4gcG9tRmlsZXMubGVuZ3RoID09PSAxICYmIHBvbUZpbGVzWzBdLnJlbGF0aXZlRGlyUGF0aCA9PT0gXCJcIjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm9qZWN0UGF0aHMge1xuICBmb2xkZXJzOiB7XG4gICAgcm9vdDogc3RyaW5nO1xuICAgIG1haW5SZXNvdXJjZXM6IHN0cmluZztcbiAgICBtZXRhSW5mUmVzb3VyY2VzOiBzdHJpbmc7XG4gICAga3ViZXJuZXRlczogc3RyaW5nO1xuICAgIHF1YXJrdXNBcHA6IHN0cmluZztcbiAgfTtcbiAgZmlsZXM6IHtcbiAgICBwb21YbWw6IHN0cmluZztcbiAgICBrb2dpdG9ZYW1sOiBzdHJpbmc7XG4gICAgcXVhcmt1c1J1bkphcjogc3RyaW5nO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgYnVpbGRQcm9qZWN0UGF0aHMgPSAocHJvamVjdEZvbGRlcjogc3RyaW5nKTogUHJvamVjdFBhdGhzID0+ICh7XG4gIGZvbGRlcnM6IHtcbiAgICByb290OiBgJHtwcm9qZWN0Rm9sZGVyfWAsXG4gICAgbWFpblJlc291cmNlczogYCR7cHJvamVjdEZvbGRlcn0vc3JjL21haW4vcmVzb3VyY2VzYCxcbiAgICBtZXRhSW5mUmVzb3VyY2VzOiBgJHtwcm9qZWN0Rm9sZGVyfS9zcmMvbWFpbi9yZXNvdXJjZXMvTUVUQS1JTkYvcmVzb3VyY2VzYCxcbiAgICBrdWJlcm5ldGVzOiBgJHtwcm9qZWN0Rm9sZGVyfS90YXJnZXQva3ViZXJuZXRlc2AsXG4gICAgcXVhcmt1c0FwcDogYCR7cHJvamVjdEZvbGRlcn0vdGFyZ2V0L3F1YXJrdXMtYXBwYCxcbiAgfSxcbiAgZmlsZXM6IHtcbiAgICBwb21YbWw6IGAke3Byb2plY3RGb2xkZXJ9LyR7UFJPSkVDVF9GSUxFUy5wb21YbWx9YCxcbiAgICBrb2dpdG9ZYW1sOiBgJHtwcm9qZWN0Rm9sZGVyfS90YXJnZXQva3ViZXJuZXRlcy8ke1BST0pFQ1RfRklMRVMua29naXRvWW1sfWAsXG4gICAgcXVhcmt1c1J1bkphcjogYCR7cHJvamVjdEZvbGRlcn0vdGFyZ2V0L3F1YXJrdXMtYXBwLyR7UFJPSkVDVF9GSUxFUy5xdWFya3VzUnVuSmFyfWAsXG4gIH0sXG59KTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRE9DS0VSX0lHTk9SRV9DT05URU5UID0gYFxuJHtQUk9KRUNUX0ZJTEVTLmRvY2tlckZpbGV9XG5gO1xuIiwiLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBHaXRQcm9ncmVzc0V2ZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGhhc2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb2FkZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3RhbFxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFByb2dyZXNzQ2FsbGJhY2tcbiAqIEBwYXJhbSB7R2l0UHJvZ3Jlc3NFdmVudH0gcHJvZ3Jlc3NcbiAqIEByZXR1cm5zIHt2b2lkIHwgUHJvbWlzZTx2b2lkPn1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdpdEh0dHBSZXF1ZXN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXJsIC0gVGhlIFVSTCB0byByZXF1ZXN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21ldGhvZD0nR0VUJ10gLSBUaGUgSFRUUCBtZXRob2QgdG8gdXNlXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIHN0cmluZz59IFtoZWFkZXJzPXt9XSAtIEhlYWRlcnMgdG8gaW5jbHVkZSBpbiB0aGUgSFRUUCByZXF1ZXN0XG4gKiBAcHJvcGVydHkge0FzeW5jSXRlcmFibGVJdGVyYXRvcjxVaW50OEFycmF5Pn0gW2JvZHldIC0gQW4gYXN5bmMgaXRlcmF0b3Igb2YgVWludDhBcnJheXMgdGhhdCBtYWtlIHVwIHRoZSBib2R5IG9mIFBPU1QgcmVxdWVzdHNcbiAqIEBwcm9wZXJ0eSB7UHJvZ3Jlc3NDYWxsYmFja30gW29uUHJvZ3Jlc3NdIC0gUmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgKGVtaXR0aW5nIGBHaXRQcm9ncmVzc0V2ZW50YHMpXG4gKiBAcHJvcGVydHkge29iamVjdH0gW3NpZ25hbF0gLSBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSAoY2FuY2VsaW5nIGEgcmVxdWVzdClcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdpdEh0dHBSZXNwb25zZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVybCAtIFRoZSBmaW5hbCBVUkwgdGhhdCB3YXMgZmV0Y2hlZCBhZnRlciBhbnkgcmVkaXJlY3RzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21ldGhvZF0gLSBUaGUgSFRUUCBtZXRob2QgdGhhdCB3YXMgdXNlZFxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbaGVhZGVyc10gLSBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcm9wZXJ0eSB7QXN5bmNJdGVyYWJsZUl0ZXJhdG9yPFVpbnQ4QXJyYXk+fSBbYm9keV0gLSBBbiBhc3luYyBpdGVyYXRvciBvZiBVaW50OEFycmF5cyB0aGF0IG1ha2UgdXAgdGhlIGJvZHkgb2YgdGhlIHJlc3BvbnNlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhdHVzQ29kZSAtIFRoZSBIVFRQIHN0YXR1cyBjb2RlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdHVzTWVzc2FnZSAtIFRoZSBIVFRQIHN0YXR1cyBtZXNzYWdlXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgSHR0cEZldGNoXG4gKiBAcGFyYW0ge0dpdEh0dHBSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHaXRIdHRwUmVzcG9uc2U+fVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSHR0cENsaWVudFxuICogQHByb3BlcnR5IHtIdHRwRmV0Y2h9IHJlcXVlc3RcbiAqL1xuXG4vLyBDb252ZXJ0IGEgdmFsdWUgdG8gYW4gQXN5bmMgSXRlcmF0b3Jcbi8vIFRoaXMgd2lsbCBiZSBlYXNpZXIgd2l0aCBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb25zLlxuZnVuY3Rpb24gZnJvbVZhbHVlKHZhbHVlKSB7XG4gIGxldCBxdWV1ZSA9IFt2YWx1ZV07XG4gIHJldHVybiB7XG4gICAgbmV4dCgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiBxdWV1ZS5sZW5ndGggPT09IDAsIHZhbHVlOiBxdWV1ZS5wb3AoKSB9KVxuICAgIH0sXG4gICAgcmV0dXJuKCkge1xuICAgICAgcXVldWUgPSBbXTtcbiAgICAgIHJldHVybiB7fVxuICAgIH0sXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRJdGVyYXRvcihpdGVyYWJsZSkge1xuICBpZiAoaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKSB7XG4gICAgcmV0dXJuIGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpXG4gIH1cbiAgaWYgKGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICByZXR1cm4gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpXG4gIH1cbiAgaWYgKGl0ZXJhYmxlLm5leHQpIHtcbiAgICByZXR1cm4gaXRlcmFibGVcbiAgfVxuICByZXR1cm4gZnJvbVZhbHVlKGl0ZXJhYmxlKVxufVxuXG4vLyBDdXJyZW50bHkgJ2ZvciBhd2FpdCcgdXBzZXRzIG15IGxpbnRlcnMuXG5hc3luYyBmdW5jdGlvbiBmb3JBd2FpdChpdGVyYWJsZSwgY2IpIHtcbiAgY29uc3QgaXRlciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpdGVyLm5leHQoKTtcbiAgICBpZiAodmFsdWUpIGF3YWl0IGNiKHZhbHVlKTtcbiAgICBpZiAoZG9uZSkgYnJlYWtcbiAgfVxuICBpZiAoaXRlci5yZXR1cm4pIGl0ZXIucmV0dXJuKCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbGxlY3QoaXRlcmFibGUpIHtcbiAgbGV0IHNpemUgPSAwO1xuICBjb25zdCBidWZmZXJzID0gW107XG4gIC8vIFRoaXMgd2lsbCBiZSBlYXNpZXIgb25jZSBgZm9yIGF3YWl0IC4uLiBvZmAgbG9vcHMgYXJlIGF2YWlsYWJsZS5cbiAgYXdhaXQgZm9yQXdhaXQoaXRlcmFibGUsIHZhbHVlID0+IHtcbiAgICBidWZmZXJzLnB1c2godmFsdWUpO1xuICAgIHNpemUgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgIHJlc3VsdC5zZXQoYnVmZmVyLCBuZXh0SW5kZXgpO1xuICAgIG5leHRJbmRleCArPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIENvbnZlcnQgYSB3ZWIgUmVhZGFibGVTdHJlYW0gKG5vdCBOb2RlIHN0cmVhbSEpIHRvIGFuIEFzeW5jIEl0ZXJhdG9yXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9qYWtlYXJjaGliYWxkLmNvbS8yMDE3L2FzeW5jLWl0ZXJhdG9ycy1hbmQtZ2VuZXJhdG9ycy9cbmZ1bmN0aW9uIGZyb21TdHJlYW0oc3RyZWFtKSB7XG4gIC8vIFVzZSBuYXRpdmUgYXN5bmMgaXRlcmF0aW9uIGlmIGl0J3MgYXZhaWxhYmxlLlxuICBpZiAoc3RyZWFtW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkgcmV0dXJuIHN0cmVhbVxuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIHJldHVybiB7XG4gICAgbmV4dCgpIHtcbiAgICAgIHJldHVybiByZWFkZXIucmVhZCgpXG4gICAgfSxcbiAgICByZXR1cm4oKSB7XG4gICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIHJldHVybiB7fVxuICAgIH0sXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgfVxufVxuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBIdHRwQ2xpZW50XG4gKlxuICogQHBhcmFtIHtHaXRIdHRwUmVxdWVzdH0gcmVxdWVzdFxuICogQHJldHVybnMge1Byb21pc2U8R2l0SHR0cFJlc3BvbnNlPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVxdWVzdCh7XG4gIG9uUHJvZ3Jlc3MsXG4gIHVybCxcbiAgbWV0aG9kID0gJ0dFVCcsXG4gIGhlYWRlcnMgPSB7fSxcbiAgYm9keSxcbn0pIHtcbiAgLy8gc3RyZWFtaW5nIHVwbG9hZHMgYXJlbid0IHBvc3NpYmxlIHlldCBpbiB0aGUgYnJvd3NlclxuICBpZiAoYm9keSkge1xuICAgIGJvZHkgPSBhd2FpdCBjb2xsZWN0KGJvZHkpO1xuICB9XG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgeyBtZXRob2QsIGhlYWRlcnMsIGJvZHkgfSk7XG4gIGNvbnN0IGl0ZXIgPVxuICAgIHJlcy5ib2R5ICYmIHJlcy5ib2R5LmdldFJlYWRlclxuICAgICAgPyBmcm9tU3RyZWFtKHJlcy5ib2R5KVxuICAgICAgOiBbbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzLmFycmF5QnVmZmVyKCkpXTtcbiAgLy8gY29udmVydCBIZWFkZXIgb2JqZWN0IHRvIG9yZGluYXJ5IEpTT05cbiAgaGVhZGVycyA9IHt9O1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiByZXMuaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHVybDogcmVzLnVybCxcbiAgICBtZXRob2Q6IHJlcy5tZXRob2QsXG4gICAgc3RhdHVzQ29kZTogcmVzLnN0YXR1cyxcbiAgICBzdGF0dXNNZXNzYWdlOiByZXMuc3RhdHVzVGV4dCxcbiAgICBib2R5OiBpdGVyLFxuICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gIH1cbn1cblxudmFyIGluZGV4ID0geyByZXF1ZXN0IH07XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuZXhwb3J0IHsgcmVxdWVzdCB9O1xuIiwiaW1wb3J0IEFzeW5jTG9jayBmcm9tICdhc3luYy1sb2NrJztcbmltcG9ydCBIYXNoIGZyb20gJ3NoYS5qcy9zaGExLmpzJztcbmltcG9ydCBjcmMzMiBmcm9tICdjcmMtMzInO1xuaW1wb3J0IHBha28gZnJvbSAncGFrbyc7XG5pbXBvcnQgaWdub3JlIGZyb20gJ2lnbm9yZSc7XG5pbXBvcnQgcGlmeSBmcm9tICdwaWZ5JztcbmltcG9ydCBjbGVhbkdpdFJlZiBmcm9tICdjbGVhbi1naXQtcmVmJztcbmltcG9ydCBkaWZmM01lcmdlIGZyb20gJ2RpZmYzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBHaXRQcm9ncmVzc0V2ZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGhhc2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb2FkZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0b3RhbFxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFByb2dyZXNzQ2FsbGJhY2tcbiAqIEBwYXJhbSB7R2l0UHJvZ3Jlc3NFdmVudH0gcHJvZ3Jlc3NcbiAqIEByZXR1cm5zIHt2b2lkIHwgUHJvbWlzZTx2b2lkPn1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdpdEh0dHBSZXF1ZXN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gdXJsIC0gVGhlIFVSTCB0byByZXF1ZXN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21ldGhvZD0nR0VUJ10gLSBUaGUgSFRUUCBtZXRob2QgdG8gdXNlXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIHN0cmluZz59IFtoZWFkZXJzPXt9XSAtIEhlYWRlcnMgdG8gaW5jbHVkZSBpbiB0aGUgSFRUUCByZXF1ZXN0XG4gKiBAcHJvcGVydHkge0FzeW5jSXRlcmFibGVJdGVyYXRvcjxVaW50OEFycmF5Pn0gW2JvZHldIC0gQW4gYXN5bmMgaXRlcmF0b3Igb2YgVWludDhBcnJheXMgdGhhdCBtYWtlIHVwIHRoZSBib2R5IG9mIFBPU1QgcmVxdWVzdHNcbiAqIEBwcm9wZXJ0eSB7UHJvZ3Jlc3NDYWxsYmFja30gW29uUHJvZ3Jlc3NdIC0gUmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgKGVtaXR0aW5nIGBHaXRQcm9ncmVzc0V2ZW50YHMpXG4gKiBAcHJvcGVydHkge29iamVjdH0gW3NpZ25hbF0gLSBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSAoY2FuY2VsaW5nIGEgcmVxdWVzdClcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdpdEh0dHBSZXNwb25zZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVybCAtIFRoZSBmaW5hbCBVUkwgdGhhdCB3YXMgZmV0Y2hlZCBhZnRlciBhbnkgcmVkaXJlY3RzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21ldGhvZF0gLSBUaGUgSFRUUCBtZXRob2QgdGhhdCB3YXMgdXNlZFxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbaGVhZGVyc10gLSBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcm9wZXJ0eSB7QXN5bmNJdGVyYWJsZUl0ZXJhdG9yPFVpbnQ4QXJyYXk+fSBbYm9keV0gLSBBbiBhc3luYyBpdGVyYXRvciBvZiBVaW50OEFycmF5cyB0aGF0IG1ha2UgdXAgdGhlIGJvZHkgb2YgdGhlIHJlc3BvbnNlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RhdHVzQ29kZSAtIFRoZSBIVFRQIHN0YXR1cyBjb2RlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3RhdHVzTWVzc2FnZSAtIFRoZSBIVFRQIHN0YXR1cyBtZXNzYWdlXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgSHR0cEZldGNoXG4gKiBAcGFyYW0ge0dpdEh0dHBSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZTxHaXRIdHRwUmVzcG9uc2U+fVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSHR0cENsaWVudFxuICogQHByb3BlcnR5IHtIdHRwRmV0Y2h9IHJlcXVlc3RcbiAqL1xuXG4vKipcbiAqIEEgZ2l0IGNvbW1pdCBvYmplY3QuXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29tbWl0T2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSBDb21taXQgbWVzc2FnZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRyZWUgU0hBLTEgb2JqZWN0IGlkIG9mIGNvcnJlc3BvbmRpbmcgZmlsZSB0cmVlXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBwYXJlbnQgYW4gYXJyYXkgb2YgemVybyBvciBtb3JlIFNIQS0xIG9iamVjdCBpZHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBhdXRob3JcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdXRob3IubmFtZSBUaGUgYXV0aG9yJ3MgbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGF1dGhvci5lbWFpbCBUaGUgYXV0aG9yJ3MgZW1haWxcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhdXRob3IudGltZXN0YW1wIFVUQyBVbml4IHRpbWVzdGFtcCBpbiBzZWNvbmRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gYXV0aG9yLnRpbWV6b25lT2Zmc2V0IFRpbWV6b25lIGRpZmZlcmVuY2UgZnJvbSBVVEMgaW4gbWludXRlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGNvbW1pdHRlclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbW1pdHRlci5uYW1lIFRoZSBjb21taXR0ZXIncyBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29tbWl0dGVyLmVtYWlsIFRoZSBjb21taXR0ZXIncyBlbWFpbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbW1pdHRlci50aW1lc3RhbXAgVVRDIFVuaXggdGltZXN0YW1wIGluIHNlY29uZHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb21taXR0ZXIudGltZXpvbmVPZmZzZXQgVGltZXpvbmUgZGlmZmVyZW5jZSBmcm9tIFVUQyBpbiBtaW51dGVzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2dwZ3NpZ10gUEdQIHNpZ25hdHVyZSAoaWYgcHJlc2VudClcbiAqL1xuXG4vKipcbiAqIEFuIGVudHJ5IGZyb20gYSBnaXQgdHJlZSBvYmplY3QuIEZpbGVzIGFyZSBjYWxsZWQgJ2Jsb2JzJyBhbmQgZGlyZWN0b3JpZXMgYXJlIGNhbGxlZCAndHJlZXMnLlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRyZWVFbnRyeVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1vZGUgdGhlIDYgZGlnaXQgaGV4YWRlY2ltYWwgbW9kZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBhdGggdGhlIG5hbWUgb2YgdGhlIGZpbGUgb3IgZGlyZWN0b3J5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkIHRoZSBTSEEtMSBvYmplY3QgaWQgb2YgdGhlIGJsb2Igb3IgdHJlZVxuICogQHByb3BlcnR5IHsnY29tbWl0J3wnYmxvYid8J3RyZWUnfSB0eXBlIHRoZSB0eXBlIG9mIG9iamVjdFxuICovXG5cbi8qKlxuICogQSBnaXQgdHJlZSBvYmplY3QuIFRyZWVzIHJlcHJlc2VudCBhIGRpcmVjdG9yeSBzbmFwc2hvdC5cbiAqXG4gKiBAdHlwZWRlZiB7VHJlZUVudHJ5W119IFRyZWVPYmplY3RcbiAqL1xuXG4vKipcbiAqIEEgZ2l0IGFubm90YXRlZCB0YWcgb2JqZWN0LlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFRhZ09iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9iamVjdCBTSEEtMSBvYmplY3QgaWQgb2Ygb2JqZWN0IGJlaW5nIHRhZ2dlZFxuICogQHByb3BlcnR5IHsnYmxvYicgfCAndHJlZScgfCAnY29tbWl0JyB8ICd0YWcnfSB0eXBlIHRoZSB0eXBlIG9mIHRoZSBvYmplY3QgYmVpbmcgdGFnZ2VkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGFnIHRoZSB0YWcgbmFtZVxuICogQHByb3BlcnR5IHtPYmplY3R9IHRhZ2dlclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRhZ2dlci5uYW1lIHRoZSB0YWdnZXIncyBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdGFnZ2VyLmVtYWlsIHRoZSB0YWdnZXIncyBlbWFpbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHRhZ2dlci50aW1lc3RhbXAgVVRDIFVuaXggdGltZXN0YW1wIGluIHNlY29uZHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0YWdnZXIudGltZXpvbmVPZmZzZXQgdGltZXpvbmUgZGlmZmVyZW5jZSBmcm9tIFVUQyBpbiBtaW51dGVzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVzc2FnZSB0YWcgbWVzc2FnZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtncGdzaWddIFBHUCBzaWduYXR1cmUgKGlmIHByZXNlbnQpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZWFkQ29tbWl0UmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkIC0gU0hBLTEgb2JqZWN0IGlkIG9mIHRoaXMgY29tbWl0XG4gKiBAcHJvcGVydHkge0NvbW1pdE9iamVjdH0gY29tbWl0IC0gdGhlIHBhcnNlZCBjb21taXQgb2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF5bG9hZCAtIFBHUCBzaWduaW5nIHBheWxvYWRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlcnZlclJlZiAtIFRoaXMgb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIHNjaGVtYTpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZWYgLSBUaGUgbmFtZSBvZiB0aGUgcmVmXG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkIC0gVGhlIFNIQS0xIG9iamVjdCBpZCB0aGUgcmVmIHBvaW50cyB0b1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0YXJnZXRdIC0gVGhlIHRhcmdldCByZWYgcG9pbnRlZCB0byBieSBhIHN5bWJvbGljIHJlZlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwZWVsZWRdIC0gSWYgdGhlIG9pZCBpcyB0aGUgU0hBLTEgb2JqZWN0IGlkIG9mIGFuIGFubm90YXRlZCB0YWcsIHRoaXMgaXMgdGhlIFNIQS0xIG9iamVjdCBpZCB0aGF0IHRoZSBhbm5vdGF0ZWQgdGFnIHBvaW50cyB0b1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYgV2Fsa2VyXG4gKiBAcHJvcGVydHkge1N5bWJvbH0gU3ltYm9sKCdHaXRXYWxrZXJTeW1ib2wnKVxuICovXG5cbi8qKlxuICogTm9ybWFsaXplZCBzdWJzZXQgb2YgZmlsZXN5c3RlbSBgc3RhdGAgZGF0YTpcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0XG4gKiBAcHJvcGVydHkge251bWJlcn0gY3RpbWVTZWNvbmRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gY3RpbWVOYW5vc2Vjb25kc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG10aW1lU2Vjb25kc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG10aW1lTmFub3NlY29uZHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkZXZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbm9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb2RlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWlkXG4gKiBAcHJvcGVydHkge251bWJlcn0gZ2lkXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2l6ZVxuICovXG5cbi8qKlxuICogVGhlIGBXYWxrZXJFbnRyeWAgaXMgYW4gaW50ZXJmYWNlIHRoYXQgYWJzdHJhY3RzIGNvbXB1dGluZyBtYW55IGNvbW1vbiB0cmVlIC8gYmxvYiBzdGF0cy5cbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBXYWxrZXJFbnRyeVxuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiBQcm9taXNlPCd0cmVlJ3wnYmxvYid8J3NwZWNpYWwnfCdjb21taXQnPn0gdHlwZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbigpOiBQcm9taXNlPG51bWJlcj59IG1vZGVcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogUHJvbWlzZTxzdHJpbmc+fSBvaWRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oKTogUHJvbWlzZTxVaW50OEFycmF5fHZvaWQ+fSBjb250ZW50XG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKCk6IFByb21pc2U8U3RhdD59IHN0YXRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhbGxiYWNrRnNDbGllbnRcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHJlYWRGaWxlIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzX3JlYWRmaWxlX3BhdGhfb3B0aW9uc19jYWxsYmFja1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gd3JpdGVGaWxlIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzX3dyaXRlZmlsZV9maWxlX2RhdGFfb3B0aW9uc19jYWxsYmFja1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gdW5saW5rIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzX3VubGlua19wYXRoX2NhbGxiYWNrXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSByZWFkZGlyIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzX3JlYWRkaXJfcGF0aF9vcHRpb25zX2NhbGxiYWNrXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBta2RpciAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19mc19ta2Rpcl9wYXRoX21vZGVfY2FsbGJhY2tcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHJtZGlyIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzX3JtZGlyX3BhdGhfY2FsbGJhY2tcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHN0YXQgLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNfc3RhdF9wYXRoX29wdGlvbnNfY2FsbGJhY2tcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IGxzdGF0IC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzX2xzdGF0X3BhdGhfb3B0aW9uc19jYWxsYmFja1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3JlYWRsaW5rXSAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19mc19yZWFkbGlua19wYXRoX29wdGlvbnNfY2FsbGJhY2tcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtzeW1saW5rXSAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19mc19zeW1saW5rX3RhcmdldF9wYXRoX3R5cGVfY2FsbGJhY2tcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtjaG1vZF0gLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNfY2htb2RfcGF0aF9tb2RlX2NhbGxiYWNrXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcm9taXNlRnNDbGllbnRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwcm9taXNlc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcHJvbWlzZXMucmVhZEZpbGUgLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNwcm9taXNlc19yZWFkZmlsZV9wYXRoX29wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHByb21pc2VzLndyaXRlRmlsZSAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19mc3Byb21pc2VzX3dyaXRlZmlsZV9maWxlX2RhdGFfb3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcHJvbWlzZXMudW5saW5rIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzcHJvbWlzZXNfdW5saW5rX3BhdGhcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHByb21pc2VzLnJlYWRkaXIgLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNwcm9taXNlc19yZWFkZGlyX3BhdGhfb3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcHJvbWlzZXMubWtkaXIgLSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNwcm9taXNlc19ta2Rpcl9wYXRoX29wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHByb21pc2VzLnJtZGlyIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzcHJvbWlzZXNfcm1kaXJfcGF0aFxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gcHJvbWlzZXMuc3RhdCAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19mc3Byb21pc2VzX3N0YXRfcGF0aF9vcHRpb25zXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBwcm9taXNlcy5sc3RhdCAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19mc3Byb21pc2VzX2xzdGF0X3BhdGhfb3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3Byb21pc2VzLnJlYWRsaW5rXSAtIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19mc3Byb21pc2VzX3JlYWRsaW5rX3BhdGhfb3B0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW3Byb21pc2VzLnN5bWxpbmtdIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzcHJvbWlzZXNfc3ltbGlua190YXJnZXRfcGF0aF90eXBlXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9ufSBbcHJvbWlzZXMuY2htb2RdIC0gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9mcy5odG1sI2ZzX2ZzcHJvbWlzZXNfY2htb2RfcGF0aF9tb2RlXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Q2FsbGJhY2tGc0NsaWVudCB8IFByb21pc2VGc0NsaWVudH0gRnNDbGllbnRcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBNZXNzYWdlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7dm9pZCB8IFByb21pc2U8dm9pZD59XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBHaXRBdXRoXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VzZXJuYW1lXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtwYXNzd29yZF1cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2hlYWRlcnNdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjYW5jZWxdIFRlbGxzIGdpdCB0byB0aHJvdyBhIGBVc2VyQ2FuY2VsZWRFcnJvcmAgKGluc3RlYWQgb2YgYW4gYEh0dHBFcnJvcmApLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEF1dGhDYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtHaXRBdXRofSBhdXRoIE1pZ2h0IGhhdmUgc29tZSB2YWx1ZXMgaWYgdGhlIFVSTCBpdHNlbGYgb3JpZ2luYWxseSBjb250YWluZWQgYSB1c2VybmFtZSBvciBwYXNzd29yZC5cbiAqIEByZXR1cm5zIHtHaXRBdXRoIHwgdm9pZCB8IFByb21pc2U8R2l0QXV0aCB8IHZvaWQ+fVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEF1dGhGYWlsdXJlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7R2l0QXV0aH0gYXV0aCBUaGUgY3JlZGVudGlhbHMgdGhhdCBmYWlsZWRcbiAqIEByZXR1cm5zIHtHaXRBdXRoIHwgdm9pZCB8IFByb21pc2U8R2l0QXV0aCB8IHZvaWQ+fVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEF1dGhTdWNjZXNzQ2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7R2l0QXV0aH0gYXV0aFxuICogQHJldHVybnMge3ZvaWQgfCBQcm9taXNlPHZvaWQ+fVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2lnblBhcmFtc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHBheWxvYWQgLSBhIHBsYWludGV4dCBtZXNzYWdlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2VjcmV0S2V5IC0gYW4gJ0FTQ0lJIGFybW9yJyBlbmNvZGVkIFBHUCBrZXkgKHRlY2huaWNhbGx5IGNhbiBhY3R1YWxseSBjb250YWluIF9tdWx0aXBsZV8ga2V5cylcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTaWduQ2FsbGJhY2tcbiAqIEBwYXJhbSB7U2lnblBhcmFtc30gYXJnc1xuICogQHJldHVybiB7e3NpZ25hdHVyZTogc3RyaW5nfSB8IFByb21pc2U8e3NpZ25hdHVyZTogc3RyaW5nfT59IC0gYW4gJ0FTQ0lJIGFybW9yJyBlbmNvZGVkIFwiZGV0YWNoZWRcIiBzaWduYXR1cmVcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBXYWxrZXJNYXBcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZVxuICogQHBhcmFtIHtXYWxrZXJFbnRyeVtdfSBlbnRyaWVzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFdhbGtlclJlZHVjZVxuICogQHBhcmFtIHthbnl9IHBhcmVudFxuICogQHBhcmFtIHthbnlbXX0gY2hpbGRyZW5cbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgV2Fsa2VySXRlcmF0ZUNhbGxiYWNrXG4gKiBAcGFyYW0ge1dhbGtlckVudHJ5W119IGVudHJpZXNcbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueVtdPn1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBXYWxrZXJJdGVyYXRlXG4gKiBAcGFyYW0ge1dhbGtlckl0ZXJhdGVDYWxsYmFja30gd2Fsa1xuICogQHBhcmFtIHtJdGVyYWJsZUl0ZXJhdG9yPFdhbGtlckVudHJ5W10+fSBjaGlsZHJlblxuICogQHJldHVybnMge1Byb21pc2U8YW55W10+fVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVmVXBkYXRlU3RhdHVzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IG9rXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXJyb3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFB1c2hSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gb2tcbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gZXJyb3JcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgUmVmVXBkYXRlU3RhdHVzPn0gcmVmc1xuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbaGVhZGVyc11cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHswfDF9IEhlYWRTdGF0dXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHswfDF8Mn0gV29ya2RpclN0YXR1c1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYgezB8MXwyfDN9IFN0YWdlU3RhdHVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7W3N0cmluZywgSGVhZFN0YXR1cywgV29ya2RpclN0YXR1cywgU3RhZ2VTdGF0dXNdfSBTdGF0dXNSb3dcbiAqL1xuXG5jbGFzcyBCYXNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAvLyBTZXR0aW5nIHRoaXMgaGVyZSBhbGxvd3MgVFMgdG8gaW5mZXIgdGhhdCBhbGwgZ2l0IGVycm9ycyBoYXZlIGEgYGNhbGxlcmAgcHJvcGVydHkgYW5kXG4gICAgLy8gdGhhdCBpdHMgdHlwZSBpcyBzdHJpbmcuXG4gICAgdGhpcy5jYWxsZXIgPSAnJztcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICAvLyBFcnJvciBvYmplY3RzIGFyZW4ndCBub3JtYWxseSBzZXJpYWxpemFibGUuIFNvIHdlIGRvIHNvbWV0aGluZyBhYm91dCB0aGF0LlxuICAgIHJldHVybiB7XG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICBjYWxsZXI6IHRoaXMuY2FsbGVyLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgfVxuICB9XG5cbiAgZnJvbUpTT04oanNvbikge1xuICAgIGNvbnN0IGUgPSBuZXcgQmFzZUVycm9yKGpzb24ubWVzc2FnZSk7XG4gICAgZS5jb2RlID0ganNvbi5jb2RlO1xuICAgIGUuZGF0YSA9IGpzb24uZGF0YTtcbiAgICBlLmNhbGxlciA9IGpzb24uY2FsbGVyO1xuICAgIGUuc3RhY2sgPSBqc29uLnN0YWNrO1xuICAgIHJldHVybiBlXG4gIH1cblxuICBnZXQgaXNJc29tb3JwaGljR2l0RXJyb3IoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5jbGFzcyBJbnRlcm5hbEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoXG4gICAgICBgQW4gaW50ZXJuYWwgZXJyb3IgY2F1c2VkIHRoaXMgY29tbWFuZCB0byBmYWlsLiBQbGVhc2UgZmlsZSBhIGJ1ZyByZXBvcnQgYXQgaHR0cHM6Ly9naXRodWIuY29tL2lzb21vcnBoaWMtZ2l0L2lzb21vcnBoaWMtZ2l0L2lzc3VlcyB3aXRoIHRoaXMgZXJyb3IgbWVzc2FnZTogJHttZXNzYWdlfWBcbiAgICApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IEludGVybmFsRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IG1lc3NhZ2UgfTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnSW50ZXJuYWxFcnJvcid9ICovXG5JbnRlcm5hbEVycm9yLmNvZGUgPSAnSW50ZXJuYWxFcnJvcic7XG5cbmNsYXNzIFVuc2FmZUZpbGVwYXRoRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVwYXRoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihmaWxlcGF0aCkge1xuICAgIHN1cGVyKGBUaGUgZmlsZXBhdGggXCIke2ZpbGVwYXRofVwiIGNvbnRhaW5zIHVuc2FmZSBjaGFyYWN0ZXIgc2VxdWVuY2VzYCk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gVW5zYWZlRmlsZXBhdGhFcnJvci5jb2RlO1xuICAgIHRoaXMuZGF0YSA9IHsgZmlsZXBhdGggfTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnVW5zYWZlRmlsZXBhdGhFcnJvcid9ICovXG5VbnNhZmVGaWxlcGF0aEVycm9yLmNvZGUgPSAnVW5zYWZlRmlsZXBhdGhFcnJvcic7XG5cbi8vIE1vZGVsZWQgYWZ0ZXIgaHR0cHM6Ly9naXRodWIuY29tL3RqZm9udGFpbmUvbm9kZS1idWZmZXJjdXJzb3Jcbi8vIGJ1dCB3aXRoIHRoZSBnb2FsIG9mIGJlaW5nIG11Y2ggbGlnaHRlciB3ZWlnaHQuXG5jbGFzcyBCdWZmZXJDdXJzb3Ige1xuICBjb25zdHJ1Y3RvcihidWZmZXIpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICB0aGlzLl9zdGFydCA9IDA7XG4gIH1cblxuICBlb2YoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ID49IHRoaXMuYnVmZmVyLmxlbmd0aFxuICB9XG5cbiAgdGVsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRcbiAgfVxuXG4gIHNlZWsobikge1xuICAgIHRoaXMuX3N0YXJ0ID0gbjtcbiAgfVxuXG4gIHNsaWNlKG4pIHtcbiAgICBjb25zdCByID0gdGhpcy5idWZmZXIuc2xpY2UodGhpcy5fc3RhcnQsIHRoaXMuX3N0YXJ0ICsgbik7XG4gICAgdGhpcy5fc3RhcnQgKz0gbjtcbiAgICByZXR1cm4gclxuICB9XG5cbiAgdG9TdHJpbmcoZW5jLCBsZW5ndGgpIHtcbiAgICBjb25zdCByID0gdGhpcy5idWZmZXIudG9TdHJpbmcoZW5jLCB0aGlzLl9zdGFydCwgdGhpcy5fc3RhcnQgKyBsZW5ndGgpO1xuICAgIHRoaXMuX3N0YXJ0ICs9IGxlbmd0aDtcbiAgICByZXR1cm4gclxuICB9XG5cbiAgd3JpdGUodmFsdWUsIGxlbmd0aCwgZW5jKSB7XG4gICAgY29uc3QgciA9IHRoaXMuYnVmZmVyLndyaXRlKHZhbHVlLCB0aGlzLl9zdGFydCwgbGVuZ3RoLCBlbmMpO1xuICAgIHRoaXMuX3N0YXJ0ICs9IGxlbmd0aDtcbiAgICByZXR1cm4gclxuICB9XG5cbiAgY29weShzb3VyY2UsIHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCByID0gc291cmNlLmNvcHkodGhpcy5idWZmZXIsIHRoaXMuX3N0YXJ0LCBzdGFydCwgZW5kKTtcbiAgICB0aGlzLl9zdGFydCArPSByO1xuICAgIHJldHVybiByXG4gIH1cblxuICByZWFkVUludDgoKSB7XG4gICAgY29uc3QgciA9IHRoaXMuYnVmZmVyLnJlYWRVSW50OCh0aGlzLl9zdGFydCk7XG4gICAgdGhpcy5fc3RhcnQgKz0gMTtcbiAgICByZXR1cm4gclxuICB9XG5cbiAgd3JpdGVVSW50OCh2YWx1ZSkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmJ1ZmZlci53cml0ZVVJbnQ4KHZhbHVlLCB0aGlzLl9zdGFydCk7XG4gICAgdGhpcy5fc3RhcnQgKz0gMTtcbiAgICByZXR1cm4gclxuICB9XG5cbiAgcmVhZFVJbnQxNkJFKCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmJ1ZmZlci5yZWFkVUludDE2QkUodGhpcy5fc3RhcnQpO1xuICAgIHRoaXMuX3N0YXJ0ICs9IDI7XG4gICAgcmV0dXJuIHJcbiAgfVxuXG4gIHdyaXRlVUludDE2QkUodmFsdWUpIHtcbiAgICBjb25zdCByID0gdGhpcy5idWZmZXIud3JpdGVVSW50MTZCRSh2YWx1ZSwgdGhpcy5fc3RhcnQpO1xuICAgIHRoaXMuX3N0YXJ0ICs9IDI7XG4gICAgcmV0dXJuIHJcbiAgfVxuXG4gIHJlYWRVSW50MzJCRSgpIHtcbiAgICBjb25zdCByID0gdGhpcy5idWZmZXIucmVhZFVJbnQzMkJFKHRoaXMuX3N0YXJ0KTtcbiAgICB0aGlzLl9zdGFydCArPSA0O1xuICAgIHJldHVybiByXG4gIH1cblxuICB3cml0ZVVJbnQzMkJFKHZhbHVlKSB7XG4gICAgY29uc3QgciA9IHRoaXMuYnVmZmVyLndyaXRlVUludDMyQkUodmFsdWUsIHRoaXMuX3N0YXJ0KTtcbiAgICB0aGlzLl9zdGFydCArPSA0O1xuICAgIHJldHVybiByXG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZVN0cmluZ3MoYSwgYikge1xuICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDAzNTUxMDcvMjE2ODQxNlxuICByZXR1cm4gLShhIDwgYikgfHwgKyhhID4gYilcbn1cblxuZnVuY3Rpb24gY29tcGFyZVBhdGgoYSwgYikge1xuICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDAzNTUxMDcvMjE2ODQxNlxuICByZXR1cm4gY29tcGFyZVN0cmluZ3MoYS5wYXRoLCBiLnBhdGgpXG59XG5cbi8qKlxuICogRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ2l0L2dpdC9ibG9iL21hc3Rlci9Eb2N1bWVudGF0aW9uL3RlY2huaWNhbC9pbmRleC1mb3JtYXQudHh0XG4gKlxuICogMzItYml0IG1vZGUsIHNwbGl0IGludG8gKGhpZ2ggdG8gbG93IGJpdHMpXG4gKlxuICogIDQtYml0IG9iamVjdCB0eXBlXG4gKiAgICB2YWxpZCB2YWx1ZXMgaW4gYmluYXJ5IGFyZSAxMDAwIChyZWd1bGFyIGZpbGUpLCAxMDEwIChzeW1ib2xpYyBsaW5rKVxuICogICAgYW5kIDExMTAgKGdpdGxpbmspXG4gKlxuICogIDMtYml0IHVudXNlZFxuICpcbiAqICA5LWJpdCB1bml4IHBlcm1pc3Npb24uIE9ubHkgMDc1NSBhbmQgMDY0NCBhcmUgdmFsaWQgZm9yIHJlZ3VsYXIgZmlsZXMuXG4gKiAgU3ltYm9saWMgbGlua3MgYW5kIGdpdGxpbmtzIGhhdmUgdmFsdWUgMCBpbiB0aGlzIGZpZWxkLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVNb2RlKG1vZGUpIHtcbiAgLy8gTm90ZTogQnJvd3NlckZTIHdpbGwgdXNlIC0xIGZvciBcInVua25vd25cIlxuICAvLyBJIG5lZWQgdG8gbWFrZSBpdCBub24tbmVnYXRpdmUgZm9yIHRoZXNlIGJpdHNoaWZ0cyB0byB3b3JrLlxuICBsZXQgdHlwZSA9IG1vZGUgPiAwID8gbW9kZSA+PiAxMiA6IDA7XG4gIC8vIElmIGl0IGlzbid0IHZhbGlkLCBhc3N1bWUgaXQgYXMgYSBcInJlZ3VsYXIgZmlsZVwiXG4gIC8vIDAxMDAgPSBkaXJlY3RvcnlcbiAgLy8gMTAwMCA9IHJlZ3VsYXIgZmlsZVxuICAvLyAxMDEwID0gc3ltbGlua1xuICAvLyAxMTEwID0gZ2l0bGlua1xuICBpZiAoXG4gICAgdHlwZSAhPT0gMGIwMTAwICYmXG4gICAgdHlwZSAhPT0gMGIxMDAwICYmXG4gICAgdHlwZSAhPT0gMGIxMDEwICYmXG4gICAgdHlwZSAhPT0gMGIxMTEwXG4gICkge1xuICAgIHR5cGUgPSAwYjEwMDA7XG4gIH1cbiAgbGV0IHBlcm1pc3Npb25zID0gbW9kZSAmIDBvNzc3O1xuICAvLyBJcyB0aGUgZmlsZSBleGVjdXRhYmxlPyB0aGVuIDc1NS4gRWxzZSA2NDQuXG4gIGlmIChwZXJtaXNzaW9ucyAmIDBiMDAxMDAxMDAxKSB7XG4gICAgcGVybWlzc2lvbnMgPSAwbzc1NTtcbiAgfSBlbHNlIHtcbiAgICBwZXJtaXNzaW9ucyA9IDBvNjQ0O1xuICB9XG4gIC8vIElmIGl0J3Mgbm90IGEgcmVndWxhciBmaWxlLCBzY3J1YiBhbGwgcGVybWlzc2lvbnNcbiAgaWYgKHR5cGUgIT09IDBiMTAwMCkgcGVybWlzc2lvbnMgPSAwO1xuICByZXR1cm4gKHR5cGUgPDwgMTIpICsgcGVybWlzc2lvbnNcbn1cblxuY29uc3QgTUFYX1VJTlQzMiA9IDIgKiogMzI7XG5cbmZ1bmN0aW9uIFNlY29uZHNOYW5vc2Vjb25kcyhcbiAgZ2l2ZW5TZWNvbmRzLFxuICBnaXZlbk5hbm9zZWNvbmRzLFxuICBtaWxsaXNlY29uZHMsXG4gIGRhdGVcbikge1xuICBpZiAoZ2l2ZW5TZWNvbmRzICE9PSB1bmRlZmluZWQgJiYgZ2l2ZW5OYW5vc2Vjb25kcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIFtnaXZlblNlY29uZHMsIGdpdmVuTmFub3NlY29uZHNdXG4gIH1cbiAgaWYgKG1pbGxpc2Vjb25kcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWlsbGlzZWNvbmRzID0gZGF0ZS52YWx1ZU9mKCk7XG4gIH1cbiAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gIGNvbnN0IG5hbm9zZWNvbmRzID0gKG1pbGxpc2Vjb25kcyAtIHNlY29uZHMgKiAxMDAwKSAqIDEwMDAwMDA7XG4gIHJldHVybiBbc2Vjb25kcywgbmFub3NlY29uZHNdXG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0YXRzKGUpIHtcbiAgY29uc3QgW2N0aW1lU2Vjb25kcywgY3RpbWVOYW5vc2Vjb25kc10gPSBTZWNvbmRzTmFub3NlY29uZHMoXG4gICAgZS5jdGltZVNlY29uZHMsXG4gICAgZS5jdGltZU5hbm9zZWNvbmRzLFxuICAgIGUuY3RpbWVNcyxcbiAgICBlLmN0aW1lXG4gICk7XG4gIGNvbnN0IFttdGltZVNlY29uZHMsIG10aW1lTmFub3NlY29uZHNdID0gU2Vjb25kc05hbm9zZWNvbmRzKFxuICAgIGUubXRpbWVTZWNvbmRzLFxuICAgIGUubXRpbWVOYW5vc2Vjb25kcyxcbiAgICBlLm10aW1lTXMsXG4gICAgZS5tdGltZVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgY3RpbWVTZWNvbmRzOiBjdGltZVNlY29uZHMgJSBNQVhfVUlOVDMyLFxuICAgIGN0aW1lTmFub3NlY29uZHM6IGN0aW1lTmFub3NlY29uZHMgJSBNQVhfVUlOVDMyLFxuICAgIG10aW1lU2Vjb25kczogbXRpbWVTZWNvbmRzICUgTUFYX1VJTlQzMixcbiAgICBtdGltZU5hbm9zZWNvbmRzOiBtdGltZU5hbm9zZWNvbmRzICUgTUFYX1VJTlQzMixcbiAgICBkZXY6IGUuZGV2ICUgTUFYX1VJTlQzMixcbiAgICBpbm86IGUuaW5vICUgTUFYX1VJTlQzMixcbiAgICBtb2RlOiBub3JtYWxpemVNb2RlKGUubW9kZSAlIE1BWF9VSU5UMzIpLFxuICAgIHVpZDogZS51aWQgJSBNQVhfVUlOVDMyLFxuICAgIGdpZDogZS5naWQgJSBNQVhfVUlOVDMyLFxuICAgIC8vIHNpemUgb2YgLTEgaGFwcGVucyBvdmVyIGEgQnJvd3NlckZTIEhUVFAgQmFja2VuZCB0aGF0IGRvZXNuJ3Qgc2VydmUgQ29udGVudC1MZW5ndGggaGVhZGVyc1xuICAgIC8vIChsaWtlIHRoZSBLYXJtYSB3ZWJzZXJ2ZXIpIGJlY2F1c2UgQnJvd3NlckZTIEhUVFAgQmFja2VuZCB1c2VzIEhUVFAgSEVBRCByZXF1ZXN0cyB0byBkbyBmcy5zdGF0XG4gICAgc2l6ZTogZS5zaXplID4gLTEgPyBlLnNpemUgJSBNQVhfVUlOVDMyIDogMCxcbiAgfVxufVxuXG5mdW5jdGlvbiB0b0hleChidWZmZXIpIHtcbiAgbGV0IGhleCA9ICcnO1xuICBmb3IgKGNvbnN0IGJ5dGUgb2YgbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSkge1xuICAgIGlmIChieXRlIDwgMTYpIGhleCArPSAnMCc7XG4gICAgaGV4ICs9IGJ5dGUudG9TdHJpbmcoMTYpO1xuICB9XG4gIHJldHVybiBoZXhcbn1cblxuLyogZXNsaW50LWVudiBub2RlLCBicm93c2VyICovXG5cbmxldCBzdXBwb3J0c1N1YnRsZVNIQTEgPSBudWxsO1xuXG5hc3luYyBmdW5jdGlvbiBzaGFzdW0oYnVmZmVyKSB7XG4gIGlmIChzdXBwb3J0c1N1YnRsZVNIQTEgPT09IG51bGwpIHtcbiAgICBzdXBwb3J0c1N1YnRsZVNIQTEgPSBhd2FpdCB0ZXN0U3VidGxlU0hBMSgpO1xuICB9XG4gIHJldHVybiBzdXBwb3J0c1N1YnRsZVNIQTEgPyBzdWJ0bGVTSEExKGJ1ZmZlcikgOiBzaGFzdW1TeW5jKGJ1ZmZlcilcbn1cblxuLy8gVGhpcyBpcyBtb2RlbGVkIGFmdGVyIEBkb21pbmljdGFycidzIFwic2hhc3VtXCIgbW9kdWxlLFxuLy8gYnV0IHdpdGhvdXQgdGhlICdqc29uLXN0YWJsZS1zdHJpbmdpZnknIGRlcGVuZGVuY3kgYW5kXG4vLyBleHRyYSB0eXBlLWNhc3RpbmcgZmVhdHVyZXMuXG5mdW5jdGlvbiBzaGFzdW1TeW5jKGJ1ZmZlcikge1xuICByZXR1cm4gbmV3IEhhc2goKS51cGRhdGUoYnVmZmVyKS5kaWdlc3QoJ2hleCcpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHN1YnRsZVNIQTEoYnVmZmVyKSB7XG4gIGNvbnN0IGhhc2ggPSBhd2FpdCBjcnlwdG8uc3VidGxlLmRpZ2VzdCgnU0hBLTEnLCBidWZmZXIpO1xuICByZXR1cm4gdG9IZXgoaGFzaClcbn1cblxuYXN5bmMgZnVuY3Rpb24gdGVzdFN1YnRsZVNIQTEoKSB7XG4gIC8vIEknbSB1c2luZyBhIHJhdGhlciBjcnVkZSBtZXRob2Qgb2YgcHJvZ3Jlc3NpdmUgZW5oYW5jZW1lbnQsIGJlY2F1c2VcbiAgLy8gc29tZSBicm93c2VycyB0aGF0IGhhdmUgY3J5cHRvLnN1YnRsZS5kaWdlc3QgZG9uJ3QgYWN0dWFsbHkgaW1wbGVtZW50IFNIQS0xLlxuICB0cnkge1xuICAgIGNvbnN0IGhhc2ggPSBhd2FpdCBzdWJ0bGVTSEExKG5ldyBVaW50OEFycmF5KFtdKSk7XG4gICAgaWYgKGhhc2ggPT09ICdkYTM5YTNlZTVlNmI0YjBkMzI1NWJmZWY5NTYwMTg5MGFmZDgwNzA5JykgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIG5vIGJvdGhlclxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBFeHRyYWN0IDEtYml0IGFzc3VtZS12YWxpZCwgMS1iaXQgZXh0ZW5kZWQgZmxhZywgMi1iaXQgbWVyZ2Ugc3RhdGUgZmxhZywgMTItYml0IHBhdGggbGVuZ3RoIGZsYWdcbmZ1bmN0aW9uIHBhcnNlQ2FjaGVFbnRyeUZsYWdzKGJpdHMpIHtcbiAgcmV0dXJuIHtcbiAgICBhc3N1bWVWYWxpZDogQm9vbGVhbihiaXRzICYgMGIxMDAwMDAwMDAwMDAwMDAwKSxcbiAgICBleHRlbmRlZDogQm9vbGVhbihiaXRzICYgMGIwMTAwMDAwMDAwMDAwMDAwKSxcbiAgICBzdGFnZTogKGJpdHMgJiAwYjAwMTEwMDAwMDAwMDAwMDApID4+IDEyLFxuICAgIG5hbWVMZW5ndGg6IGJpdHMgJiAwYjAwMDAxMTExMTExMTExMTEsXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyQ2FjaGVFbnRyeUZsYWdzKGVudHJ5KSB7XG4gIGNvbnN0IGZsYWdzID0gZW50cnkuZmxhZ3M7XG4gIC8vIDEtYml0IGV4dGVuZGVkIGZsYWcgKG11c3QgYmUgemVybyBpbiB2ZXJzaW9uIDIpXG4gIGZsYWdzLmV4dGVuZGVkID0gZmFsc2U7XG4gIC8vIDEyLWJpdCBuYW1lIGxlbmd0aCBpZiB0aGUgbGVuZ3RoIGlzIGxlc3MgdGhhbiAweEZGRjsgb3RoZXJ3aXNlIDB4RkZGXG4gIC8vIGlzIHN0b3JlZCBpbiB0aGlzIGZpZWxkLlxuICBmbGFncy5uYW1lTGVuZ3RoID0gTWF0aC5taW4oQnVmZmVyLmZyb20oZW50cnkucGF0aCkubGVuZ3RoLCAweGZmZik7XG4gIHJldHVybiAoXG4gICAgKGZsYWdzLmFzc3VtZVZhbGlkID8gMGIxMDAwMDAwMDAwMDAwMDAwIDogMCkgK1xuICAgIChmbGFncy5leHRlbmRlZCA/IDBiMDEwMDAwMDAwMDAwMDAwMCA6IDApICtcbiAgICAoKGZsYWdzLnN0YWdlICYgMGIxMSkgPDwgMTIpICtcbiAgICAoZmxhZ3MubmFtZUxlbmd0aCAmIDBiMTExMTExMTExMTExKVxuICApXG59XG5cbmNsYXNzIEdpdEluZGV4IHtcbiAgLyo6OlxuICAgX2VudHJpZXM6IE1hcDxzdHJpbmcsIENhY2hlRW50cnk+XG4gICBfZGlydHk6IGJvb2xlYW4gLy8gVXNlZCB0byBkZXRlcm1pbmUgaWYgaW5kZXggbmVlZHMgdG8gYmUgc2F2ZWQgdG8gZmlsZXN5c3RlbVxuICAgKi9cbiAgY29uc3RydWN0b3IoZW50cmllcykge1xuICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5fZW50cmllcyA9IGVudHJpZXMgfHwgbmV3IE1hcCgpO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIGZyb20oYnVmZmVyKSB7XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgICByZXR1cm4gR2l0SW5kZXguZnJvbUJ1ZmZlcihidWZmZXIpXG4gICAgfSBlbHNlIGlmIChidWZmZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgR2l0SW5kZXgobnVsbClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoJ2ludmFsaWQgdHlwZSBwYXNzZWQgdG8gR2l0SW5kZXguZnJvbScpXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGZyb21CdWZmZXIoYnVmZmVyKSB7XG4gICAgLy8gVmVyaWZ5IHNoYXN1bVxuICAgIGNvbnN0IHNoYUNvbXB1dGVkID0gYXdhaXQgc2hhc3VtKGJ1ZmZlci5zbGljZSgwLCAtMjApKTtcbiAgICBjb25zdCBzaGFDbGFpbWVkID0gYnVmZmVyLnNsaWNlKC0yMCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIGlmIChzaGFDbGFpbWVkICE9PSBzaGFDb21wdXRlZCkge1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGNoZWNrc3VtIGluIEdpdEluZGV4IGJ1ZmZlcjogZXhwZWN0ZWQgJHtzaGFDbGFpbWVkfSBidXQgc2F3ICR7c2hhQ29tcHV0ZWR9YFxuICAgICAgKVxuICAgIH1cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgQnVmZmVyQ3Vyc29yKGJ1ZmZlcik7XG4gICAgY29uc3QgX2VudHJpZXMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgbWFnaWMgPSByZWFkZXIudG9TdHJpbmcoJ3V0ZjgnLCA0KTtcbiAgICBpZiAobWFnaWMgIT09ICdESVJDJykge1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoYEluYXZsaWQgZGlyY2FjaGUgbWFnaWMgZmlsZSBudW1iZXI6ICR7bWFnaWN9YClcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbiA9IHJlYWRlci5yZWFkVUludDMyQkUoKTtcbiAgICBpZiAodmVyc2lvbiAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoYFVuc3VwcG9ydGVkIGRpcmNhY2hlIHZlcnNpb246ICR7dmVyc2lvbn1gKVxuICAgIH1cbiAgICBjb25zdCBudW1FbnRyaWVzID0gcmVhZGVyLnJlYWRVSW50MzJCRSgpO1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoIXJlYWRlci5lb2YoKSAmJiBpIDwgbnVtRW50cmllcykge1xuICAgICAgY29uc3QgZW50cnkgPSB7fTtcbiAgICAgIGVudHJ5LmN0aW1lU2Vjb25kcyA9IHJlYWRlci5yZWFkVUludDMyQkUoKTtcbiAgICAgIGVudHJ5LmN0aW1lTmFub3NlY29uZHMgPSByZWFkZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgICBlbnRyeS5tdGltZVNlY29uZHMgPSByZWFkZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgICBlbnRyeS5tdGltZU5hbm9zZWNvbmRzID0gcmVhZGVyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgZW50cnkuZGV2ID0gcmVhZGVyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgZW50cnkuaW5vID0gcmVhZGVyLnJlYWRVSW50MzJCRSgpO1xuICAgICAgZW50cnkubW9kZSA9IHJlYWRlci5yZWFkVUludDMyQkUoKTtcbiAgICAgIGVudHJ5LnVpZCA9IHJlYWRlci5yZWFkVUludDMyQkUoKTtcbiAgICAgIGVudHJ5LmdpZCA9IHJlYWRlci5yZWFkVUludDMyQkUoKTtcbiAgICAgIGVudHJ5LnNpemUgPSByZWFkZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgICBlbnRyeS5vaWQgPSByZWFkZXIuc2xpY2UoMjApLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIGNvbnN0IGZsYWdzID0gcmVhZGVyLnJlYWRVSW50MTZCRSgpO1xuICAgICAgZW50cnkuZmxhZ3MgPSBwYXJzZUNhY2hlRW50cnlGbGFncyhmbGFncyk7XG4gICAgICAvLyBUT0RPOiBoYW5kbGUgaWYgKHZlcnNpb24gPT09IDMgJiYgZW50cnkuZmxhZ3MuZXh0ZW5kZWQpXG4gICAgICBjb25zdCBwYXRobGVuZ3RoID0gYnVmZmVyLmluZGV4T2YoMCwgcmVhZGVyLnRlbGwoKSArIDEpIC0gcmVhZGVyLnRlbGwoKTtcbiAgICAgIGlmIChwYXRobGVuZ3RoIDwgMSkge1xuICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihgR290IGEgcGF0aCBsZW5ndGggb2Y6ICR7cGF0aGxlbmd0aH1gKVxuICAgICAgfVxuICAgICAgLy8gVE9ETzogaGFuZGxlIHBhdGhuYW1lcyBsYXJnZXIgdGhhbiAxMiBiaXRzXG4gICAgICBlbnRyeS5wYXRoID0gcmVhZGVyLnRvU3RyaW5nKCd1dGY4JywgcGF0aGxlbmd0aCk7XG5cbiAgICAgIC8vIFByZXZlbnQgbWFsaWNpb3VzIHBhdGhzIGxpa2UgXCIuLlxcZm9vXCJcbiAgICAgIGlmIChlbnRyeS5wYXRoLmluY2x1ZGVzKCcuLlxcXFwnKSB8fCBlbnRyeS5wYXRoLmluY2x1ZGVzKCcuLi8nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zYWZlRmlsZXBhdGhFcnJvcihlbnRyeS5wYXRoKVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgbmV4dCBiaXQgaXMgYXdrd2FyZC4gV2UgZXhwZWN0IDEgdG8gOCBudWxsIGNoYXJhY3RlcnNcbiAgICAgIC8vIHN1Y2ggdGhhdCB0aGUgdG90YWwgc2l6ZSBvZiB0aGUgZW50cnkgaXMgYSBtdWx0aXBsZSBvZiA4IGJpdHMuXG4gICAgICAvLyAoSGVuY2Ugc3VidHJhY3QgMTIgYnl0ZXMgZm9yIHRoZSBoZWFkZXIuKVxuICAgICAgbGV0IHBhZGRpbmcgPSA4IC0gKChyZWFkZXIudGVsbCgpIC0gMTIpICUgOCk7XG4gICAgICBpZiAocGFkZGluZyA9PT0gMCkgcGFkZGluZyA9IDg7XG4gICAgICB3aGlsZSAocGFkZGluZy0tKSB7XG4gICAgICAgIGNvbnN0IHRtcCA9IHJlYWRlci5yZWFkVUludDgoKTtcbiAgICAgICAgaWYgKHRtcCAhPT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKFxuICAgICAgICAgICAgYEV4cGVjdGVkIDEtOCBudWxsIGNoYXJhY3RlcnMgYnV0IGdvdCAnJHt0bXB9JyBhZnRlciAke2VudHJ5LnBhdGh9YFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChyZWFkZXIuZW9mKCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZmlsZScpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGVuZCBvZiBhd2t3YXJkIHBhcnRcbiAgICAgIF9lbnRyaWVzLnNldChlbnRyeS5wYXRoLCBlbnRyeSk7XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBuZXcgR2l0SW5kZXgoX2VudHJpZXMpXG4gIH1cblxuICBnZXQgZW50cmllcygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuX2VudHJpZXMudmFsdWVzKCldLnNvcnQoY29tcGFyZVBhdGgpXG4gIH1cblxuICBnZXQgZW50cmllc01hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cmllc1xuICB9XG5cbiAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5lbnRyaWVzKSB7XG4gICAgICB5aWVsZCBlbnRyeTtcbiAgICB9XG4gIH1cblxuICBpbnNlcnQoeyBmaWxlcGF0aCwgc3RhdHMsIG9pZCB9KSB7XG4gICAgc3RhdHMgPSBub3JtYWxpemVTdGF0cyhzdGF0cyk7XG4gICAgY29uc3QgYmZpbGVwYXRoID0gQnVmZmVyLmZyb20oZmlsZXBhdGgpO1xuICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgY3RpbWVTZWNvbmRzOiBzdGF0cy5jdGltZVNlY29uZHMsXG4gICAgICBjdGltZU5hbm9zZWNvbmRzOiBzdGF0cy5jdGltZU5hbm9zZWNvbmRzLFxuICAgICAgbXRpbWVTZWNvbmRzOiBzdGF0cy5tdGltZVNlY29uZHMsXG4gICAgICBtdGltZU5hbm9zZWNvbmRzOiBzdGF0cy5tdGltZU5hbm9zZWNvbmRzLFxuICAgICAgZGV2OiBzdGF0cy5kZXYsXG4gICAgICBpbm86IHN0YXRzLmlubyxcbiAgICAgIC8vIFdlIHByb3ZpZGUgYSBmYWxsYmFjayB2YWx1ZSBmb3IgYG1vZGVgIGhlcmUgYmVjYXVzZSBub3QgYWxsIGZzXG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXNzaWduIGl0LCBidXQgd2UgdXNlIGl0IGluIEdpdFRyZWUuXG4gICAgICAvLyAnMTAwNjQ0JyBpcyBmb3IgYSBcInJlZ3VsYXIgbm9uLWV4ZWN1dGFibGUgZmlsZVwiXG4gICAgICBtb2RlOiBzdGF0cy5tb2RlIHx8IDBvMTAwNjQ0LFxuICAgICAgdWlkOiBzdGF0cy51aWQsXG4gICAgICBnaWQ6IHN0YXRzLmdpZCxcbiAgICAgIHNpemU6IHN0YXRzLnNpemUsXG4gICAgICBwYXRoOiBmaWxlcGF0aCxcbiAgICAgIG9pZDogb2lkLFxuICAgICAgZmxhZ3M6IHtcbiAgICAgICAgYXNzdW1lVmFsaWQ6IGZhbHNlLFxuICAgICAgICBleHRlbmRlZDogZmFsc2UsXG4gICAgICAgIHN0YWdlOiAwLFxuICAgICAgICBuYW1lTGVuZ3RoOiBiZmlsZXBhdGgubGVuZ3RoIDwgMHhmZmYgPyBiZmlsZXBhdGgubGVuZ3RoIDogMHhmZmYsXG4gICAgICB9LFxuICAgIH07XG4gICAgdGhpcy5fZW50cmllcy5zZXQoZW50cnkucGF0aCwgZW50cnkpO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIGRlbGV0ZSh7IGZpbGVwYXRoIH0pIHtcbiAgICBpZiAodGhpcy5fZW50cmllcy5oYXMoZmlsZXBhdGgpKSB7XG4gICAgICB0aGlzLl9lbnRyaWVzLmRlbGV0ZShmaWxlcGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuX2VudHJpZXMua2V5cygpKSB7XG4gICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChmaWxlcGF0aCArICcvJykpIHtcbiAgICAgICAgICB0aGlzLl9lbnRyaWVzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuX2VudHJpZXMuY2xlYXIoKTtcbiAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllc1xuICAgICAgLm1hcChlbnRyeSA9PiBgJHtlbnRyeS5tb2RlLnRvU3RyaW5nKDgpfSAke2VudHJ5Lm9pZH0gICAgJHtlbnRyeS5wYXRofWApXG4gICAgICAuam9pbignXFxuJylcbiAgfVxuXG4gIGFzeW5jIHRvT2JqZWN0KCkge1xuICAgIGNvbnN0IGhlYWRlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IEJ1ZmZlckN1cnNvcihoZWFkZXIpO1xuICAgIHdyaXRlci53cml0ZSgnRElSQycsIDQsICd1dGY4Jyk7XG4gICAgd3JpdGVyLndyaXRlVUludDMyQkUoMik7XG4gICAgd3JpdGVyLndyaXRlVUludDMyQkUodGhpcy5lbnRyaWVzLmxlbmd0aCk7XG4gICAgY29uc3QgYm9keSA9IEJ1ZmZlci5jb25jYXQoXG4gICAgICB0aGlzLmVudHJpZXMubWFwKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3QgYnBhdGggPSBCdWZmZXIuZnJvbShlbnRyeS5wYXRoKTtcbiAgICAgICAgLy8gdGhlIGZpeGVkIGxlbmd0aCArIHRoZSBmaWxlbmFtZSArIGF0IGxlYXN0IG9uZSBudWxsIGNoYXIgPT4gYWxpZ24gYnkgOFxuICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLmNlaWwoKDYyICsgYnBhdGgubGVuZ3RoICsgMSkgLyA4KSAqIDg7XG4gICAgICAgIGNvbnN0IHdyaXR0ZW4gPSBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gbmV3IEJ1ZmZlckN1cnNvcih3cml0dGVuKTtcbiAgICAgICAgY29uc3Qgc3RhdCA9IG5vcm1hbGl6ZVN0YXRzKGVudHJ5KTtcbiAgICAgICAgd3JpdGVyLndyaXRlVUludDMyQkUoc3RhdC5jdGltZVNlY29uZHMpO1xuICAgICAgICB3cml0ZXIud3JpdGVVSW50MzJCRShzdGF0LmN0aW1lTmFub3NlY29uZHMpO1xuICAgICAgICB3cml0ZXIud3JpdGVVSW50MzJCRShzdGF0Lm10aW1lU2Vjb25kcyk7XG4gICAgICAgIHdyaXRlci53cml0ZVVJbnQzMkJFKHN0YXQubXRpbWVOYW5vc2Vjb25kcyk7XG4gICAgICAgIHdyaXRlci53cml0ZVVJbnQzMkJFKHN0YXQuZGV2KTtcbiAgICAgICAgd3JpdGVyLndyaXRlVUludDMyQkUoc3RhdC5pbm8pO1xuICAgICAgICB3cml0ZXIud3JpdGVVSW50MzJCRShzdGF0Lm1vZGUpO1xuICAgICAgICB3cml0ZXIud3JpdGVVSW50MzJCRShzdGF0LnVpZCk7XG4gICAgICAgIHdyaXRlci53cml0ZVVJbnQzMkJFKHN0YXQuZ2lkKTtcbiAgICAgICAgd3JpdGVyLndyaXRlVUludDMyQkUoc3RhdC5zaXplKTtcbiAgICAgICAgd3JpdGVyLndyaXRlKGVudHJ5Lm9pZCwgMjAsICdoZXgnKTtcbiAgICAgICAgd3JpdGVyLndyaXRlVUludDE2QkUocmVuZGVyQ2FjaGVFbnRyeUZsYWdzKGVudHJ5KSk7XG4gICAgICAgIHdyaXRlci53cml0ZShlbnRyeS5wYXRoLCBicGF0aC5sZW5ndGgsICd1dGY4Jyk7XG4gICAgICAgIHJldHVybiB3cml0dGVuXG4gICAgICB9KVxuICAgICk7XG4gICAgY29uc3QgbWFpbiA9IEJ1ZmZlci5jb25jYXQoW2hlYWRlciwgYm9keV0pO1xuICAgIGNvbnN0IHN1bSA9IGF3YWl0IHNoYXN1bShtYWluKTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbbWFpbiwgQnVmZmVyLmZyb20oc3VtLCAnaGV4JyldKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVTdGF0cyhlbnRyeSwgc3RhdHMpIHtcbiAgLy8gQ29tcGFyaXNvbiBiYXNlZCBvbiB0aGUgZGVzY3JpcHRpb24gaW4gUGFyYWdyYXBoIDQgb2ZcbiAgLy8gaHR0cHM6Ly93d3cua2VybmVsLm9yZy9wdWIvc29mdHdhcmUvc2NtL2dpdC9kb2NzL3RlY2huaWNhbC9yYWN5LWdpdC50eHRcbiAgY29uc3QgZSA9IG5vcm1hbGl6ZVN0YXRzKGVudHJ5KTtcbiAgY29uc3QgcyA9IG5vcm1hbGl6ZVN0YXRzKHN0YXRzKTtcbiAgY29uc3Qgc3RhbGVuZXNzID1cbiAgICBlLm1vZGUgIT09IHMubW9kZSB8fFxuICAgIGUubXRpbWVTZWNvbmRzICE9PSBzLm10aW1lU2Vjb25kcyB8fFxuICAgIGUuY3RpbWVTZWNvbmRzICE9PSBzLmN0aW1lU2Vjb25kcyB8fFxuICAgIGUudWlkICE9PSBzLnVpZCB8fFxuICAgIGUuZ2lkICE9PSBzLmdpZCB8fFxuICAgIGUuaW5vICE9PSBzLmlubyB8fFxuICAgIGUuc2l6ZSAhPT0gcy5zaXplO1xuICByZXR1cm4gc3RhbGVuZXNzXG59XG5cbi8vIGltcG9ydCBMb2NrTWFuYWdlciBmcm9tICd0cmF2aXgtbG9jay1tYW5hZ2VyJ1xuXG4vLyBpbXBvcnQgTG9jayBmcm9tICcuLi91dGlscy5qcydcblxuLy8gY29uc3QgbG0gPSBuZXcgTG9ja01hbmFnZXIoKVxubGV0IGxvY2sgPSBudWxsO1xuXG5jb25zdCBJbmRleENhY2hlID0gU3ltYm9sKCdJbmRleENhY2hlJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuICByZXR1cm4ge1xuICAgIG1hcDogbmV3IE1hcCgpLFxuICAgIHN0YXRzOiBuZXcgTWFwKCksXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gdXBkYXRlQ2FjaGVkSW5kZXhGaWxlKGZzLCBmaWxlcGF0aCwgY2FjaGUpIHtcbiAgY29uc3Qgc3RhdCA9IGF3YWl0IGZzLmxzdGF0KGZpbGVwYXRoKTtcbiAgY29uc3QgcmF3SW5kZXhGaWxlID0gYXdhaXQgZnMucmVhZChmaWxlcGF0aCk7XG4gIGNvbnN0IGluZGV4ID0gYXdhaXQgR2l0SW5kZXguZnJvbShyYXdJbmRleEZpbGUpO1xuICAvLyBjYWNoZSB0aGUgR2l0SW5kZXggb2JqZWN0IHNvIHdlIGRvbid0IG5lZWQgdG8gcmUtcmVhZCBpdCBldmVyeSB0aW1lLlxuICBjYWNoZS5tYXAuc2V0KGZpbGVwYXRoLCBpbmRleCk7XG4gIC8vIFNhdmUgdGhlIHN0YXQgZGF0YSBmb3IgdGhlIGluZGV4IHNvIHdlIGtub3cgd2hldGhlciB0aGUgY2FjaGVkIGZpbGUgaXMgc3RhbGUgKG1vZGlmaWVkIGJ5IGFuIG91dHNpZGUgcHJvY2VzcykuXG4gIGNhY2hlLnN0YXRzLnNldChmaWxlcGF0aCwgc3RhdCk7XG59XG5cbi8vIERldGVybWluZSB3aGV0aGVyIG91ciBjb3B5IG9mIHRoZSBpbmRleCBmaWxlIGlzIHN0YWxlXG5hc3luYyBmdW5jdGlvbiBpc0luZGV4U3RhbGUoZnMsIGZpbGVwYXRoLCBjYWNoZSkge1xuICBjb25zdCBzYXZlZFN0YXRzID0gY2FjaGUuc3RhdHMuZ2V0KGZpbGVwYXRoKTtcbiAgaWYgKHNhdmVkU3RhdHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWVcbiAgY29uc3QgY3VyclN0YXRzID0gYXdhaXQgZnMubHN0YXQoZmlsZXBhdGgpO1xuICBpZiAoc2F2ZWRTdGF0cyA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlXG4gIGlmIChjdXJyU3RhdHMgPT09IG51bGwpIHJldHVybiBmYWxzZVxuICByZXR1cm4gY29tcGFyZVN0YXRzKHNhdmVkU3RhdHMsIGN1cnJTdGF0cylcbn1cblxuY2xhc3MgR2l0SW5kZXhNYW5hZ2VyIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IG9wdHMuZnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuZ2l0ZGlyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzLmNhY2hlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oR2l0SW5kZXgpOiBhbnl9IGNsb3N1cmVcbiAgICovXG4gIHN0YXRpYyBhc3luYyBhY3F1aXJlKHsgZnMsIGdpdGRpciwgY2FjaGUgfSwgY2xvc3VyZSkge1xuICAgIGlmICghY2FjaGVbSW5kZXhDYWNoZV0pIGNhY2hlW0luZGV4Q2FjaGVdID0gY3JlYXRlQ2FjaGUoKTtcblxuICAgIGNvbnN0IGZpbGVwYXRoID0gYCR7Z2l0ZGlyfS9pbmRleGA7XG4gICAgaWYgKGxvY2sgPT09IG51bGwpIGxvY2sgPSBuZXcgQXN5bmNMb2NrKHsgbWF4UGVuZGluZzogSW5maW5pdHkgfSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBhd2FpdCBsb2NrLmFjcXVpcmUoZmlsZXBhdGgsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQWNxdWlyZSBhIGZpbGUgbG9jayB3aGlsZSB3ZSdyZSByZWFkaW5nIHRoZSBpbmRleFxuICAgICAgLy8gdG8gbWFrZSBzdXJlIG90aGVyIHByb2Nlc3NlcyBhcmVuJ3Qgd3JpdGluZyB0byBpdFxuICAgICAgLy8gc2ltdWx0YW5lb3VzbHksIHdoaWNoIGNvdWxkIHJlc3VsdCBpbiBhIGNvcnJ1cHRlZCBpbmRleC5cbiAgICAgIC8vIGNvbnN0IGZpbGVMb2NrID0gYXdhaXQgTG9jayhmaWxlcGF0aClcbiAgICAgIGlmIChhd2FpdCBpc0luZGV4U3RhbGUoZnMsIGZpbGVwYXRoLCBjYWNoZVtJbmRleENhY2hlXSkpIHtcbiAgICAgICAgYXdhaXQgdXBkYXRlQ2FjaGVkSW5kZXhGaWxlKGZzLCBmaWxlcGF0aCwgY2FjaGVbSW5kZXhDYWNoZV0pO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5kZXggPSBjYWNoZVtJbmRleENhY2hlXS5tYXAuZ2V0KGZpbGVwYXRoKTtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGNsb3N1cmUoaW5kZXgpO1xuICAgICAgaWYgKGluZGV4Ll9kaXJ0eSkge1xuICAgICAgICAvLyBBY3F1aXJlIGEgZmlsZSBsb2NrIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdGhlIGluZGV4IGZpbGVcbiAgICAgICAgLy8gbGV0IGZpbGVMb2NrID0gYXdhaXQgTG9jayhmaWxlcGF0aClcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgaW5kZXgudG9PYmplY3QoKTtcbiAgICAgICAgYXdhaXQgZnMud3JpdGUoZmlsZXBhdGgsIGJ1ZmZlcik7XG4gICAgICAgIC8vIFVwZGF0ZSBjYWNoZWQgc3RhdCB2YWx1ZVxuICAgICAgICBjYWNoZVtJbmRleENhY2hlXS5zdGF0cy5zZXQoZmlsZXBhdGgsIGF3YWl0IGZzLmxzdGF0KGZpbGVwYXRoKSk7XG4gICAgICAgIGluZGV4Ll9kaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGNvbnN0IGxhc3QgPSBNYXRoLm1heChwYXRoLmxhc3RJbmRleE9mKCcvJyksIHBhdGgubGFzdEluZGV4T2YoJ1xcXFwnKSk7XG4gIGlmIChsYXN0ID4gLTEpIHtcbiAgICBwYXRoID0gcGF0aC5zbGljZShsYXN0ICsgMSk7XG4gIH1cbiAgcmV0dXJuIHBhdGhcbn1cblxuZnVuY3Rpb24gZGlybmFtZShwYXRoKSB7XG4gIGNvbnN0IGxhc3QgPSBNYXRoLm1heChwYXRoLmxhc3RJbmRleE9mKCcvJyksIHBhdGgubGFzdEluZGV4T2YoJ1xcXFwnKSk7XG4gIGlmIChsYXN0ID09PSAtMSkgcmV0dXJuICcuJ1xuICBpZiAobGFzdCA9PT0gMCkgcmV0dXJuICcvJ1xuICByZXR1cm4gcGF0aC5zbGljZSgwLCBsYXN0KVxufVxuXG4vKjo6XG50eXBlIE5vZGUgPSB7XG4gIHR5cGU6IHN0cmluZyxcbiAgZnVsbHBhdGg6IHN0cmluZyxcbiAgYmFzZW5hbWU6IHN0cmluZyxcbiAgbWV0YWRhdGE6IE9iamVjdCwgLy8gbW9kZSwgb2lkXG4gIHBhcmVudD86IE5vZGUsXG4gIGNoaWxkcmVuOiBBcnJheTxOb2RlPlxufVxuKi9cblxuZnVuY3Rpb24gZmxhdEZpbGVMaXN0VG9EaXJlY3RvcnlTdHJ1Y3R1cmUoZmlsZXMpIHtcbiAgY29uc3QgaW5vZGVzID0gbmV3IE1hcCgpO1xuICBjb25zdCBta2RpciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAoIWlub2Rlcy5oYXMobmFtZSkpIHtcbiAgICAgIGNvbnN0IGRpciA9IHtcbiAgICAgICAgdHlwZTogJ3RyZWUnLFxuICAgICAgICBmdWxscGF0aDogbmFtZSxcbiAgICAgICAgYmFzZW5hbWU6IGJhc2VuYW1lKG5hbWUpLFxuICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIH07XG4gICAgICBpbm9kZXMuc2V0KG5hbWUsIGRpcik7XG4gICAgICAvLyBUaGlzIHJlY3Vyc2l2ZWx5IGdlbmVyYXRlcyBhbnkgbWlzc2luZyBwYXJlbnQgZm9sZGVycy5cbiAgICAgIC8vIFdlIGRvIGl0IGFmdGVyIHdlJ3ZlIGFkZGVkIHRoZSBpbm9kZSB0byB0aGUgc2V0IHNvIHRoYXRcbiAgICAgIC8vIHdlIGRvbid0IHJlY3Vyc2UgaW5maW5pdGVseSB0cnlpbmcgdG8gY3JlYXRlIHRoZSByb290ICcuJyBkaXJuYW1lLlxuICAgICAgZGlyLnBhcmVudCA9IG1rZGlyKGRpcm5hbWUobmFtZSkpO1xuICAgICAgaWYgKGRpci5wYXJlbnQgJiYgZGlyLnBhcmVudCAhPT0gZGlyKSBkaXIucGFyZW50LmNoaWxkcmVuLnB1c2goZGlyKTtcbiAgICB9XG4gICAgcmV0dXJuIGlub2Rlcy5nZXQobmFtZSlcbiAgfTtcblxuICBjb25zdCBta2ZpbGUgPSBmdW5jdGlvbihuYW1lLCBtZXRhZGF0YSkge1xuICAgIGlmICghaW5vZGVzLmhhcyhuYW1lKSkge1xuICAgICAgY29uc3QgZmlsZSA9IHtcbiAgICAgICAgdHlwZTogJ2Jsb2InLFxuICAgICAgICBmdWxscGF0aDogbmFtZSxcbiAgICAgICAgYmFzZW5hbWU6IGJhc2VuYW1lKG5hbWUpLFxuICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEsXG4gICAgICAgIC8vIFRoaXMgcmVjdXJzaXZlbHkgZ2VuZXJhdGVzIGFueSBtaXNzaW5nIHBhcmVudCBmb2xkZXJzLlxuICAgICAgICBwYXJlbnQ6IG1rZGlyKGRpcm5hbWUobmFtZSkpLFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICB9O1xuICAgICAgaWYgKGZpbGUucGFyZW50KSBmaWxlLnBhcmVudC5jaGlsZHJlbi5wdXNoKGZpbGUpO1xuICAgICAgaW5vZGVzLnNldChuYW1lLCBmaWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGlub2Rlcy5nZXQobmFtZSlcbiAgfTtcblxuICBta2RpcignLicpO1xuICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICBta2ZpbGUoZmlsZS5wYXRoLCBmaWxlKTtcbiAgfVxuICByZXR1cm4gaW5vZGVzXG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBtb2RlXG4gKi9cbmZ1bmN0aW9uIG1vZGUydHlwZShtb2RlKSB7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlIDBvMDQwMDAwOiByZXR1cm4gJ3RyZWUnXG4gICAgY2FzZSAwbzEwMDY0NDogcmV0dXJuICdibG9iJ1xuICAgIGNhc2UgMG8xMDA3NTU6IHJldHVybiAnYmxvYidcbiAgICBjYXNlIDBvMTIwMDAwOiByZXR1cm4gJ2Jsb2InXG4gICAgY2FzZSAwbzE2MDAwMDogcmV0dXJuICdjb21taXQnXG4gIH1cbiAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoYFVuZXhwZWN0ZWQgR2l0VHJlZSBlbnRyeSBtb2RlOiAke21vZGUudG9TdHJpbmcoOCl9YClcbn1cblxuY2xhc3MgR2l0V2Fsa2VySW5kZXgge1xuICBjb25zdHJ1Y3Rvcih7IGZzLCBnaXRkaXIsIGNhY2hlIH0pIHtcbiAgICB0aGlzLnRyZWVQcm9taXNlID0gR2l0SW5kZXhNYW5hZ2VyLmFjcXVpcmUoXG4gICAgICB7IGZzLCBnaXRkaXIsIGNhY2hlIH0sXG4gICAgICBhc3luYyBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gZmxhdEZpbGVMaXN0VG9EaXJlY3RvcnlTdHJ1Y3R1cmUoaW5kZXguZW50cmllcylcbiAgICAgIH1cbiAgICApO1xuICAgIGNvbnN0IHdhbGtlciA9IHRoaXM7XG4gICAgdGhpcy5Db25zdHJ1Y3RFbnRyeSA9IGNsYXNzIFN0YWdlRW50cnkge1xuICAgICAgY29uc3RydWN0b3IoZnVsbHBhdGgpIHtcbiAgICAgICAgdGhpcy5fZnVsbHBhdGggPSBmdWxscGF0aDtcbiAgICAgICAgdGhpcy5fdHlwZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb2lkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGFzeW5jIHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB3YWxrZXIudHlwZSh0aGlzKVxuICAgICAgfVxuXG4gICAgICBhc3luYyBtb2RlKCkge1xuICAgICAgICByZXR1cm4gd2Fsa2VyLm1vZGUodGhpcylcbiAgICAgIH1cblxuICAgICAgYXN5bmMgc3RhdCgpIHtcbiAgICAgICAgcmV0dXJuIHdhbGtlci5zdGF0KHRoaXMpXG4gICAgICB9XG5cbiAgICAgIGFzeW5jIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB3YWxrZXIuY29udGVudCh0aGlzKVxuICAgICAgfVxuXG4gICAgICBhc3luYyBvaWQoKSB7XG4gICAgICAgIHJldHVybiB3YWxrZXIub2lkKHRoaXMpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIHJlYWRkaXIoZW50cnkpIHtcbiAgICBjb25zdCBmaWxlcGF0aCA9IGVudHJ5Ll9mdWxscGF0aDtcbiAgICBjb25zdCB0cmVlID0gYXdhaXQgdGhpcy50cmVlUHJvbWlzZTtcbiAgICBjb25zdCBpbm9kZSA9IHRyZWUuZ2V0KGZpbGVwYXRoKTtcbiAgICBpZiAoIWlub2RlKSByZXR1cm4gbnVsbFxuICAgIGlmIChpbm9kZS50eXBlID09PSAnYmxvYicpIHJldHVybiBudWxsXG4gICAgaWYgKGlub2RlLnR5cGUgIT09ICd0cmVlJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFTk9URElSOiBub3QgYSBkaXJlY3RvcnksIHNjYW5kaXIgJyR7ZmlsZXBhdGh9J2ApXG4gICAgfVxuICAgIGNvbnN0IG5hbWVzID0gaW5vZGUuY2hpbGRyZW4ubWFwKGlub2RlID0+IGlub2RlLmZ1bGxwYXRoKTtcbiAgICBuYW1lcy5zb3J0KGNvbXBhcmVTdHJpbmdzKTtcbiAgICByZXR1cm4gbmFtZXNcbiAgfVxuXG4gIGFzeW5jIHR5cGUoZW50cnkpIHtcbiAgICBpZiAoZW50cnkuX3R5cGUgPT09IGZhbHNlKSB7XG4gICAgICBhd2FpdCBlbnRyeS5zdGF0KCk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS5fdHlwZVxuICB9XG5cbiAgYXN5bmMgbW9kZShlbnRyeSkge1xuICAgIGlmIChlbnRyeS5fbW9kZSA9PT0gZmFsc2UpIHtcbiAgICAgIGF3YWl0IGVudHJ5LnN0YXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5Ll9tb2RlXG4gIH1cblxuICBhc3luYyBzdGF0KGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5Ll9zdGF0ID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgdHJlZSA9IGF3YWl0IHRoaXMudHJlZVByb21pc2U7XG4gICAgICBjb25zdCBpbm9kZSA9IHRyZWUuZ2V0KGVudHJ5Ll9mdWxscGF0aCk7XG4gICAgICBpZiAoIWlub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5LCBsc3RhdCAnJHtlbnRyeS5fZnVsbHBhdGh9J2BcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHMgPSBpbm9kZS50eXBlID09PSAndHJlZScgPyB7fSA6IG5vcm1hbGl6ZVN0YXRzKGlub2RlLm1ldGFkYXRhKTtcbiAgICAgIGVudHJ5Ll90eXBlID0gaW5vZGUudHlwZSA9PT0gJ3RyZWUnID8gJ3RyZWUnIDogbW9kZTJ0eXBlKHN0YXRzLm1vZGUpO1xuICAgICAgZW50cnkuX21vZGUgPSBzdGF0cy5tb2RlO1xuICAgICAgaWYgKGlub2RlLnR5cGUgPT09ICd0cmVlJykge1xuICAgICAgICBlbnRyeS5fc3RhdCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJ5Ll9zdGF0ID0gc3RhdHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS5fc3RhdFxuICB9XG5cbiAgYXN5bmMgY29udGVudChfZW50cnkpIHtcbiAgICAvLyBDYW5ub3QgZ2V0IGNvbnRlbnQgZm9yIGFuIGluZGV4IGVudHJ5XG4gIH1cblxuICBhc3luYyBvaWQoZW50cnkpIHtcbiAgICBpZiAoZW50cnkuX29pZCA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHRyZWUgPSBhd2FpdCB0aGlzLnRyZWVQcm9taXNlO1xuICAgICAgY29uc3QgaW5vZGUgPSB0cmVlLmdldChlbnRyeS5fZnVsbHBhdGgpO1xuICAgICAgZW50cnkuX29pZCA9IGlub2RlLm1ldGFkYXRhLm9pZDtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5Ll9vaWRcbiAgfVxufVxuXG4vLyBUaGlzIGlzIHBhcnQgb2YgYW4gZWxhYm9yYXRlIHN5c3RlbSB0byBmYWNpbGl0YXRlIGNvZGUtc3BsaXR0aW5nIC8gdHJlZS1zaGFraW5nLlxuLy8gY29tbWFuZHMvd2Fsay5qcyBjYW4gZGVwZW5kIG9uIG9ubHkgdGhpcywgYW5kIHRoZSBhY3R1YWwgV2Fsa2VyIGNsYXNzZXMgZXhwb3J0ZWRcbi8vIGNhbiBiZSBvcGFxdWUgLSBvbmx5IGhhdmluZyBhIHNpbmdsZSBwcm9wZXJ0eSAodGhpcyBzeW1ib2wpIHRoYXQgaXMgbm90IGVudW1lcmFibGUsXG4vLyBhbmQgdGh1cyB0aGUgY29uc3RydWN0b3IgY2FuIGJlIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB3YWxrIHdoaWxlIGJlaW5nIFwidW51c2FibGVcIlxuLy8gb3V0c2lkZSBvZiBpdC5cbmNvbnN0IEdpdFdhbGtTeW1ib2wgPSBTeW1ib2woJ0dpdFdhbGtTeW1ib2wnKTtcblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHJldHVybnMge1dhbGtlcn1cbiAqL1xuZnVuY3Rpb24gU1RBR0UoKSB7XG4gIGNvbnN0IG8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgR2l0V2Fsa1N5bWJvbCwge1xuICAgIHZhbHVlOiBmdW5jdGlvbih7IGZzLCBnaXRkaXIsIGNhY2hlIH0pIHtcbiAgICAgIHJldHVybiBuZXcgR2l0V2Fsa2VySW5kZXgoeyBmcywgZ2l0ZGlyLCBjYWNoZSB9KVxuICAgIH0sXG4gIH0pO1xuICBPYmplY3QuZnJlZXplKG8pO1xuICByZXR1cm4gb1xufVxuXG4vLyBAdHMtY2hlY2tcblxuY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gd2hhdFxuICAgKi9cbiAgY29uc3RydWN0b3Iod2hhdCkge1xuICAgIHN1cGVyKGBDb3VsZCBub3QgZmluZCAke3doYXR9LmApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IE5vdEZvdW5kRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IHdoYXQgfTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnTm90Rm91bmRFcnJvcid9ICovXG5Ob3RGb3VuZEVycm9yLmNvZGUgPSAnTm90Rm91bmRFcnJvcic7XG5cbmNsYXNzIE9iamVjdFR5cGVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2lkXG4gICAqIEBwYXJhbSB7J2Jsb2InfCdjb21taXQnfCd0YWcnfCd0cmVlJ30gYWN0dWFsXG4gICAqIEBwYXJhbSB7J2Jsb2InfCdjb21taXQnfCd0YWcnfCd0cmVlJ30gZXhwZWN0ZWRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtmaWxlcGF0aF1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9pZCwgYWN0dWFsLCBleHBlY3RlZCwgZmlsZXBhdGgpIHtcbiAgICBzdXBlcihcbiAgICAgIGBPYmplY3QgJHtvaWR9ICR7XG4gICAgICAgIGZpbGVwYXRoID8gYGF0ICR7ZmlsZXBhdGh9YCA6ICcnXG4gICAgICB9d2FzIGFudGljaXBhdGVkIHRvIGJlIGEgJHtleHBlY3RlZH0gYnV0IGl0IGlzIGEgJHthY3R1YWx9LmBcbiAgICApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IE9iamVjdFR5cGVFcnJvci5jb2RlO1xuICAgIHRoaXMuZGF0YSA9IHsgb2lkLCBhY3R1YWwsIGV4cGVjdGVkLCBmaWxlcGF0aCB9O1xuICB9XG59XG4vKiogQHR5cGUgeydPYmplY3RUeXBlRXJyb3InfSAqL1xuT2JqZWN0VHlwZUVycm9yLmNvZGUgPSAnT2JqZWN0VHlwZUVycm9yJztcblxuY2xhc3MgSW52YWxpZE9pZEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcihgRXhwZWN0ZWQgYSA0MC1jaGFyIGhleCBvYmplY3QgaWQgYnV0IHNhdyBcIiR7dmFsdWV9XCIuYCk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gSW52YWxpZE9pZEVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyB2YWx1ZSB9O1xuICB9XG59XG4vKiogQHR5cGUgeydJbnZhbGlkT2lkRXJyb3InfSAqL1xuSW52YWxpZE9pZEVycm9yLmNvZGUgPSAnSW52YWxpZE9pZEVycm9yJztcblxuY2xhc3MgTm9SZWZzcGVjRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVxuICAgKi9cbiAgY29uc3RydWN0b3IocmVtb3RlKSB7XG4gICAgc3VwZXIoYENvdWxkIG5vdCBmaW5kIGEgZmV0Y2ggcmVmc3BlYyBmb3IgcmVtb3RlIFwiJHtyZW1vdGV9XCIuIE1ha2Ugc3VyZSB0aGUgY29uZmlnIGZpbGUgaGFzIGFuIGVudHJ5IGxpa2UgdGhlIGZvbGxvd2luZzpcbltyZW1vdGUgXCIke3JlbW90ZX1cIl1cblxcdGZldGNoID0gK3JlZnMvaGVhZHMvKjpyZWZzL3JlbW90ZXMvb3JpZ2luLypcbmApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IE5vUmVmc3BlY0Vycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyByZW1vdGUgfTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnTm9SZWZzcGVjRXJyb3InfSAqL1xuTm9SZWZzcGVjRXJyb3IuY29kZSA9ICdOb1JlZnNwZWNFcnJvcic7XG5cbmNsYXNzIEdpdFBhY2tlZFJlZnMge1xuICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgdGhpcy5yZWZzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucGFyc2VkQ29uZmlnID0gW107XG4gICAgaWYgKHRleHQpIHtcbiAgICAgIGxldCBrZXkgPSBudWxsO1xuICAgICAgdGhpcy5wYXJzZWRDb25maWcgPSB0ZXh0XG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKGxpbmUgPT4ge1xuICAgICAgICAgIGlmICgvXlxccyojLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBsaW5lLCBjb21tZW50OiB0cnVlIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaSA9IGxpbmUuaW5kZXhPZignICcpO1xuICAgICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ14nKSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG9pZCBmb3IgdGhlIGNvbW1pdCBhc3NvY2lhdGVkIHdpdGggdGhlIGFubm90YXRlZCB0YWcgaW1tZWRpYXRlbHkgcHJlY2VkaW5nIHRoaXMgbGluZS5cbiAgICAgICAgICAgIC8vIFRyaW0gb2ZmIHRoZSAnXidcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbGluZS5zbGljZSgxKTtcbiAgICAgICAgICAgIC8vIFRoZSB0YWduYW1lXnt9IHN5bnRheCBpcyBiYXNlZCBvbiB0aGUgb3V0cHV0IG9mIGBnaXQgc2hvdy1yZWYgLS10YWdzIC1kYFxuICAgICAgICAgICAgdGhpcy5yZWZzLnNldChrZXkgKyAnXnt9JywgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgbGluZSwgcmVmOiBrZXksIHBlZWxlZDogdmFsdWUgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFuIG9pZCBmb2xsb3dlZCBieSB0aGUgcmVmIG5hbWVcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbGluZS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIGtleSA9IGxpbmUuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdGhpcy5yZWZzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmUsIHJlZjoga2V5LCBvaWQ6IHZhbHVlIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhdGljIGZyb20odGV4dCkge1xuICAgIHJldHVybiBuZXcgR2l0UGFja2VkUmVmcyh0ZXh0KVxuICB9XG5cbiAgZGVsZXRlKHJlZikge1xuICAgIHRoaXMucGFyc2VkQ29uZmlnID0gdGhpcy5wYXJzZWRDb25maWcuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LnJlZiAhPT0gcmVmKTtcbiAgICB0aGlzLnJlZnMuZGVsZXRlKHJlZik7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZWRDb25maWcubWFwKCh7IGxpbmUgfSkgPT4gbGluZSkuam9pbignXFxuJykgKyAnXFxuJ1xuICB9XG59XG5cbmNsYXNzIEdpdFJlZlNwZWMge1xuICBjb25zdHJ1Y3Rvcih7IHJlbW90ZVBhdGgsIGxvY2FsUGF0aCwgZm9yY2UsIG1hdGNoUHJlZml4IH0pIHtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHtcbiAgICAgIHJlbW90ZVBhdGgsXG4gICAgICBsb2NhbFBhdGgsXG4gICAgICBmb3JjZSxcbiAgICAgIG1hdGNoUHJlZml4LFxuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGZyb20ocmVmc3BlYykge1xuICAgIGNvbnN0IFtcbiAgICAgIGZvcmNlTWF0Y2gsXG4gICAgICByZW1vdGVQYXRoLFxuICAgICAgcmVtb3RlR2xvYk1hdGNoLFxuICAgICAgbG9jYWxQYXRoLFxuICAgICAgbG9jYWxHbG9iTWF0Y2gsXG4gICAgXSA9IHJlZnNwZWMubWF0Y2goL14oXFwrPykoLio/KShcXCo/KTooLio/KShcXCo/KSQvKS5zbGljZSgxKTtcbiAgICBjb25zdCBmb3JjZSA9IGZvcmNlTWF0Y2ggPT09ICcrJztcbiAgICBjb25zdCByZW1vdGVJc0dsb2IgPSByZW1vdGVHbG9iTWF0Y2ggPT09ICcqJztcbiAgICBjb25zdCBsb2NhbElzR2xvYiA9IGxvY2FsR2xvYk1hdGNoID09PSAnKic7XG4gICAgLy8gdmFsaWRhdGVcbiAgICAvLyBUT0RPOiBNYWtlIHRoaXMgY2hlY2sgbW9yZSBudWFuY2VkLCBhbmQgZGVwZW5kIG9uIHdoZXRoZXIgdGhpcyBpcyBhIGZldGNoIHJlZnNwZWMgb3IgYSBwdXNoIHJlZnNwZWNcbiAgICBpZiAocmVtb3RlSXNHbG9iICE9PSBsb2NhbElzR2xvYikge1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoJ0ludmFsaWQgcmVmc3BlYycpXG4gICAgfVxuICAgIHJldHVybiBuZXcgR2l0UmVmU3BlYyh7XG4gICAgICByZW1vdGVQYXRoLFxuICAgICAgbG9jYWxQYXRoLFxuICAgICAgZm9yY2UsXG4gICAgICBtYXRjaFByZWZpeDogcmVtb3RlSXNHbG9iLFxuICAgIH0pXG4gICAgLy8gVE9ETzogV2UgbmVlZCB0byBydW4gcmVzb2x2ZVJlZiBvbiBib3RoIHBhdGhzIHRvIGV4cGFuZCB0aGVtIHRvIHRoZWlyIGZ1bGwgbmFtZS5cbiAgfVxuXG4gIHRyYW5zbGF0ZShyZW1vdGVCcmFuY2gpIHtcbiAgICBpZiAodGhpcy5tYXRjaFByZWZpeCkge1xuICAgICAgaWYgKHJlbW90ZUJyYW5jaC5zdGFydHNXaXRoKHRoaXMucmVtb3RlUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxQYXRoICsgcmVtb3RlQnJhbmNoLnJlcGxhY2UodGhpcy5yZW1vdGVQYXRoLCAnJylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbW90ZUJyYW5jaCA9PT0gdGhpcy5yZW1vdGVQYXRoKSByZXR1cm4gdGhpcy5sb2NhbFBhdGhcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldmVyc2VUcmFuc2xhdGUobG9jYWxCcmFuY2gpIHtcbiAgICBpZiAodGhpcy5tYXRjaFByZWZpeCkge1xuICAgICAgaWYgKGxvY2FsQnJhbmNoLnN0YXJ0c1dpdGgodGhpcy5sb2NhbFBhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbW90ZVBhdGggKyBsb2NhbEJyYW5jaC5yZXBsYWNlKHRoaXMubG9jYWxQYXRoLCAnJylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvY2FsQnJhbmNoID09PSB0aGlzLmxvY2FsUGF0aCkgcmV0dXJuIHRoaXMucmVtb3RlUGF0aFxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmNsYXNzIEdpdFJlZlNwZWNTZXQge1xuICBjb25zdHJ1Y3RvcihydWxlcyA9IFtdKSB7XG4gICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICB9XG5cbiAgc3RhdGljIGZyb20ocmVmc3BlY3MpIHtcbiAgICBjb25zdCBydWxlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcmVmc3BlYyBvZiByZWZzcGVjcykge1xuICAgICAgcnVsZXMucHVzaChHaXRSZWZTcGVjLmZyb20ocmVmc3BlYykpOyAvLyBtaWdodCB0aHJvd1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEdpdFJlZlNwZWNTZXQocnVsZXMpXG4gIH1cblxuICBhZGQocmVmc3BlYykge1xuICAgIGNvbnN0IHJ1bGUgPSBHaXRSZWZTcGVjLmZyb20ocmVmc3BlYyk7IC8vIG1pZ2h0IHRocm93XG4gICAgdGhpcy5ydWxlcy5wdXNoKHJ1bGUpO1xuICB9XG5cbiAgdHJhbnNsYXRlKHJlbW90ZVJlZnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgdGhpcy5ydWxlcykge1xuICAgICAgZm9yIChjb25zdCByZW1vdGVSZWYgb2YgcmVtb3RlUmVmcykge1xuICAgICAgICBjb25zdCBsb2NhbFJlZiA9IHJ1bGUudHJhbnNsYXRlKHJlbW90ZVJlZik7XG4gICAgICAgIGlmIChsb2NhbFJlZikge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKFtyZW1vdGVSZWYsIGxvY2FsUmVmXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgdHJhbnNsYXRlT25lKHJlbW90ZVJlZikge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgcnVsZSBvZiB0aGlzLnJ1bGVzKSB7XG4gICAgICBjb25zdCBsb2NhbFJlZiA9IHJ1bGUudHJhbnNsYXRlKHJlbW90ZVJlZik7XG4gICAgICBpZiAobG9jYWxSZWYpIHtcbiAgICAgICAgcmVzdWx0ID0gbG9jYWxSZWY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGxvY2FsTmFtZXNwYWNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlc1xuICAgICAgLmZpbHRlcihydWxlID0+IHJ1bGUubWF0Y2hQcmVmaXgpXG4gICAgICAubWFwKHJ1bGUgPT4gcnVsZS5sb2NhbFBhdGgucmVwbGFjZSgvXFwvJC8sICcnKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlUmVmTmFtZXMoYSwgYikge1xuICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDAzNTUxMDcvMjE2ODQxNlxuICBjb25zdCBfYSA9IGEucmVwbGFjZSgvXFxeXFx7XFx9JC8sICcnKTtcbiAgY29uc3QgX2IgPSBiLnJlcGxhY2UoL1xcXlxce1xcfSQvLCAnJyk7XG4gIGNvbnN0IHRtcCA9IC0oX2EgPCBfYikgfHwgKyhfYSA+IF9iKTtcbiAgaWYgKHRtcCA9PT0gMCkge1xuICAgIHJldHVybiBhLmVuZHNXaXRoKCdee30nKSA/IDEgOiAtMVxuICB9XG4gIHJldHVybiB0bXBcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUGF0aChwYXRoKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gcGF0aFxuICAgICAgLnJlcGxhY2UoL1xcL1xcLlxcLy9nLCBcIi9cIikgLy8gUmVwbGFjZSAnLy4vJyB3aXRoICcvJ1xuICAgICAgLnJlcGxhY2UoL1xcL3syLH0vZywgXCIvXCIpIC8vIFJlcGxhY2UgY29uc2VjdXRpdmUgJy8nXG4gICAgICAucmVwbGFjZSgvXlxcL1xcLiQvLCBcIi9cIikgLy8gaWYgcGF0aCA9PT0gJy8uJyByZXR1cm4gJy8nXG4gICAgICAucmVwbGFjZSgvXlxcLlxcLyQvLCBcIi5cIikgLy8gaWYgcGF0aCA9PT0gJy4vJyByZXR1cm4gJy4nXG4gICAgICAucmVwbGFjZSgvXlxcLlxcLy8sIFwiXCIpIC8vIFJlbW92ZSBsZWFkaW5nICcuLydcbiAgICAgIC5yZXBsYWNlKC9cXC9cXC4kLywgXCJcIikgLy8gUmVtb3ZlIHRyYWlsaW5nICcvLidcbiAgICAgIC8vIC5yZXBsYWNlKC8oLispXFwvJC8sICckMScpIC8vIFJlbW92ZSB0cmFpbGluZyAnLydcbiAgICAgIC5yZXBsYWNlKC9eJC8sIFwiLlwiKTsgLy8gaWYgcGF0aCA9PT0gJycgcmV0dXJuICcuJ1xuICByZXR1cm4gKG5vcm1hbGl6ZWRQYXRoLmxlbmd0aCA+IDEgJiYgbm9ybWFsaXplZFBhdGguZW5kc1dpdGgoXCIvXCIpKSA/IG5vcm1hbGl6ZWRQYXRoLnNsaWNlKDAsIC0xKSA6IG5vcm1hbGl6ZWRQYXRoO1xufVxuXG4vLyBGb3Igc29tZSByZWFzb24gcGF0aC5wb3NpeC5qb2luIGlzIHVuZGVmaW5lZCBpbiB3ZWJwYWNrXG5cbmZ1bmN0aW9uIGpvaW4oLi4ucGFydHMpIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZVBhdGgocGFydHMubWFwKG5vcm1hbGl6ZVBhdGgpLmpvaW4oJy8nKSlcbn1cblxuLy8gVGhpcyBpcyBzdHJhaWdodCBmcm9tIHBhcnNlX3VuaXRfZmFjdG9yIGluIGNvbmZpZy5jIG9mIGNhbm9uaWNhbCBnaXRcbmNvbnN0IG51bSA9IHZhbCA9PiB7XG4gIHZhbCA9IHZhbC50b0xvd2VyQ2FzZSgpO1xuICBsZXQgbiA9IHBhcnNlSW50KHZhbCk7XG4gIGlmICh2YWwuZW5kc1dpdGgoJ2snKSkgbiAqPSAxMDI0O1xuICBpZiAodmFsLmVuZHNXaXRoKCdtJykpIG4gKj0gMTAyNCAqIDEwMjQ7XG4gIGlmICh2YWwuZW5kc1dpdGgoJ2cnKSkgbiAqPSAxMDI0ICogMTAyNCAqIDEwMjQ7XG4gIHJldHVybiBuXG59O1xuXG4vLyBUaGlzIGlzIHN0cmFpZ2h0IGZyb20gZ2l0X3BhcnNlX21heWJlX2Jvb2xfdGV4dCBpbiBjb25maWcuYyBvZiBjYW5vbmljYWwgZ2l0XG5jb25zdCBib29sID0gdmFsID0+IHtcbiAgdmFsID0gdmFsLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAodmFsID09PSAndHJ1ZScgfHwgdmFsID09PSAneWVzJyB8fCB2YWwgPT09ICdvbicpIHJldHVybiB0cnVlXG4gIGlmICh2YWwgPT09ICdmYWxzZScgfHwgdmFsID09PSAnbm8nIHx8IHZhbCA9PT0gJ29mZicpIHJldHVybiBmYWxzZVxuICB0aHJvdyBFcnJvcihcbiAgICBgRXhwZWN0ZWQgJ3RydWUnLCAnZmFsc2UnLCAneWVzJywgJ25vJywgJ29uJywgb3IgJ29mZicsIGJ1dCBnb3QgJHt2YWx9YFxuICApXG59O1xuXG5jb25zdCBzY2hlbWEgPSB7XG4gIGNvcmU6IHtcbiAgICBmaWxlbW9kZTogYm9vbCxcbiAgICBiYXJlOiBib29sLFxuICAgIGxvZ2FsbHJlZnVwZGF0ZXM6IGJvb2wsXG4gICAgc3ltbGlua3M6IGJvb2wsXG4gICAgaWdub3JlY2FzZTogYm9vbCxcbiAgICBiaWdGaWxlVGhyZXNob2xkOiBudW0sXG4gIH0sXG59O1xuXG4vLyBodHRwczovL2dpdC1zY20uY29tL2RvY3MvZ2l0LWNvbmZpZyNfc3ludGF4XG5cbi8vIHNlY3Rpb24gc3RhcnRzIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbi8vIHNlY3Rpb24gaXMgYWxwaGFudW1lcmljIChBU0NJSSkgd2l0aCAtIGFuZCAuXG4vLyBzZWN0aW9uIGlzIGNhc2UgaW5zZW5zaXRpdmVcbi8vIHN1YnNlY3Rpb24gaXMgb3B0aW9ubmFsXG4vLyBzdWJzZWN0aW9uIGlzIHNwZWNpZmllZCBhZnRlciBzZWN0aW9uIGFuZCBvbmUgb3IgbW9yZSBzcGFjZXNcbi8vIHN1YnNlY3Rpb24gaXMgc3BlY2lmaWVkIGJldHdlZW4gZG91YmxlIHF1b3Rlc1xuY29uc3QgU0VDVElPTl9MSU5FX1JFR0VYID0gL15cXFsoW0EtWmEtejAtOS0uXSspKD86IFwiKC4qKVwiKT9cXF0kLztcbmNvbnN0IFNFQ1RJT05fUkVHRVggPSAvXltBLVphLXowLTktLl0rJC87XG5cbi8vIHZhcmlhYmxlIGxpbmVzIGNvbnRhaW4gYSBuYW1lLCBhbmQgZXF1YWwgc2lnbiBhbmQgdGhlbiBhIHZhbHVlXG4vLyB2YXJpYWJsZSBsaW5lcyBjYW4gYWxzbyBvbmx5IGNvbnRhaW4gYSBuYW1lICh0aGUgaW1wbGljaXQgdmFsdWUgaXMgYSBib29sZWFuIHRydWUpXG4vLyB2YXJpYWJsZSBuYW1lIGlzIGFscGhhbnVtZXJpYyAoQVNDSUkpIHdpdGggLVxuLy8gdmFyaWFibGUgbmFtZSBzdGFydHMgd2l0aCBhbiBhbHBoYWJldGljIGNoYXJhY3RlclxuLy8gdmFyaWFibGUgbmFtZSBpcyBjYXNlIGluc2Vuc2l0aXZlXG5jb25zdCBWQVJJQUJMRV9MSU5FX1JFR0VYID0gL14oW0EtWmEtel1bQS1aYS16LV0qKSg/OiAqPSAqKC4qKSk/JC87XG5jb25zdCBWQVJJQUJMRV9OQU1FX1JFR0VYID0gL15bQS1aYS16XVtBLVphLXotXSokLztcblxuY29uc3QgVkFSSUFCTEVfVkFMVUVfQ09NTUVOVF9SRUdFWCA9IC9eKC4qPykoICpbIztdLiopJC87XG5cbmNvbnN0IGV4dHJhY3RTZWN0aW9uTGluZSA9IGxpbmUgPT4ge1xuICBjb25zdCBtYXRjaGVzID0gU0VDVElPTl9MSU5FX1JFR0VYLmV4ZWMobGluZSk7XG4gIGlmIChtYXRjaGVzICE9IG51bGwpIHtcbiAgICBjb25zdCBbc2VjdGlvbiwgc3Vic2VjdGlvbl0gPSBtYXRjaGVzLnNsaWNlKDEpO1xuICAgIHJldHVybiBbc2VjdGlvbiwgc3Vic2VjdGlvbl1cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblxuY29uc3QgZXh0cmFjdFZhcmlhYmxlTGluZSA9IGxpbmUgPT4ge1xuICBjb25zdCBtYXRjaGVzID0gVkFSSUFCTEVfTElORV9SRUdFWC5leGVjKGxpbmUpO1xuICBpZiAobWF0Y2hlcyAhPSBudWxsKSB7XG4gICAgY29uc3QgW25hbWUsIHJhd1ZhbHVlID0gJ3RydWUnXSA9IG1hdGNoZXMuc2xpY2UoMSk7XG4gICAgY29uc3QgdmFsdWVXaXRob3V0Q29tbWVudHMgPSByZW1vdmVDb21tZW50cyhyYXdWYWx1ZSk7XG4gICAgY29uc3QgdmFsdWVXaXRob3V0UXVvdGVzID0gcmVtb3ZlUXVvdGVzKHZhbHVlV2l0aG91dENvbW1lbnRzKTtcbiAgICByZXR1cm4gW25hbWUsIHZhbHVlV2l0aG91dFF1b3Rlc11cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblxuY29uc3QgcmVtb3ZlQ29tbWVudHMgPSByYXdWYWx1ZSA9PiB7XG4gIGNvbnN0IGNvbW1lbnRNYXRjaGVzID0gVkFSSUFCTEVfVkFMVUVfQ09NTUVOVF9SRUdFWC5leGVjKHJhd1ZhbHVlKTtcbiAgaWYgKGNvbW1lbnRNYXRjaGVzID09IG51bGwpIHtcbiAgICByZXR1cm4gcmF3VmFsdWVcbiAgfVxuICBjb25zdCBbdmFsdWVXaXRob3V0Q29tbWVudCwgY29tbWVudF0gPSBjb21tZW50TWF0Y2hlcy5zbGljZSgxKTtcbiAgLy8gaWYgb2RkIG51bWJlciBvZiBxdW90ZXMgYmVmb3JlIGFuZCBhZnRlciBjb21tZW50ID0+IGNvbW1lbnQgaXMgZXNjYXBlZFxuICBpZiAoXG4gICAgaGFzT2RkTnVtYmVyT2ZRdW90ZXModmFsdWVXaXRob3V0Q29tbWVudCkgJiZcbiAgICBoYXNPZGROdW1iZXJPZlF1b3Rlcyhjb21tZW50KVxuICApIHtcbiAgICByZXR1cm4gYCR7dmFsdWVXaXRob3V0Q29tbWVudH0ke2NvbW1lbnR9YFxuICB9XG4gIHJldHVybiB2YWx1ZVdpdGhvdXRDb21tZW50XG59O1xuXG5jb25zdCBoYXNPZGROdW1iZXJPZlF1b3RlcyA9IHRleHQgPT4ge1xuICBjb25zdCBudW1iZXJPZlF1b3RlcyA9ICh0ZXh0Lm1hdGNoKC8oPzpefFteXFxcXF0pXCIvZykgfHwgW10pLmxlbmd0aDtcbiAgcmV0dXJuIG51bWJlck9mUXVvdGVzICUgMiAhPT0gMFxufTtcblxuY29uc3QgcmVtb3ZlUXVvdGVzID0gdGV4dCA9PiB7XG4gIHJldHVybiB0ZXh0LnNwbGl0KCcnKS5yZWR1Y2UoKG5ld1RleHQsIGMsIGlkeCwgdGV4dCkgPT4ge1xuICAgIGNvbnN0IGlzUXVvdGUgPSBjID09PSAnXCInICYmIHRleHRbaWR4IC0gMV0gIT09ICdcXFxcJztcbiAgICBjb25zdCBpc0VzY2FwZUZvclF1b3RlID0gYyA9PT0gJ1xcXFwnICYmIHRleHRbaWR4ICsgMV0gPT09ICdcIic7XG4gICAgaWYgKGlzUXVvdGUgfHwgaXNFc2NhcGVGb3JRdW90ZSkge1xuICAgICAgcmV0dXJuIG5ld1RleHRcbiAgICB9XG4gICAgcmV0dXJuIG5ld1RleHQgKyBjXG4gIH0sICcnKVxufTtcblxuY29uc3QgbG93ZXIgPSB0ZXh0ID0+IHtcbiAgcmV0dXJuIHRleHQgIT0gbnVsbCA/IHRleHQudG9Mb3dlckNhc2UoKSA6IG51bGxcbn07XG5cbmNvbnN0IGdldFBhdGggPSAoc2VjdGlvbiwgc3Vic2VjdGlvbiwgbmFtZSkgPT4ge1xuICByZXR1cm4gW2xvd2VyKHNlY3Rpb24pLCBzdWJzZWN0aW9uLCBsb3dlcihuYW1lKV1cbiAgICAuZmlsdGVyKGEgPT4gYSAhPSBudWxsKVxuICAgIC5qb2luKCcuJylcbn07XG5cbmNvbnN0IGZpbmRMYXN0SW5kZXggPSAoYXJyYXksIGNhbGxiYWNrKSA9PiB7XG4gIHJldHVybiBhcnJheS5yZWR1Y2UoKGxhc3RJbmRleCwgaXRlbSwgaW5kZXgpID0+IHtcbiAgICByZXR1cm4gY2FsbGJhY2soaXRlbSkgPyBpbmRleCA6IGxhc3RJbmRleFxuICB9LCAtMSlcbn07XG5cbi8vIE5vdGU6IHRoZXJlIGFyZSBhIExPVCBvZiBlZGdlIGNhc2VzIHRoYXQgYXJlbid0IGNvdmVyZWQgKGUuZy4ga2V5cyBpbiBzZWN0aW9ucyB0aGF0IGFsc29cbi8vIGhhdmUgc3Vic2VjdGlvbnMsIFtpbmNsdWRlXSBkaXJlY3RpdmVzLCBldGMuXG5jbGFzcyBHaXRDb25maWcge1xuICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgbGV0IHNlY3Rpb24gPSBudWxsO1xuICAgIGxldCBzdWJzZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnBhcnNlZENvbmZpZyA9IHRleHQuc3BsaXQoJ1xcbicpLm1hcChsaW5lID0+IHtcbiAgICAgIGxldCBuYW1lID0gbnVsbDtcbiAgICAgIGxldCB2YWx1ZSA9IG51bGw7XG5cbiAgICAgIGNvbnN0IHRyaW1tZWRMaW5lID0gbGluZS50cmltKCk7XG4gICAgICBjb25zdCBleHRyYWN0ZWRTZWN0aW9uID0gZXh0cmFjdFNlY3Rpb25MaW5lKHRyaW1tZWRMaW5lKTtcbiAgICAgIGNvbnN0IGlzU2VjdGlvbiA9IGV4dHJhY3RlZFNlY3Rpb24gIT0gbnVsbDtcbiAgICAgIGlmIChpc1NlY3Rpb24pIHtcbiAgICAgICAgO1tzZWN0aW9uLCBzdWJzZWN0aW9uXSA9IGV4dHJhY3RlZFNlY3Rpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBleHRyYWN0ZWRWYXJpYWJsZSA9IGV4dHJhY3RWYXJpYWJsZUxpbmUodHJpbW1lZExpbmUpO1xuICAgICAgICBjb25zdCBpc1ZhcmlhYmxlID0gZXh0cmFjdGVkVmFyaWFibGUgIT0gbnVsbDtcbiAgICAgICAgaWYgKGlzVmFyaWFibGUpIHtcbiAgICAgICAgICA7W25hbWUsIHZhbHVlXSA9IGV4dHJhY3RlZFZhcmlhYmxlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhdGggPSBnZXRQYXRoKHNlY3Rpb24sIHN1YnNlY3Rpb24sIG5hbWUpO1xuICAgICAgcmV0dXJuIHsgbGluZSwgaXNTZWN0aW9uLCBzZWN0aW9uLCBzdWJzZWN0aW9uLCBuYW1lLCB2YWx1ZSwgcGF0aCB9XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZnJvbSh0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBHaXRDb25maWcodGV4dClcbiAgfVxuXG4gIGFzeW5jIGdldChwYXRoLCBnZXRhbGwgPSBmYWxzZSkge1xuICAgIGNvbnN0IGFsbFZhbHVlcyA9IHRoaXMucGFyc2VkQ29uZmlnXG4gICAgICAuZmlsdGVyKGNvbmZpZyA9PiBjb25maWcucGF0aCA9PT0gcGF0aC50b0xvd2VyQ2FzZSgpKVxuICAgICAgLm1hcCgoeyBzZWN0aW9uLCBuYW1lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZuID0gc2NoZW1hW3NlY3Rpb25dICYmIHNjaGVtYVtzZWN0aW9uXVtuYW1lXTtcbiAgICAgICAgcmV0dXJuIGZuID8gZm4odmFsdWUpIDogdmFsdWVcbiAgICAgIH0pO1xuICAgIHJldHVybiBnZXRhbGwgPyBhbGxWYWx1ZXMgOiBhbGxWYWx1ZXMucG9wKClcbiAgfVxuXG4gIGFzeW5jIGdldGFsbChwYXRoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KHBhdGgsIHRydWUpXG4gIH1cblxuICBhc3luYyBnZXRTdWJzZWN0aW9ucyhzZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VkQ29uZmlnXG4gICAgICAuZmlsdGVyKGNvbmZpZyA9PiBjb25maWcuc2VjdGlvbiA9PT0gc2VjdGlvbiAmJiBjb25maWcuaXNTZWN0aW9uKVxuICAgICAgLm1hcChjb25maWcgPT4gY29uZmlnLnN1YnNlY3Rpb24pXG4gIH1cblxuICBhc3luYyBkZWxldGVTZWN0aW9uKHNlY3Rpb24sIHN1YnNlY3Rpb24pIHtcbiAgICB0aGlzLnBhcnNlZENvbmZpZyA9IHRoaXMucGFyc2VkQ29uZmlnLmZpbHRlcihcbiAgICAgIGNvbmZpZyA9PlxuICAgICAgICAhKGNvbmZpZy5zZWN0aW9uID09PSBzZWN0aW9uICYmIGNvbmZpZy5zdWJzZWN0aW9uID09PSBzdWJzZWN0aW9uKVxuICAgICk7XG4gIH1cblxuICBhc3luYyBhcHBlbmQocGF0aCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXQocGF0aCwgdmFsdWUsIHRydWUpXG4gIH1cblxuICBhc3luYyBzZXQocGF0aCwgdmFsdWUsIGFwcGVuZCA9IGZhbHNlKSB7XG4gICAgY29uc3QgY29uZmlnSW5kZXggPSBmaW5kTGFzdEluZGV4KFxuICAgICAgdGhpcy5wYXJzZWRDb25maWcsXG4gICAgICBjb25maWcgPT4gY29uZmlnLnBhdGggPT09IHBhdGgudG9Mb3dlckNhc2UoKVxuICAgICk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmIChjb25maWdJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5wYXJzZWRDb25maWcuc3BsaWNlKGNvbmZpZ0luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNvbmZpZ0luZGV4ICE9PSAtMSkge1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLnBhcnNlZENvbmZpZ1tjb25maWdJbmRleF07XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCB7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgbW9kaWZpZWQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYXBwZW5kKSB7XG4gICAgICAgICAgdGhpcy5wYXJzZWRDb25maWcuc3BsaWNlKGNvbmZpZ0luZGV4ICsgMSwgMCwgbW9kaWZpZWRDb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFyc2VkQ29uZmlnW2NvbmZpZ0luZGV4XSA9IG1vZGlmaWVkQ29uZmlnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwYXRoU2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICAgIGNvbnN0IHNlY3Rpb24gPSBwYXRoU2VnbWVudHMuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBuYW1lID0gcGF0aFNlZ21lbnRzLnBvcCgpO1xuICAgICAgICBjb25zdCBzdWJzZWN0aW9uID0gcGF0aFNlZ21lbnRzLmxlbmd0aFxuICAgICAgICAgID8gcGF0aFNlZ21lbnRzLmpvaW4oJy4nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNlY3Rpb25QYXRoID0gc3Vic2VjdGlvbiA/IHNlY3Rpb24gKyAnLicgKyBzdWJzZWN0aW9uIDogc2VjdGlvbjtcbiAgICAgICAgY29uc3Qgc2VjdGlvbkluZGV4ID0gdGhpcy5wYXJzZWRDb25maWcuZmluZEluZGV4KFxuICAgICAgICAgIGNvbmZpZyA9PiBjb25maWcucGF0aCA9PT0gc2VjdGlvblBhdGhcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbmV3Q29uZmlnID0ge1xuICAgICAgICAgIHNlY3Rpb24sXG4gICAgICAgICAgc3Vic2VjdGlvbixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG1vZGlmaWVkOiB0cnVlLFxuICAgICAgICAgIHBhdGg6IGdldFBhdGgoc2VjdGlvbiwgc3Vic2VjdGlvbiwgbmFtZSksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChTRUNUSU9OX1JFR0VYLnRlc3Qoc2VjdGlvbikgJiYgVkFSSUFCTEVfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgaWYgKHNlY3Rpb25JbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBSZXVzZSBleGlzdGluZyBzZWN0aW9uXG4gICAgICAgICAgICB0aGlzLnBhcnNlZENvbmZpZy5zcGxpY2Uoc2VjdGlvbkluZGV4ICsgMSwgMCwgbmV3Q29uZmlnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQWRkIGEgbmV3IHNlY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IG5ld1NlY3Rpb24gPSB7XG4gICAgICAgICAgICAgIHNlY3Rpb24sXG4gICAgICAgICAgICAgIHN1YnNlY3Rpb24sXG4gICAgICAgICAgICAgIG1vZGlmaWVkOiB0cnVlLFxuICAgICAgICAgICAgICBwYXRoOiBnZXRQYXRoKHNlY3Rpb24sIHN1YnNlY3Rpb24sIG51bGwpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucGFyc2VkQ29uZmlnLnB1c2gobmV3U2VjdGlvbiwgbmV3Q29uZmlnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZWRDb25maWdcbiAgICAgIC5tYXAoKHsgbGluZSwgc2VjdGlvbiwgc3Vic2VjdGlvbiwgbmFtZSwgdmFsdWUsIG1vZGlmaWVkID0gZmFsc2UgfSkgPT4ge1xuICAgICAgICBpZiAoIW1vZGlmaWVkKSB7XG4gICAgICAgICAgcmV0dXJuIGxpbmVcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSAhPSBudWxsICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYFxcdCR7bmFtZX0gPSAke3ZhbHVlfWBcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Vic2VjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGBbJHtzZWN0aW9ufSBcIiR7c3Vic2VjdGlvbn1cIl1gXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBbJHtzZWN0aW9ufV1gXG4gICAgICB9KVxuICAgICAgLmpvaW4oJ1xcbicpXG4gIH1cbn1cblxuY2xhc3MgR2l0Q29uZmlnTWFuYWdlciB7XG4gIHN0YXRpYyBhc3luYyBnZXQoeyBmcywgZ2l0ZGlyIH0pIHtcbiAgICAvLyBXZSBjYW4gaW1wcm92ZSBlZmZpY2llbmN5IGxhdGVyIGlmIG5lZWRlZC5cbiAgICAvLyBUT0RPOiByZWFkIGZyb20gZnVsbCBsaXN0IG9mIGdpdCBjb25maWcgZmlsZXNcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgZnMucmVhZChgJHtnaXRkaXJ9L2NvbmZpZ2AsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KTtcbiAgICByZXR1cm4gR2l0Q29uZmlnLmZyb20odGV4dClcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBzYXZlKHsgZnMsIGdpdGRpciwgY29uZmlnIH0pIHtcbiAgICAvLyBXZSBjYW4gaW1wcm92ZSBlZmZpY2llbmN5IGxhdGVyIGlmIG5lZWRlZC5cbiAgICAvLyBUT0RPOiBoYW5kbGUgc2F2aW5nIHRvIHRoZSBjb3JyZWN0IGdsb2JhbC91c2VyL3JlcG8gbG9jYXRpb25cbiAgICBhd2FpdCBmcy53cml0ZShgJHtnaXRkaXJ9L2NvbmZpZ2AsIGNvbmZpZy50b1N0cmluZygpLCB7XG4gICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgIH0pO1xuICB9XG59XG5cbi8vIFRoaXMgaXMgYSBjb252ZW5pZW5jZSB3cmFwcGVyIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIGZpbGVzIGluIHRoZSAncmVmcycgZGlyZWN0b3J5LlxuXG4vLyBAc2VlIGh0dHBzOi8vZ2l0LXNjbS5jb20vZG9jcy9naXQtcmV2LXBhcnNlLmh0bWwjX3NwZWNpZnlpbmdfcmV2aXNpb25zXG5jb25zdCByZWZwYXRocyA9IHJlZiA9PiBbXG4gIGAke3JlZn1gLFxuICBgcmVmcy8ke3JlZn1gLFxuICBgcmVmcy90YWdzLyR7cmVmfWAsXG4gIGByZWZzL2hlYWRzLyR7cmVmfWAsXG4gIGByZWZzL3JlbW90ZXMvJHtyZWZ9YCxcbiAgYHJlZnMvcmVtb3Rlcy8ke3JlZn0vSEVBRGAsXG5dO1xuXG4vLyBAc2VlIGh0dHBzOi8vZ2l0LXNjbS5jb20vZG9jcy9naXRyZXBvc2l0b3J5LWxheW91dFxuY29uc3QgR0lUX0ZJTEVTID0gWydjb25maWcnLCAnZGVzY3JpcHRpb24nLCAnaW5kZXgnLCAnc2hhbGxvdycsICdjb21tb25kaXInXTtcblxuY2xhc3MgR2l0UmVmTWFuYWdlciB7XG4gIHN0YXRpYyBhc3luYyB1cGRhdGVSZW1vdGVSZWZzKHtcbiAgICBmcyxcbiAgICBnaXRkaXIsXG4gICAgcmVtb3RlLFxuICAgIHJlZnMsXG4gICAgc3ltcmVmcyxcbiAgICB0YWdzLFxuICAgIHJlZnNwZWNzID0gdW5kZWZpbmVkLFxuICAgIHBydW5lID0gZmFsc2UsXG4gICAgcHJ1bmVUYWdzID0gZmFsc2UsXG4gIH0pIHtcbiAgICAvLyBWYWxpZGF0ZSBpbnB1dFxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgcmVmcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKCF2YWx1ZS5tYXRjaCgvWzAtOWEtZl17NDB9LykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPaWRFcnJvcih2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gYXdhaXQgR2l0Q29uZmlnTWFuYWdlci5nZXQoeyBmcywgZ2l0ZGlyIH0pO1xuICAgIGlmICghcmVmc3BlY3MpIHtcbiAgICAgIHJlZnNwZWNzID0gYXdhaXQgY29uZmlnLmdldGFsbChgcmVtb3RlLiR7cmVtb3RlfS5mZXRjaGApO1xuICAgICAgaWYgKHJlZnNwZWNzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgTm9SZWZzcGVjRXJyb3IocmVtb3RlKVxuICAgICAgfVxuICAgICAgLy8gVGhlcmUncyBzb21lIGludGVyZXN0aW5nIGJlaGF2aW9yIHdpdGggSEVBRCB0aGF0IGRvZXNuJ3QgZm9sbG93IHRoZSByZWZzcGVjLlxuICAgICAgcmVmc3BlY3MudW5zaGlmdChgK0hFQUQ6cmVmcy9yZW1vdGVzLyR7cmVtb3RlfS9IRUFEYCk7XG4gICAgfVxuICAgIGNvbnN0IHJlZnNwZWMgPSBHaXRSZWZTcGVjU2V0LmZyb20ocmVmc3BlY3MpO1xuICAgIGNvbnN0IGFjdHVhbFJlZnNUb1dyaXRlID0gbmV3IE1hcCgpO1xuICAgIC8vIERlbGV0ZSBhbGwgY3VycmVudCB0YWdzIGlmIHRoZSBwcnVuZVRhZ3MgYXJndW1lbnQgaXMgdHJ1ZS5cbiAgICBpZiAocHJ1bmVUYWdzKSB7XG4gICAgICBjb25zdCB0YWdzID0gYXdhaXQgR2l0UmVmTWFuYWdlci5saXN0UmVmcyh7XG4gICAgICAgIGZzLFxuICAgICAgICBnaXRkaXIsXG4gICAgICAgIGZpbGVwYXRoOiAncmVmcy90YWdzJyxcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgR2l0UmVmTWFuYWdlci5kZWxldGVSZWZzKHtcbiAgICAgICAgZnMsXG4gICAgICAgIGdpdGRpcixcbiAgICAgICAgcmVmczogdGFncy5tYXAodGFnID0+IGByZWZzL3RhZ3MvJHt0YWd9YCksXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWRkIGFsbCB0YWdzIGlmIHRoZSBmZXRjaCB0YWdzIGFyZ3VtZW50IGlzIHRydWUuXG4gICAgaWYgKHRhZ3MpIHtcbiAgICAgIGZvciAoY29uc3Qgc2VydmVyUmVmIG9mIHJlZnMua2V5cygpKSB7XG4gICAgICAgIGlmIChzZXJ2ZXJSZWYuc3RhcnRzV2l0aCgncmVmcy90YWdzJykgJiYgIXNlcnZlclJlZi5lbmRzV2l0aCgnXnt9JykpIHtcbiAgICAgICAgICAvLyBHaXQncyBiZWhhdmlvciBpcyB0byBvbmx5IGZldGNoIHRhZ3MgdGhhdCBkbyBub3QgY29uZmxpY3Qgd2l0aCB0YWdzIGFscmVhZHkgcHJlc2VudC5cbiAgICAgICAgICBpZiAoIShhd2FpdCBHaXRSZWZNYW5hZ2VyLmV4aXN0cyh7IGZzLCBnaXRkaXIsIHJlZjogc2VydmVyUmVmIH0pKSkge1xuICAgICAgICAgICAgLy8gQWx3YXlzIHVzZSB0aGUgb2JqZWN0IGlkIG9mIHRoZSB0YWcgaXRzZWxmLCBhbmQgbm90IHRoZSBwZWVsZWQgb2JqZWN0IGlkLlxuICAgICAgICAgICAgY29uc3Qgb2lkID0gcmVmcy5nZXQoc2VydmVyUmVmKTtcbiAgICAgICAgICAgIGFjdHVhbFJlZnNUb1dyaXRlLnNldChzZXJ2ZXJSZWYsIG9pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENvbWJpbmUgcmVmcyBhbmQgc3ltcmVmcyBnaXZpbmcgc3ltcmVmcyBwcmlvcml0eVxuICAgIGNvbnN0IHJlZlRyYW5zbGF0aW9ucyA9IHJlZnNwZWMudHJhbnNsYXRlKFsuLi5yZWZzLmtleXMoKV0pO1xuICAgIGZvciAoY29uc3QgW3NlcnZlclJlZiwgdHJhbnNsYXRlZFJlZl0gb2YgcmVmVHJhbnNsYXRpb25zKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHJlZnMuZ2V0KHNlcnZlclJlZik7XG4gICAgICBhY3R1YWxSZWZzVG9Xcml0ZS5zZXQodHJhbnNsYXRlZFJlZiwgdmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCBzeW1yZWZUcmFuc2xhdGlvbnMgPSByZWZzcGVjLnRyYW5zbGF0ZShbLi4uc3ltcmVmcy5rZXlzKCldKTtcbiAgICBmb3IgKGNvbnN0IFtzZXJ2ZXJSZWYsIHRyYW5zbGF0ZWRSZWZdIG9mIHN5bXJlZlRyYW5zbGF0aW9ucykge1xuICAgICAgY29uc3QgdmFsdWUgPSBzeW1yZWZzLmdldChzZXJ2ZXJSZWYpO1xuICAgICAgY29uc3Qgc3ltdGFyZ2V0ID0gcmVmc3BlYy50cmFuc2xhdGVPbmUodmFsdWUpO1xuICAgICAgaWYgKHN5bXRhcmdldCkge1xuICAgICAgICBhY3R1YWxSZWZzVG9Xcml0ZS5zZXQodHJhbnNsYXRlZFJlZiwgYHJlZjogJHtzeW10YXJnZXR9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIElmIGBwcnVuZWAgYXJndW1lbnQgaXMgdHJ1ZSwgY2xlYXIgb3V0IHRoZSBleGlzdGluZyBsb2NhbCByZWZzcGVjIHJvb3RzXG4gICAgY29uc3QgcHJ1bmVkID0gW107XG4gICAgaWYgKHBydW5lKSB7XG4gICAgICBmb3IgKGNvbnN0IGZpbGVwYXRoIG9mIHJlZnNwZWMubG9jYWxOYW1lc3BhY2VzKCkpIHtcbiAgICAgICAgY29uc3QgcmVmcyA9IChcbiAgICAgICAgICBhd2FpdCBHaXRSZWZNYW5hZ2VyLmxpc3RSZWZzKHtcbiAgICAgICAgICAgIGZzLFxuICAgICAgICAgICAgZ2l0ZGlyLFxuICAgICAgICAgICAgZmlsZXBhdGgsXG4gICAgICAgICAgfSlcbiAgICAgICAgKS5tYXAoZmlsZSA9PiBgJHtmaWxlcGF0aH0vJHtmaWxlfWApO1xuICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiByZWZzKSB7XG4gICAgICAgICAgaWYgKCFhY3R1YWxSZWZzVG9Xcml0ZS5oYXMocmVmKSkge1xuICAgICAgICAgICAgcHJ1bmVkLnB1c2gocmVmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcnVuZWQubGVuZ3RoID4gMCkge1xuICAgICAgICBhd2FpdCBHaXRSZWZNYW5hZ2VyLmRlbGV0ZVJlZnMoeyBmcywgZ2l0ZGlyLCByZWZzOiBwcnVuZWQgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVwZGF0ZSBmaWxlc1xuICAgIC8vIFRPRE86IEZvciBsYXJnZSByZXBvcyB3aXRoIGEgaGlzdG9yeSBvZiB0aG91c2FuZHMgb2YgcHVsbCByZXF1ZXN0c1xuICAgIC8vIChpLmUuIGdpdGxhYi1jZSkgaXQgd291bGQgYmUgdmFzdGx5IG1vcmUgZWZmaWNpZW50IHRvIHdyaXRlIHRoZW1cbiAgICAvLyB0byAuZ2l0L3BhY2tlZC1yZWZzLlxuICAgIC8vIFRoZSB0cmljayBpcyB0byBtYWtlIHN1cmUgd2UgYSkgZG9uJ3Qgd3JpdGUgYSBwYWNrZWQgcmVmIHRoYXQgaXNcbiAgICAvLyBhbHJlYWR5IHNoYWRvd2VkIGJ5IGEgbG9vc2UgcmVmIGFuZCBiKSBkb24ndCBsb29zZSBhbnkgcmVmcyBhbHJlYWR5XG4gICAgLy8gaW4gcGFja2VkLXJlZnMuIERvaW5nIHRoaXMgZWZmaWNpZW50bHkgbWF5IGJlIGRpZmZpY3VsdC4gQVxuICAgIC8vIHNvbHV0aW9uIHRoYXQgbWlnaHQgd29yayBpc1xuICAgIC8vIGEpIGxvYWQgdGhlIGN1cnJlbnQgcGFja2VkLXJlZnMgZmlsZVxuICAgIC8vIGIpIGFkZCBhY3R1YWxSZWZzVG9Xcml0ZSwgb3ZlcnJpZGluZyB0aGUgZXhpc3RpbmcgdmFsdWVzIGlmIHByZXNlbnRcbiAgICAvLyBjKSBlbnVtZXJhdGUgYWxsIHRoZSBsb29zZSByZWZzIGN1cnJlbnRseSBpbiAuZ2l0L3JlZnMvcmVtb3Rlcy8ke3JlbW90ZX1cbiAgICAvLyBkKSBvdmVyd3JpdGUgdGhlaXIgdmFsdWUgd2l0aCB0aGUgbmV3IHZhbHVlLlxuICAgIC8vIEV4YW1wbGVzIG9mIHJlZnMgd2UgbmVlZCB0byBhdm9pZCB3cml0aW5nIGluIGxvb3NlIGZvcm1hdCBmb3IgZWZmaWNpZW55J3Mgc2FrZVxuICAgIC8vIGFyZSAuZ2l0L3JlZnMvcmVtb3Rlcy9vcmlnaW4vcmVmcy9yZW1vdGVzL3JlbW90ZV9taXJyb3JfMzA1OVxuICAgIC8vIGFuZCAuZ2l0L3JlZnMvcmVtb3Rlcy9vcmlnaW4vcmVmcy9tZXJnZS1yZXF1ZXN0c1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGFjdHVhbFJlZnNUb1dyaXRlKSB7XG4gICAgICBhd2FpdCBmcy53cml0ZShqb2luKGdpdGRpciwga2V5KSwgYCR7dmFsdWUudHJpbSgpfVxcbmAsICd1dGY4Jyk7XG4gICAgfVxuICAgIHJldHVybiB7IHBydW5lZCB9XG4gIH1cblxuICAvLyBUT0RPOiBtYWtlIHRoaXMgbGVzcyBjcnVkZT9cbiAgc3RhdGljIGFzeW5jIHdyaXRlUmVmKHsgZnMsIGdpdGRpciwgcmVmLCB2YWx1ZSB9KSB7XG4gICAgLy8gVmFsaWRhdGUgaW5wdXRcbiAgICBpZiAoIXZhbHVlLm1hdGNoKC9bMC05YS1mXXs0MH0vKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRPaWRFcnJvcih2YWx1ZSlcbiAgICB9XG4gICAgYXdhaXQgZnMud3JpdGUoam9pbihnaXRkaXIsIHJlZiksIGAke3ZhbHVlLnRyaW0oKX1cXG5gLCAndXRmOCcpO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIHdyaXRlU3ltYm9saWNSZWYoeyBmcywgZ2l0ZGlyLCByZWYsIHZhbHVlIH0pIHtcbiAgICBhd2FpdCBmcy53cml0ZShqb2luKGdpdGRpciwgcmVmKSwgJ3JlZjogJyArIGAke3ZhbHVlLnRyaW0oKX1cXG5gLCAndXRmOCcpO1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIGRlbGV0ZVJlZih7IGZzLCBnaXRkaXIsIHJlZiB9KSB7XG4gICAgcmV0dXJuIEdpdFJlZk1hbmFnZXIuZGVsZXRlUmVmcyh7IGZzLCBnaXRkaXIsIHJlZnM6IFtyZWZdIH0pXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZGVsZXRlUmVmcyh7IGZzLCBnaXRkaXIsIHJlZnMgfSkge1xuICAgIC8vIERlbGV0ZSByZWd1bGFyIHJlZlxuICAgIGF3YWl0IFByb21pc2UuYWxsKHJlZnMubWFwKHJlZiA9PiBmcy5ybShqb2luKGdpdGRpciwgcmVmKSkpKTtcbiAgICAvLyBEZWxldGUgYW55IHBhY2tlZCByZWZcbiAgICBsZXQgdGV4dCA9IGF3YWl0IGZzLnJlYWQoYCR7Z2l0ZGlyfS9wYWNrZWQtcmVmc2AsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KTtcbiAgICBjb25zdCBwYWNrZWQgPSBHaXRQYWNrZWRSZWZzLmZyb20odGV4dCk7XG4gICAgY29uc3QgYmVmb3JlU2l6ZSA9IHBhY2tlZC5yZWZzLnNpemU7XG4gICAgZm9yIChjb25zdCByZWYgb2YgcmVmcykge1xuICAgICAgaWYgKHBhY2tlZC5yZWZzLmhhcyhyZWYpKSB7XG4gICAgICAgIHBhY2tlZC5kZWxldGUocmVmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhY2tlZC5yZWZzLnNpemUgPCBiZWZvcmVTaXplKSB7XG4gICAgICB0ZXh0ID0gcGFja2VkLnRvU3RyaW5nKCk7XG4gICAgICBhd2FpdCBmcy53cml0ZShgJHtnaXRkaXJ9L3BhY2tlZC1yZWZzYCwgdGV4dCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWZcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmRlcHRoXVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICAgKi9cbiAgc3RhdGljIGFzeW5jIHJlc29sdmUoeyBmcywgZ2l0ZGlyLCByZWYsIGRlcHRoID0gdW5kZWZpbmVkIH0pIHtcbiAgICBpZiAoZGVwdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVwdGgtLTtcbiAgICAgIGlmIChkZXB0aCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHJlZlxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgc2hhO1xuICAgIC8vIElzIGl0IGEgcmVmIHBvaW50ZXI/XG4gICAgaWYgKHJlZi5zdGFydHNXaXRoKCdyZWY6ICcpKSB7XG4gICAgICByZWYgPSByZWYuc2xpY2UoJ3JlZjogJy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGZzLCBnaXRkaXIsIHJlZiwgZGVwdGggfSlcbiAgICB9XG4gICAgLy8gSXMgaXQgYSBjb21wbGV0ZSBhbmQgdmFsaWQgU0hBP1xuICAgIGlmIChyZWYubGVuZ3RoID09PSA0MCAmJiAvWzAtOWEtZl17NDB9Ly50ZXN0KHJlZikpIHtcbiAgICAgIHJldHVybiByZWZcbiAgICB9XG4gICAgLy8gV2UgbmVlZCB0byBhbHRlcm5hdGUgYmV0d2VlbiB0aGUgZmlsZSBzeXN0ZW0gYW5kIHRoZSBwYWNrZWQtcmVmc1xuICAgIGNvbnN0IHBhY2tlZE1hcCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucGFja2VkUmVmcyh7IGZzLCBnaXRkaXIgfSk7XG4gICAgLy8gTG9vayBpbiBhbGwgdGhlIHByb3BlciBwYXRocywgaW4gdGhpcyBvcmRlclxuICAgIGNvbnN0IGFsbHBhdGhzID0gcmVmcGF0aHMocmVmKS5maWx0ZXIocCA9PiAhR0lUX0ZJTEVTLmluY2x1ZGVzKHApKTsgLy8gZXhjbHVkZSBnaXQgc3lzdGVtIGZpbGVzICgjNzA5KVxuXG4gICAgZm9yIChjb25zdCByZWYgb2YgYWxscGF0aHMpIHtcbiAgICAgIHNoYSA9XG4gICAgICAgIChhd2FpdCBmcy5yZWFkKGAke2dpdGRpcn0vJHtyZWZ9YCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pKSB8fFxuICAgICAgICBwYWNrZWRNYXAuZ2V0KHJlZik7XG4gICAgICBpZiAoc2hhKSB7XG4gICAgICAgIHJldHVybiBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoeyBmcywgZ2l0ZGlyLCByZWY6IHNoYS50cmltKCksIGRlcHRoIH0pXG4gICAgICB9XG4gICAgfVxuICAgIC8vIERvIHdlIGdpdmUgdXA/XG4gICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IocmVmKVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGV4aXN0cyh7IGZzLCBnaXRkaXIsIHJlZiB9KSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIuZXhwYW5kKHsgZnMsIGdpdGRpciwgcmVmIH0pO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBleHBhbmQoeyBmcywgZ2l0ZGlyLCByZWYgfSkge1xuICAgIC8vIElzIGl0IGEgY29tcGxldGUgYW5kIHZhbGlkIFNIQT9cbiAgICBpZiAocmVmLmxlbmd0aCA9PT0gNDAgJiYgL1swLTlhLWZdezQwfS8udGVzdChyZWYpKSB7XG4gICAgICByZXR1cm4gcmVmXG4gICAgfVxuICAgIC8vIFdlIG5lZWQgdG8gYWx0ZXJuYXRlIGJldHdlZW4gdGhlIGZpbGUgc3lzdGVtIGFuZCB0aGUgcGFja2VkLXJlZnNcbiAgICBjb25zdCBwYWNrZWRNYXAgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnBhY2tlZFJlZnMoeyBmcywgZ2l0ZGlyIH0pO1xuICAgIC8vIExvb2sgaW4gYWxsIHRoZSBwcm9wZXIgcGF0aHMsIGluIHRoaXMgb3JkZXJcbiAgICBjb25zdCBhbGxwYXRocyA9IHJlZnBhdGhzKHJlZik7XG4gICAgZm9yIChjb25zdCByZWYgb2YgYWxscGF0aHMpIHtcbiAgICAgIGlmIChhd2FpdCBmcy5leGlzdHMoYCR7Z2l0ZGlyfS8ke3JlZn1gKSkgcmV0dXJuIHJlZlxuICAgICAgaWYgKHBhY2tlZE1hcC5oYXMocmVmKSkgcmV0dXJuIHJlZlxuICAgIH1cbiAgICAvLyBEbyB3ZSBnaXZlIHVwP1xuICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKHJlZilcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBleHBhbmRBZ2FpbnN0TWFwKHsgcmVmLCBtYXAgfSkge1xuICAgIC8vIExvb2sgaW4gYWxsIHRoZSBwcm9wZXIgcGF0aHMsIGluIHRoaXMgb3JkZXJcbiAgICBjb25zdCBhbGxwYXRocyA9IHJlZnBhdGhzKHJlZik7XG4gICAgZm9yIChjb25zdCByZWYgb2YgYWxscGF0aHMpIHtcbiAgICAgIGlmIChhd2FpdCBtYXAuaGFzKHJlZikpIHJldHVybiByZWZcbiAgICB9XG4gICAgLy8gRG8gd2UgZ2l2ZSB1cD9cbiAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcihyZWYpXG4gIH1cblxuICBzdGF0aWMgcmVzb2x2ZUFnYWluc3RNYXAoeyByZWYsIGZ1bGxyZWYgPSByZWYsIGRlcHRoID0gdW5kZWZpbmVkLCBtYXAgfSkge1xuICAgIGlmIChkZXB0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXB0aC0tO1xuICAgICAgaWYgKGRlcHRoID09PSAtMSkge1xuICAgICAgICByZXR1cm4geyBmdWxscmVmLCBvaWQ6IHJlZiB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIElzIGl0IGEgcmVmIHBvaW50ZXI/XG4gICAgaWYgKHJlZi5zdGFydHNXaXRoKCdyZWY6ICcpKSB7XG4gICAgICByZWYgPSByZWYuc2xpY2UoJ3JlZjogJy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIEdpdFJlZk1hbmFnZXIucmVzb2x2ZUFnYWluc3RNYXAoeyByZWYsIGZ1bGxyZWYsIGRlcHRoLCBtYXAgfSlcbiAgICB9XG4gICAgLy8gSXMgaXQgYSBjb21wbGV0ZSBhbmQgdmFsaWQgU0hBP1xuICAgIGlmIChyZWYubGVuZ3RoID09PSA0MCAmJiAvWzAtOWEtZl17NDB9Ly50ZXN0KHJlZikpIHtcbiAgICAgIHJldHVybiB7IGZ1bGxyZWYsIG9pZDogcmVmIH1cbiAgICB9XG4gICAgLy8gTG9vayBpbiBhbGwgdGhlIHByb3BlciBwYXRocywgaW4gdGhpcyBvcmRlclxuICAgIGNvbnN0IGFsbHBhdGhzID0gcmVmcGF0aHMocmVmKTtcbiAgICBmb3IgKGNvbnN0IHJlZiBvZiBhbGxwYXRocykge1xuICAgICAgY29uc3Qgc2hhID0gbWFwLmdldChyZWYpO1xuICAgICAgaWYgKHNoYSkge1xuICAgICAgICByZXR1cm4gR2l0UmVmTWFuYWdlci5yZXNvbHZlQWdhaW5zdE1hcCh7XG4gICAgICAgICAgcmVmOiBzaGEudHJpbSgpLFxuICAgICAgICAgIGZ1bGxyZWY6IHJlZixcbiAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICBtYXAsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAgIC8vIERvIHdlIGdpdmUgdXA/XG4gICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IocmVmKVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIHBhY2tlZFJlZnMoeyBmcywgZ2l0ZGlyIH0pIHtcbiAgICBjb25zdCB0ZXh0ID0gYXdhaXQgZnMucmVhZChgJHtnaXRkaXJ9L3BhY2tlZC1yZWZzYCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICAgIGNvbnN0IHBhY2tlZCA9IEdpdFBhY2tlZFJlZnMuZnJvbSh0ZXh0KTtcbiAgICByZXR1cm4gcGFja2VkLnJlZnNcbiAgfVxuXG4gIC8vIExpc3QgYWxsIHRoZSByZWZzIHRoYXQgbWF0Y2ggdGhlIGBmaWxlcGF0aGAgcHJlZml4XG4gIHN0YXRpYyBhc3luYyBsaXN0UmVmcyh7IGZzLCBnaXRkaXIsIGZpbGVwYXRoIH0pIHtcbiAgICBjb25zdCBwYWNrZWRNYXAgPSBHaXRSZWZNYW5hZ2VyLnBhY2tlZFJlZnMoeyBmcywgZ2l0ZGlyIH0pO1xuICAgIGxldCBmaWxlcyA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGZpbGVzID0gYXdhaXQgZnMucmVhZGRpckRlZXAoYCR7Z2l0ZGlyfS8ke2ZpbGVwYXRofWApO1xuICAgICAgZmlsZXMgPSBmaWxlcy5tYXAoeCA9PiB4LnJlcGxhY2UoYCR7Z2l0ZGlyfS8ke2ZpbGVwYXRofS9gLCAnJykpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZmlsZXMgPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBrZXkgb2YgKGF3YWl0IHBhY2tlZE1hcCkua2V5cygpKSB7XG4gICAgICAvLyBmaWx0ZXIgYnkgcHJlZml4XG4gICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoZmlsZXBhdGgpKSB7XG4gICAgICAgIC8vIHJlbW92ZSBwcmVmaXhcbiAgICAgICAga2V5ID0ga2V5LnJlcGxhY2UoZmlsZXBhdGggKyAnLycsICcnKTtcbiAgICAgICAgLy8gRG9uJ3QgaW5jbHVkZSBkdXBsaWNhdGVzOyB0aGUgbG9vc2UgZmlsZXMgaGF2ZSBwcmVjZWRlbmNlIGFueXdheVxuICAgICAgICBpZiAoIWZpbGVzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBmaWxlcy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gc2luY2Ugd2UganVzdCBhcHBlbmRlZCB0aGluZ3Mgb250byBhbiBhcnJheSwgd2UgbmVlZCB0byBzb3J0IHRoZW0gbm93XG4gICAgZmlsZXMuc29ydChjb21wYXJlUmVmTmFtZXMpO1xuICAgIHJldHVybiBmaWxlc1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIGxpc3RCcmFuY2hlcyh7IGZzLCBnaXRkaXIsIHJlbW90ZSB9KSB7XG4gICAgaWYgKHJlbW90ZSkge1xuICAgICAgcmV0dXJuIEdpdFJlZk1hbmFnZXIubGlzdFJlZnMoe1xuICAgICAgICBmcyxcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICBmaWxlcGF0aDogYHJlZnMvcmVtb3Rlcy8ke3JlbW90ZX1gLFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEdpdFJlZk1hbmFnZXIubGlzdFJlZnMoeyBmcywgZ2l0ZGlyLCBmaWxlcGF0aDogYHJlZnMvaGVhZHNgIH0pXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGxpc3RUYWdzKHsgZnMsIGdpdGRpciB9KSB7XG4gICAgY29uc3QgdGFncyA9IGF3YWl0IEdpdFJlZk1hbmFnZXIubGlzdFJlZnMoe1xuICAgICAgZnMsXG4gICAgICBnaXRkaXIsXG4gICAgICBmaWxlcGF0aDogYHJlZnMvdGFnc2AsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRhZ3MuZmlsdGVyKHggPT4gIXguZW5kc1dpdGgoJ157fScpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVUcmVlRW50cnlQYXRoKGEsIGIpIHtcbiAgLy8gR2l0IHNvcnRzIHRyZWUgZW50cmllcyBhcyBpZiB0aGVyZSBpcyBhIHRyYWlsaW5nIHNsYXNoIG9uIGRpcmVjdG9yeSBuYW1lcy5cbiAgcmV0dXJuIGNvbXBhcmVTdHJpbmdzKGFwcGVuZFNsYXNoSWZEaXIoYSksIGFwcGVuZFNsYXNoSWZEaXIoYikpXG59XG5cbmZ1bmN0aW9uIGFwcGVuZFNsYXNoSWZEaXIoZW50cnkpIHtcbiAgcmV0dXJuIGVudHJ5Lm1vZGUgPT09ICcwNDAwMDAnID8gZW50cnkucGF0aCArICcvJyA6IGVudHJ5LnBhdGhcbn1cblxuLyoqXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gVHJlZUVudHJ5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbW9kZSAtIHRoZSA2IGRpZ2l0IGhleGFkZWNpbWFsIG1vZGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXRoIC0gdGhlIG5hbWUgb2YgdGhlIGZpbGUgb3IgZGlyZWN0b3J5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkIC0gdGhlIFNIQS0xIG9iamVjdCBpZCBvZiB0aGUgYmxvYiBvciB0cmVlXG4gKiBAcHJvcGVydHkgeydjb21taXQnfCdibG9iJ3wndHJlZSd9IHR5cGUgLSB0aGUgdHlwZSBvZiBvYmplY3RcbiAqL1xuXG5mdW5jdGlvbiBtb2RlMnR5cGUkMShtb2RlKSB7XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBzd2l0Y2ggKG1vZGUpIHtcbiAgICBjYXNlICcwNDAwMDAnOiByZXR1cm4gJ3RyZWUnXG4gICAgY2FzZSAnMTAwNjQ0JzogcmV0dXJuICdibG9iJ1xuICAgIGNhc2UgJzEwMDc1NSc6IHJldHVybiAnYmxvYidcbiAgICBjYXNlICcxMjAwMDAnOiByZXR1cm4gJ2Jsb2InXG4gICAgY2FzZSAnMTYwMDAwJzogcmV0dXJuICdjb21taXQnXG4gIH1cbiAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoYFVuZXhwZWN0ZWQgR2l0VHJlZSBlbnRyeSBtb2RlOiAke21vZGV9YClcbn1cblxuZnVuY3Rpb24gcGFyc2VCdWZmZXIoYnVmZmVyKSB7XG4gIGNvbnN0IF9lbnRyaWVzID0gW107XG4gIGxldCBjdXJzb3IgPSAwO1xuICB3aGlsZSAoY3Vyc29yIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgIGNvbnN0IHNwYWNlID0gYnVmZmVyLmluZGV4T2YoMzIsIGN1cnNvcik7XG4gICAgaWYgKHNwYWNlID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoXG4gICAgICAgIGBHaXRUcmVlOiBFcnJvciBwYXJzaW5nIGJ1ZmZlciBhdCBieXRlIGxvY2F0aW9uICR7Y3Vyc29yfTogQ291bGQgbm90IGZpbmQgdGhlIG5leHQgc3BhY2UgY2hhcmFjdGVyLmBcbiAgICAgIClcbiAgICB9XG4gICAgY29uc3QgbnVsbGNoYXIgPSBidWZmZXIuaW5kZXhPZigwLCBjdXJzb3IpO1xuICAgIGlmIChudWxsY2hhciA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKFxuICAgICAgICBgR2l0VHJlZTogRXJyb3IgcGFyc2luZyBidWZmZXIgYXQgYnl0ZSBsb2NhdGlvbiAke2N1cnNvcn06IENvdWxkIG5vdCBmaW5kIHRoZSBuZXh0IG51bGwgY2hhcmFjdGVyLmBcbiAgICAgIClcbiAgICB9XG4gICAgbGV0IG1vZGUgPSBidWZmZXIuc2xpY2UoY3Vyc29yLCBzcGFjZSkudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICBpZiAobW9kZSA9PT0gJzQwMDAwJykgbW9kZSA9ICcwNDAwMDAnOyAvLyBtYWtlcyBpdCBsaW5lIHVwIG5lYXRlciBpbiBwcmludGVkIG91dHB1dFxuICAgIGNvbnN0IHR5cGUgPSBtb2RlMnR5cGUkMShtb2RlKTtcbiAgICBjb25zdCBwYXRoID0gYnVmZmVyLnNsaWNlKHNwYWNlICsgMSwgbnVsbGNoYXIpLnRvU3RyaW5nKCd1dGY4Jyk7XG5cbiAgICAvLyBQcmV2ZW50IG1hbGljaW91cyBnaXQgcmVwb3MgZnJvbSB3cml0aW5nIHRvIFwiLi5cXGZvb1wiIG9uIGNsb25lIGV0Y1xuICAgIGlmIChwYXRoLmluY2x1ZGVzKCdcXFxcJykgfHwgcGF0aC5pbmNsdWRlcygnLycpKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zYWZlRmlsZXBhdGhFcnJvcihwYXRoKVxuICAgIH1cblxuICAgIGNvbnN0IG9pZCA9IGJ1ZmZlci5zbGljZShudWxsY2hhciArIDEsIG51bGxjaGFyICsgMjEpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjdXJzb3IgPSBudWxsY2hhciArIDIxO1xuICAgIF9lbnRyaWVzLnB1c2goeyBtb2RlLCBwYXRoLCBvaWQsIHR5cGUgfSk7XG4gIH1cbiAgcmV0dXJuIF9lbnRyaWVzXG59XG5cbmZ1bmN0aW9uIGxpbWl0TW9kZVRvQWxsb3dlZChtb2RlKSB7XG4gIGlmICh0eXBlb2YgbW9kZSA9PT0gJ251bWJlcicpIHtcbiAgICBtb2RlID0gbW9kZS50b1N0cmluZyg4KTtcbiAgfVxuICAvLyB0cmVlXG4gIGlmIChtb2RlLm1hdGNoKC9eMD80LiovKSkgcmV0dXJuICcwNDAwMDAnIC8vIERpcmVjdG9yeVxuICBpZiAobW9kZS5tYXRjaCgvXjEwMDYuKi8pKSByZXR1cm4gJzEwMDY0NCcgLy8gUmVndWxhciBub24tZXhlY3V0YWJsZSBmaWxlXG4gIGlmIChtb2RlLm1hdGNoKC9eMTAwNy4qLykpIHJldHVybiAnMTAwNzU1JyAvLyBSZWd1bGFyIGV4ZWN1dGFibGUgZmlsZVxuICBpZiAobW9kZS5tYXRjaCgvXjEyMC4qLykpIHJldHVybiAnMTIwMDAwJyAvLyBTeW1ib2xpYyBsaW5rXG4gIGlmIChtb2RlLm1hdGNoKC9eMTYwLiovKSkgcmV0dXJuICcxNjAwMDAnIC8vIENvbW1pdCAoZ2l0IHN1Ym1vZHVsZSByZWZlcmVuY2UpXG4gIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKGBDb3VsZCBub3QgdW5kZXJzdGFuZCBmaWxlIG1vZGU6ICR7bW9kZX1gKVxufVxuXG5mdW5jdGlvbiBudWRnZUludG9TaGFwZShlbnRyeSkge1xuICBpZiAoIWVudHJ5Lm9pZCAmJiBlbnRyeS5zaGEpIHtcbiAgICBlbnRyeS5vaWQgPSBlbnRyeS5zaGE7IC8vIEdpdGh1YlxuICB9XG4gIGVudHJ5Lm1vZGUgPSBsaW1pdE1vZGVUb0FsbG93ZWQoZW50cnkubW9kZSk7IC8vIGluZGV4XG4gIGlmICghZW50cnkudHlwZSkge1xuICAgIGVudHJ5LnR5cGUgPSBtb2RlMnR5cGUkMShlbnRyeS5tb2RlKTsgLy8gaW5kZXhcbiAgfVxuICByZXR1cm4gZW50cnlcbn1cblxuY2xhc3MgR2l0VHJlZSB7XG4gIGNvbnN0cnVjdG9yKGVudHJpZXMpIHtcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGVudHJpZXMpKSB7XG4gICAgICB0aGlzLl9lbnRyaWVzID0gcGFyc2VCdWZmZXIoZW50cmllcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVudHJpZXMpKSB7XG4gICAgICB0aGlzLl9lbnRyaWVzID0gZW50cmllcy5tYXAobnVkZ2VJbnRvU2hhcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcignaW52YWxpZCB0eXBlIHBhc3NlZCB0byBHaXRUcmVlIGNvbnN0cnVjdG9yJylcbiAgICB9XG4gICAgLy8gVHJlZSBlbnRyaWVzIGFyZSBub3Qgc29ydGVkIGFscGhhYmV0aWNhbGx5IGluIHRoZSB1c3VhbCBzZW5zZSAoc2VlIGBjb21wYXJlVHJlZUVudHJ5UGF0aGApXG4gICAgLy8gYnV0IGl0IGlzIGltcG9ydGFudCBsYXRlciBvbiB0aGF0IHRoZXNlIGJlIHNvcnRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IHdvdWxkIGJlIHJldHVybmVkIGZyb20gcmVhZGRpci5cbiAgICB0aGlzLl9lbnRyaWVzLnNvcnQoY29tcGFyZVBhdGgpO1xuICB9XG5cbiAgc3RhdGljIGZyb20odHJlZSkge1xuICAgIHJldHVybiBuZXcgR2l0VHJlZSh0cmVlKVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9lbnRyaWVzXG4gICAgICAubWFwKGVudHJ5ID0+IGAke2VudHJ5Lm1vZGV9ICR7ZW50cnkudHlwZX0gJHtlbnRyeS5vaWR9ICAgICR7ZW50cnkucGF0aH1gKVxuICAgICAgLmpvaW4oJ1xcbicpXG4gIH1cblxuICB0b09iamVjdCgpIHtcbiAgICAvLyBBZGp1c3QgdGhlIHNvcnQgb3JkZXIgdG8gbWF0Y2ggZ2l0J3NcbiAgICBjb25zdCBlbnRyaWVzID0gWy4uLnRoaXMuX2VudHJpZXNdO1xuICAgIGVudHJpZXMuc29ydChjb21wYXJlVHJlZUVudHJ5UGF0aCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoXG4gICAgICBlbnRyaWVzLm1hcChlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0IG1vZGUgPSBCdWZmZXIuZnJvbShlbnRyeS5tb2RlLnJlcGxhY2UoL14wLywgJycpKTtcbiAgICAgICAgY29uc3Qgc3BhY2UgPSBCdWZmZXIuZnJvbSgnICcpO1xuICAgICAgICBjb25zdCBwYXRoID0gQnVmZmVyLmZyb20oZW50cnkucGF0aCwgJ3V0ZjgnKTtcbiAgICAgICAgY29uc3QgbnVsbGNoYXIgPSBCdWZmZXIuZnJvbShbMF0pO1xuICAgICAgICBjb25zdCBvaWQgPSBCdWZmZXIuZnJvbShlbnRyeS5vaWQsICdoZXgnKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW21vZGUsIHNwYWNlLCBwYXRoLCBudWxsY2hhciwgb2lkXSlcbiAgICAgIH0pXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtUcmVlRW50cnlbXX1cbiAgICovXG4gIGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudHJpZXNcbiAgfVxuXG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMuX2VudHJpZXMpIHtcbiAgICAgIHlpZWxkIGVudHJ5O1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBHaXRPYmplY3Qge1xuICBzdGF0aWMgd3JhcCh7IHR5cGUsIG9iamVjdCB9KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW1xuICAgICAgQnVmZmVyLmZyb20oYCR7dHlwZX0gJHtvYmplY3QuYnl0ZUxlbmd0aC50b1N0cmluZygpfVxceDAwYCksXG4gICAgICBCdWZmZXIuZnJvbShvYmplY3QpLFxuICAgIF0pXG4gIH1cblxuICBzdGF0aWMgdW53cmFwKGJ1ZmZlcikge1xuICAgIGNvbnN0IHMgPSBidWZmZXIuaW5kZXhPZigzMik7IC8vIGZpcnN0IHNwYWNlXG4gICAgY29uc3QgaSA9IGJ1ZmZlci5pbmRleE9mKDApOyAvLyBmaXJzdCBudWxsIHZhbHVlXG4gICAgY29uc3QgdHlwZSA9IGJ1ZmZlci5zbGljZSgwLCBzKS50b1N0cmluZygndXRmOCcpOyAvLyBnZXQgdHlwZSBvZiBvYmplY3RcbiAgICBjb25zdCBsZW5ndGggPSBidWZmZXIuc2xpY2UocyArIDEsIGkpLnRvU3RyaW5nKCd1dGY4Jyk7IC8vIGdldCB0eXBlIG9mIG9iamVjdFxuICAgIGNvbnN0IGFjdHVhbExlbmd0aCA9IGJ1ZmZlci5sZW5ndGggLSAoaSArIDEpO1xuICAgIC8vIHZlcmlmeSBsZW5ndGhcbiAgICBpZiAocGFyc2VJbnQobGVuZ3RoKSAhPT0gYWN0dWFsTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihcbiAgICAgICAgYExlbmd0aCBtaXNtYXRjaDogZXhwZWN0ZWQgJHtsZW5ndGh9IGJ5dGVzIGJ1dCBnb3QgJHthY3R1YWxMZW5ndGh9IGluc3RlYWQuYFxuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZSxcbiAgICAgIG9iamVjdDogQnVmZmVyLmZyb20oYnVmZmVyLnNsaWNlKGkgKyAxKSksXG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlYWRPYmplY3RMb29zZSh7IGZzLCBnaXRkaXIsIG9pZCB9KSB7XG4gIGNvbnN0IHNvdXJjZSA9IGBvYmplY3RzLyR7b2lkLnNsaWNlKDAsIDIpfS8ke29pZC5zbGljZSgyKX1gO1xuICBjb25zdCBmaWxlID0gYXdhaXQgZnMucmVhZChgJHtnaXRkaXJ9LyR7c291cmNlfWApO1xuICBpZiAoIWZpbGUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHJldHVybiB7IG9iamVjdDogZmlsZSwgZm9ybWF0OiAnZGVmbGF0ZWQnLCBzb3VyY2UgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBkZWx0YVxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZVxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gYXBwbHlEZWx0YShkZWx0YSwgc291cmNlKSB7XG4gIGNvbnN0IHJlYWRlciA9IG5ldyBCdWZmZXJDdXJzb3IoZGVsdGEpO1xuICBjb25zdCBzb3VyY2VTaXplID0gcmVhZFZhckludExFKHJlYWRlcik7XG5cbiAgaWYgKHNvdXJjZVNpemUgIT09IHNvdXJjZS5ieXRlTGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoXG4gICAgICBgYXBwbHlEZWx0YSBleHBlY3RlZCBzb3VyY2UgYnVmZmVyIHRvIGJlICR7c291cmNlU2l6ZX0gYnl0ZXMgYnV0IHRoZSBwcm92aWRlZCBidWZmZXIgd2FzICR7c291cmNlLmxlbmd0aH0gYnl0ZXNgXG4gICAgKVxuICB9XG4gIGNvbnN0IHRhcmdldFNpemUgPSByZWFkVmFySW50TEUocmVhZGVyKTtcbiAgbGV0IHRhcmdldDtcblxuICBjb25zdCBmaXJzdE9wID0gcmVhZE9wKHJlYWRlciwgc291cmNlKTtcbiAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0gcmV0dXJuIHJhdyBidWZmZXIgaWYgaXQncyBqdXN0IHNpbmdsZSBzaW1wbGUgY29weVxuICBpZiAoZmlyc3RPcC5ieXRlTGVuZ3RoID09PSB0YXJnZXRTaXplKSB7XG4gICAgdGFyZ2V0ID0gZmlyc3RPcDtcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2UsIGFsbG9jYXRlIGEgZnJlc2ggYnVmZmVyIGFuZCBzbGljZXNcbiAgICB0YXJnZXQgPSBCdWZmZXIuYWxsb2ModGFyZ2V0U2l6ZSk7XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IEJ1ZmZlckN1cnNvcih0YXJnZXQpO1xuICAgIHdyaXRlci5jb3B5KGZpcnN0T3ApO1xuXG4gICAgd2hpbGUgKCFyZWFkZXIuZW9mKCkpIHtcbiAgICAgIHdyaXRlci5jb3B5KHJlYWRPcChyZWFkZXIsIHNvdXJjZSkpO1xuICAgIH1cblxuICAgIGNvbnN0IHRlbGwgPSB3cml0ZXIudGVsbCgpO1xuICAgIGlmICh0YXJnZXRTaXplICE9PSB0ZWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihcbiAgICAgICAgYGFwcGx5RGVsdGEgZXhwZWN0ZWQgdGFyZ2V0IGJ1ZmZlciB0byBiZSAke3RhcmdldFNpemV9IGJ5dGVzIGJ1dCB0aGUgcmVzdWx0aW5nIGJ1ZmZlciB3YXMgJHt0ZWxsfSBieXRlc2BcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldFxufVxuXG5mdW5jdGlvbiByZWFkVmFySW50TEUocmVhZGVyKSB7XG4gIGxldCByZXN1bHQgPSAwO1xuICBsZXQgc2hpZnQgPSAwO1xuICBsZXQgYnl0ZSA9IG51bGw7XG4gIGRvIHtcbiAgICBieXRlID0gcmVhZGVyLnJlYWRVSW50OCgpO1xuICAgIHJlc3VsdCB8PSAoYnl0ZSAmIDBiMDExMTExMTEpIDw8IHNoaWZ0O1xuICAgIHNoaWZ0ICs9IDc7XG4gIH0gd2hpbGUgKGJ5dGUgJiAwYjEwMDAwMDAwKVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHJlYWRDb21wYWN0TEUocmVhZGVyLCBmbGFncywgc2l6ZSkge1xuICBsZXQgcmVzdWx0ID0gMDtcbiAgbGV0IHNoaWZ0ID0gMDtcbiAgd2hpbGUgKHNpemUtLSkge1xuICAgIGlmIChmbGFncyAmIDBiMDAwMDAwMDEpIHtcbiAgICAgIHJlc3VsdCB8PSByZWFkZXIucmVhZFVJbnQ4KCkgPDwgc2hpZnQ7XG4gICAgfVxuICAgIGZsYWdzID4+PSAxO1xuICAgIHNoaWZ0ICs9IDg7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiByZWFkT3AocmVhZGVyLCBzb3VyY2UpIHtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gIGNvbnN0IGJ5dGUgPSByZWFkZXIucmVhZFVJbnQ4KCk7XG4gIGNvbnN0IENPUFkgPSAwYjEwMDAwMDAwO1xuICBjb25zdCBPRkZTID0gMGIwMDAwMTExMTtcbiAgY29uc3QgU0laRSA9IDBiMDExMTAwMDA7XG4gIGlmIChieXRlICYgQ09QWSkge1xuICAgIC8vIGNvcHkgY29uc2lzdHMgb2YgNCBieXRlIG9mZnNldCwgMyBieXRlIHNpemUgKGluIExFIG9yZGVyKVxuICAgIGNvbnN0IG9mZnNldCA9IHJlYWRDb21wYWN0TEUocmVhZGVyLCBieXRlICYgT0ZGUywgNCk7XG4gICAgbGV0IHNpemUgPSByZWFkQ29tcGFjdExFKHJlYWRlciwgKGJ5dGUgJiBTSVpFKSA+PiA0LCAzKTtcbiAgICAvLyBZdXAuIFRoZXkgcmVhbGx5IGRpZCB0aGlzIG9wdGltaXphdGlvbi5cbiAgICBpZiAoc2l6ZSA9PT0gMCkgc2l6ZSA9IDB4MTAwMDA7XG4gICAgcmV0dXJuIHNvdXJjZS5zbGljZShvZmZzZXQsIG9mZnNldCArIHNpemUpXG4gIH0gZWxzZSB7XG4gICAgLy8gaW5zZXJ0XG4gICAgcmV0dXJuIHJlYWRlci5zbGljZShieXRlKVxuICB9XG59XG5cbi8vIENvbnZlcnQgYSB2YWx1ZSB0byBhbiBBc3luYyBJdGVyYXRvclxuLy8gVGhpcyB3aWxsIGJlIGVhc2llciB3aXRoIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbnMuXG5mdW5jdGlvbiBmcm9tVmFsdWUodmFsdWUpIHtcbiAgbGV0IHF1ZXVlID0gW3ZhbHVlXTtcbiAgcmV0dXJuIHtcbiAgICBuZXh0KCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IHF1ZXVlLmxlbmd0aCA9PT0gMCwgdmFsdWU6IHF1ZXVlLnBvcCgpIH0pXG4gICAgfSxcbiAgICByZXR1cm4oKSB7XG4gICAgICBxdWV1ZSA9IFtdO1xuICAgICAgcmV0dXJuIHt9XG4gICAgfSxcbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yKGl0ZXJhYmxlKSB7XG4gIGlmIChpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHtcbiAgICByZXR1cm4gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKClcbiAgfVxuICBpZiAoaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgIHJldHVybiBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKClcbiAgfVxuICBpZiAoaXRlcmFibGUubmV4dCkge1xuICAgIHJldHVybiBpdGVyYWJsZVxuICB9XG4gIHJldHVybiBmcm9tVmFsdWUoaXRlcmFibGUpXG59XG5cbi8vIGluc3BpcmVkIGJ5ICdnYXJ0YWwnIGJ1dCBsaWdodGVyLXdlaWdodCBhbmQgbW9yZSBiYXR0bGUtdGVzdGVkLlxuY2xhc3MgU3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5zdHJlYW0gPSBnZXRJdGVyYXRvcihzdHJlYW0pO1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmN1cnNvciA9IDA7XG4gICAgdGhpcy51bmRvQ3Vyc29yID0gMDtcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Rpc2NhcmRlZEJ5dGVzID0gMDtcbiAgfVxuXG4gIGVvZigpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5kZWQgJiYgdGhpcy5jdXJzb3IgPT09IHRoaXMuYnVmZmVyLmxlbmd0aFxuICB9XG5cbiAgdGVsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzY2FyZGVkQnl0ZXMgKyB0aGlzLmN1cnNvclxuICB9XG5cbiAgYXN5bmMgYnl0ZSgpIHtcbiAgICBpZiAodGhpcy5lb2YoKSkgcmV0dXJuXG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIGF3YWl0IHRoaXMuX2luaXQoKTtcbiAgICBpZiAodGhpcy5jdXJzb3IgPT09IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgYXdhaXQgdGhpcy5fbG9hZG5leHQoKTtcbiAgICAgIGlmICh0aGlzLl9lbmRlZCkgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3IoMSk7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMudW5kb0N1cnNvcl1cbiAgfVxuXG4gIGFzeW5jIGNodW5rKCkge1xuICAgIGlmICh0aGlzLmVvZigpKSByZXR1cm5cbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkgYXdhaXQgdGhpcy5faW5pdCgpO1xuICAgIGlmICh0aGlzLmN1cnNvciA9PT0gdGhpcy5idWZmZXIubGVuZ3RoKSB7XG4gICAgICBhd2FpdCB0aGlzLl9sb2FkbmV4dCgpO1xuICAgICAgaWYgKHRoaXMuX2VuZGVkKSByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvcih0aGlzLmJ1ZmZlci5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zbGljZSh0aGlzLnVuZG9DdXJzb3IsIHRoaXMuY3Vyc29yKVxuICB9XG5cbiAgYXN5bmMgcmVhZChuKSB7XG4gICAgaWYgKHRoaXMuZW9mKCkpIHJldHVyblxuICAgIGlmICghdGhpcy5zdGFydGVkKSBhd2FpdCB0aGlzLl9pbml0KCk7XG4gICAgaWYgKHRoaXMuY3Vyc29yICsgbiA+IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdHJpbSgpO1xuICAgICAgYXdhaXQgdGhpcy5fYWNjdW11bGF0ZShuKTtcbiAgICB9XG4gICAgdGhpcy5fbW92ZUN1cnNvcihuKTtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIuc2xpY2UodGhpcy51bmRvQ3Vyc29yLCB0aGlzLmN1cnNvcilcbiAgfVxuXG4gIGFzeW5jIHNraXAobikge1xuICAgIGlmICh0aGlzLmVvZigpKSByZXR1cm5cbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkgYXdhaXQgdGhpcy5faW5pdCgpO1xuICAgIGlmICh0aGlzLmN1cnNvciArIG4gPiB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3RyaW0oKTtcbiAgICAgIGF3YWl0IHRoaXMuX2FjY3VtdWxhdGUobik7XG4gICAgfVxuICAgIHRoaXMuX21vdmVDdXJzb3Iobik7XG4gIH1cblxuICBhc3luYyB1bmRvKCkge1xuICAgIHRoaXMuY3Vyc29yID0gdGhpcy51bmRvQ3Vyc29yO1xuICB9XG5cbiAgYXN5bmMgX25leHQoKSB7XG4gICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICBsZXQgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgdGhpcy5zdHJlYW0ubmV4dCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICB0aGlzLl9lbmRlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgX3RyaW0oKSB7XG4gICAgLy8gVGhyb3cgYXdheSBwYXJ0cyBvZiB0aGUgYnVmZmVyIHdlIGRvbid0IG5lZWQgYW55bW9yZVxuICAgIC8vIGFzc2VydCh0aGlzLmN1cnNvciA8PSB0aGlzLmJ1ZmZlci5sZW5ndGgpXG4gICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zbGljZSh0aGlzLnVuZG9DdXJzb3IpO1xuICAgIHRoaXMuY3Vyc29yIC09IHRoaXMudW5kb0N1cnNvcjtcbiAgICB0aGlzLl9kaXNjYXJkZWRCeXRlcyArPSB0aGlzLnVuZG9DdXJzb3I7XG4gICAgdGhpcy51bmRvQ3Vyc29yID0gMDtcbiAgfVxuXG4gIF9tb3ZlQ3Vyc29yKG4pIHtcbiAgICB0aGlzLnVuZG9DdXJzb3IgPSB0aGlzLmN1cnNvcjtcbiAgICB0aGlzLmN1cnNvciArPSBuO1xuICAgIGlmICh0aGlzLmN1cnNvciA+IHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX2FjY3VtdWxhdGUobikge1xuICAgIGlmICh0aGlzLl9lbmRlZCkgcmV0dXJuXG4gICAgLy8gRXhwYW5kIHRoZSBidWZmZXIgdW50aWwgd2UgaGF2ZSBOIGJ5dGVzIG9mIGRhdGFcbiAgICAvLyBvciB3ZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIHN0cmVhbVxuICAgIGNvbnN0IGJ1ZmZlcnMgPSBbdGhpcy5idWZmZXJdO1xuICAgIHdoaWxlICh0aGlzLmN1cnNvciArIG4gPiBsZW5ndGhCdWZmZXJzKGJ1ZmZlcnMpKSB7XG4gICAgICBjb25zdCBuZXh0YnVmZmVyID0gYXdhaXQgdGhpcy5fbmV4dCgpO1xuICAgICAgaWYgKHRoaXMuX2VuZGVkKSBicmVha1xuICAgICAgYnVmZmVycy5wdXNoKG5leHRidWZmZXIpO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycyk7XG4gIH1cblxuICBhc3luYyBfbG9hZG5leHQoKSB7XG4gICAgdGhpcy5fZGlzY2FyZGVkQnl0ZXMgKz0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgIHRoaXMudW5kb0N1cnNvciA9IDA7XG4gICAgdGhpcy5jdXJzb3IgPSAwO1xuICAgIHRoaXMuYnVmZmVyID0gYXdhaXQgdGhpcy5fbmV4dCgpO1xuICB9XG5cbiAgYXN5bmMgX2luaXQoKSB7XG4gICAgdGhpcy5idWZmZXIgPSBhd2FpdCB0aGlzLl9uZXh0KCk7XG4gIH1cbn1cblxuLy8gVGhpcyBoZWxwZXIgZnVuY3Rpb24gaGVscHMgdXMgcG9zdHBvbmUgY29uY2F0ZW5hdGluZyBidWZmZXJzLCB3aGljaFxuLy8gd291bGQgY3JlYXRlIGludGVybWVkaWF0ZSBidWZmZXIgb2JqZWN0cyxcbmZ1bmN0aW9uIGxlbmd0aEJ1ZmZlcnMoYnVmZmVycykge1xuICByZXR1cm4gYnVmZmVycy5yZWR1Y2UoKGFjYywgYnVmZmVyKSA9PiBhY2MgKyBidWZmZXIubGVuZ3RoLCAwKVxufVxuXG4vLyBNeSB2ZXJzaW9uIG9mIGdpdC1saXN0LXBhY2sgLSByb3VnaGx5IDE1eCBmYXN0ZXIgdGhhbiB0aGUgb3JpZ2luYWxcblxuYXN5bmMgZnVuY3Rpb24gbGlzdHBhY2soc3RyZWFtLCBvbkRhdGEpIHtcbiAgY29uc3QgcmVhZGVyID0gbmV3IFN0cmVhbVJlYWRlcihzdHJlYW0pO1xuICBsZXQgUEFDSyA9IGF3YWl0IHJlYWRlci5yZWFkKDQpO1xuICBQQUNLID0gUEFDSy50b1N0cmluZygndXRmOCcpO1xuICBpZiAoUEFDSyAhPT0gJ1BBQ0snKSB7XG4gICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoYEludmFsaWQgUEFDSyBoZWFkZXIgJyR7UEFDS30nYClcbiAgfVxuXG4gIGxldCB2ZXJzaW9uID0gYXdhaXQgcmVhZGVyLnJlYWQoNCk7XG4gIHZlcnNpb24gPSB2ZXJzaW9uLnJlYWRVSW50MzJCRSgwKTtcbiAgaWYgKHZlcnNpb24gIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihgSW52YWxpZCBwYWNrZmlsZSB2ZXJzaW9uOiAke3ZlcnNpb259YClcbiAgfVxuXG4gIGxldCBudW1PYmplY3RzID0gYXdhaXQgcmVhZGVyLnJlYWQoNCk7XG4gIG51bU9iamVjdHMgPSBudW1PYmplY3RzLnJlYWRVSW50MzJCRSgwKTtcbiAgLy8gSWYgKGZvciBzb21lIGdvZGZvcnNha2VuIHJlYXNvbikgdGhpcyBpcyBhbiBlbXB0eSBwYWNrZmlsZSwgYWJvcnQgbm93LlxuICBpZiAobnVtT2JqZWN0cyA8IDEpIHJldHVyblxuXG4gIHdoaWxlICghcmVhZGVyLmVvZigpICYmIG51bU9iamVjdHMtLSkge1xuICAgIGNvbnN0IG9mZnNldCA9IHJlYWRlci50ZWxsKCk7XG4gICAgY29uc3QgeyB0eXBlLCBsZW5ndGgsIG9mcywgcmVmZXJlbmNlIH0gPSBhd2FpdCBwYXJzZUhlYWRlcihyZWFkZXIpO1xuICAgIGNvbnN0IGluZmxhdG9yID0gbmV3IHBha28uSW5mbGF0ZSgpO1xuICAgIHdoaWxlICghaW5mbGF0b3IucmVzdWx0KSB7XG4gICAgICBjb25zdCBjaHVuayA9IGF3YWl0IHJlYWRlci5jaHVuaygpO1xuICAgICAgaWYgKCFjaHVuaykgYnJlYWtcbiAgICAgIGluZmxhdG9yLnB1c2goY2h1bmssIGZhbHNlKTtcbiAgICAgIGlmIChpbmZsYXRvci5lcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoYFBha28gZXJyb3I6ICR7aW5mbGF0b3IubXNnfWApXG4gICAgICB9XG4gICAgICBpZiAoaW5mbGF0b3IucmVzdWx0KSB7XG4gICAgICAgIGlmIChpbmZsYXRvci5yZXN1bHQubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihcbiAgICAgICAgICAgIGBJbmZsYXRlZCBvYmplY3Qgc2l6ZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGF0IHN0YXRlZCBpbiBwYWNrZmlsZS5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmFja3RyYWNrIHBhcnNlciB0byB3aGVyZSBkZWZsYXRlZCBkYXRhIGVuZHNcbiAgICAgICAgYXdhaXQgcmVhZGVyLnVuZG8oKTtcbiAgICAgICAgYXdhaXQgcmVhZGVyLnJlYWQoY2h1bmsubGVuZ3RoIC0gaW5mbGF0b3Iuc3RybS5hdmFpbF9pbik7XG4gICAgICAgIGNvbnN0IGVuZCA9IHJlYWRlci50ZWxsKCk7XG4gICAgICAgIGF3YWl0IG9uRGF0YSh7XG4gICAgICAgICAgZGF0YTogaW5mbGF0b3IucmVzdWx0LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgbnVtOiBudW1PYmplY3RzLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgIG9mcyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlSGVhZGVyKHJlYWRlcikge1xuICAvLyBPYmplY3QgdHlwZSBpcyBlbmNvZGVkIGluIGJpdHMgNjU0XG4gIGxldCBieXRlID0gYXdhaXQgcmVhZGVyLmJ5dGUoKTtcbiAgY29uc3QgdHlwZSA9IChieXRlID4+IDQpICYgMGIxMTE7XG4gIC8vIFRoZSBsZW5ndGggZW5jb2RpbmcgZ2V0IGNvbXBsaWNhdGVkLlxuICAvLyBMYXN0IGZvdXIgYml0cyBvZiBsZW5ndGggaXMgZW5jb2RlZCBpbiBiaXRzIDMyMTBcbiAgbGV0IGxlbmd0aCA9IGJ5dGUgJiAwYjExMTE7XG4gIC8vIFdoZXRoZXIgdGhlIG5leHQgYnl0ZSBpcyBwYXJ0IG9mIHRoZSB2YXJpYWJsZS1sZW5ndGggZW5jb2RlZCBudW1iZXJcbiAgLy8gaXMgZW5jb2RlZCBpbiBiaXQgN1xuICBpZiAoYnl0ZSAmIDBiMTAwMDAwMDApIHtcbiAgICBsZXQgc2hpZnQgPSA0O1xuICAgIGRvIHtcbiAgICAgIGJ5dGUgPSBhd2FpdCByZWFkZXIuYnl0ZSgpO1xuICAgICAgbGVuZ3RoIHw9IChieXRlICYgMGIwMTExMTExMSkgPDwgc2hpZnQ7XG4gICAgICBzaGlmdCArPSA3O1xuICAgIH0gd2hpbGUgKGJ5dGUgJiAwYjEwMDAwMDAwKVxuICB9XG4gIC8vIEhhbmRsZSBkZWx0aWZpZWQgb2JqZWN0c1xuICBsZXQgb2ZzO1xuICBsZXQgcmVmZXJlbmNlO1xuICBpZiAodHlwZSA9PT0gNikge1xuICAgIGxldCBzaGlmdCA9IDA7XG4gICAgb2ZzID0gMDtcbiAgICBjb25zdCBieXRlcyA9IFtdO1xuICAgIGRvIHtcbiAgICAgIGJ5dGUgPSBhd2FpdCByZWFkZXIuYnl0ZSgpO1xuICAgICAgb2ZzIHw9IChieXRlICYgMGIwMTExMTExMSkgPDwgc2hpZnQ7XG4gICAgICBzaGlmdCArPSA3O1xuICAgICAgYnl0ZXMucHVzaChieXRlKTtcbiAgICB9IHdoaWxlIChieXRlICYgMGIxMDAwMDAwMClcbiAgICByZWZlcmVuY2UgPSBCdWZmZXIuZnJvbShieXRlcyk7XG4gIH1cbiAgaWYgKHR5cGUgPT09IDcpIHtcbiAgICBjb25zdCBidWYgPSBhd2FpdCByZWFkZXIucmVhZCgyMCk7XG4gICAgcmVmZXJlbmNlID0gYnVmO1xuICB9XG4gIHJldHVybiB7IHR5cGUsIGxlbmd0aCwgb2ZzLCByZWZlcmVuY2UgfVxufVxuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxubGV0IHN1cHBvcnRzRGVjb21wcmVzc2lvblN0cmVhbSA9IGZhbHNlO1xuXG5hc3luYyBmdW5jdGlvbiBpbmZsYXRlKGJ1ZmZlcikge1xuICBpZiAoc3VwcG9ydHNEZWNvbXByZXNzaW9uU3RyZWFtID09PSBudWxsKSB7XG4gICAgc3VwcG9ydHNEZWNvbXByZXNzaW9uU3RyZWFtID0gdGVzdERlY29tcHJlc3Npb25TdHJlYW0oKTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydHNEZWNvbXByZXNzaW9uU3RyZWFtXG4gICAgPyBicm93c2VySW5mbGF0ZShidWZmZXIpXG4gICAgOiBwYWtvLmluZmxhdGUoYnVmZmVyKVxufVxuXG5hc3luYyBmdW5jdGlvbiBicm93c2VySW5mbGF0ZShidWZmZXIpIHtcbiAgY29uc3QgZHMgPSBuZXcgRGVjb21wcmVzc2lvblN0cmVhbSgnZGVmbGF0ZScpO1xuICBjb25zdCBkID0gbmV3IEJsb2IoW2J1ZmZlcl0pLnN0cmVhbSgpLnBpcGVUaHJvdWdoKGRzKTtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IG5ldyBSZXNwb25zZShkKS5hcnJheUJ1ZmZlcigpKVxufVxuXG5mdW5jdGlvbiB0ZXN0RGVjb21wcmVzc2lvblN0cmVhbSgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBkcyA9IG5ldyBEZWNvbXByZXNzaW9uU3RyZWFtKCdkZWZsYXRlJyk7XG4gICAgaWYgKGRzKSByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChfKSB7XG4gICAgLy8gbm8gYm90aGVyXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGRlY29kZVZhckludChyZWFkZXIpIHtcbiAgY29uc3QgYnl0ZXMgPSBbXTtcbiAgbGV0IGJ5dGUgPSAwO1xuICBsZXQgbXVsdGlieXRlID0gMDtcbiAgZG8ge1xuICAgIGJ5dGUgPSByZWFkZXIucmVhZFVJbnQ4KCk7XG4gICAgLy8gV2Uga2VlcCBiaXRzIDY1NDMyMTBcbiAgICBjb25zdCBsYXN0U2V2ZW4gPSBieXRlICYgMGIwMTExMTExMTtcbiAgICBieXRlcy5wdXNoKGxhc3RTZXZlbik7XG4gICAgLy8gV2hldGhlciB0aGUgbmV4dCBieXRlIGlzIHBhcnQgb2YgdGhlIHZhcmlhYmxlLWxlbmd0aCBlbmNvZGVkIG51bWJlclxuICAgIC8vIGlzIGVuY29kZWQgaW4gYml0IDdcbiAgICBtdWx0aWJ5dGUgPSBieXRlICYgMGIxMDAwMDAwMDtcbiAgfSB3aGlsZSAobXVsdGlieXRlKVxuICAvLyBOb3cgdGhhdCBhbGwgdGhlIGJ5dGVzIGFyZSBpbiBiaWctZW5kaWFuIG9yZGVyLFxuICAvLyBhbHRlcm5hdGUgc2hpZnRpbmcgdGhlIGJpdHMgbGVmdCBieSA3IGFuZCBPUi1pbmcgdGhlIG5leHQgYnl0ZS5cbiAgLy8gQW5kLi4uIGRvIGEgd2VpcmQgaW5jcmVtZW50LWJ5LW9uZSB0aGluZyB0aGF0IEkgZG9uJ3QgcXVpdGUgdW5kZXJzdGFuZC5cbiAgcmV0dXJuIGJ5dGVzLnJlZHVjZSgoYSwgYikgPT4gKChhICsgMSkgPDwgNykgfCBiLCAtMSlcbn1cblxuLy8gSSdtIHByZXR0eSBtdWNoIGNvcHlpbmcgdGhpcyBvbmUgZnJvbSB0aGUgZ2l0IEMgc291cmNlIGNvZGUsXG4vLyBiZWNhdXNlIGl0IG1ha2VzIG5vIHNlbnNlLlxuZnVuY3Rpb24gb3RoZXJWYXJJbnREZWNvZGUocmVhZGVyLCBzdGFydFdpdGgpIHtcbiAgbGV0IHJlc3VsdCA9IHN0YXJ0V2l0aDtcbiAgbGV0IHNoaWZ0ID0gNDtcbiAgbGV0IGJ5dGUgPSBudWxsO1xuICBkbyB7XG4gICAgYnl0ZSA9IHJlYWRlci5yZWFkVUludDgoKTtcbiAgICByZXN1bHQgfD0gKGJ5dGUgJiAwYjAxMTExMTExKSA8PCBzaGlmdDtcbiAgICBzaGlmdCArPSA3O1xuICB9IHdoaWxlIChieXRlICYgMGIxMDAwMDAwMClcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5jbGFzcyBHaXRQYWNrSW5kZXgge1xuICBjb25zdHJ1Y3RvcihzdHVmZikge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgc3R1ZmYpO1xuICAgIHRoaXMub2Zmc2V0Q2FjaGUgPSB7fTtcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tSWR4KHsgaWR4LCBnZXRFeHRlcm5hbFJlZkRlbHRhIH0pIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgQnVmZmVyQ3Vyc29yKGlkeCk7XG4gICAgY29uc3QgbWFnaWMgPSByZWFkZXIuc2xpY2UoNCkudG9TdHJpbmcoJ2hleCcpO1xuICAgIC8vIENoZWNrIGZvciBJRFggdjIgbWFnaWMgbnVtYmVyXG4gICAgaWYgKG1hZ2ljICE9PSAnZmY3NDRmNjMnKSB7XG4gICAgICByZXR1cm4gLy8gdW5kZWZpbmVkXG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb24gPSByZWFkZXIucmVhZFVJbnQzMkJFKCk7XG4gICAgaWYgKHZlcnNpb24gIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKFxuICAgICAgICBgVW5hYmxlIHRvIHJlYWQgdmVyc2lvbiAke3ZlcnNpb259IHBhY2tmaWxlIElEWC4gKE9ubHkgdmVyc2lvbiAyIHN1cHBvcnRlZClgXG4gICAgICApXG4gICAgfVxuICAgIGlmIChpZHguYnl0ZUxlbmd0aCA+IDIwNDggKiAxMDI0ICogMTAyNCkge1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoXG4gICAgICAgIGBUbyBrZWVwIGltcGxlbWVudGF0aW9uIHNpbXBsZSwgSSBoYXZlbid0IGltcGxlbWVudGVkIHRoZSBsYXllciA1IGZlYXR1cmUgbmVlZGVkIHRvIHN1cHBvcnQgcGFja2ZpbGVzID4gMkdCIGluIHNpemUuYFxuICAgICAgKVxuICAgIH1cbiAgICAvLyBTa2lwIG92ZXIgZmFub3V0IHRhYmxlXG4gICAgcmVhZGVyLnNlZWsocmVhZGVyLnRlbGwoKSArIDQgKiAyNTUpO1xuICAgIC8vIEdldCBoYXNoZXNcbiAgICBjb25zdCBzaXplID0gcmVhZGVyLnJlYWRVSW50MzJCRSgpO1xuICAgIGNvbnN0IGhhc2hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBjb25zdCBoYXNoID0gcmVhZGVyLnNsaWNlKDIwKS50b1N0cmluZygnaGV4Jyk7XG4gICAgICBoYXNoZXNbaV0gPSBoYXNoO1xuICAgIH1cbiAgICByZWFkZXIuc2VlayhyZWFkZXIudGVsbCgpICsgNCAqIHNpemUpO1xuICAgIC8vIFNraXAgb3ZlciBDUkNzXG4gICAgLy8gR2V0IG9mZnNldHNcbiAgICBjb25zdCBvZmZzZXRzID0gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBvZmZzZXRzLnNldChoYXNoZXNbaV0sIHJlYWRlci5yZWFkVUludDMyQkUoKSk7XG4gICAgfVxuICAgIGNvbnN0IHBhY2tmaWxlU2hhID0gcmVhZGVyLnNsaWNlKDIwKS50b1N0cmluZygnaGV4Jyk7XG4gICAgcmV0dXJuIG5ldyBHaXRQYWNrSW5kZXgoe1xuICAgICAgaGFzaGVzLFxuICAgICAgY3Jjczoge30sXG4gICAgICBvZmZzZXRzLFxuICAgICAgcGFja2ZpbGVTaGEsXG4gICAgICBnZXRFeHRlcm5hbFJlZkRlbHRhLFxuICAgIH0pXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZnJvbVBhY2soeyBwYWNrLCBnZXRFeHRlcm5hbFJlZkRlbHRhLCBvblByb2dyZXNzIH0pIHtcbiAgICBjb25zdCBsaXN0cGFja1R5cGVzID0ge1xuICAgICAgMTogJ2NvbW1pdCcsXG4gICAgICAyOiAndHJlZScsXG4gICAgICAzOiAnYmxvYicsXG4gICAgICA0OiAndGFnJyxcbiAgICAgIDY6ICdvZnMtZGVsdGEnLFxuICAgICAgNzogJ3JlZi1kZWx0YScsXG4gICAgfTtcbiAgICBjb25zdCBvZmZzZXRUb09iamVjdCA9IHt9O1xuXG4gICAgLy8gT2xkZXIgcGFja2ZpbGVzIGRvIE5PVCB1c2UgdGhlIHNoYXN1bSBvZiB0aGUgcGFjayBpdHNlbGYsXG4gICAgLy8gc28gaXQgaXMgcmVjb21tZW5kZWQgdG8ganVzdCB1c2Ugd2hhdGV2ZXIgYnl0ZXMgYXJlIGluIHRoZSB0cmFpbGVyLlxuICAgIC8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2dpdC9naXQvY29tbWl0LzExOTBhMWFjZjgwMGFjZGNmZDc1NjlmODdhYzE1NjBlMmQwNzc0MTRcbiAgICBjb25zdCBwYWNrZmlsZVNoYSA9IHBhY2suc2xpY2UoLTIwKS50b1N0cmluZygnaGV4Jyk7XG5cbiAgICBjb25zdCBoYXNoZXMgPSBbXTtcbiAgICBjb25zdCBjcmNzID0ge307XG4gICAgY29uc3Qgb2Zmc2V0cyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgdG90YWxPYmplY3RDb3VudCA9IG51bGw7XG4gICAgbGV0IGxhc3RQZXJjZW50ID0gbnVsbDtcblxuICAgIGF3YWl0IGxpc3RwYWNrKFtwYWNrXSwgYXN5bmMgKHsgZGF0YSwgdHlwZSwgcmVmZXJlbmNlLCBvZmZzZXQsIG51bSB9KSA9PiB7XG4gICAgICBpZiAodG90YWxPYmplY3RDb3VudCA9PT0gbnVsbCkgdG90YWxPYmplY3RDb3VudCA9IG51bTtcbiAgICAgIGNvbnN0IHBlcmNlbnQgPSBNYXRoLmZsb29yKFxuICAgICAgICAoKHRvdGFsT2JqZWN0Q291bnQgLSBudW0pICogMTAwKSAvIHRvdGFsT2JqZWN0Q291bnRcbiAgICAgICk7XG4gICAgICBpZiAocGVyY2VudCAhPT0gbGFzdFBlcmNlbnQpIHtcbiAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBhd2FpdCBvblByb2dyZXNzKHtcbiAgICAgICAgICAgIHBoYXNlOiAnUmVjZWl2aW5nIG9iamVjdHMnLFxuICAgICAgICAgICAgbG9hZGVkOiB0b3RhbE9iamVjdENvdW50IC0gbnVtLFxuICAgICAgICAgICAgdG90YWw6IHRvdGFsT2JqZWN0Q291bnQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQZXJjZW50ID0gcGVyY2VudDtcbiAgICAgIC8vIENoYW5nZSB0eXBlIGZyb20gYSBudW1iZXIgdG8gYSBtZWFuaW5nZnVsIHN0cmluZ1xuICAgICAgdHlwZSA9IGxpc3RwYWNrVHlwZXNbdHlwZV07XG5cbiAgICAgIGlmIChbJ2NvbW1pdCcsICd0cmVlJywgJ2Jsb2InLCAndGFnJ10uaW5jbHVkZXModHlwZSkpIHtcbiAgICAgICAgb2Zmc2V0VG9PYmplY3Rbb2Zmc2V0XSA9IHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29mcy1kZWx0YScpIHtcbiAgICAgICAgb2Zmc2V0VG9PYmplY3Rbb2Zmc2V0XSA9IHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlZi1kZWx0YScpIHtcbiAgICAgICAgb2Zmc2V0VG9PYmplY3Rbb2Zmc2V0XSA9IHtcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFdlIG5lZWQgdG8ga25vdyB0aGUgbGVuZ3RocyBvZiB0aGUgc2xpY2VzIHRvIGNvbXB1dGUgdGhlIENSQ3MuXG4gICAgY29uc3Qgb2Zmc2V0QXJyYXkgPSBPYmplY3Qua2V5cyhvZmZzZXRUb09iamVjdCkubWFwKE51bWJlcik7XG4gICAgZm9yIChjb25zdCBbaSwgc3RhcnRdIG9mIG9mZnNldEFycmF5LmVudHJpZXMoKSkge1xuICAgICAgY29uc3QgZW5kID1cbiAgICAgICAgaSArIDEgPT09IG9mZnNldEFycmF5Lmxlbmd0aCA/IHBhY2suYnl0ZUxlbmd0aCAtIDIwIDogb2Zmc2V0QXJyYXlbaSArIDFdO1xuICAgICAgY29uc3QgbyA9IG9mZnNldFRvT2JqZWN0W3N0YXJ0XTtcbiAgICAgIGNvbnN0IGNyYyA9IGNyYzMyLmJ1ZihwYWNrLnNsaWNlKHN0YXJ0LCBlbmQpKSA+Pj4gMDtcbiAgICAgIG8uZW5kID0gZW5kO1xuICAgICAgby5jcmMgPSBjcmM7XG4gICAgfVxuXG4gICAgLy8gV2UgZG9uJ3QgaGF2ZSB0aGUgaGFzaGVzIHlldC4gQnV0IHdlIGNhbiBnZW5lcmF0ZSB0aGVtIHVzaW5nIHRoZSAucmVhZFNsaWNlIGZ1bmN0aW9uIVxuICAgIGNvbnN0IHAgPSBuZXcgR2l0UGFja0luZGV4KHtcbiAgICAgIHBhY2s6IFByb21pc2UucmVzb2x2ZShwYWNrKSxcbiAgICAgIHBhY2tmaWxlU2hhLFxuICAgICAgY3JjcyxcbiAgICAgIGhhc2hlcyxcbiAgICAgIG9mZnNldHMsXG4gICAgICBnZXRFeHRlcm5hbFJlZkRlbHRhLFxuICAgIH0pO1xuXG4gICAgLy8gUmVzb2x2ZSBkZWx0YXMgYW5kIGNvbXB1dGUgdGhlIG9pZHNcbiAgICBsYXN0UGVyY2VudCA9IG51bGw7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCBvYmplY3RzQnlEZXB0aCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICBmb3IgKGxldCBvZmZzZXQgaW4gb2Zmc2V0VG9PYmplY3QpIHtcbiAgICAgIG9mZnNldCA9IE51bWJlcihvZmZzZXQpO1xuICAgICAgY29uc3QgcGVyY2VudCA9IE1hdGguZmxvb3IoKGNvdW50KysgKiAxMDApIC8gdG90YWxPYmplY3RDb3VudCk7XG4gICAgICBpZiAocGVyY2VudCAhPT0gbGFzdFBlcmNlbnQpIHtcbiAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBhd2FpdCBvblByb2dyZXNzKHtcbiAgICAgICAgICAgIHBoYXNlOiAnUmVzb2x2aW5nIGRlbHRhcycsXG4gICAgICAgICAgICBsb2FkZWQ6IGNvdW50LFxuICAgICAgICAgICAgdG90YWw6IHRvdGFsT2JqZWN0Q291bnQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQZXJjZW50ID0gcGVyY2VudDtcblxuICAgICAgY29uc3QgbyA9IG9mZnNldFRvT2JqZWN0W29mZnNldF07XG4gICAgICBpZiAoby5vaWQpIGNvbnRpbnVlXG4gICAgICB0cnkge1xuICAgICAgICBwLnJlYWREZXB0aCA9IDA7XG4gICAgICAgIHAuZXh0ZXJuYWxSZWFkRGVwdGggPSAwO1xuICAgICAgICBjb25zdCB7IHR5cGUsIG9iamVjdCB9ID0gYXdhaXQgcC5yZWFkU2xpY2UoeyBzdGFydDogb2Zmc2V0IH0pO1xuICAgICAgICBvYmplY3RzQnlEZXB0aFtwLnJlYWREZXB0aF0gKz0gMTtcbiAgICAgICAgY29uc3Qgb2lkID0gYXdhaXQgc2hhc3VtKEdpdE9iamVjdC53cmFwKHsgdHlwZSwgb2JqZWN0IH0pKTtcbiAgICAgICAgby5vaWQgPSBvaWQ7XG4gICAgICAgIGhhc2hlcy5wdXNoKG9pZCk7XG4gICAgICAgIG9mZnNldHMuc2V0KG9pZCwgb2Zmc2V0KTtcbiAgICAgICAgY3Jjc1tvaWRdID0gby5jcmM7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNoZXMuc29ydCgpO1xuICAgIHJldHVybiBwXG4gIH1cblxuICBhc3luYyB0b0J1ZmZlcigpIHtcbiAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgY29uc3Qgd3JpdGUgPSAoc3RyLCBlbmNvZGluZykgPT4ge1xuICAgICAgYnVmZmVycy5wdXNoKEJ1ZmZlci5mcm9tKHN0ciwgZW5jb2RpbmcpKTtcbiAgICB9O1xuICAgIC8vIFdyaXRlIG91dCBJRFggdjIgbWFnaWMgbnVtYmVyXG4gICAgd3JpdGUoJ2ZmNzQ0ZjYzJywgJ2hleCcpO1xuICAgIC8vIFdyaXRlIG91dCB2ZXJzaW9uIG51bWJlciAyXG4gICAgd3JpdGUoJzAwMDAwMDAyJywgJ2hleCcpO1xuICAgIC8vIFdyaXRlIGZhbm91dCB0YWJsZVxuICAgIGNvbnN0IGZhbm91dEJ1ZmZlciA9IG5ldyBCdWZmZXJDdXJzb3IoQnVmZmVyLmFsbG9jKDI1NiAqIDQpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgZm9yIChjb25zdCBoYXNoIG9mIHRoaXMuaGFzaGVzKSB7XG4gICAgICAgIGlmIChwYXJzZUludChoYXNoLnNsaWNlKDAsIDIpLCAxNikgPD0gaSkgY291bnQrKztcbiAgICAgIH1cbiAgICAgIGZhbm91dEJ1ZmZlci53cml0ZVVJbnQzMkJFKGNvdW50KTtcbiAgICB9XG4gICAgYnVmZmVycy5wdXNoKGZhbm91dEJ1ZmZlci5idWZmZXIpO1xuICAgIC8vIFdyaXRlIG91dCBoYXNoZXNcbiAgICBmb3IgKGNvbnN0IGhhc2ggb2YgdGhpcy5oYXNoZXMpIHtcbiAgICAgIHdyaXRlKGhhc2gsICdoZXgnKTtcbiAgICB9XG4gICAgLy8gV3JpdGUgb3V0IGNyY3NcbiAgICBjb25zdCBjcmNzQnVmZmVyID0gbmV3IEJ1ZmZlckN1cnNvcihCdWZmZXIuYWxsb2ModGhpcy5oYXNoZXMubGVuZ3RoICogNCkpO1xuICAgIGZvciAoY29uc3QgaGFzaCBvZiB0aGlzLmhhc2hlcykge1xuICAgICAgY3Jjc0J1ZmZlci53cml0ZVVJbnQzMkJFKHRoaXMuY3Jjc1toYXNoXSk7XG4gICAgfVxuICAgIGJ1ZmZlcnMucHVzaChjcmNzQnVmZmVyLmJ1ZmZlcik7XG4gICAgLy8gV3JpdGUgb3V0IG9mZnNldHNcbiAgICBjb25zdCBvZmZzZXRzQnVmZmVyID0gbmV3IEJ1ZmZlckN1cnNvcihCdWZmZXIuYWxsb2ModGhpcy5oYXNoZXMubGVuZ3RoICogNCkpO1xuICAgIGZvciAoY29uc3QgaGFzaCBvZiB0aGlzLmhhc2hlcykge1xuICAgICAgb2Zmc2V0c0J1ZmZlci53cml0ZVVJbnQzMkJFKHRoaXMub2Zmc2V0cy5nZXQoaGFzaCkpO1xuICAgIH1cbiAgICBidWZmZXJzLnB1c2gob2Zmc2V0c0J1ZmZlci5idWZmZXIpO1xuICAgIC8vIFdyaXRlIG91dCBwYWNrZmlsZSBjaGVja3N1bVxuICAgIHdyaXRlKHRoaXMucGFja2ZpbGVTaGEsICdoZXgnKTtcbiAgICAvLyBXcml0ZSBvdXQgc2hhc3VtXG4gICAgY29uc3QgdG90YWxCdWZmZXIgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpO1xuICAgIGNvbnN0IHNoYSA9IGF3YWl0IHNoYXN1bSh0b3RhbEJ1ZmZlcik7XG4gICAgY29uc3Qgc2hhQnVmZmVyID0gQnVmZmVyLmFsbG9jKDIwKTtcbiAgICBzaGFCdWZmZXIud3JpdGUoc2hhLCAnaGV4Jyk7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3RvdGFsQnVmZmVyLCBzaGFCdWZmZXJdKVxuICB9XG5cbiAgYXN5bmMgbG9hZCh7IHBhY2sgfSkge1xuICAgIHRoaXMucGFjayA9IHBhY2s7XG4gIH1cblxuICBhc3luYyB1bmxvYWQoKSB7XG4gICAgdGhpcy5wYWNrID0gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIHJlYWQoeyBvaWQgfSkge1xuICAgIGlmICghdGhpcy5vZmZzZXRzLmdldChvaWQpKSB7XG4gICAgICBpZiAodGhpcy5nZXRFeHRlcm5hbFJlZkRlbHRhKSB7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxSZWFkRGVwdGgrKztcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXh0ZXJuYWxSZWZEZWx0YShvaWQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihgQ291bGQgbm90IHJlYWQgb2JqZWN0ICR7b2lkfSBmcm9tIHBhY2tmaWxlYClcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLm9mZnNldHMuZ2V0KG9pZCk7XG4gICAgcmV0dXJuIHRoaXMucmVhZFNsaWNlKHsgc3RhcnQgfSlcbiAgfVxuXG4gIGFzeW5jIHJlYWRTbGljZSh7IHN0YXJ0IH0pIHtcbiAgICBpZiAodGhpcy5vZmZzZXRDYWNoZVtzdGFydF0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9mZnNldENhY2hlW3N0YXJ0XSlcbiAgICB9XG4gICAgdGhpcy5yZWFkRGVwdGgrKztcbiAgICBjb25zdCB0eXBlcyA9IHtcbiAgICAgIDBiMDAxMDAwMDogJ2NvbW1pdCcsXG4gICAgICAwYjAxMDAwMDA6ICd0cmVlJyxcbiAgICAgIDBiMDExMDAwMDogJ2Jsb2InLFxuICAgICAgMGIxMDAwMDAwOiAndGFnJyxcbiAgICAgIDBiMTEwMDAwMDogJ29mc19kZWx0YScsXG4gICAgICAwYjExMTAwMDA6ICdyZWZfZGVsdGEnLFxuICAgIH07XG4gICAgaWYgKCF0aGlzLnBhY2spIHtcbiAgICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKFxuICAgICAgICAnVHJpZWQgdG8gcmVhZCBmcm9tIGEgR2l0UGFja0luZGV4IHdpdGggbm8gcGFja2ZpbGUgbG9hZGVkIGludG8gbWVtb3J5J1xuICAgICAgKVxuICAgIH1cbiAgICBjb25zdCByYXcgPSAoYXdhaXQgdGhpcy5wYWNrKS5zbGljZShzdGFydCk7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEJ1ZmZlckN1cnNvcihyYXcpO1xuICAgIGNvbnN0IGJ5dGUgPSByZWFkZXIucmVhZFVJbnQ4KCk7XG4gICAgLy8gT2JqZWN0IHR5cGUgaXMgZW5jb2RlZCBpbiBiaXRzIDY1NFxuICAgIGNvbnN0IGJ0eXBlID0gYnl0ZSAmIDBiMTExMDAwMDtcbiAgICBsZXQgdHlwZSA9IHR5cGVzW2J0eXBlXTtcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcignVW5yZWNvZ25pemVkIHR5cGU6IDBiJyArIGJ0eXBlLnRvU3RyaW5nKDIpKVxuICAgIH1cbiAgICAvLyBUaGUgbGVuZ3RoIGVuY29kaW5nIGdldCBjb21wbGljYXRlZC5cbiAgICAvLyBMYXN0IGZvdXIgYml0cyBvZiBsZW5ndGggaXMgZW5jb2RlZCBpbiBiaXRzIDMyMTBcbiAgICBjb25zdCBsYXN0Rm91ciA9IGJ5dGUgJiAwYjExMTE7XG4gICAgbGV0IGxlbmd0aCA9IGxhc3RGb3VyO1xuICAgIC8vIFdoZXRoZXIgdGhlIG5leHQgYnl0ZSBpcyBwYXJ0IG9mIHRoZSB2YXJpYWJsZS1sZW5ndGggZW5jb2RlZCBudW1iZXJcbiAgICAvLyBpcyBlbmNvZGVkIGluIGJpdCA3XG4gICAgY29uc3QgbXVsdGlieXRlID0gYnl0ZSAmIDBiMTAwMDAwMDA7XG4gICAgaWYgKG11bHRpYnl0ZSkge1xuICAgICAgbGVuZ3RoID0gb3RoZXJWYXJJbnREZWNvZGUocmVhZGVyLCBsYXN0Rm91cik7XG4gICAgfVxuICAgIGxldCBiYXNlID0gbnVsbDtcbiAgICBsZXQgb2JqZWN0ID0gbnVsbDtcbiAgICAvLyBIYW5kbGUgZGVsdGlmaWVkIG9iamVjdHNcbiAgICBpZiAodHlwZSA9PT0gJ29mc19kZWx0YScpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGRlY29kZVZhckludChyZWFkZXIpO1xuICAgICAgY29uc3QgYmFzZU9mZnNldCA9IHN0YXJ0IC0gb2Zmc2V0XG4gICAgICA7KHsgb2JqZWN0OiBiYXNlLCB0eXBlIH0gPSBhd2FpdCB0aGlzLnJlYWRTbGljZSh7IHN0YXJ0OiBiYXNlT2Zmc2V0IH0pKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdyZWZfZGVsdGEnKSB7XG4gICAgICBjb25zdCBvaWQgPSByZWFkZXIuc2xpY2UoMjApLnRvU3RyaW5nKCdoZXgnKVxuICAgICAgOyh7IG9iamVjdDogYmFzZSwgdHlwZSB9ID0gYXdhaXQgdGhpcy5yZWFkKHsgb2lkIH0pKTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIHVuZGVsdGlmaWVkIG9iamVjdHNcbiAgICBjb25zdCBidWZmZXIgPSByYXcuc2xpY2UocmVhZGVyLnRlbGwoKSk7XG4gICAgb2JqZWN0ID0gQnVmZmVyLmZyb20oYXdhaXQgaW5mbGF0ZShidWZmZXIpKTtcbiAgICAvLyBBc3NlcnQgdGhhdCB0aGUgb2JqZWN0IGxlbmd0aCBpcyBhcyBleHBlY3RlZC5cbiAgICBpZiAob2JqZWN0LmJ5dGVMZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoXG4gICAgICAgIGBQYWNrZmlsZSB0b2xkIHVzIG9iamVjdCB3b3VsZCBoYXZlIGxlbmd0aCAke2xlbmd0aH0gYnV0IGl0IGhhZCBsZW5ndGggJHtvYmplY3QuYnl0ZUxlbmd0aH1gXG4gICAgICApXG4gICAgfVxuICAgIGlmIChiYXNlKSB7XG4gICAgICBvYmplY3QgPSBCdWZmZXIuZnJvbShhcHBseURlbHRhKG9iamVjdCwgYmFzZSkpO1xuICAgIH1cbiAgICAvLyBDYWNoZSB0aGUgcmVzdWx0IGJhc2VkIG9uIGRlcHRoLlxuICAgIGlmICh0aGlzLnJlYWREZXB0aCA+IDMpIHtcbiAgICAgIC8vIGhhbmQgdHVuZWQgZm9yIHNwZWVkIC8gbWVtb3J5IHVzYWdlIHRyYWRlb2ZmXG4gICAgICB0aGlzLm9mZnNldENhY2hlW3N0YXJ0XSA9IHsgdHlwZSwgb2JqZWN0IH07XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGUsIGZvcm1hdDogJ2NvbnRlbnQnLCBvYmplY3QgfVxuICB9XG59XG5cbmNvbnN0IFBhY2tmaWxlQ2FjaGUgPSBTeW1ib2woJ1BhY2tmaWxlQ2FjaGUnKTtcblxuYXN5bmMgZnVuY3Rpb24gbG9hZFBhY2tJbmRleCh7XG4gIGZzLFxuICBmaWxlbmFtZSxcbiAgZ2V0RXh0ZXJuYWxSZWZEZWx0YSxcbiAgZW1pdHRlcixcbiAgZW1pdHRlclByZWZpeCxcbn0pIHtcbiAgY29uc3QgaWR4ID0gYXdhaXQgZnMucmVhZChmaWxlbmFtZSk7XG4gIHJldHVybiBHaXRQYWNrSW5kZXguZnJvbUlkeCh7IGlkeCwgZ2V0RXh0ZXJuYWxSZWZEZWx0YSB9KVxufVxuXG5mdW5jdGlvbiByZWFkUGFja0luZGV4KHtcbiAgZnMsXG4gIGNhY2hlLFxuICBmaWxlbmFtZSxcbiAgZ2V0RXh0ZXJuYWxSZWZEZWx0YSxcbiAgZW1pdHRlcixcbiAgZW1pdHRlclByZWZpeCxcbn0pIHtcbiAgLy8gVHJ5IHRvIGdldCB0aGUgcGFja2ZpbGUgaW5kZXggZnJvbSB0aGUgaW4tbWVtb3J5IGNhY2hlXG4gIGlmICghY2FjaGVbUGFja2ZpbGVDYWNoZV0pIGNhY2hlW1BhY2tmaWxlQ2FjaGVdID0gbmV3IE1hcCgpO1xuICBsZXQgcCA9IGNhY2hlW1BhY2tmaWxlQ2FjaGVdLmdldChmaWxlbmFtZSk7XG4gIGlmICghcCkge1xuICAgIHAgPSBsb2FkUGFja0luZGV4KHtcbiAgICAgIGZzLFxuICAgICAgZmlsZW5hbWUsXG4gICAgICBnZXRFeHRlcm5hbFJlZkRlbHRhLFxuICAgICAgZW1pdHRlcixcbiAgICAgIGVtaXR0ZXJQcmVmaXgsXG4gICAgfSk7XG4gICAgY2FjaGVbUGFja2ZpbGVDYWNoZV0uc2V0KGZpbGVuYW1lLCBwKTtcbiAgfVxuICByZXR1cm4gcFxufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkT2JqZWN0UGFja2VkKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBnaXRkaXIsXG4gIG9pZCxcbiAgZm9ybWF0ID0gJ2NvbnRlbnQnLFxuICBnZXRFeHRlcm5hbFJlZkRlbHRhLFxufSkge1xuICAvLyBDaGVjayB0byBzZWUgaWYgaXQncyBpbiBhIHBhY2tmaWxlLlxuICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIHRoZSAuaWR4IGZpbGVzXG4gIGxldCBsaXN0ID0gYXdhaXQgZnMucmVhZGRpcihqb2luKGdpdGRpciwgJ29iamVjdHMvcGFjaycpKTtcbiAgbGlzdCA9IGxpc3QuZmlsdGVyKHggPT4geC5lbmRzV2l0aCgnLmlkeCcpKTtcbiAgZm9yIChjb25zdCBmaWxlbmFtZSBvZiBsaXN0KSB7XG4gICAgY29uc3QgaW5kZXhGaWxlID0gYCR7Z2l0ZGlyfS9vYmplY3RzL3BhY2svJHtmaWxlbmFtZX1gO1xuICAgIGNvbnN0IHAgPSBhd2FpdCByZWFkUGFja0luZGV4KHtcbiAgICAgIGZzLFxuICAgICAgY2FjaGUsXG4gICAgICBmaWxlbmFtZTogaW5kZXhGaWxlLFxuICAgICAgZ2V0RXh0ZXJuYWxSZWZEZWx0YSxcbiAgICB9KTtcbiAgICBpZiAocC5lcnJvcikgdGhyb3cgbmV3IEludGVybmFsRXJyb3IocC5lcnJvcilcbiAgICAvLyBJZiB0aGUgcGFja2ZpbGUgRE9FUyBoYXZlIHRoZSBvaWQgd2UncmUgbG9va2luZyBmb3IuLi5cbiAgICBpZiAocC5vZmZzZXRzLmhhcyhvaWQpKSB7XG4gICAgICAvLyBHZXQgdGhlIHJlc29sdmVkIGdpdCBvYmplY3QgZnJvbSB0aGUgcGFja2ZpbGVcbiAgICAgIGlmICghcC5wYWNrKSB7XG4gICAgICAgIGNvbnN0IHBhY2tGaWxlID0gaW5kZXhGaWxlLnJlcGxhY2UoL2lkeCQvLCAncGFjaycpO1xuICAgICAgICBwLnBhY2sgPSBmcy5yZWFkKHBhY2tGaWxlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHAucmVhZCh7IG9pZCwgZ2V0RXh0ZXJuYWxSZWZEZWx0YSB9KTtcbiAgICAgIHJlc3VsdC5mb3JtYXQgPSAnY29udGVudCc7XG4gICAgICByZXN1bHQuc291cmNlID0gYG9iamVjdHMvcGFjay8ke2ZpbGVuYW1lLnJlcGxhY2UoL2lkeCQvLCAncGFjaycpfWA7XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9XG4gIC8vIEZhaWxlZCB0byBmaW5kIGl0XG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9pZFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmZvcm1hdF1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3JlYWRPYmplY3Qoe1xuICBmcyxcbiAgY2FjaGUsXG4gIGdpdGRpcixcbiAgb2lkLFxuICBmb3JtYXQgPSAnY29udGVudCcsXG59KSB7XG4gIC8vIEN1cnJ5IHRoZSBjdXJyZW50IHJlYWQgbWV0aG9kIHNvIHRoYXQgdGhlIHBhY2tmaWxlIHVuLWRlbHRpZmljYXRpb25cbiAgLy8gcHJvY2VzcyBjYW4gYWNxdWlyZSBleHRlcm5hbCByZWYtZGVsdGFzLlxuICBjb25zdCBnZXRFeHRlcm5hbFJlZkRlbHRhID0gb2lkID0+IF9yZWFkT2JqZWN0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcblxuICBsZXQgcmVzdWx0O1xuICAvLyBFbXB0eSB0cmVlIC0gaGFyZC1jb2RlZCBzbyB3ZSBjYW4gdXNlIGl0IGFzIGEgc2hvcnRoYW5kLlxuICAvLyBOb3RlOiBJIHRoaW5rIHRoZSBjYW5vbmljYWwgZ2l0IGltcGxlbWVudGF0aW9uIG11c3QgZG8gdGhpcyB0b28gYmVjYXVzZVxuICAvLyBgZ2l0IGNhdC1maWxlIC10IDRiODI1ZGM2NDJjYjZlYjlhMDYwZTU0YmY4ZDY5Mjg4ZmJlZTQ5MDRgIHByaW50cyBcInRyZWVcIiBldmVuIGluIGVtcHR5IHJlcG9zLlxuICBpZiAob2lkID09PSAnNGI4MjVkYzY0MmNiNmViOWEwNjBlNTRiZjhkNjkyODhmYmVlNDkwNCcpIHtcbiAgICByZXN1bHQgPSB7IGZvcm1hdDogJ3dyYXBwZWQnLCBvYmplY3Q6IEJ1ZmZlci5mcm9tKGB0cmVlIDBcXHgwMGApIH07XG4gIH1cbiAgLy8gTG9vayBmb3IgaXQgaW4gdGhlIGxvb3NlIG9iamVjdCBkaXJlY3RvcnkuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgcmVhZE9iamVjdExvb3NlKHsgZnMsIGdpdGRpciwgb2lkIH0pO1xuICB9XG4gIC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIGluIGEgcGFja2ZpbGUuXG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gYXdhaXQgcmVhZE9iamVjdFBhY2tlZCh7XG4gICAgICBmcyxcbiAgICAgIGNhY2hlLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgb2lkLFxuICAgICAgZ2V0RXh0ZXJuYWxSZWZEZWx0YSxcbiAgICB9KTtcbiAgfVxuICAvLyBGaW5hbGx5XG4gIGlmICghcmVzdWx0KSB7XG4gICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3Iob2lkKVxuICB9XG5cbiAgaWYgKGZvcm1hdCA9PT0gJ2RlZmxhdGVkJykge1xuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIGlmIChyZXN1bHQuZm9ybWF0ID09PSAnZGVmbGF0ZWQnKSB7XG4gICAgcmVzdWx0Lm9iamVjdCA9IEJ1ZmZlci5mcm9tKGF3YWl0IGluZmxhdGUocmVzdWx0Lm9iamVjdCkpO1xuICAgIHJlc3VsdC5mb3JtYXQgPSAnd3JhcHBlZCc7XG4gIH1cblxuICBpZiAocmVzdWx0LmZvcm1hdCA9PT0gJ3dyYXBwZWQnKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gJ3dyYXBwZWQnICYmIHJlc3VsdC5mb3JtYXQgPT09ICd3cmFwcGVkJykge1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgICBjb25zdCBzaGEgPSBhd2FpdCBzaGFzdW0ocmVzdWx0Lm9iamVjdCk7XG4gICAgaWYgKHNoYSAhPT0gb2lkKSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihcbiAgICAgICAgYFNIQSBjaGVjayBmYWlsZWQhIEV4cGVjdGVkICR7b2lkfSwgY29tcHV0ZWQgJHtzaGF9YFxuICAgICAgKVxuICAgIH1cbiAgICBjb25zdCB7IG9iamVjdCwgdHlwZSB9ID0gR2l0T2JqZWN0LnVud3JhcChyZXN1bHQub2JqZWN0KTtcbiAgICByZXN1bHQudHlwZSA9IHR5cGU7XG4gICAgcmVzdWx0Lm9iamVjdCA9IG9iamVjdDtcbiAgICByZXN1bHQuZm9ybWF0ID0gJ2NvbnRlbnQnO1xuICB9XG5cbiAgaWYgKHJlc3VsdC5mb3JtYXQgPT09ICdjb250ZW50Jykge1xuICAgIGlmIChmb3JtYXQgPT09ICdjb250ZW50JykgcmV0dXJuIHJlc3VsdFxuICAgIHJldHVyblxuICB9XG5cbiAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoYGludmFsaWQgZm9ybWF0IFwiJHtyZXN1bHQuZm9ybWF0fVwiYClcbn1cblxuY2xhc3MgQWxyZWFkeUV4aXN0c0Vycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7J25vdGUnfCdyZW1vdGUnfCd0YWcnfCdicmFuY2gnfSBub3VuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB3aGVyZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhbkZvcmNlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihub3VuLCB3aGVyZSwgY2FuRm9yY2UgPSB0cnVlKSB7XG4gICAgc3VwZXIoXG4gICAgICBgRmFpbGVkIHRvIGNyZWF0ZSAke25vdW59IGF0ICR7d2hlcmV9IGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuJHtcbiAgICAgICAgY2FuRm9yY2VcbiAgICAgICAgICA/IGAgKEhpbnQ6IHVzZSAnZm9yY2U6IHRydWUnIHBhcmFtZXRlciB0byBvdmVyd3JpdGUgZXhpc3RpbmcgJHtub3VufS4pYFxuICAgICAgICAgIDogJydcbiAgICAgIH1gXG4gICAgKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBBbHJlYWR5RXhpc3RzRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IG5vdW4sIHdoZXJlLCBjYW5Gb3JjZSB9O1xuICB9XG59XG4vKiogQHR5cGUgeydBbHJlYWR5RXhpc3RzRXJyb3InfSAqL1xuQWxyZWFkeUV4aXN0c0Vycm9yLmNvZGUgPSAnQWxyZWFkeUV4aXN0c0Vycm9yJztcblxuY2xhc3MgQW1iaWd1b3VzRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHsnb2lkcyd8J3JlZnMnfSBub3Vuc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnRcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gbWF0Y2hlc1xuICAgKi9cbiAgY29uc3RydWN0b3Iobm91bnMsIHNob3J0LCBtYXRjaGVzKSB7XG4gICAgc3VwZXIoXG4gICAgICBgRm91bmQgbXVsdGlwbGUgJHtub3Vuc30gbWF0Y2hpbmcgXCIke3Nob3J0fVwiICgke21hdGNoZXMuam9pbihcbiAgICAgICAgJywgJ1xuICAgICAgKX0pLiBVc2UgYSBsb25nZXIgYWJicmV2aWF0aW9uIGxlbmd0aCB0byBkaXNhbWJpZ3VhdGUgdGhlbS5gXG4gICAgKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBBbWJpZ3VvdXNFcnJvci5jb2RlO1xuICAgIHRoaXMuZGF0YSA9IHsgbm91bnMsIHNob3J0LCBtYXRjaGVzIH07XG4gIH1cbn1cbi8qKiBAdHlwZSB7J0FtYmlndW91c0Vycm9yJ30gKi9cbkFtYmlndW91c0Vycm9yLmNvZGUgPSAnQW1iaWd1b3VzRXJyb3InO1xuXG5jbGFzcyBDaGVja291dENvbmZsaWN0RXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmlsZXBhdGhzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihmaWxlcGF0aHMpIHtcbiAgICBzdXBlcihcbiAgICAgIGBZb3VyIGxvY2FsIGNoYW5nZXMgdG8gdGhlIGZvbGxvd2luZyBmaWxlcyB3b3VsZCBiZSBvdmVyd3JpdHRlbiBieSBjaGVja291dDogJHtmaWxlcGF0aHMuam9pbihcbiAgICAgICAgJywgJ1xuICAgICAgKX1gXG4gICAgKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBDaGVja291dENvbmZsaWN0RXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IGZpbGVwYXRocyB9O1xuICB9XG59XG4vKiogQHR5cGUgeydDaGVja291dENvbmZsaWN0RXJyb3InfSAqL1xuQ2hlY2tvdXRDb25mbGljdEVycm9yLmNvZGUgPSAnQ2hlY2tvdXRDb25mbGljdEVycm9yJztcblxuY2xhc3MgQ29tbWl0Tm90RmV0Y2hlZEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWZcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9pZFxuICAgKi9cbiAgY29uc3RydWN0b3IocmVmLCBvaWQpIHtcbiAgICBzdXBlcihcbiAgICAgIGBGYWlsZWQgdG8gY2hlY2tvdXQgXCIke3JlZn1cIiBiZWNhdXNlIGNvbW1pdCAke29pZH0gaXMgbm90IGF2YWlsYWJsZSBsb2NhbGx5LiBEbyBhIGdpdCBmZXRjaCB0byBtYWtlIHRoZSBicmFuY2ggYXZhaWxhYmxlIGxvY2FsbHkuYFxuICAgICk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gQ29tbWl0Tm90RmV0Y2hlZEVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyByZWYsIG9pZCB9O1xuICB9XG59XG4vKiogQHR5cGUgeydDb21taXROb3RGZXRjaGVkRXJyb3InfSAqL1xuQ29tbWl0Tm90RmV0Y2hlZEVycm9yLmNvZGUgPSAnQ29tbWl0Tm90RmV0Y2hlZEVycm9yJztcblxuY2xhc3MgRW1wdHlTZXJ2ZXJSZXNwb25zZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYEVtcHR5IHJlc3BvbnNlIGZyb20gZ2l0IHNlcnZlci5gKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBFbXB0eVNlcnZlclJlc3BvbnNlRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7fTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnRW1wdHlTZXJ2ZXJSZXNwb25zZUVycm9yJ30gKi9cbkVtcHR5U2VydmVyUmVzcG9uc2VFcnJvci5jb2RlID0gJ0VtcHR5U2VydmVyUmVzcG9uc2VFcnJvcic7XG5cbmNsYXNzIEZhc3RGb3J3YXJkRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgQSBzaW1wbGUgZmFzdC1mb3J3YXJkIG1lcmdlIHdhcyBub3QgcG9zc2libGUuYCk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gRmFzdEZvcndhcmRFcnJvci5jb2RlO1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICB9XG59XG4vKiogQHR5cGUgeydGYXN0Rm9yd2FyZEVycm9yJ30gKi9cbkZhc3RGb3J3YXJkRXJyb3IuY29kZSA9ICdGYXN0Rm9yd2FyZEVycm9yJztcblxuY2xhc3MgR2l0UHVzaEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmV0dHlEZXRhaWxzXG4gICAqIEBwYXJhbSB7UHVzaFJlc3VsdH0gcmVzdWx0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihwcmV0dHlEZXRhaWxzLCByZXN1bHQpIHtcbiAgICBzdXBlcihgT25lIG9yIG1vcmUgYnJhbmNoZXMgd2VyZSBub3QgdXBkYXRlZDogJHtwcmV0dHlEZXRhaWxzfWApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IEdpdFB1c2hFcnJvci5jb2RlO1xuICAgIHRoaXMuZGF0YSA9IHsgcHJldHR5RGV0YWlscywgcmVzdWx0IH07XG4gIH1cbn1cbi8qKiBAdHlwZSB7J0dpdFB1c2hFcnJvcid9ICovXG5HaXRQdXNoRXJyb3IuY29kZSA9ICdHaXRQdXNoRXJyb3InO1xuXG5jbGFzcyBIdHRwRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1c0NvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1c01lc3NhZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlc3BvbnNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCByZXNwb25zZSkge1xuICAgIHN1cGVyKGBIVFRQIEVycm9yOiAke3N0YXR1c0NvZGV9ICR7c3RhdHVzTWVzc2FnZX1gKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBIdHRwRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIHJlc3BvbnNlIH07XG4gIH1cbn1cbi8qKiBAdHlwZSB7J0h0dHBFcnJvcid9ICovXG5IdHRwRXJyb3IuY29kZSA9ICdIdHRwRXJyb3InO1xuXG5jbGFzcyBJbnZhbGlkRmlsZXBhdGhFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0geydsZWFkaW5nLXNsYXNoJ3wndHJhaWxpbmctc2xhc2gnfSBbcmVhc29uXVxuICAgKi9cbiAgY29uc3RydWN0b3IocmVhc29uKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSAnaW52YWxpZCBmaWxlcGF0aCc7XG4gICAgaWYgKHJlYXNvbiA9PT0gJ2xlYWRpbmctc2xhc2gnIHx8IHJlYXNvbiA9PT0gJ3RyYWlsaW5nLXNsYXNoJykge1xuICAgICAgbWVzc2FnZSA9IGBcImZpbGVwYXRoXCIgcGFyYW1ldGVyIHNob3VsZCBub3QgaW5jbHVkZSBsZWFkaW5nIG9yIHRyYWlsaW5nIGRpcmVjdG9yeSBzZXBhcmF0b3JzIGJlY2F1c2UgdGhlc2UgY2FuIGNhdXNlIHByb2JsZW1zIG9uIHNvbWUgcGxhdGZvcm1zLmA7XG4gICAgfVxuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IEludmFsaWRGaWxlcGF0aEVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyByZWFzb24gfTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnSW52YWxpZEZpbGVwYXRoRXJyb3InfSAqL1xuSW52YWxpZEZpbGVwYXRoRXJyb3IuY29kZSA9ICdJbnZhbGlkRmlsZXBhdGhFcnJvcic7XG5cbmNsYXNzIEludmFsaWRSZWZOYW1lRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3VnZ2VzdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhbkZvcmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZWYsIHN1Z2dlc3Rpb24pIHtcbiAgICBzdXBlcihcbiAgICAgIGBcIiR7cmVmfVwiIHdvdWxkIGJlIGFuIGludmFsaWQgZ2l0IHJlZmVyZW5jZS4gKEhpbnQ6IGEgdmFsaWQgYWx0ZXJuYXRpdmUgd291bGQgYmUgXCIke3N1Z2dlc3Rpb259XCIuKWBcbiAgICApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IEludmFsaWRSZWZOYW1lRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IHJlZiwgc3VnZ2VzdGlvbiB9O1xuICB9XG59XG4vKiogQHR5cGUgeydJbnZhbGlkUmVmTmFtZUVycm9yJ30gKi9cbkludmFsaWRSZWZOYW1lRXJyb3IuY29kZSA9ICdJbnZhbGlkUmVmTmFtZUVycm9yJztcblxuY2xhc3MgTWF4RGVwdGhFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRlcHRoKSB7XG4gICAgc3VwZXIoYE1heGltdW0gc2VhcmNoIGRlcHRoIG9mICR7ZGVwdGh9IGV4Y2VlZGVkLmApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IE1heERlcHRoRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IGRlcHRoIH07XG4gIH1cbn1cbi8qKiBAdHlwZSB7J01heERlcHRoRXJyb3InfSAqL1xuTWF4RGVwdGhFcnJvci5jb2RlID0gJ01heERlcHRoRXJyb3InO1xuXG5jbGFzcyBNZXJnZU5vdFN1cHBvcnRlZEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoYE1lcmdlcyB3aXRoIGNvbmZsaWN0cyBhcmUgbm90IHN1cHBvcnRlZCB5ZXQuYCk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gTWVyZ2VOb3RTdXBwb3J0ZWRFcnJvci5jb2RlO1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICB9XG59XG4vKiogQHR5cGUgeydNZXJnZU5vdFN1cHBvcnRlZEVycm9yJ30gKi9cbk1lcmdlTm90U3VwcG9ydGVkRXJyb3IuY29kZSA9ICdNZXJnZU5vdFN1cHBvcnRlZEVycm9yJztcblxuY2xhc3MgTWlzc2luZ05hbWVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0geydhdXRob3InfCdjb21taXR0ZXInfCd0YWdnZXInfSByb2xlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihyb2xlKSB7XG4gICAgc3VwZXIoXG4gICAgICBgTm8gbmFtZSB3YXMgcHJvdmlkZWQgZm9yICR7cm9sZX0gaW4gdGhlIGFyZ3VtZW50IG9yIGluIHRoZSAuZ2l0L2NvbmZpZyBmaWxlLmBcbiAgICApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IE1pc3NpbmdOYW1lRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IHJvbGUgfTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnTWlzc2luZ05hbWVFcnJvcid9ICovXG5NaXNzaW5nTmFtZUVycm9yLmNvZGUgPSAnTWlzc2luZ05hbWVFcnJvcic7XG5cbmNsYXNzIE1pc3NpbmdQYXJhbWV0ZXJFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1ldGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXIpIHtcbiAgICBzdXBlcihcbiAgICAgIGBUaGUgZnVuY3Rpb24gcmVxdWlyZXMgYSBcIiR7cGFyYW1ldGVyfVwiIHBhcmFtZXRlciBidXQgbm9uZSB3YXMgcHJvdmlkZWQuYFxuICAgICk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gTWlzc2luZ1BhcmFtZXRlckVycm9yLmNvZGU7XG4gICAgdGhpcy5kYXRhID0geyBwYXJhbWV0ZXIgfTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnTWlzc2luZ1BhcmFtZXRlckVycm9yJ30gKi9cbk1pc3NpbmdQYXJhbWV0ZXJFcnJvci5jb2RlID0gJ01pc3NpbmdQYXJhbWV0ZXJFcnJvcic7XG5cbmNsYXNzIFBhcnNlRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV4cGVjdGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY3R1YWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgICBzdXBlcihgRXhwZWN0ZWQgXCIke2V4cGVjdGVkfVwiIGJ1dCByZWNlaXZlZCBcIiR7YWN0dWFsfVwiLmApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IFBhcnNlRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IGV4cGVjdGVkLCBhY3R1YWwgfTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnUGFyc2VFcnJvcid9ICovXG5QYXJzZUVycm9yLmNvZGUgPSAnUGFyc2VFcnJvcic7XG5cbmNsYXNzIFB1c2hSZWplY3RlZEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7J25vdC1mYXN0LWZvcndhcmQnfCd0YWctZXhpc3RzJ30gcmVhc29uXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZWFzb24pIHtcbiAgICBsZXQgbWVzc2FnZSA9ICcnO1xuICAgIGlmIChyZWFzb24gPT09ICdub3QtZmFzdC1mb3J3YXJkJykge1xuICAgICAgbWVzc2FnZSA9ICcgYmVjYXVzZSBpdCB3YXMgbm90IGEgc2ltcGxlIGZhc3QtZm9yd2FyZCc7XG4gICAgfSBlbHNlIGlmIChyZWFzb24gPT09ICd0YWctZXhpc3RzJykge1xuICAgICAgbWVzc2FnZSA9ICcgYmVjYXVzZSB0YWcgYWxyZWFkeSBleGlzdHMnO1xuICAgIH1cbiAgICBzdXBlcihgUHVzaCByZWplY3RlZCR7bWVzc2FnZX0uIFVzZSBcImZvcmNlOiB0cnVlXCIgdG8gb3ZlcnJpZGUuYCk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gUHVzaFJlamVjdGVkRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IHJlYXNvbiB9O1xuICB9XG59XG4vKiogQHR5cGUgeydQdXNoUmVqZWN0ZWRFcnJvcid9ICovXG5QdXNoUmVqZWN0ZWRFcnJvci5jb2RlID0gJ1B1c2hSZWplY3RlZEVycm9yJztcblxuY2xhc3MgUmVtb3RlQ2FwYWJpbGl0eUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7J3NoYWxsb3cnfCdkZWVwZW4tc2luY2UnfCdkZWVwZW4tbm90J3wnZGVlcGVuLXJlbGF0aXZlJ30gY2FwYWJpbGl0eVxuICAgKiBAcGFyYW0geydkZXB0aCd8J3NpbmNlJ3wnZXhjbHVkZSd8J3JlbGF0aXZlJ30gcGFyYW1ldGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjYXBhYmlsaXR5LCBwYXJhbWV0ZXIpIHtcbiAgICBzdXBlcihcbiAgICAgIGBSZW1vdGUgZG9lcyBub3Qgc3VwcG9ydCB0aGUgXCIke2NhcGFiaWxpdHl9XCIgc28gdGhlIFwiJHtwYXJhbWV0ZXJ9XCIgcGFyYW1ldGVyIGNhbm5vdCBiZSB1c2VkLmBcbiAgICApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IFJlbW90ZUNhcGFiaWxpdHlFcnJvci5jb2RlO1xuICAgIHRoaXMuZGF0YSA9IHsgY2FwYWJpbGl0eSwgcGFyYW1ldGVyIH07XG4gIH1cbn1cbi8qKiBAdHlwZSB7J1JlbW90ZUNhcGFiaWxpdHlFcnJvcid9ICovXG5SZW1vdGVDYXBhYmlsaXR5RXJyb3IuY29kZSA9ICdSZW1vdGVDYXBhYmlsaXR5RXJyb3InO1xuXG5jbGFzcyBTbWFydEh0dHBFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJldmlld1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByZXZpZXcsIHJlc3BvbnNlKSB7XG4gICAgc3VwZXIoXG4gICAgICBgUmVtb3RlIGRpZCBub3QgcmVwbHkgdXNpbmcgdGhlIFwic21hcnRcIiBIVFRQIHByb3RvY29sLiBFeHBlY3RlZCBcIjAwMWUjIHNlcnZpY2U9Z2l0LXVwbG9hZC1wYWNrXCIgYnV0IHJlY2VpdmVkOiAke3ByZXZpZXd9YFxuICAgICk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gU21hcnRIdHRwRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IHByZXZpZXcsIHJlc3BvbnNlIH07XG4gIH1cbn1cbi8qKiBAdHlwZSB7J1NtYXJ0SHR0cEVycm9yJ30gKi9cblNtYXJ0SHR0cEVycm9yLmNvZGUgPSAnU21hcnRIdHRwRXJyb3InO1xuXG5jbGFzcyBVbmtub3duVHJhbnNwb3J0RXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNwb3J0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdWdnZXN0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih1cmwsIHRyYW5zcG9ydCwgc3VnZ2VzdGlvbikge1xuICAgIHN1cGVyKFxuICAgICAgYEdpdCByZW1vdGUgXCIke3VybH1cIiB1c2VzIGFuIHVucmVjb2duaXplZCB0cmFuc3BvcnQgcHJvdG9jb2w6IFwiJHt0cmFuc3BvcnR9XCJgXG4gICAgKTtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLm5hbWUgPSBVbmtub3duVHJhbnNwb3J0RXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IHVybCwgdHJhbnNwb3J0LCBzdWdnZXN0aW9uIH07XG4gIH1cbn1cbi8qKiBAdHlwZSB7J1Vua25vd25UcmFuc3BvcnRFcnJvcid9ICovXG5Vbmtub3duVHJhbnNwb3J0RXJyb3IuY29kZSA9ICdVbmtub3duVHJhbnNwb3J0RXJyb3InO1xuXG5jbGFzcyBVcmxQYXJzZUVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICovXG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHN1cGVyKGBDYW5ub3QgcGFyc2UgcmVtb3RlIFVSTDogXCIke3VybH1cImApO1xuICAgIHRoaXMuY29kZSA9IHRoaXMubmFtZSA9IFVybFBhcnNlRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7IHVybCB9O1xuICB9XG59XG4vKiogQHR5cGUgeydVcmxQYXJzZUVycm9yJ30gKi9cblVybFBhcnNlRXJyb3IuY29kZSA9ICdVcmxQYXJzZUVycm9yJztcblxuY2xhc3MgVXNlckNhbmNlbGVkRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihgVGhlIG9wZXJhdGlvbiB3YXMgY2FuY2VsZWQuYCk7XG4gICAgdGhpcy5jb2RlID0gdGhpcy5uYW1lID0gVXNlckNhbmNlbGVkRXJyb3IuY29kZTtcbiAgICB0aGlzLmRhdGEgPSB7fTtcbiAgfVxufVxuLyoqIEB0eXBlIHsnVXNlckNhbmNlbGVkRXJyb3InfSAqL1xuVXNlckNhbmNlbGVkRXJyb3IuY29kZSA9ICdVc2VyQ2FuY2VsZWRFcnJvcic7XG5cblxuXG52YXIgRXJyb3JzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFscmVhZHlFeGlzdHNFcnJvcjogQWxyZWFkeUV4aXN0c0Vycm9yLFxuICBBbWJpZ3VvdXNFcnJvcjogQW1iaWd1b3VzRXJyb3IsXG4gIENoZWNrb3V0Q29uZmxpY3RFcnJvcjogQ2hlY2tvdXRDb25mbGljdEVycm9yLFxuICBDb21taXROb3RGZXRjaGVkRXJyb3I6IENvbW1pdE5vdEZldGNoZWRFcnJvcixcbiAgRW1wdHlTZXJ2ZXJSZXNwb25zZUVycm9yOiBFbXB0eVNlcnZlclJlc3BvbnNlRXJyb3IsXG4gIEZhc3RGb3J3YXJkRXJyb3I6IEZhc3RGb3J3YXJkRXJyb3IsXG4gIEdpdFB1c2hFcnJvcjogR2l0UHVzaEVycm9yLFxuICBIdHRwRXJyb3I6IEh0dHBFcnJvcixcbiAgSW50ZXJuYWxFcnJvcjogSW50ZXJuYWxFcnJvcixcbiAgSW52YWxpZEZpbGVwYXRoRXJyb3I6IEludmFsaWRGaWxlcGF0aEVycm9yLFxuICBJbnZhbGlkT2lkRXJyb3I6IEludmFsaWRPaWRFcnJvcixcbiAgSW52YWxpZFJlZk5hbWVFcnJvcjogSW52YWxpZFJlZk5hbWVFcnJvcixcbiAgTWF4RGVwdGhFcnJvcjogTWF4RGVwdGhFcnJvcixcbiAgTWVyZ2VOb3RTdXBwb3J0ZWRFcnJvcjogTWVyZ2VOb3RTdXBwb3J0ZWRFcnJvcixcbiAgTWlzc2luZ05hbWVFcnJvcjogTWlzc2luZ05hbWVFcnJvcixcbiAgTWlzc2luZ1BhcmFtZXRlckVycm9yOiBNaXNzaW5nUGFyYW1ldGVyRXJyb3IsXG4gIE5vUmVmc3BlY0Vycm9yOiBOb1JlZnNwZWNFcnJvcixcbiAgTm90Rm91bmRFcnJvcjogTm90Rm91bmRFcnJvcixcbiAgT2JqZWN0VHlwZUVycm9yOiBPYmplY3RUeXBlRXJyb3IsXG4gIFBhcnNlRXJyb3I6IFBhcnNlRXJyb3IsXG4gIFB1c2hSZWplY3RlZEVycm9yOiBQdXNoUmVqZWN0ZWRFcnJvcixcbiAgUmVtb3RlQ2FwYWJpbGl0eUVycm9yOiBSZW1vdGVDYXBhYmlsaXR5RXJyb3IsXG4gIFNtYXJ0SHR0cEVycm9yOiBTbWFydEh0dHBFcnJvcixcbiAgVW5rbm93blRyYW5zcG9ydEVycm9yOiBVbmtub3duVHJhbnNwb3J0RXJyb3IsXG4gIFVuc2FmZUZpbGVwYXRoRXJyb3I6IFVuc2FmZUZpbGVwYXRoRXJyb3IsXG4gIFVybFBhcnNlRXJyb3I6IFVybFBhcnNlRXJyb3IsXG4gIFVzZXJDYW5jZWxlZEVycm9yOiBVc2VyQ2FuY2VsZWRFcnJvclxufSk7XG5cbmZ1bmN0aW9uIGZvcm1hdEF1dGhvcih7IG5hbWUsIGVtYWlsLCB0aW1lc3RhbXAsIHRpbWV6b25lT2Zmc2V0IH0pIHtcbiAgdGltZXpvbmVPZmZzZXQgPSBmb3JtYXRUaW1lem9uZU9mZnNldCh0aW1lem9uZU9mZnNldCk7XG4gIHJldHVybiBgJHtuYW1lfSA8JHtlbWFpbH0+ICR7dGltZXN0YW1wfSAke3RpbWV6b25lT2Zmc2V0fWBcbn1cblxuLy8gVGhlIGFtb3VudCBvZiBlZmZvcnQgdGhhdCB3ZW50IGludG8gY3JhZnRpbmcgdGhlc2UgY2FzZXMgdG8gaGFuZGxlXG4vLyAtMCAoanVzdCBzbyB3ZSBkb24ndCBsb3NlIHRoYXQgaW5mb3JtYXRpb24gd2hlbiBwYXJzaW5nIGFuZCByZWNvbnN0cnVjdGluZylcbi8vIGJ1dCBjYW4gYWxzbyBkZWZhdWx0IHRvICswIHdhcyBleHRyYW9yZGluYXJ5LlxuXG5mdW5jdGlvbiBmb3JtYXRUaW1lem9uZU9mZnNldChtaW51dGVzKSB7XG4gIGNvbnN0IHNpZ24gPSBzaW1wbGVTaWduKG5lZ2F0ZUV4Y2VwdEZvclplcm8obWludXRlcykpO1xuICBtaW51dGVzID0gTWF0aC5hYnMobWludXRlcyk7XG4gIGNvbnN0IGhvdXJzID0gTWF0aC5mbG9vcihtaW51dGVzIC8gNjApO1xuICBtaW51dGVzIC09IGhvdXJzICogNjA7XG4gIGxldCBzdHJIb3VycyA9IFN0cmluZyhob3Vycyk7XG4gIGxldCBzdHJNaW51dGVzID0gU3RyaW5nKG1pbnV0ZXMpO1xuICBpZiAoc3RySG91cnMubGVuZ3RoIDwgMikgc3RySG91cnMgPSAnMCcgKyBzdHJIb3VycztcbiAgaWYgKHN0ck1pbnV0ZXMubGVuZ3RoIDwgMikgc3RyTWludXRlcyA9ICcwJyArIHN0ck1pbnV0ZXM7XG4gIHJldHVybiAoc2lnbiA9PT0gLTEgPyAnLScgOiAnKycpICsgc3RySG91cnMgKyBzdHJNaW51dGVzXG59XG5cbmZ1bmN0aW9uIHNpbXBsZVNpZ24obikge1xuICByZXR1cm4gTWF0aC5zaWduKG4pIHx8IChPYmplY3QuaXMobiwgLTApID8gLTEgOiAxKVxufVxuXG5mdW5jdGlvbiBuZWdhdGVFeGNlcHRGb3JaZXJvKG4pIHtcbiAgcmV0dXJuIG4gPT09IDAgPyBuIDogLW5cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTmV3bGluZXMoc3RyKSB7XG4gIC8vIHJlbW92ZSBhbGwgPENSPlxuICBzdHIgPSBzdHIucmVwbGFjZSgvXFxyL2csICcnKTtcbiAgLy8gbm8gZXh0cmEgbmV3bGluZXMgdXAgZnJvbnRcbiAgc3RyID0gc3RyLnJlcGxhY2UoL15cXG4rLywgJycpO1xuICAvLyBhbmQgYSBzaW5nbGUgbmV3bGluZSBhdCB0aGUgZW5kXG4gIHN0ciA9IHN0ci5yZXBsYWNlKC9cXG4rJC8sICcnKSArICdcXG4nO1xuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHBhcnNlQXV0aG9yKGF1dGhvcikge1xuICBjb25zdCBbLCBuYW1lLCBlbWFpbCwgdGltZXN0YW1wLCBvZmZzZXRdID0gYXV0aG9yLm1hdGNoKFxuICAgIC9eKC4qKSA8KC4qKT4gKC4qKSAoLiopJC9cbiAgKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lLFxuICAgIGVtYWlsOiBlbWFpbCxcbiAgICB0aW1lc3RhbXA6IE51bWJlcih0aW1lc3RhbXApLFxuICAgIHRpbWV6b25lT2Zmc2V0OiBwYXJzZVRpbWV6b25lT2Zmc2V0KG9mZnNldCksXG4gIH1cbn1cblxuLy8gVGhlIGFtb3VudCBvZiBlZmZvcnQgdGhhdCB3ZW50IGludG8gY3JhZnRpbmcgdGhlc2UgY2FzZXMgdG8gaGFuZGxlXG4vLyAtMCAoanVzdCBzbyB3ZSBkb24ndCBsb3NlIHRoYXQgaW5mb3JtYXRpb24gd2hlbiBwYXJzaW5nIGFuZCByZWNvbnN0cnVjdGluZylcbi8vIGJ1dCBjYW4gYWxzbyBkZWZhdWx0IHRvICswIHdhcyBleHRyYW9yZGluYXJ5LlxuXG5mdW5jdGlvbiBwYXJzZVRpbWV6b25lT2Zmc2V0KG9mZnNldCkge1xuICBsZXQgWywgc2lnbiwgaG91cnMsIG1pbnV0ZXNdID0gb2Zmc2V0Lm1hdGNoKC8oXFwrfC0pKFxcZFxcZCkoXFxkXFxkKS8pO1xuICBtaW51dGVzID0gKHNpZ24gPT09ICcrJyA/IDEgOiAtMSkgKiAoTnVtYmVyKGhvdXJzKSAqIDYwICsgTnVtYmVyKG1pbnV0ZXMpKTtcbiAgcmV0dXJuIG5lZ2F0ZUV4Y2VwdEZvclplcm8kMShtaW51dGVzKVxufVxuXG5mdW5jdGlvbiBuZWdhdGVFeGNlcHRGb3JaZXJvJDEobikge1xuICByZXR1cm4gbiA9PT0gMCA/IG4gOiAtblxufVxuXG5jbGFzcyBHaXRBbm5vdGF0ZWRUYWcge1xuICBjb25zdHJ1Y3Rvcih0YWcpIHtcbiAgICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX3RhZyA9IHRhZztcbiAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih0YWcpKSB7XG4gICAgICB0aGlzLl90YWcgPSB0YWcudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YWcgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLl90YWcgPSBHaXRBbm5vdGF0ZWRUYWcucmVuZGVyKHRhZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKFxuICAgICAgICAnaW52YWxpZCB0eXBlIHBhc3NlZCB0byBHaXRBbm5vdGF0ZWRUYWcgY29uc3RydWN0b3InXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGZyb20odGFnKSB7XG4gICAgcmV0dXJuIG5ldyBHaXRBbm5vdGF0ZWRUYWcodGFnKVxuICB9XG5cbiAgc3RhdGljIHJlbmRlcihvYmopIHtcbiAgICByZXR1cm4gYG9iamVjdCAke29iai5vYmplY3R9XG50eXBlICR7b2JqLnR5cGV9XG50YWcgJHtvYmoudGFnfVxudGFnZ2VyICR7Zm9ybWF0QXV0aG9yKG9iai50YWdnZXIpfVxuXG4ke29iai5tZXNzYWdlfVxuJHtvYmouZ3Bnc2lnID8gb2JqLmdwZ3NpZyA6ICcnfWBcbiAgfVxuXG4gIGp1c3RIZWFkZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl90YWcuc2xpY2UoMCwgdGhpcy5fdGFnLmluZGV4T2YoJ1xcblxcbicpKVxuICB9XG5cbiAgbWVzc2FnZSgpIHtcbiAgICBjb25zdCB0YWcgPSB0aGlzLndpdGhvdXRTaWduYXR1cmUoKTtcbiAgICByZXR1cm4gdGFnLnNsaWNlKHRhZy5pbmRleE9mKCdcXG5cXG4nKSArIDIpXG4gIH1cblxuICBwYXJzZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzLmhlYWRlcnMoKSwge1xuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlKCksXG4gICAgICBncGdzaWc6IHRoaXMuZ3Bnc2lnKCksXG4gICAgfSlcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFnXG4gIH1cblxuICBoZWFkZXJzKCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLmp1c3RIZWFkZXJzKCkuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGhzID0gW107XG4gICAgZm9yIChjb25zdCBoIG9mIGhlYWRlcnMpIHtcbiAgICAgIGlmIChoWzBdID09PSAnICcpIHtcbiAgICAgICAgLy8gY29tYmluZSB3aXRoIHByZXZpb3VzIGhlYWRlciAod2l0aG91dCBzcGFjZSBpbmRlbnQpXG4gICAgICAgIGhzW2hzLmxlbmd0aCAtIDFdICs9ICdcXG4nICsgaC5zbGljZSgxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhzLnB1c2goaCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgIGZvciAoY29uc3QgaCBvZiBocykge1xuICAgICAgY29uc3Qga2V5ID0gaC5zbGljZSgwLCBoLmluZGV4T2YoJyAnKSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGguc2xpY2UoaC5pbmRleE9mKCcgJykgKyAxKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrZXldKSkge1xuICAgICAgICBvYmpba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvYmoudGFnZ2VyKSB7XG4gICAgICBvYmoudGFnZ2VyID0gcGFyc2VBdXRob3Iob2JqLnRhZ2dlcik7XG4gICAgfVxuICAgIGlmIChvYmouY29tbWl0dGVyKSB7XG4gICAgICBvYmouY29tbWl0dGVyID0gcGFyc2VBdXRob3Iob2JqLmNvbW1pdHRlcik7XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxuXG4gIHdpdGhvdXRTaWduYXR1cmUoKSB7XG4gICAgY29uc3QgdGFnID0gbm9ybWFsaXplTmV3bGluZXModGhpcy5fdGFnKTtcbiAgICBpZiAodGFnLmluZGV4T2YoJ1xcbi0tLS0tQkVHSU4gUEdQIFNJR05BVFVSRS0tLS0tJykgPT09IC0xKSByZXR1cm4gdGFnXG4gICAgcmV0dXJuIHRhZy5zbGljZSgwLCB0YWcubGFzdEluZGV4T2YoJ1xcbi0tLS0tQkVHSU4gUEdQIFNJR05BVFVSRS0tLS0tJykpXG4gIH1cblxuICBncGdzaWcoKSB7XG4gICAgaWYgKHRoaXMuX3RhZy5pbmRleE9mKCdcXG4tLS0tLUJFR0lOIFBHUCBTSUdOQVRVUkUtLS0tLScpID09PSAtMSkgcmV0dXJuXG4gICAgY29uc3Qgc2lnbmF0dXJlID0gdGhpcy5fdGFnLnNsaWNlKFxuICAgICAgdGhpcy5fdGFnLmluZGV4T2YoJy0tLS0tQkVHSU4gUEdQIFNJR05BVFVSRS0tLS0tJyksXG4gICAgICB0aGlzLl90YWcuaW5kZXhPZignLS0tLS1FTkQgUEdQIFNJR05BVFVSRS0tLS0tJykgK1xuICAgICAgICAnLS0tLS1FTkQgUEdQIFNJR05BVFVSRS0tLS0tJy5sZW5ndGhcbiAgICApO1xuICAgIHJldHVybiBub3JtYWxpemVOZXdsaW5lcyhzaWduYXR1cmUpXG4gIH1cblxuICBwYXlsb2FkKCkge1xuICAgIHJldHVybiB0aGlzLndpdGhvdXRTaWduYXR1cmUoKSArICdcXG4nXG4gIH1cblxuICB0b09iamVjdCgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5fdGFnLCAndXRmOCcpXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgc2lnbih0YWcsIHNpZ24sIHNlY3JldEtleSkge1xuICAgIGNvbnN0IHBheWxvYWQgPSB0YWcucGF5bG9hZCgpO1xuICAgIGxldCB7IHNpZ25hdHVyZSB9ID0gYXdhaXQgc2lnbih7IHBheWxvYWQsIHNlY3JldEtleSB9KTtcbiAgICAvLyByZW5vcm1hbGl6ZSB0aGUgbGluZSBlbmRpbmdzIHRvIHRoZSBvbmUgdHJ1ZSBsaW5lLWVuZGluZ1xuICAgIHNpZ25hdHVyZSA9IG5vcm1hbGl6ZU5ld2xpbmVzKHNpZ25hdHVyZSk7XG4gICAgY29uc3Qgc2lnbmVkVGFnID0gcGF5bG9hZCArIHNpZ25hdHVyZTtcbiAgICAvLyByZXR1cm4gYSBuZXcgdGFnIG9iamVjdFxuICAgIHJldHVybiBHaXRBbm5vdGF0ZWRUYWcuZnJvbShzaWduZWRUYWcpXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZW50KHN0cikge1xuICByZXR1cm4gKFxuICAgIHN0clxuICAgICAgLnRyaW0oKVxuICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgLm1hcCh4ID0+ICcgJyArIHgpXG4gICAgICAuam9pbignXFxuJykgKyAnXFxuJ1xuICApXG59XG5cbmZ1bmN0aW9uIG91dGRlbnQoc3RyKSB7XG4gIHJldHVybiBzdHJcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLm1hcCh4ID0+IHgucmVwbGFjZSgvXiAvLCAnJykpXG4gICAgLmpvaW4oJ1xcbicpXG59XG5cbmNsYXNzIEdpdENvbW1pdCB7XG4gIGNvbnN0cnVjdG9yKGNvbW1pdCkge1xuICAgIGlmICh0eXBlb2YgY29tbWl0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fY29tbWl0ID0gY29tbWl0O1xuICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGNvbW1pdCkpIHtcbiAgICAgIHRoaXMuX2NvbW1pdCA9IGNvbW1pdC50b1N0cmluZygndXRmOCcpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbW1pdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuX2NvbW1pdCA9IEdpdENvbW1pdC5yZW5kZXIoY29tbWl0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoJ2ludmFsaWQgdHlwZSBwYXNzZWQgdG8gR2l0Q29tbWl0IGNvbnN0cnVjdG9yJylcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZnJvbVBheWxvYWRTaWduYXR1cmUoeyBwYXlsb2FkLCBzaWduYXR1cmUgfSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBHaXRDb21taXQuanVzdEhlYWRlcnMocGF5bG9hZCk7XG4gICAgY29uc3QgbWVzc2FnZSA9IEdpdENvbW1pdC5qdXN0TWVzc2FnZShwYXlsb2FkKTtcbiAgICBjb25zdCBjb21taXQgPSBub3JtYWxpemVOZXdsaW5lcyhcbiAgICAgIGhlYWRlcnMgKyAnXFxuZ3Bnc2lnJyArIGluZGVudChzaWduYXR1cmUpICsgJ1xcbicgKyBtZXNzYWdlXG4gICAgKTtcbiAgICByZXR1cm4gbmV3IEdpdENvbW1pdChjb21taXQpXG4gIH1cblxuICBzdGF0aWMgZnJvbShjb21taXQpIHtcbiAgICByZXR1cm4gbmV3IEdpdENvbW1pdChjb21taXQpXG4gIH1cblxuICB0b09iamVjdCgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5fY29tbWl0LCAndXRmOCcpXG4gIH1cblxuICAvLyBUb2RvOiBhbGxvdyBzZXR0aW5nIHRoZSBoZWFkZXJzIGFuZCBtZXNzYWdlXG4gIGhlYWRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VIZWFkZXJzKClcbiAgfVxuXG4gIC8vIFRvZG86IGFsbG93IHNldHRpbmcgdGhlIGhlYWRlcnMgYW5kIG1lc3NhZ2VcbiAgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gR2l0Q29tbWl0Lmp1c3RNZXNzYWdlKHRoaXMuX2NvbW1pdClcbiAgfVxuXG4gIHBhcnNlKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgbWVzc2FnZTogdGhpcy5tZXNzYWdlKCkgfSwgdGhpcy5oZWFkZXJzKCkpXG4gIH1cblxuICBzdGF0aWMganVzdE1lc3NhZ2UoY29tbWl0KSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZU5ld2xpbmVzKGNvbW1pdC5zbGljZShjb21taXQuaW5kZXhPZignXFxuXFxuJykgKyAyKSlcbiAgfVxuXG4gIHN0YXRpYyBqdXN0SGVhZGVycyhjb21taXQpIHtcbiAgICByZXR1cm4gY29tbWl0LnNsaWNlKDAsIGNvbW1pdC5pbmRleE9mKCdcXG5cXG4nKSlcbiAgfVxuXG4gIHBhcnNlSGVhZGVycygpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gR2l0Q29tbWl0Lmp1c3RIZWFkZXJzKHRoaXMuX2NvbW1pdCkuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IGhzID0gW107XG4gICAgZm9yIChjb25zdCBoIG9mIGhlYWRlcnMpIHtcbiAgICAgIGlmIChoWzBdID09PSAnICcpIHtcbiAgICAgICAgLy8gY29tYmluZSB3aXRoIHByZXZpb3VzIGhlYWRlciAod2l0aG91dCBzcGFjZSBpbmRlbnQpXG4gICAgICAgIGhzW2hzLmxlbmd0aCAtIDFdICs9ICdcXG4nICsgaC5zbGljZSgxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhzLnB1c2goaCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgIHBhcmVudDogW10sXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGggb2YgaHMpIHtcbiAgICAgIGNvbnN0IGtleSA9IGguc2xpY2UoMCwgaC5pbmRleE9mKCcgJykpO1xuICAgICAgY29uc3QgdmFsdWUgPSBoLnNsaWNlKGguaW5kZXhPZignICcpICsgMSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba2V5XSkpIHtcbiAgICAgICAgb2JqW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqLmF1dGhvcikge1xuICAgICAgb2JqLmF1dGhvciA9IHBhcnNlQXV0aG9yKG9iai5hdXRob3IpO1xuICAgIH1cbiAgICBpZiAob2JqLmNvbW1pdHRlcikge1xuICAgICAgb2JqLmNvbW1pdHRlciA9IHBhcnNlQXV0aG9yKG9iai5jb21taXR0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqXG4gIH1cblxuICBzdGF0aWMgcmVuZGVySGVhZGVycyhvYmopIHtcbiAgICBsZXQgaGVhZGVycyA9ICcnO1xuICAgIGlmIChvYmoudHJlZSkge1xuICAgICAgaGVhZGVycyArPSBgdHJlZSAke29iai50cmVlfVxcbmA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlcnMgKz0gYHRyZWUgNGI4MjVkYzY0MmNiNmViOWEwNjBlNTRiZjhkNjkyODhmYmVlNDkwNFxcbmA7IC8vIHRoZSBudWxsIHRyZWVcbiAgICB9XG4gICAgaWYgKG9iai5wYXJlbnQpIHtcbiAgICAgIGlmIChvYmoucGFyZW50Lmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKGBjb21taXQgJ3BhcmVudCcgcHJvcGVydHkgc2hvdWxkIGJlIGFuIGFycmF5YClcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgcCBvZiBvYmoucGFyZW50KSB7XG4gICAgICAgIGhlYWRlcnMgKz0gYHBhcmVudCAke3B9XFxuYDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYXV0aG9yID0gb2JqLmF1dGhvcjtcbiAgICBoZWFkZXJzICs9IGBhdXRob3IgJHtmb3JtYXRBdXRob3IoYXV0aG9yKX1cXG5gO1xuICAgIGNvbnN0IGNvbW1pdHRlciA9IG9iai5jb21taXR0ZXIgfHwgb2JqLmF1dGhvcjtcbiAgICBoZWFkZXJzICs9IGBjb21taXR0ZXIgJHtmb3JtYXRBdXRob3IoY29tbWl0dGVyKX1cXG5gO1xuICAgIGlmIChvYmouZ3Bnc2lnKSB7XG4gICAgICBoZWFkZXJzICs9ICdncGdzaWcnICsgaW5kZW50KG9iai5ncGdzaWcpO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgc3RhdGljIHJlbmRlcihvYmopIHtcbiAgICByZXR1cm4gR2l0Q29tbWl0LnJlbmRlckhlYWRlcnMob2JqKSArICdcXG4nICsgbm9ybWFsaXplTmV3bGluZXMob2JqLm1lc3NhZ2UpXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbW1pdFxuICB9XG5cbiAgd2l0aG91dFNpZ25hdHVyZSgpIHtcbiAgICBjb25zdCBjb21taXQgPSBub3JtYWxpemVOZXdsaW5lcyh0aGlzLl9jb21taXQpO1xuICAgIGlmIChjb21taXQuaW5kZXhPZignXFxuZ3Bnc2lnJykgPT09IC0xKSByZXR1cm4gY29tbWl0XG4gICAgY29uc3QgaGVhZGVycyA9IGNvbW1pdC5zbGljZSgwLCBjb21taXQuaW5kZXhPZignXFxuZ3Bnc2lnJykpO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBjb21taXQuc2xpY2UoXG4gICAgICBjb21taXQuaW5kZXhPZignLS0tLS1FTkQgUEdQIFNJR05BVFVSRS0tLS0tXFxuJykgK1xuICAgICAgICAnLS0tLS1FTkQgUEdQIFNJR05BVFVSRS0tLS0tXFxuJy5sZW5ndGhcbiAgICApO1xuICAgIHJldHVybiBub3JtYWxpemVOZXdsaW5lcyhoZWFkZXJzICsgJ1xcbicgKyBtZXNzYWdlKVxuICB9XG5cbiAgaXNvbGF0ZVNpZ25hdHVyZSgpIHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSB0aGlzLl9jb21taXQuc2xpY2UoXG4gICAgICB0aGlzLl9jb21taXQuaW5kZXhPZignLS0tLS1CRUdJTiBQR1AgU0lHTkFUVVJFLS0tLS0nKSxcbiAgICAgIHRoaXMuX2NvbW1pdC5pbmRleE9mKCctLS0tLUVORCBQR1AgU0lHTkFUVVJFLS0tLS0nKSArXG4gICAgICAgICctLS0tLUVORCBQR1AgU0lHTkFUVVJFLS0tLS0nLmxlbmd0aFxuICAgICk7XG4gICAgcmV0dXJuIG91dGRlbnQoc2lnbmF0dXJlKVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIHNpZ24oY29tbWl0LCBzaWduLCBzZWNyZXRLZXkpIHtcbiAgICBjb25zdCBwYXlsb2FkID0gY29tbWl0LndpdGhvdXRTaWduYXR1cmUoKTtcbiAgICBjb25zdCBtZXNzYWdlID0gR2l0Q29tbWl0Lmp1c3RNZXNzYWdlKGNvbW1pdC5fY29tbWl0KTtcbiAgICBsZXQgeyBzaWduYXR1cmUgfSA9IGF3YWl0IHNpZ24oeyBwYXlsb2FkLCBzZWNyZXRLZXkgfSk7XG4gICAgLy8gcmVub3JtYWxpemUgdGhlIGxpbmUgZW5kaW5ncyB0byB0aGUgb25lIHRydWUgbGluZS1lbmRpbmdcbiAgICBzaWduYXR1cmUgPSBub3JtYWxpemVOZXdsaW5lcyhzaWduYXR1cmUpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBHaXRDb21taXQuanVzdEhlYWRlcnMoY29tbWl0Ll9jb21taXQpO1xuICAgIGNvbnN0IHNpZ25lZENvbW1pdCA9XG4gICAgICBoZWFkZXJzICsgJ1xcbicgKyAnZ3Bnc2lnJyArIGluZGVudChzaWduYXR1cmUpICsgJ1xcbicgKyBtZXNzYWdlO1xuICAgIC8vIHJldHVybiBhIG5ldyBjb21taXQgb2JqZWN0XG4gICAgcmV0dXJuIEdpdENvbW1pdC5mcm9tKHNpZ25lZENvbW1pdClcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlVHJlZSh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSkge1xuICAvLyBFbXB0eSB0cmVlIC0gYnlwYXNzIGByZWFkT2JqZWN0YFxuICBpZiAob2lkID09PSAnNGI4MjVkYzY0MmNiNmViOWEwNjBlNTRiZjhkNjkyODhmYmVlNDkwNCcpIHtcbiAgICByZXR1cm4geyB0cmVlOiBHaXRUcmVlLmZyb20oW10pLCBvaWQgfVxuICB9XG4gIGNvbnN0IHsgdHlwZSwgb2JqZWN0IH0gPSBhd2FpdCBfcmVhZE9iamVjdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG4gIC8vIFJlc29sdmUgYW5ub3RhdGVkIHRhZyBvYmplY3RzIHRvIHdoYXRldmVyXG4gIGlmICh0eXBlID09PSAndGFnJykge1xuICAgIG9pZCA9IEdpdEFubm90YXRlZFRhZy5mcm9tKG9iamVjdCkucGFyc2UoKS5vYmplY3Q7XG4gICAgcmV0dXJuIHJlc29sdmVUcmVlKHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KVxuICB9XG4gIC8vIFJlc29sdmUgY29tbWl0cyB0byB0cmVlc1xuICBpZiAodHlwZSA9PT0gJ2NvbW1pdCcpIHtcbiAgICBvaWQgPSBHaXRDb21taXQuZnJvbShvYmplY3QpLnBhcnNlKCkudHJlZTtcbiAgICByZXR1cm4gcmVzb2x2ZVRyZWUoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pXG4gIH1cbiAgaWYgKHR5cGUgIT09ICd0cmVlJykge1xuICAgIHRocm93IG5ldyBPYmplY3RUeXBlRXJyb3Iob2lkLCB0eXBlLCAndHJlZScpXG4gIH1cbiAgcmV0dXJuIHsgdHJlZTogR2l0VHJlZS5mcm9tKG9iamVjdCksIG9pZCB9XG59XG5cbmNsYXNzIEdpdFdhbGtlclJlcG8ge1xuICBjb25zdHJ1Y3Rvcih7IGZzLCBnaXRkaXIsIHJlZiwgY2FjaGUgfSkge1xuICAgIHRoaXMuZnMgPSBmcztcbiAgICB0aGlzLmNhY2hlID0gY2FjaGU7XG4gICAgdGhpcy5naXRkaXIgPSBnaXRkaXI7XG4gICAgdGhpcy5tYXBQcm9taXNlID0gKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIGxldCBvaWQ7XG4gICAgICB0cnkge1xuICAgICAgICBvaWQgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoeyBmcywgZ2l0ZGlyLCByZWYgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvcikge1xuICAgICAgICAgIC8vIEhhbmRsZSBmcmVzaCBicmFuY2hlcyB3aXRoIG5vIGNvbW1pdHNcbiAgICAgICAgICBvaWQgPSAnNGI4MjVkYzY0MmNiNmViOWEwNjBlNTRiZjhkNjkyODhmYmVlNDkwNCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyZWUgPSBhd2FpdCByZXNvbHZlVHJlZSh7IGZzLCBjYWNoZTogdGhpcy5jYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG4gICAgICB0cmVlLnR5cGUgPSAndHJlZSc7XG4gICAgICB0cmVlLm1vZGUgPSAnNDAwMDAnO1xuICAgICAgbWFwLnNldCgnLicsIHRyZWUpO1xuICAgICAgcmV0dXJuIG1hcFxuICAgIH0pKCk7XG4gICAgY29uc3Qgd2Fsa2VyID0gdGhpcztcbiAgICB0aGlzLkNvbnN0cnVjdEVudHJ5ID0gY2xhc3MgVHJlZUVudHJ5IHtcbiAgICAgIGNvbnN0cnVjdG9yKGZ1bGxwYXRoKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxwYXRoID0gZnVsbHBhdGg7XG4gICAgICAgIHRoaXMuX3R5cGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbW9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fb2lkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGFzeW5jIHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB3YWxrZXIudHlwZSh0aGlzKVxuICAgICAgfVxuXG4gICAgICBhc3luYyBtb2RlKCkge1xuICAgICAgICByZXR1cm4gd2Fsa2VyLm1vZGUodGhpcylcbiAgICAgIH1cblxuICAgICAgYXN5bmMgc3RhdCgpIHtcbiAgICAgICAgcmV0dXJuIHdhbGtlci5zdGF0KHRoaXMpXG4gICAgICB9XG5cbiAgICAgIGFzeW5jIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB3YWxrZXIuY29udGVudCh0aGlzKVxuICAgICAgfVxuXG4gICAgICBhc3luYyBvaWQoKSB7XG4gICAgICAgIHJldHVybiB3YWxrZXIub2lkKHRoaXMpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIHJlYWRkaXIoZW50cnkpIHtcbiAgICBjb25zdCBmaWxlcGF0aCA9IGVudHJ5Ll9mdWxscGF0aDtcbiAgICBjb25zdCB7IGZzLCBjYWNoZSwgZ2l0ZGlyIH0gPSB0aGlzO1xuICAgIGNvbnN0IG1hcCA9IGF3YWl0IHRoaXMubWFwUHJvbWlzZTtcbiAgICBjb25zdCBvYmogPSBtYXAuZ2V0KGZpbGVwYXRoKTtcbiAgICBpZiAoIW9iaikgdGhyb3cgbmV3IEVycm9yKGBObyBvYmogZm9yICR7ZmlsZXBhdGh9YClcbiAgICBjb25zdCBvaWQgPSBvYmoub2lkO1xuICAgIGlmICghb2lkKSB0aHJvdyBuZXcgRXJyb3IoYE5vIG9pZCBmb3Igb2JqICR7SlNPTi5zdHJpbmdpZnkob2JqKX1gKVxuICAgIGlmIChvYmoudHlwZSAhPT0gJ3RyZWUnKSB7XG4gICAgICAvLyBUT0RPOiBzdXBwb3J0IHN1Ym1vZHVsZXMgKHR5cGUgPT09ICdjb21taXQnKVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgY29uc3QgeyB0eXBlLCBvYmplY3QgfSA9IGF3YWl0IF9yZWFkT2JqZWN0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcbiAgICBpZiAodHlwZSAhPT0gb2JqLnR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBPYmplY3RUeXBlRXJyb3Iob2lkLCB0eXBlLCBvYmoudHlwZSlcbiAgICB9XG4gICAgY29uc3QgdHJlZSA9IEdpdFRyZWUuZnJvbShvYmplY3QpO1xuICAgIC8vIGNhY2hlIGFsbCBlbnRyaWVzXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiB0cmVlKSB7XG4gICAgICBtYXAuc2V0KGpvaW4oZmlsZXBhdGgsIGVudHJ5LnBhdGgpLCBlbnRyeSk7XG4gICAgfVxuICAgIHJldHVybiB0cmVlLmVudHJpZXMoKS5tYXAoZW50cnkgPT4gam9pbihmaWxlcGF0aCwgZW50cnkucGF0aCkpXG4gIH1cblxuICBhc3luYyB0eXBlKGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5Ll90eXBlID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgbWFwID0gYXdhaXQgdGhpcy5tYXBQcm9taXNlO1xuICAgICAgY29uc3QgeyB0eXBlIH0gPSBtYXAuZ2V0KGVudHJ5Ll9mdWxscGF0aCk7XG4gICAgICBlbnRyeS5fdHlwZSA9IHR5cGU7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS5fdHlwZVxuICB9XG5cbiAgYXN5bmMgbW9kZShlbnRyeSkge1xuICAgIGlmIChlbnRyeS5fbW9kZSA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IG1hcCA9IGF3YWl0IHRoaXMubWFwUHJvbWlzZTtcbiAgICAgIGNvbnN0IHsgbW9kZSB9ID0gbWFwLmdldChlbnRyeS5fZnVsbHBhdGgpO1xuICAgICAgZW50cnkuX21vZGUgPSBub3JtYWxpemVNb2RlKHBhcnNlSW50KG1vZGUsIDgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5Ll9tb2RlXG4gIH1cblxuICBhc3luYyBzdGF0KF9lbnRyeSkge31cblxuICBhc3luYyBjb250ZW50KGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5Ll9jb250ZW50ID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgbWFwID0gYXdhaXQgdGhpcy5tYXBQcm9taXNlO1xuICAgICAgY29uc3QgeyBmcywgY2FjaGUsIGdpdGRpciB9ID0gdGhpcztcbiAgICAgIGNvbnN0IG9iaiA9IG1hcC5nZXQoZW50cnkuX2Z1bGxwYXRoKTtcbiAgICAgIGNvbnN0IG9pZCA9IG9iai5vaWQ7XG4gICAgICBjb25zdCB7IHR5cGUsIG9iamVjdCB9ID0gYXdhaXQgX3JlYWRPYmplY3QoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pO1xuICAgICAgaWYgKHR5cGUgIT09ICdibG9iJykge1xuICAgICAgICBlbnRyeS5fY29udGVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJ5Ll9jb250ZW50ID0gbmV3IFVpbnQ4QXJyYXkob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5Ll9jb250ZW50XG4gIH1cblxuICBhc3luYyBvaWQoZW50cnkpIHtcbiAgICBpZiAoZW50cnkuX29pZCA9PT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IG1hcCA9IGF3YWl0IHRoaXMubWFwUHJvbWlzZTtcbiAgICAgIGNvbnN0IG9iaiA9IG1hcC5nZXQoZW50cnkuX2Z1bGxwYXRoKTtcbiAgICAgIGVudHJ5Ll9vaWQgPSBvYmoub2lkO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnkuX29pZFxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVmPSdIRUFEJ11cbiAqIEByZXR1cm5zIHtXYWxrZXJ9XG4gKi9cbmZ1bmN0aW9uIFRSRUUoeyByZWYgPSAnSEVBRCcgfSkge1xuICBjb25zdCBvID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIEdpdFdhbGtTeW1ib2wsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oeyBmcywgZ2l0ZGlyLCBjYWNoZSB9KSB7XG4gICAgICByZXR1cm4gbmV3IEdpdFdhbGtlclJlcG8oeyBmcywgZ2l0ZGlyLCByZWYsIGNhY2hlIH0pXG4gICAgfSxcbiAgfSk7XG4gIE9iamVjdC5mcmVlemUobyk7XG4gIHJldHVybiBvXG59XG5cbi8vIEB0cy1jaGVja1xuXG5jbGFzcyBHaXRXYWxrZXJGcyB7XG4gIGNvbnN0cnVjdG9yKHsgZnMsIGRpciwgZ2l0ZGlyLCBjYWNoZSB9KSB7XG4gICAgdGhpcy5mcyA9IGZzO1xuICAgIHRoaXMuY2FjaGUgPSBjYWNoZTtcbiAgICB0aGlzLmRpciA9IGRpcjtcbiAgICB0aGlzLmdpdGRpciA9IGdpdGRpcjtcbiAgICBjb25zdCB3YWxrZXIgPSB0aGlzO1xuICAgIHRoaXMuQ29uc3RydWN0RW50cnkgPSBjbGFzcyBXb3JrZGlyRW50cnkge1xuICAgICAgY29uc3RydWN0b3IoZnVsbHBhdGgpIHtcbiAgICAgICAgdGhpcy5fZnVsbHBhdGggPSBmdWxscGF0aDtcbiAgICAgICAgdGhpcy5fdHlwZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9tb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vaWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgYXN5bmMgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHdhbGtlci50eXBlKHRoaXMpXG4gICAgICB9XG5cbiAgICAgIGFzeW5jIG1vZGUoKSB7XG4gICAgICAgIHJldHVybiB3YWxrZXIubW9kZSh0aGlzKVxuICAgICAgfVxuXG4gICAgICBhc3luYyBzdGF0KCkge1xuICAgICAgICByZXR1cm4gd2Fsa2VyLnN0YXQodGhpcylcbiAgICAgIH1cblxuICAgICAgYXN5bmMgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHdhbGtlci5jb250ZW50KHRoaXMpXG4gICAgICB9XG5cbiAgICAgIGFzeW5jIG9pZCgpIHtcbiAgICAgICAgcmV0dXJuIHdhbGtlci5vaWQodGhpcylcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgYXN5bmMgcmVhZGRpcihlbnRyeSkge1xuICAgIGNvbnN0IGZpbGVwYXRoID0gZW50cnkuX2Z1bGxwYXRoO1xuICAgIGNvbnN0IHsgZnMsIGRpciB9ID0gdGhpcztcbiAgICBjb25zdCBuYW1lcyA9IGF3YWl0IGZzLnJlYWRkaXIoam9pbihkaXIsIGZpbGVwYXRoKSk7XG4gICAgaWYgKG5hbWVzID09PSBudWxsKSByZXR1cm4gbnVsbFxuICAgIHJldHVybiBuYW1lcy5tYXAobmFtZSA9PiBqb2luKGZpbGVwYXRoLCBuYW1lKSlcbiAgfVxuXG4gIGFzeW5jIHR5cGUoZW50cnkpIHtcbiAgICBpZiAoZW50cnkuX3R5cGUgPT09IGZhbHNlKSB7XG4gICAgICBhd2FpdCBlbnRyeS5zdGF0KCk7XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS5fdHlwZVxuICB9XG5cbiAgYXN5bmMgbW9kZShlbnRyeSkge1xuICAgIGlmIChlbnRyeS5fbW9kZSA9PT0gZmFsc2UpIHtcbiAgICAgIGF3YWl0IGVudHJ5LnN0YXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5Ll9tb2RlXG4gIH1cblxuICBhc3luYyBzdGF0KGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5Ll9zdGF0ID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgeyBmcywgZGlyIH0gPSB0aGlzO1xuICAgICAgbGV0IHN0YXQgPSBhd2FpdCBmcy5sc3RhdChgJHtkaXJ9LyR7ZW50cnkuX2Z1bGxwYXRofWApO1xuICAgICAgaWYgKCFzdGF0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRU5PRU5UOiBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5LCBsc3RhdCAnJHtlbnRyeS5fZnVsbHBhdGh9J2BcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgbGV0IHR5cGUgPSBzdGF0LmlzRGlyZWN0b3J5KCkgPyAndHJlZScgOiAnYmxvYic7XG4gICAgICBpZiAodHlwZSA9PT0gJ2Jsb2InICYmICFzdGF0LmlzRmlsZSgpICYmICFzdGF0LmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgdHlwZSA9ICdzcGVjaWFsJztcbiAgICAgIH1cbiAgICAgIGVudHJ5Ll90eXBlID0gdHlwZTtcbiAgICAgIHN0YXQgPSBub3JtYWxpemVTdGF0cyhzdGF0KTtcbiAgICAgIGVudHJ5Ll9tb2RlID0gc3RhdC5tb2RlO1xuICAgICAgLy8gd29ya2Fyb3VuZCBmb3IgYSBCcm93c2VyRlMgZWRnZSBjYXNlXG4gICAgICBpZiAoc3RhdC5zaXplID09PSAtMSAmJiBlbnRyeS5fYWN0dWFsU2l6ZSkge1xuICAgICAgICBzdGF0LnNpemUgPSBlbnRyeS5fYWN0dWFsU2l6ZTtcbiAgICAgIH1cbiAgICAgIGVudHJ5Ll9zdGF0ID0gc3RhdDtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJ5Ll9zdGF0XG4gIH1cblxuICBhc3luYyBjb250ZW50KGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5Ll9jb250ZW50ID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgeyBmcywgZGlyIH0gPSB0aGlzO1xuICAgICAgaWYgKChhd2FpdCBlbnRyeS50eXBlKCkpID09PSAndHJlZScpIHtcbiAgICAgICAgZW50cnkuX2NvbnRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgZnMucmVhZChgJHtkaXJ9LyR7ZW50cnkuX2Z1bGxwYXRofWApO1xuICAgICAgICAvLyB3b3JrYXJvdW5kIGZvciBhIEJyb3dzZXJGUyBlZGdlIGNhc2VcbiAgICAgICAgZW50cnkuX2FjdHVhbFNpemUgPSBjb250ZW50Lmxlbmd0aDtcbiAgICAgICAgaWYgKGVudHJ5Ll9zdGF0ICYmIGVudHJ5Ll9zdGF0LnNpemUgPT09IC0xKSB7XG4gICAgICAgICAgZW50cnkuX3N0YXQuc2l6ZSA9IGVudHJ5Ll9hY3R1YWxTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5Ll9jb250ZW50ID0gbmV3IFVpbnQ4QXJyYXkoY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbnRyeS5fY29udGVudFxuICB9XG5cbiAgYXN5bmMgb2lkKGVudHJ5KSB7XG4gICAgaWYgKGVudHJ5Ll9vaWQgPT09IGZhbHNlKSB7XG4gICAgICBjb25zdCB7IGZzLCBnaXRkaXIsIGNhY2hlIH0gPSB0aGlzO1xuICAgICAgbGV0IG9pZDtcbiAgICAgIC8vIFNlZSBpZiB3ZSBjYW4gdXNlIHRoZSBTSEExIGhhc2ggaW4gdGhlIGluZGV4LlxuICAgICAgYXdhaXQgR2l0SW5kZXhNYW5hZ2VyLmFjcXVpcmUoeyBmcywgZ2l0ZGlyLCBjYWNoZSB9LCBhc3luYyBmdW5jdGlvbihcbiAgICAgICAgaW5kZXhcbiAgICAgICkge1xuICAgICAgICBjb25zdCBzdGFnZSA9IGluZGV4LmVudHJpZXNNYXAuZ2V0KGVudHJ5Ll9mdWxscGF0aCk7XG4gICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZW50cnkuc3RhdCgpO1xuICAgICAgICBpZiAoIXN0YWdlIHx8IGNvbXBhcmVTdGF0cyhzdGF0cywgc3RhZ2UpKSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IGVudHJ5LmNvbnRlbnQoKTtcbiAgICAgICAgICBpZiAoY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9pZCA9IGF3YWl0IHNoYXN1bShcbiAgICAgICAgICAgICAgR2l0T2JqZWN0LndyYXAoeyB0eXBlOiAnYmxvYicsIG9iamVjdDogYXdhaXQgZW50cnkuY29udGVudCgpIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzdGF0cyBpbiB0aGUgaW5kZXggc28gd2Ugd2lsbCBnZXQgYSBcImNhY2hlIGhpdFwiIG5leHQgdGltZVxuICAgICAgICAgICAgLy8gMSkgaWYgd2UgY2FuIChiZWNhdXNlIHRoZSBvaWQgYW5kIG1vZGUgYXJlIHRoZSBzYW1lKVxuICAgICAgICAgICAgLy8gMikgYW5kIG9ubHkgaWYgd2UgbmVlZCB0byAoYmVjYXVzZSBvdGhlciBzdGF0cyBkaWZmZXIpXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHN0YWdlICYmXG4gICAgICAgICAgICAgIG9pZCA9PT0gc3RhZ2Uub2lkICYmXG4gICAgICAgICAgICAgIHN0YXRzLm1vZGUgPT09IHN0YWdlLm1vZGUgJiZcbiAgICAgICAgICAgICAgY29tcGFyZVN0YXRzKHN0YXRzLCBzdGFnZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpbmRleC5pbnNlcnQoe1xuICAgICAgICAgICAgICAgIGZpbGVwYXRoOiBlbnRyeS5fZnVsbHBhdGgsXG4gICAgICAgICAgICAgICAgc3RhdHMsXG4gICAgICAgICAgICAgICAgb2lkOiBvaWQsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIGluZGV4IFNIQTEgcmF0aGVyIHRoYW4gY29tcHV0ZSBpdFxuICAgICAgICAgIG9pZCA9IHN0YWdlLm9pZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlbnRyeS5fb2lkID0gb2lkO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnkuX29pZFxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEByZXR1cm5zIHtXYWxrZXJ9XG4gKi9cbmZ1bmN0aW9uIFdPUktESVIoKSB7XG4gIGNvbnN0IG8gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgR2l0V2Fsa1N5bWJvbCwge1xuICAgIHZhbHVlOiBmdW5jdGlvbih7IGZzLCBkaXIsIGdpdGRpciwgY2FjaGUgfSkge1xuICAgICAgcmV0dXJuIG5ldyBHaXRXYWxrZXJGcyh7IGZzLCBkaXIsIGdpdGRpciwgY2FjaGUgfSlcbiAgICB9LFxuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShvKTtcbiAgcmV0dXJuIG9cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8vIEknbSBwdXR0aW5nIHRoaXMgaW4gYSBNYW5hZ2VyIGJlY2F1c2UgSSByZWNrb24gaXQgY291bGQgYmVuZWZpdFxuLy8gZnJvbSBhIExPVCBvZiBjYWNoZWluZy5cbmNsYXNzIEdpdElnbm9yZU1hbmFnZXIge1xuICBzdGF0aWMgYXN5bmMgaXNJZ25vcmVkKHsgZnMsIGRpciwgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksIGZpbGVwYXRoIH0pIHtcbiAgICAvLyBBTFdBWVMgaWdub3JlIFwiLmdpdFwiIGZvbGRlcnMuXG4gICAgaWYgKGJhc2VuYW1lKGZpbGVwYXRoKSA9PT0gJy5naXQnKSByZXR1cm4gdHJ1ZVxuICAgIC8vICcuJyBpcyBub3QgYSB2YWxpZCBnaXRpZ25vcmUgZW50cnksIHNvICcuJyBpcyBuZXZlciBpZ25vcmVkXG4gICAgaWYgKGZpbGVwYXRoID09PSAnLicpIHJldHVybiBmYWxzZVxuICAgIC8vIENoZWNrIGFuZCBsb2FkIGV4Y2x1c2lvbiBydWxlcyBmcm9tIHByb2plY3QgZXhjbHVkZSBmaWxlICguZ2l0L2luZm8vZXhjbHVkZSlcbiAgICBsZXQgZXhjbHVkZXMgPSAnJztcbiAgICBjb25zdCBleGNsdWRlc0ZpbGUgPSBqb2luKGdpdGRpciwgJ2luZm8nLCAnZXhjbHVkZScpO1xuICAgIGlmIChhd2FpdCBmcy5leGlzdHMoZXhjbHVkZXNGaWxlKSkge1xuICAgICAgZXhjbHVkZXMgPSBhd2FpdCBmcy5yZWFkKGV4Y2x1ZGVzRmlsZSwgJ3V0ZjgnKTtcbiAgICB9XG4gICAgLy8gRmluZCBhbGwgdGhlIC5naXRpZ25vcmUgZmlsZXMgdGhhdCBjb3VsZCBhZmZlY3QgdGhpcyBmaWxlXG4gICAgY29uc3QgcGFpcnMgPSBbXG4gICAgICB7XG4gICAgICAgIGdpdGlnbm9yZTogam9pbihkaXIsICcuZ2l0aWdub3JlJyksXG4gICAgICAgIGZpbGVwYXRoLFxuICAgICAgfSxcbiAgICBdO1xuICAgIGNvbnN0IHBpZWNlcyA9IGZpbGVwYXRoLnNwbGl0KCcvJykuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBmb2xkZXIgPSBwaWVjZXMuc2xpY2UoMCwgaSkuam9pbignLycpO1xuICAgICAgY29uc3QgZmlsZSA9IHBpZWNlcy5zbGljZShpKS5qb2luKCcvJyk7XG4gICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgZ2l0aWdub3JlOiBqb2luKGRpciwgZm9sZGVyLCAnLmdpdGlnbm9yZScpLFxuICAgICAgICBmaWxlcGF0aDogZmlsZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgaWdub3JlZFN0YXR1cyA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcCBvZiBwYWlycykge1xuICAgICAgbGV0IGZpbGU7XG4gICAgICB0cnkge1xuICAgICAgICBmaWxlID0gYXdhaXQgZnMucmVhZChwLmdpdGlnbm9yZSwgJ3V0ZjgnKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09ICdOT0VOVCcpIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBjb25zdCBpZ24gPSBpZ25vcmUoKS5hZGQoZXhjbHVkZXMpO1xuICAgICAgaWduLmFkZChmaWxlKTtcbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgZGlyZWN0b3J5IGlzIGV4Y2x1ZGVkLCB3ZSBhcmUgZG9uZS5cbiAgICAgIC8vIFwiSXQgaXMgbm90IHBvc3NpYmxlIHRvIHJlLWluY2x1ZGUgYSBmaWxlIGlmIGEgcGFyZW50IGRpcmVjdG9yeSBvZiB0aGF0IGZpbGUgaXMgZXhjbHVkZWQuIEdpdCBkb2VzbuKAmXQgbGlzdCBleGNsdWRlZCBkaXJlY3RvcmllcyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgc28gYW55IHBhdHRlcm5zIG9uIGNvbnRhaW5lZCBmaWxlcyBoYXZlIG5vIGVmZmVjdCwgbm8gbWF0dGVyIHdoZXJlIHRoZXkgYXJlIGRlZmluZWQuXCJcbiAgICAgIC8vIHNvdXJjZTogaHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdGlnbm9yZVxuICAgICAgY29uc3QgcGFyZW50ZGlyID0gZGlybmFtZShwLmZpbGVwYXRoKTtcbiAgICAgIGlmIChwYXJlbnRkaXIgIT09ICcuJyAmJiBpZ24uaWdub3JlcyhwYXJlbnRkaXIpKSByZXR1cm4gdHJ1ZVxuICAgICAgLy8gSWYgdGhlIGZpbGUgaXMgY3VycmVudGx5IGlnbm9yZWQsIHRlc3QgZm9yIFVOaWdub3JpbmcuXG4gICAgICBpZiAoaWdub3JlZFN0YXR1cykge1xuICAgICAgICBpZ25vcmVkU3RhdHVzID0gIWlnbi50ZXN0KHAuZmlsZXBhdGgpLnVuaWdub3JlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlnbm9yZWRTdGF0dXMgPSBpZ24udGVzdChwLmZpbGVwYXRoKS5pZ25vcmVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWdub3JlZFN0YXR1c1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgZGlyZWN0b3J5IGF0IHRoZSBzcGVjaWZpZWQgZmlsZXBhdGggcmVjdXJzaXZlbHkuIFVzZWQgaW50ZXJuYWxseSB0byByZXBsaWNhdGUgdGhlIGJlaGF2aW9yIG9mXG4gKiBmcy5wcm9taXNlcy5ybSh7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSkgZnJvbSBOb2RlLmpzIDE0IGFuZCBhYm92ZSB3aGVuIG5vdCBhdmFpbGFibGUuIElmIHRoZSBwcm92aWRlZFxuICogZmlsZXBhdGggcmVzb2x2ZXMgdG8gYSBmaWxlLCBpdCB3aWxsIGJlIHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCAtIFRoZSBmaWxlIG9yIGRpcmVjdG9yeSB0byByZW1vdmUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJtUmVjdXJzaXZlKGZzLCBmaWxlcGF0aCkge1xuICBjb25zdCBlbnRyaWVzID0gYXdhaXQgZnMucmVhZGRpcihmaWxlcGF0aCk7XG4gIGlmIChlbnRyaWVzID09IG51bGwpIHtcbiAgICBhd2FpdCBmcy5ybShmaWxlcGF0aCk7XG4gIH0gZWxzZSBpZiAoZW50cmllcy5sZW5ndGgpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGVudHJpZXMubWFwKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3Qgc3VicGF0aCA9IGpvaW4oZmlsZXBhdGgsIGVudHJ5KTtcbiAgICAgICAgcmV0dXJuIGZzLmxzdGF0KHN1YnBhdGgpLnRoZW4oc3RhdCA9PiB7XG4gICAgICAgICAgaWYgKCFzdGF0KSByZXR1cm5cbiAgICAgICAgICByZXR1cm4gc3RhdC5pc0RpcmVjdG9yeSgpID8gcm1SZWN1cnNpdmUoZnMsIHN1YnBhdGgpIDogZnMucm0oc3VicGF0aClcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgKS50aGVuKCgpID0+IGZzLnJtZGlyKGZpbGVwYXRoKSk7XG4gIH0gZWxzZSB7XG4gICAgYXdhaXQgZnMucm1kaXIoZmlsZXBhdGgpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBqdXN0IGEgY29sbGVjdGlvbiBvZiBoZWxwZXIgZnVuY3Rpb25zIHJlYWxseS4gQXQgbGVhc3QgdGhhdCdzIGhvdyBpdCBzdGFydGVkLlxuICovXG5jbGFzcyBGaWxlU3lzdGVtIHtcbiAgY29uc3RydWN0b3IoZnMpIHtcbiAgICBpZiAodHlwZW9mIGZzLl9vcmlnaW5hbF91bndyYXBwZWRfZnMgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gZnNcblxuICAgIGNvbnN0IHByb21pc2VzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmcywgJ3Byb21pc2VzJyk7XG4gICAgaWYgKHByb21pc2VzICYmIHByb21pc2VzLmVudW1lcmFibGUpIHtcbiAgICAgIHRoaXMuX3JlYWRGaWxlID0gZnMucHJvbWlzZXMucmVhZEZpbGUuYmluZChmcy5wcm9taXNlcyk7XG4gICAgICB0aGlzLl93cml0ZUZpbGUgPSBmcy5wcm9taXNlcy53cml0ZUZpbGUuYmluZChmcy5wcm9taXNlcyk7XG4gICAgICB0aGlzLl9ta2RpciA9IGZzLnByb21pc2VzLm1rZGlyLmJpbmQoZnMucHJvbWlzZXMpO1xuICAgICAgaWYgKGZzLnByb21pc2VzLnJtKSB7XG4gICAgICAgIHRoaXMuX3JtID0gZnMucHJvbWlzZXMucm0uYmluZChmcy5wcm9taXNlcyk7XG4gICAgICB9IGVsc2UgaWYgKGZzLnByb21pc2VzLnJtZGlyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5fcm0gPSBmcy5wcm9taXNlcy5ybWRpci5iaW5kKGZzLnByb21pc2VzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JtID0gcm1SZWN1cnNpdmUuYmluZChudWxsLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JtZGlyID0gZnMucHJvbWlzZXMucm1kaXIuYmluZChmcy5wcm9taXNlcyk7XG4gICAgICB0aGlzLl91bmxpbmsgPSBmcy5wcm9taXNlcy51bmxpbmsuYmluZChmcy5wcm9taXNlcyk7XG4gICAgICB0aGlzLl9zdGF0ID0gZnMucHJvbWlzZXMuc3RhdC5iaW5kKGZzLnByb21pc2VzKTtcbiAgICAgIHRoaXMuX2xzdGF0ID0gZnMucHJvbWlzZXMubHN0YXQuYmluZChmcy5wcm9taXNlcyk7XG4gICAgICB0aGlzLl9yZWFkZGlyID0gZnMucHJvbWlzZXMucmVhZGRpci5iaW5kKGZzLnByb21pc2VzKTtcbiAgICAgIHRoaXMuX3JlYWRsaW5rID0gZnMucHJvbWlzZXMucmVhZGxpbmsuYmluZChmcy5wcm9taXNlcyk7XG4gICAgICB0aGlzLl9zeW1saW5rID0gZnMucHJvbWlzZXMuc3ltbGluay5iaW5kKGZzLnByb21pc2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVhZEZpbGUgPSBwaWZ5KGZzLnJlYWRGaWxlLmJpbmQoZnMpKTtcbiAgICAgIHRoaXMuX3dyaXRlRmlsZSA9IHBpZnkoZnMud3JpdGVGaWxlLmJpbmQoZnMpKTtcbiAgICAgIHRoaXMuX21rZGlyID0gcGlmeShmcy5ta2Rpci5iaW5kKGZzKSk7XG4gICAgICBpZiAoZnMucm0pIHtcbiAgICAgICAgdGhpcy5fcm0gPSBwaWZ5KGZzLnJtLmJpbmQoZnMpKTtcbiAgICAgIH0gZWxzZSBpZiAoZnMucm1kaXIubGVuZ3RoID4gMikge1xuICAgICAgICB0aGlzLl9ybSA9IHBpZnkoZnMucm1kaXIuYmluZChmcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcm0gPSBybVJlY3Vyc2l2ZS5iaW5kKG51bGwsIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcm1kaXIgPSBwaWZ5KGZzLnJtZGlyLmJpbmQoZnMpKTtcbiAgICAgIHRoaXMuX3VubGluayA9IHBpZnkoZnMudW5saW5rLmJpbmQoZnMpKTtcbiAgICAgIHRoaXMuX3N0YXQgPSBwaWZ5KGZzLnN0YXQuYmluZChmcykpO1xuICAgICAgdGhpcy5fbHN0YXQgPSBwaWZ5KGZzLmxzdGF0LmJpbmQoZnMpKTtcbiAgICAgIHRoaXMuX3JlYWRkaXIgPSBwaWZ5KGZzLnJlYWRkaXIuYmluZChmcykpO1xuICAgICAgdGhpcy5fcmVhZGxpbmsgPSBwaWZ5KGZzLnJlYWRsaW5rLmJpbmQoZnMpKTtcbiAgICAgIHRoaXMuX3N5bWxpbmsgPSBwaWZ5KGZzLnN5bWxpbmsuYmluZChmcykpO1xuICAgIH1cbiAgICB0aGlzLl9vcmlnaW5hbF91bndyYXBwZWRfZnMgPSBmcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiBhIGZpbGUgZXhpc3RzLCBmYWxzZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgKiBSZXRocm93cyBlcnJvcnMgdGhhdCBhcmVuJ3QgcmVsYXRlZCB0byBmaWxlIGV4aXN0YW5jZS5cbiAgICovXG4gIGFzeW5jIGV4aXN0cyhmaWxlcGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX3N0YXQoZmlsZXBhdGgpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcgfHwgZXJyLmNvZGUgPT09ICdFTk9URElSJykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVbmhhbmRsZWQgZXJyb3IgaW4gXCJGaWxlU3lzdGVtLmV4aXN0cygpXCIgZnVuY3Rpb24nLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBjb250ZW50cyBvZiBhIGZpbGUgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZmlsZXBhdGhcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXJ8c3RyaW5nfG51bGw+fVxuICAgKi9cbiAgYXN5bmMgcmVhZChmaWxlcGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBidWZmZXIgPSBhd2FpdCB0aGlzLl9yZWFkRmlsZShmaWxlcGF0aCwgb3B0aW9ucyk7XG4gICAgICAvLyBDb252ZXJ0IHBsYWluIEFycmF5QnVmZmVycyB0byBCdWZmZXJzXG4gICAgICBpZiAodHlwZW9mIGJ1ZmZlciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXJcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgZmlsZSAoY3JlYXRpbmcgbWlzc2luZyBkaXJlY3RvcmllcyBpZiBuZWVkIGJlKSB3aXRob3V0IHRocm93aW5nIGVycm9ycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpbGVwYXRoXG4gICAqIEBwYXJhbSB7QnVmZmVyfFVpbnQ4QXJyYXl8c3RyaW5nfSBjb250ZW50c1xuICAgKiBAcGFyYW0ge29iamVjdHxzdHJpbmd9IFtvcHRpb25zXVxuICAgKi9cbiAgYXN5bmMgd3JpdGUoZmlsZXBhdGgsIGNvbnRlbnRzLCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5fd3JpdGVGaWxlKGZpbGVwYXRoLCBjb250ZW50cywgb3B0aW9ucyk7XG4gICAgICByZXR1cm5cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIEhtbS4gTGV0J3MgdHJ5IG1rZGlycCBhbmQgdHJ5IGFnYWluLlxuICAgICAgYXdhaXQgdGhpcy5ta2RpcihkaXJuYW1lKGZpbGVwYXRoKSk7XG4gICAgICBhd2FpdCB0aGlzLl93cml0ZUZpbGUoZmlsZXBhdGgsIGNvbnRlbnRzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIGRpcmVjdG9yeSAob3Igc2VyaWVzIG9mIG5lc3RlZCBkaXJlY3Rvcmllcykgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvciBpZiBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICovXG4gIGFzeW5jIG1rZGlyKGZpbGVwYXRoLCBfc2VsZkNhbGwgPSBmYWxzZSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLl9ta2RpcihmaWxlcGF0aCk7XG4gICAgICByZXR1cm5cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIElmIGVyciBpcyBudWxsIHRoZW4gb3BlcmF0aW9uIHN1Y2NlZWRlZCFcbiAgICAgIGlmIChlcnIgPT09IG51bGwpIHJldHVyblxuICAgICAgLy8gSWYgdGhlIGRpcmVjdG9yeSBhbHJlYWR5IGV4aXN0cywgdGhhdCdzIE9LIVxuICAgICAgaWYgKGVyci5jb2RlID09PSAnRUVYSVNUJykgcmV0dXJuXG4gICAgICAvLyBBdm9pZCBpbmZpbml0ZSBsb29wcyBvZiBmYWlsdXJlXG4gICAgICBpZiAoX3NlbGZDYWxsKSB0aHJvdyBlcnJcbiAgICAgIC8vIElmIHdlIGdvdCBhIFwibm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeSBlcnJvclwiIGJhY2t1cCBhbmQgdHJ5IGFnYWluLlxuICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBkaXJuYW1lKGZpbGVwYXRoKTtcbiAgICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlJ3ZlIGdvbmUgdG9vIGZhclxuICAgICAgICBpZiAocGFyZW50ID09PSAnLicgfHwgcGFyZW50ID09PSAnLycgfHwgcGFyZW50ID09PSBmaWxlcGF0aCkgdGhyb3cgZXJyXG4gICAgICAgIC8vIEluZmluaXRlIHJlY3Vyc2lvbiwgd2hhdCBjb3VsZCBnbyB3cm9uZz9cbiAgICAgICAgYXdhaXQgdGhpcy5ta2RpcihwYXJlbnQpO1xuICAgICAgICBhd2FpdCB0aGlzLm1rZGlyKGZpbGVwYXRoLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgZmlsZSB3aXRob3V0IHRocm93aW5nIGFuIGVycm9yIGlmIGl0IGlzIGFscmVhZHkgZGVsZXRlZC5cbiAgICovXG4gIGFzeW5jIHJtKGZpbGVwYXRoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMuX3VubGluayhmaWxlcGF0aCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmNvZGUgIT09ICdFTk9FTlQnKSB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgZGlyZWN0b3J5IHdpdGhvdXQgdGhyb3dpbmcgYW4gZXJyb3IgaWYgaXQgaXMgYWxyZWFkeSBkZWxldGVkLlxuICAgKi9cbiAgYXN5bmMgcm1kaXIoZmlsZXBhdGgsIG9wdHMpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5yZWN1cnNpdmUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcm0oZmlsZXBhdGgsIG9wdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fcm1kaXIoZmlsZXBhdGgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlICE9PSAnRU5PRU5UJykgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSBkaXJlY3Rvcnkgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvciBpcyB0aGUgZGlyZWN0b3J5IGRvZXNuJ3QgZXhpc3RcbiAgICovXG4gIGFzeW5jIHJlYWRkaXIoZmlsZXBhdGgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbmFtZXMgPSBhd2FpdCB0aGlzLl9yZWFkZGlyKGZpbGVwYXRoKTtcbiAgICAgIC8vIE9yZGVyaW5nIGlzIG5vdCBndWFyYW50ZWVkLCBhbmQgc3lzdGVtIHNwZWNpZmljIChXaW5kb3dzIHZzIFVuaXgpXG4gICAgICAvLyBzbyB3ZSBtdXN0IHNvcnQgdGhlbSBvdXJzZWx2ZXMuXG4gICAgICBuYW1lcy5zb3J0KGNvbXBhcmVTdHJpbmdzKTtcbiAgICAgIHJldHVybiBuYW1lc1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PVERJUicpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgZmxhc3QgbGlzdCBvZiBhbGwgdGhlIGZpbGVzIG5lc3RlZCBpbnNpZGUgYSBkaXJlY3RvcnlcbiAgICpcbiAgICogQmFzZWQgb24gYW4gZWxlZ2FudCBjb25jdXJyZW50IHJlY3Vyc2l2ZSBzb2x1dGlvbiBmcm9tIFNPXG4gICAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NTEzMDk5MC8yMTY4NDE2XG4gICAqL1xuICBhc3luYyByZWFkZGlyRGVlcChkaXIpIHtcbiAgICBjb25zdCBzdWJkaXJzID0gYXdhaXQgdGhpcy5fcmVhZGRpcihkaXIpO1xuICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBzdWJkaXJzLm1hcChhc3luYyBzdWJkaXIgPT4ge1xuICAgICAgICBjb25zdCByZXMgPSBkaXIgKyAnLycgKyBzdWJkaXI7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5fc3RhdChyZXMpKS5pc0RpcmVjdG9yeSgpXG4gICAgICAgICAgPyB0aGlzLnJlYWRkaXJEZWVwKHJlcylcbiAgICAgICAgICA6IHJlc1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiBmaWxlcy5yZWR1Y2UoKGEsIGYpID0+IGEuY29uY2F0KGYpLCBbXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIFN0YXRzIG9mIGEgZmlsZS9zeW1saW5rIGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cbiAgICogUmV0aHJvd3MgZXJyb3JzIHRoYXQgYXJlbid0IHJlbGF0ZWQgdG8gZmlsZSBleGlzdGFuY2UuXG4gICAqL1xuICBhc3luYyBsc3RhdChmaWxlbmFtZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHRoaXMuX2xzdGF0KGZpbGVuYW1lKTtcbiAgICAgIHJldHVybiBzdGF0c1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSBjb250ZW50cyBvZiBhIHN5bWxpbmsgaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgcmV0dXJucyBudWxsLlxuICAgKiBSZXRocm93cyBlcnJvcnMgdGhhdCBhcmVuJ3QgcmVsYXRlZCB0byBmaWxlIGV4aXN0YW5jZS5cbiAgICovXG4gIGFzeW5jIHJlYWRsaW5rKGZpbGVuYW1lLCBvcHRzID0geyBlbmNvZGluZzogJ2J1ZmZlcicgfSkge1xuICAgIC8vIE5vdGU6IEZpbGVTeXN0ZW0ucmVhZGxpbmsgcmV0dXJucyBhIGJ1ZmZlciBieSBkZWZhdWx0XG4gICAgLy8gc28gd2UgY2FuIGR1bXAgaXQgaW50byBHaXRPYmplY3Qud3JpdGUganVzdCBsaWtlIGFueSBvdGhlciBmaWxlLlxuICAgIHRyeSB7XG4gICAgICBjb25zdCBsaW5rID0gYXdhaXQgdGhpcy5fcmVhZGxpbmsoZmlsZW5hbWUsIG9wdHMpO1xuICAgICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihsaW5rKSA/IGxpbmsgOiBCdWZmZXIuZnJvbShsaW5rKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIHRoZSBjb250ZW50cyBvZiBidWZmZXIgdG8gYSBzeW1saW5rLlxuICAgKi9cbiAgYXN5bmMgd3JpdGVsaW5rKGZpbGVuYW1lLCBidWZmZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ltbGluayhidWZmZXIudG9TdHJpbmcoJ3V0ZjgnKSwgZmlsZW5hbWUpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVPYmplY3RMb29zZSh7IGZzLCBnaXRkaXIsIG9iamVjdCwgZm9ybWF0LCBvaWQgfSkge1xuICBpZiAoZm9ybWF0ICE9PSAnZGVmbGF0ZWQnKSB7XG4gICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoXG4gICAgICAnR2l0T2JqZWN0U3RvcmVMb29zZSBleHBlY3RzIG9iamVjdHMgdG8gd3JpdGUgdG8gYmUgaW4gZGVmbGF0ZWQgZm9ybWF0J1xuICAgIClcbiAgfVxuICBjb25zdCBzb3VyY2UgPSBgb2JqZWN0cy8ke29pZC5zbGljZSgwLCAyKX0vJHtvaWQuc2xpY2UoMil9YDtcbiAgY29uc3QgZmlsZXBhdGggPSBgJHtnaXRkaXJ9LyR7c291cmNlfWA7XG4gIC8vIERvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBnaXQgb2JqZWN0cyAtIHRoaXMgaGVscHMgYXZvaWQgRVBFUk0gZXJyb3JzLlxuICAvLyBBbHRob3VnaCBJIGRvbid0IGtub3cgaG93IHdlJ2QgZml4IGNvcnJ1cHRlZCBvYmplY3RzIHRoZW4uIFBlcmhhcHMgZGVsZXRlIHRoZW1cbiAgLy8gb24gcmVhZD9cbiAgaWYgKCEoYXdhaXQgZnMuZXhpc3RzKGZpbGVwYXRoKSkpIGF3YWl0IGZzLndyaXRlKGZpbGVwYXRoLCBvYmplY3QpO1xufVxuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxubGV0IHN1cHBvcnRzQ29tcHJlc3Npb25TdHJlYW0gPSBudWxsO1xuXG5hc3luYyBmdW5jdGlvbiBkZWZsYXRlKGJ1ZmZlcikge1xuICBpZiAoc3VwcG9ydHNDb21wcmVzc2lvblN0cmVhbSA9PT0gbnVsbCkge1xuICAgIHN1cHBvcnRzQ29tcHJlc3Npb25TdHJlYW0gPSB0ZXN0Q29tcHJlc3Npb25TdHJlYW0oKTtcbiAgfVxuICByZXR1cm4gc3VwcG9ydHNDb21wcmVzc2lvblN0cmVhbVxuICAgID8gYnJvd3NlckRlZmxhdGUoYnVmZmVyKVxuICAgIDogcGFrby5kZWZsYXRlKGJ1ZmZlcilcbn1cblxuYXN5bmMgZnVuY3Rpb24gYnJvd3NlckRlZmxhdGUoYnVmZmVyKSB7XG4gIGNvbnN0IGNzID0gbmV3IENvbXByZXNzaW9uU3RyZWFtKCdkZWZsYXRlJyk7XG4gIGNvbnN0IGMgPSBuZXcgQmxvYihbYnVmZmVyXSkuc3RyZWFtKCkucGlwZVRocm91Z2goY3MpO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgbmV3IFJlc3BvbnNlKGMpLmFycmF5QnVmZmVyKCkpXG59XG5cbmZ1bmN0aW9uIHRlc3RDb21wcmVzc2lvblN0cmVhbSgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjcyA9IG5ldyBDb21wcmVzc2lvblN0cmVhbSgnZGVmbGF0ZScpO1xuICAgIC8vIFRlc3QgaWYgYEJsb2Iuc3RyZWFtYCBpcyBwcmVzZW50LiBSZWFjdCBOYXRpdmUgZG9lcyBub3QgaGF2ZSB0aGUgYHN0cmVhbWAgbWV0aG9kXG4gICAgbmV3IEJsb2IoW10pLnN0cmVhbSgpO1xuICAgIGlmIChjcykgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoXykge1xuICAgIC8vIG5vIGJvdGhlclxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5hc3luYyBmdW5jdGlvbiBfd3JpdGVPYmplY3Qoe1xuICBmcyxcbiAgZ2l0ZGlyLFxuICB0eXBlLFxuICBvYmplY3QsXG4gIGZvcm1hdCA9ICdjb250ZW50JyxcbiAgb2lkID0gdW5kZWZpbmVkLFxuICBkcnlSdW4gPSBmYWxzZSxcbn0pIHtcbiAgaWYgKGZvcm1hdCAhPT0gJ2RlZmxhdGVkJykge1xuICAgIGlmIChmb3JtYXQgIT09ICd3cmFwcGVkJykge1xuICAgICAgb2JqZWN0ID0gR2l0T2JqZWN0LndyYXAoeyB0eXBlLCBvYmplY3QgfSk7XG4gICAgfVxuICAgIG9pZCA9IGF3YWl0IHNoYXN1bShvYmplY3QpO1xuICAgIG9iamVjdCA9IEJ1ZmZlci5mcm9tKGF3YWl0IGRlZmxhdGUob2JqZWN0KSk7XG4gIH1cbiAgaWYgKCFkcnlSdW4pIHtcbiAgICBhd2FpdCB3cml0ZU9iamVjdExvb3NlKHsgZnMsIGdpdGRpciwgb2JqZWN0LCBmb3JtYXQ6ICdkZWZsYXRlZCcsIG9pZCB9KTtcbiAgfVxuICByZXR1cm4gb2lkXG59XG5cbmZ1bmN0aW9uIGFzc2VydFBhcmFtZXRlcihuYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBNaXNzaW5nUGFyYW1ldGVyRXJyb3IobmFtZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3NpeGlmeVBhdGhCdWZmZXIoYnVmZmVyKSB7XG4gIGxldCBpZHg7XG4gIHdoaWxlICh+KGlkeCA9IGJ1ZmZlci5pbmRleE9mKDkyKSkpIGJ1ZmZlcltpZHhdID0gNDc7XG4gIHJldHVybiBidWZmZXJcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQWRkIGEgZmlsZSB0byB0aGUgZ2l0IGluZGV4IChha2Egc3RhZ2luZyBhcmVhKVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZGlyIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCAnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5maWxlcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSBmaWxlIHRvIGFkZCB0byB0aGUgaW5kZXhcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgb25jZSB0aGUgZ2l0IGluZGV4IGhhcyBiZWVuIHVwZGF0ZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZnMucHJvbWlzZXMud3JpdGVGaWxlKCcvdHV0b3JpYWwvUkVBRE1FLm1kJywgYCMgVEVTVGApXG4gKiBhd2FpdCBnaXQuYWRkKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIGZpbGVwYXRoOiAnUkVBRE1FLm1kJyB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYWRkKHtcbiAgZnM6IF9mcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgZmlsZXBhdGgsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIF9mcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdkaXInLCBkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZpbGVwYXRoJywgZmlsZXBhdGgpO1xuXG4gICAgY29uc3QgZnMgPSBuZXcgRmlsZVN5c3RlbShfZnMpO1xuICAgIGF3YWl0IEdpdEluZGV4TWFuYWdlci5hY3F1aXJlKHsgZnMsIGdpdGRpciwgY2FjaGUgfSwgYXN5bmMgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGF3YWl0IGFkZFRvSW5kZXgoeyBkaXIsIGdpdGRpciwgZnMsIGZpbGVwYXRoLCBpbmRleCB9KTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuYWRkJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBhZGRUb0luZGV4KHsgZGlyLCBnaXRkaXIsIGZzLCBmaWxlcGF0aCwgaW5kZXggfSkge1xuICAvLyBUT0RPOiBTaG91bGQgaWdub3JlIFVOTEVTUyBpdCdzIGFscmVhZHkgaW4gdGhlIGluZGV4LlxuICBjb25zdCBpZ25vcmVkID0gYXdhaXQgR2l0SWdub3JlTWFuYWdlci5pc0lnbm9yZWQoe1xuICAgIGZzLFxuICAgIGRpcixcbiAgICBnaXRkaXIsXG4gICAgZmlsZXBhdGgsXG4gIH0pO1xuICBpZiAoaWdub3JlZCkgcmV0dXJuXG4gIGNvbnN0IHN0YXRzID0gYXdhaXQgZnMubHN0YXQoam9pbihkaXIsIGZpbGVwYXRoKSk7XG4gIGlmICghc3RhdHMpIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKGZpbGVwYXRoKVxuICBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gYXdhaXQgZnMucmVhZGRpcihqb2luKGRpciwgZmlsZXBhdGgpKTtcbiAgICBjb25zdCBwcm9taXNlcyA9IGNoaWxkcmVuLm1hcChjaGlsZCA9PlxuICAgICAgYWRkVG9JbmRleCh7IGRpciwgZ2l0ZGlyLCBmcywgZmlsZXBhdGg6IGpvaW4oZmlsZXBhdGgsIGNoaWxkKSwgaW5kZXggfSlcbiAgICApO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBvYmplY3QgPSBzdGF0cy5pc1N5bWJvbGljTGluaygpXG4gICAgICA/IGF3YWl0IGZzLnJlYWRsaW5rKGpvaW4oZGlyLCBmaWxlcGF0aCkpLnRoZW4ocG9zaXhpZnlQYXRoQnVmZmVyKVxuICAgICAgOiBhd2FpdCBmcy5yZWFkKGpvaW4oZGlyLCBmaWxlcGF0aCkpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKGZpbGVwYXRoKVxuICAgIGNvbnN0IG9pZCA9IGF3YWl0IF93cml0ZU9iamVjdCh7IGZzLCBnaXRkaXIsIHR5cGU6ICdibG9iJywgb2JqZWN0IH0pO1xuICAgIGluZGV4Lmluc2VydCh7IGZpbGVwYXRoLCBzdGF0cywgb2lkIH0pO1xuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtvYmplY3R9IGFyZ3MuY2FjaGVcbiAqIEBwYXJhbSB7U2lnbkNhbGxiYWNrfSBbYXJncy5vblNpZ25dXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLmF1dGhvclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuYXV0aG9yLm5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmF1dGhvci5lbWFpbFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuYXV0aG9yLnRpbWVzdGFtcFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuYXV0aG9yLnRpbWV6b25lT2Zmc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gYXJncy5jb21taXR0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmNvbW1pdHRlci5uYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5jb21taXR0ZXIuZW1haWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmNvbW1pdHRlci50aW1lc3RhbXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmNvbW1pdHRlci50aW1lem9uZU9mZnNldFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnNpZ25pbmdLZXldXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmRyeVJ1biA9IGZhbHNlXVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5ub1VwZGF0ZUJyYW5jaCA9IGZhbHNlXVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZl1cbiAqIEBwYXJhbSB7c3RyaW5nW119IFthcmdzLnBhcmVudF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy50cmVlXVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIHRoZSBTSEEtMSBvYmplY3QgaWQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgY29tbWl0LlxuICovXG5hc3luYyBmdW5jdGlvbiBfY29tbWl0KHtcbiAgZnMsXG4gIGNhY2hlLFxuICBvblNpZ24sXG4gIGdpdGRpcixcbiAgbWVzc2FnZSxcbiAgYXV0aG9yLFxuICBjb21taXR0ZXIsXG4gIHNpZ25pbmdLZXksXG4gIGRyeVJ1biA9IGZhbHNlLFxuICBub1VwZGF0ZUJyYW5jaCA9IGZhbHNlLFxuICByZWYsXG4gIHBhcmVudCxcbiAgdHJlZSxcbn0pIHtcbiAgaWYgKCFyZWYpIHtcbiAgICByZWYgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoe1xuICAgICAgZnMsXG4gICAgICBnaXRkaXIsXG4gICAgICByZWY6ICdIRUFEJyxcbiAgICAgIGRlcHRoOiAyLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIEdpdEluZGV4TWFuYWdlci5hY3F1aXJlKHsgZnMsIGdpdGRpciwgY2FjaGUgfSwgYXN5bmMgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBjb25zdCBpbm9kZXMgPSBmbGF0RmlsZUxpc3RUb0RpcmVjdG9yeVN0cnVjdHVyZShpbmRleC5lbnRyaWVzKTtcbiAgICBjb25zdCBpbm9kZSA9IGlub2Rlcy5nZXQoJy4nKTtcbiAgICBpZiAoIXRyZWUpIHtcbiAgICAgIHRyZWUgPSBhd2FpdCBjb25zdHJ1Y3RUcmVlKHsgZnMsIGdpdGRpciwgaW5vZGUsIGRyeVJ1biB9KTtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcmVudCA9IFtcbiAgICAgICAgICBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoe1xuICAgICAgICAgICAgZnMsXG4gICAgICAgICAgICBnaXRkaXIsXG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gUHJvYmFibHkgYW4gaW5pdGlhbCBjb21taXRcbiAgICAgICAgcGFyZW50ID0gW107XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBjb21tID0gR2l0Q29tbWl0LmZyb20oe1xuICAgICAgdHJlZSxcbiAgICAgIHBhcmVudCxcbiAgICAgIGF1dGhvcixcbiAgICAgIGNvbW1pdHRlcixcbiAgICAgIG1lc3NhZ2UsXG4gICAgfSk7XG4gICAgaWYgKHNpZ25pbmdLZXkpIHtcbiAgICAgIGNvbW0gPSBhd2FpdCBHaXRDb21taXQuc2lnbihjb21tLCBvblNpZ24sIHNpZ25pbmdLZXkpO1xuICAgIH1cbiAgICBjb25zdCBvaWQgPSBhd2FpdCBfd3JpdGVPYmplY3Qoe1xuICAgICAgZnMsXG4gICAgICBnaXRkaXIsXG4gICAgICB0eXBlOiAnY29tbWl0JyxcbiAgICAgIG9iamVjdDogY29tbS50b09iamVjdCgpLFxuICAgICAgZHJ5UnVuLFxuICAgIH0pO1xuICAgIGlmICghbm9VcGRhdGVCcmFuY2ggJiYgIWRyeVJ1bikge1xuICAgICAgLy8gVXBkYXRlIGJyYW5jaCBwb2ludGVyXG4gICAgICBhd2FpdCBHaXRSZWZNYW5hZ2VyLndyaXRlUmVmKHtcbiAgICAgICAgZnMsXG4gICAgICAgIGdpdGRpcixcbiAgICAgICAgcmVmLFxuICAgICAgICB2YWx1ZTogb2lkLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvaWRcbiAgfSlcbn1cblxuYXN5bmMgZnVuY3Rpb24gY29uc3RydWN0VHJlZSh7IGZzLCBnaXRkaXIsIGlub2RlLCBkcnlSdW4gfSkge1xuICAvLyB1c2UgZGVwdGggZmlyc3QgdHJhdmVyc2FsXG4gIGNvbnN0IGNoaWxkcmVuID0gaW5vZGUuY2hpbGRyZW47XG4gIGZvciAoY29uc3QgaW5vZGUgb2YgY2hpbGRyZW4pIHtcbiAgICBpZiAoaW5vZGUudHlwZSA9PT0gJ3RyZWUnKSB7XG4gICAgICBpbm9kZS5tZXRhZGF0YS5tb2RlID0gJzA0MDAwMCc7XG4gICAgICBpbm9kZS5tZXRhZGF0YS5vaWQgPSBhd2FpdCBjb25zdHJ1Y3RUcmVlKHsgZnMsIGdpdGRpciwgaW5vZGUsIGRyeVJ1biB9KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZW50cmllcyA9IGNoaWxkcmVuLm1hcChpbm9kZSA9PiAoe1xuICAgIG1vZGU6IGlub2RlLm1ldGFkYXRhLm1vZGUsXG4gICAgcGF0aDogaW5vZGUuYmFzZW5hbWUsXG4gICAgb2lkOiBpbm9kZS5tZXRhZGF0YS5vaWQsXG4gICAgdHlwZTogaW5vZGUudHlwZSxcbiAgfSkpO1xuICBjb25zdCB0cmVlID0gR2l0VHJlZS5mcm9tKGVudHJpZXMpO1xuICBjb25zdCBvaWQgPSBhd2FpdCBfd3JpdGVPYmplY3Qoe1xuICAgIGZzLFxuICAgIGdpdGRpcixcbiAgICB0eXBlOiAndHJlZScsXG4gICAgb2JqZWN0OiB0cmVlLnRvT2JqZWN0KCksXG4gICAgZHJ5UnVuLFxuICB9KTtcbiAgcmV0dXJuIG9pZFxufVxuXG4vLyBAdHMtY2hlY2tcblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUZpbGVwYXRoKHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCwgZmlsZXBhdGggfSkge1xuICAvLyBFbnN1cmUgdGhlcmUgYXJlIG5vIGxlYWRpbmcgb3IgdHJhaWxpbmcgZGlyZWN0b3J5IHNlcGFyYXRvcnMuXG4gIC8vIEkgd2FzIGdvaW5nIHRvIGRvIHRoaXMgYXV0b21hdGljYWxseSwgYnV0IHRoZW4gZm91bmQgdGhhdCB0aGUgR2l0IFRlcm1pbmFsIGZvciBXaW5kb3dzXG4gIC8vIGF1dG8tZXhwYW5kcyAtLWZpbGVwYXRoPS9zcmMvdXRpbHMgdG8gLS1maWxlcGF0aD1DOi9Vc2Vycy9XaWxsL0FwcERhdGEvTG9jYWwvUHJvZ3JhbXMvR2l0L3NyYy91dGlsc1xuICAvLyBzbyBJIGZpZ3VyZWQgaXQgd291bGQgYmUgd2lzZSB0byBwcm9tb3RlIHRoZSBiZWhhdmlvciBpbiB0aGUgYXBwbGljYXRpb24gbGF5ZXIgbm90IGp1c3QgdGhlIGxpYnJhcnkgbGF5ZXIuXG4gIGlmIChmaWxlcGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEZpbGVwYXRoRXJyb3IoJ2xlYWRpbmctc2xhc2gnKVxuICB9IGVsc2UgaWYgKGZpbGVwYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEZpbGVwYXRoRXJyb3IoJ3RyYWlsaW5nLXNsYXNoJylcbiAgfVxuICBjb25zdCBfb2lkID0gb2lkO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvbHZlVHJlZSh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG4gIGNvbnN0IHRyZWUgPSByZXN1bHQudHJlZTtcbiAgaWYgKGZpbGVwYXRoID09PSAnJykge1xuICAgIG9pZCA9IHJlc3VsdC5vaWQ7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcGF0aEFycmF5ID0gZmlsZXBhdGguc3BsaXQoJy8nKTtcbiAgICBvaWQgPSBhd2FpdCBfcmVzb2x2ZUZpbGVwYXRoKHtcbiAgICAgIGZzLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICB0cmVlLFxuICAgICAgcGF0aEFycmF5LFxuICAgICAgb2lkOiBfb2lkLFxuICAgICAgZmlsZXBhdGgsXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG9pZFxufVxuXG5hc3luYyBmdW5jdGlvbiBfcmVzb2x2ZUZpbGVwYXRoKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBnaXRkaXIsXG4gIHRyZWUsXG4gIHBhdGhBcnJheSxcbiAgb2lkLFxuICBmaWxlcGF0aCxcbn0pIHtcbiAgY29uc3QgbmFtZSA9IHBhdGhBcnJheS5zaGlmdCgpO1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRyZWUpIHtcbiAgICBpZiAoZW50cnkucGF0aCA9PT0gbmFtZSkge1xuICAgICAgaWYgKHBhdGhBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5Lm9pZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCBvYmplY3QgfSA9IGF3YWl0IF9yZWFkT2JqZWN0KHtcbiAgICAgICAgICBmcyxcbiAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICBnaXRkaXIsXG4gICAgICAgICAgb2lkOiBlbnRyeS5vaWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZSAhPT0gJ3RyZWUnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFR5cGVFcnJvcihvaWQsIHR5cGUsICdibG9iJywgZmlsZXBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgdHJlZSA9IEdpdFRyZWUuZnJvbShvYmplY3QpO1xuICAgICAgICByZXR1cm4gX3Jlc29sdmVGaWxlcGF0aCh7XG4gICAgICAgICAgZnMsXG4gICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgZ2l0ZGlyLFxuICAgICAgICAgIHRyZWUsXG4gICAgICAgICAgcGF0aEFycmF5LFxuICAgICAgICAgIG9pZCxcbiAgICAgICAgICBmaWxlcGF0aCxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IoYGZpbGUgb3IgZGlyZWN0b3J5IGZvdW5kIGF0IFwiJHtvaWR9OiR7ZmlsZXBhdGh9XCJgKVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVhZFRyZWVSZXN1bHQgLSBUaGUgb2JqZWN0IHJldHVybmVkIGhhcyB0aGUgZm9sbG93aW5nIHNjaGVtYTpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWQgLSBTSEEtMSBvYmplY3QgaWQgb2YgdGhpcyB0cmVlXG4gKiBAcHJvcGVydHkge1RyZWVPYmplY3R9IHRyZWUgLSB0aGUgcGFyc2VkIHRyZWUgb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHthbnl9IGFyZ3MuY2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Mub2lkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZmlsZXBhdGhdXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8UmVhZFRyZWVSZXN1bHQ+fVxuICovXG5hc3luYyBmdW5jdGlvbiBfcmVhZFRyZWUoe1xuICBmcyxcbiAgY2FjaGUsXG4gIGdpdGRpcixcbiAgb2lkLFxuICBmaWxlcGF0aCA9IHVuZGVmaW5lZCxcbn0pIHtcbiAgaWYgKGZpbGVwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBvaWQgPSBhd2FpdCByZXNvbHZlRmlsZXBhdGgoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkLCBmaWxlcGF0aCB9KTtcbiAgfVxuICBjb25zdCB7IHRyZWUsIG9pZDogdHJlZU9pZCB9ID0gYXdhaXQgcmVzb2x2ZVRyZWUoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgb2lkOiB0cmVlT2lkLFxuICAgIHRyZWU6IHRyZWUuZW50cmllcygpLFxuICB9O1xuICByZXR1cm4gcmVzdWx0XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7VHJlZU9iamVjdH0gYXJncy50cmVlXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3dyaXRlVHJlZSh7IGZzLCBnaXRkaXIsIHRyZWUgfSkge1xuICAvLyBDb252ZXJ0IG9iamVjdCB0byBidWZmZXJcbiAgY29uc3Qgb2JqZWN0ID0gR2l0VHJlZS5mcm9tKHRyZWUpLnRvT2JqZWN0KCk7XG4gIGNvbnN0IG9pZCA9IGF3YWl0IF93cml0ZU9iamVjdCh7XG4gICAgZnMsXG4gICAgZ2l0ZGlyLFxuICAgIHR5cGU6ICd0cmVlJyxcbiAgICBvYmplY3QsXG4gICAgZm9ybWF0OiAnY29udGVudCcsXG4gIH0pO1xuICByZXR1cm4gb2lkXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge29iamVjdH0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtTaWduQ2FsbGJhY2t9IFthcmdzLm9uU2lnbl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVmXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5vaWRcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IGFyZ3Mubm90ZVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JjZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLmF1dGhvclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuYXV0aG9yLm5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmF1dGhvci5lbWFpbFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuYXV0aG9yLnRpbWVzdGFtcFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuYXV0aG9yLnRpbWV6b25lT2Zmc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gYXJncy5jb21taXR0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmNvbW1pdHRlci5uYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5jb21taXR0ZXIuZW1haWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmNvbW1pdHRlci50aW1lc3RhbXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmNvbW1pdHRlci50aW1lem9uZU9mZnNldFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnNpZ25pbmdLZXldXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBfYWRkTm90ZSh7XG4gIGZzLFxuICBjYWNoZSxcbiAgb25TaWduLFxuICBnaXRkaXIsXG4gIHJlZixcbiAgb2lkLFxuICBub3RlLFxuICBmb3JjZSxcbiAgYXV0aG9yLFxuICBjb21taXR0ZXIsXG4gIHNpZ25pbmdLZXksXG59KSB7XG4gIC8vIEdldCB0aGUgY3VycmVudCBub3RlIGNvbW1pdFxuICBsZXQgcGFyZW50O1xuICB0cnkge1xuICAgIHBhcmVudCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGdpdGRpciwgZnMsIHJlZiB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvcikpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIC8vIEknbSB1c2luZyB0aGUgXCJlbXB0eSB0cmVlXCIgbWFnaWMgbnVtYmVyIGhlcmUgZm9yIGJyZXZpdHlcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX3JlYWRUcmVlKHtcbiAgICBmcyxcbiAgICBjYWNoZSxcbiAgICBnaXRkaXIsXG4gICAgb2lkOiBwYXJlbnQgfHwgJzRiODI1ZGM2NDJjYjZlYjlhMDYwZTU0YmY4ZDY5Mjg4ZmJlZTQ5MDQnLFxuICB9KTtcbiAgbGV0IHRyZWUgPSByZXN1bHQudHJlZTtcblxuICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYSBub3RlIGFscmVhZHkgZXhpc3RzXG4gIGlmIChmb3JjZSkge1xuICAgIHRyZWUgPSB0cmVlLmZpbHRlcihlbnRyeSA9PiBlbnRyeS5wYXRoICE9PSBvaWQpO1xuICB9IGVsc2Uge1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdHJlZSkge1xuICAgICAgaWYgKGVudHJ5LnBhdGggPT09IG9pZCkge1xuICAgICAgICB0aHJvdyBuZXcgQWxyZWFkeUV4aXN0c0Vycm9yKCdub3RlJywgb2lkKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSB0aGUgbm90ZSBibG9iXG4gIGlmICh0eXBlb2Ygbm90ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBub3RlID0gQnVmZmVyLmZyb20obm90ZSwgJ3V0ZjgnKTtcbiAgfVxuICBjb25zdCBub3RlT2lkID0gYXdhaXQgX3dyaXRlT2JqZWN0KHtcbiAgICBmcyxcbiAgICBnaXRkaXIsXG4gICAgdHlwZTogJ2Jsb2InLFxuICAgIG9iamVjdDogbm90ZSxcbiAgICBmb3JtYXQ6ICdjb250ZW50JyxcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBuZXcgbm90ZSB0cmVlXG4gIHRyZWUucHVzaCh7IG1vZGU6ICcxMDA2NDQnLCBwYXRoOiBvaWQsIG9pZDogbm90ZU9pZCwgdHlwZTogJ2Jsb2InIH0pO1xuICBjb25zdCB0cmVlT2lkID0gYXdhaXQgX3dyaXRlVHJlZSh7XG4gICAgZnMsXG4gICAgZ2l0ZGlyLFxuICAgIHRyZWUsXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgbmV3IG5vdGUgY29tbWl0XG4gIGNvbnN0IGNvbW1pdE9pZCA9IGF3YWl0IF9jb21taXQoe1xuICAgIGZzLFxuICAgIGNhY2hlLFxuICAgIG9uU2lnbixcbiAgICBnaXRkaXIsXG4gICAgcmVmLFxuICAgIHRyZWU6IHRyZWVPaWQsXG4gICAgcGFyZW50OiBwYXJlbnQgJiYgW3BhcmVudF0sXG4gICAgbWVzc2FnZTogYE5vdGUgYWRkZWQgYnkgJ2lzb21vcnBoaWMtZ2l0IGFkZE5vdGUnXFxuYCxcbiAgICBhdXRob3IsXG4gICAgY29tbWl0dGVyLFxuICAgIHNpZ25pbmdLZXksXG4gIH0pO1xuXG4gIHJldHVybiBjb21taXRPaWRcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucGF0aFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IFJlc29sdmVzIHdpdGggdGhlIGNvbmZpZyB2YWx1ZVxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBSZWFkIGNvbmZpZyB2YWx1ZVxuICogbGV0IHZhbHVlID0gYXdhaXQgZ2l0LmdldENvbmZpZyh7XG4gKiAgIGRpcjogJyRpbnB1dCgoLykpJyxcbiAqICAgcGF0aDogJyRpbnB1dCgodXNlci5uYW1lKSknXG4gKiB9KVxuICogY29uc29sZS5sb2codmFsdWUpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBfZ2V0Q29uZmlnKHsgZnMsIGdpdGRpciwgcGF0aCB9KSB7XG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuZ2V0KHsgZnMsIGdpdGRpciB9KTtcbiAgcmV0dXJuIGNvbmZpZy5nZXQocGF0aClcbn1cblxuLyoqXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZCB8IHtuYW1lOiBzdHJpbmcsIGVtYWlsOiBzdHJpbmcsIGRhdGU6IERhdGUsIHRpbWVzdGFtcDogbnVtYmVyLCB0aW1lem9uZU9mZnNldDogbnVtYmVyIH0+fVxuICovXG5hc3luYyBmdW5jdGlvbiBub3JtYWxpemVBdXRob3JPYmplY3QoeyBmcywgZ2l0ZGlyLCBhdXRob3IgPSB7fSB9KSB7XG4gIGxldCB7IG5hbWUsIGVtYWlsLCB0aW1lc3RhbXAsIHRpbWV6b25lT2Zmc2V0IH0gPSBhdXRob3I7XG4gIG5hbWUgPSBuYW1lIHx8IChhd2FpdCBfZ2V0Q29uZmlnKHsgZnMsIGdpdGRpciwgcGF0aDogJ3VzZXIubmFtZScgfSkpO1xuICBlbWFpbCA9IGVtYWlsIHx8IChhd2FpdCBfZ2V0Q29uZmlnKHsgZnMsIGdpdGRpciwgcGF0aDogJ3VzZXIuZW1haWwnIH0pKSB8fCAnJztcblxuICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgdGltZXN0YW1wID0gdGltZXN0YW1wICE9IG51bGwgPyB0aW1lc3RhbXAgOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgdGltZXpvbmVPZmZzZXQgPVxuICAgIHRpbWV6b25lT2Zmc2V0ICE9IG51bGxcbiAgICAgID8gdGltZXpvbmVPZmZzZXRcbiAgICAgIDogbmV3IERhdGUodGltZXN0YW1wICogMTAwMCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblxuICByZXR1cm4geyBuYW1lLCBlbWFpbCwgdGltZXN0YW1wLCB0aW1lem9uZU9mZnNldCB9XG59XG5cbi8qKlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQgfCB7bmFtZTogc3RyaW5nLCBlbWFpbDogc3RyaW5nLCB0aW1lc3RhbXA6IG51bWJlciwgdGltZXpvbmVPZmZzZXQ6IG51bWJlciB9Pn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbm9ybWFsaXplQ29tbWl0dGVyT2JqZWN0KHtcbiAgZnMsXG4gIGdpdGRpcixcbiAgYXV0aG9yLFxuICBjb21taXR0ZXIsXG59KSB7XG4gIGNvbW1pdHRlciA9IE9iamVjdC5hc3NpZ24oe30sIGNvbW1pdHRlciB8fCBhdXRob3IpO1xuICAvLyBNYXRjaCBjb21taXR0ZXIncyBkYXRlIHRvIGF1dGhvcidzIG9uZSwgaWYgb21pdHRlZFxuICBpZiAoYXV0aG9yKSB7XG4gICAgY29tbWl0dGVyLnRpbWVzdGFtcCA9IGNvbW1pdHRlci50aW1lc3RhbXAgfHwgYXV0aG9yLnRpbWVzdGFtcDtcbiAgICBjb21taXR0ZXIudGltZXpvbmVPZmZzZXQgPSBjb21taXR0ZXIudGltZXpvbmVPZmZzZXQgfHwgYXV0aG9yLnRpbWV6b25lT2Zmc2V0O1xuICB9XG4gIGNvbW1pdHRlciA9IGF3YWl0IG5vcm1hbGl6ZUF1dGhvck9iamVjdCh7IGZzLCBnaXRkaXIsIGF1dGhvcjogY29tbWl0dGVyIH0pO1xuICByZXR1cm4gY29tbWl0dGVyXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEFkZCBvciB1cGRhdGUgYW4gb2JqZWN0IG5vdGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7U2lnbkNhbGxiYWNrfSBbYXJncy5vblNpZ25dIC0gYSBQR1Agc2lnbmluZyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZl0gLSBUaGUgbm90ZXMgcmVmIHRvIGxvb2sgdW5kZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9pZCAtIFRoZSBTSEEtMSBvYmplY3QgaWQgb2YgdGhlIG9iamVjdCB0byBhZGQgdGhlIG5vdGUgdG8uXG4gKiBAcGFyYW0ge3N0cmluZ3xVaW50OEFycmF5fSBhcmdzLm5vdGUgLSBUaGUgbm90ZSB0byBhZGRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZm9yY2VdIC0gT3Zlci13cml0ZSBub3RlIGlmIGl0IGFscmVhZHkgZXhpc3RzLlxuICogQHBhcmFtIHtPYmplY3R9IFthcmdzLmF1dGhvcl0gLSBUaGUgZGV0YWlscyBhYm91dCB0aGUgYXV0aG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmF1dGhvci5uYW1lXSAtIERlZmF1bHQgaXMgYHVzZXIubmFtZWAgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmF1dGhvci5lbWFpbF0gLSBEZWZhdWx0IGlzIGB1c2VyLmVtYWlsYCBjb25maWcuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuYXV0aG9yLnRpbWVzdGFtcD1NYXRoLmZsb29yKERhdGUubm93KCkvMTAwMCldIC0gU2V0IHRoZSBhdXRob3IgdGltZXN0YW1wIGZpZWxkLiBUaGlzIGlzIHRoZSBpbnRlZ2VyIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBVbml4IGVwb2NoICgxOTcwLTAxLTAxIDAwOjAwOjAwKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5hdXRob3IudGltZXpvbmVPZmZzZXRdIC0gU2V0IHRoZSBhdXRob3IgdGltZXpvbmUgb2Zmc2V0IGZpZWxkLiBUaGlzIGlzIHRoZSBkaWZmZXJlbmNlLCBpbiBtaW51dGVzLCBmcm9tIHRoZSBjdXJyZW50IHRpbWV6b25lIHRvIFVUQy4gRGVmYXVsdCBpcyBgKG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KClgLlxuICogQHBhcmFtIHtPYmplY3R9IFthcmdzLmNvbW1pdHRlciA9IGF1dGhvcl0gLSBUaGUgZGV0YWlscyBhYm91dCB0aGUgbm90ZSBjb21taXR0ZXIsIGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgYXV0aG9yIHBhcmFtZXRlci4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGF1dGhvciBkZXRhaWxzIGFyZSB1c2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvbW1pdHRlci5uYW1lXSAtIERlZmF1bHQgaXMgYHVzZXIubmFtZWAgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvbW1pdHRlci5lbWFpbF0gLSBEZWZhdWx0IGlzIGB1c2VyLmVtYWlsYCBjb25maWcuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuY29tbWl0dGVyLnRpbWVzdGFtcD1NYXRoLmZsb29yKERhdGUubm93KCkvMTAwMCldIC0gU2V0IHRoZSBjb21taXR0ZXIgdGltZXN0YW1wIGZpZWxkLiBUaGlzIGlzIHRoZSBpbnRlZ2VyIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBVbml4IGVwb2NoICgxOTcwLTAxLTAxIDAwOjAwOjAwKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5jb21taXR0ZXIudGltZXpvbmVPZmZzZXRdIC0gU2V0IHRoZSBjb21taXR0ZXIgdGltZXpvbmUgb2Zmc2V0IGZpZWxkLiBUaGlzIGlzIHRoZSBkaWZmZXJlbmNlLCBpbiBtaW51dGVzLCBmcm9tIHRoZSBjdXJyZW50IHRpbWV6b25lIHRvIFVUQy4gRGVmYXVsdCBpcyBgKG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KClgLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnNpZ25pbmdLZXldIC0gU2lnbiB0aGUgbm90ZSBjb21taXQgdXNpbmcgdGhpcyBwcml2YXRlIFBHUCBrZXkuXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCB0aGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSBjb21taXQgb2JqZWN0IGZvciB0aGUgYWRkZWQgbm90ZS5cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBhZGROb3RlKHtcbiAgZnM6IF9mcyxcbiAgb25TaWduLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICByZWYgPSAncmVmcy9ub3Rlcy9jb21taXRzJyxcbiAgb2lkLFxuICBub3RlLFxuICBmb3JjZSxcbiAgYXV0aG9yOiBfYXV0aG9yLFxuICBjb21taXR0ZXI6IF9jb21taXR0ZXIsXG4gIHNpZ25pbmdLZXksXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIF9mcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignb2lkJywgb2lkKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ25vdGUnLCBub3RlKTtcbiAgICBpZiAoc2lnbmluZ0tleSkge1xuICAgICAgYXNzZXJ0UGFyYW1ldGVyKCdvblNpZ24nLCBvblNpZ24pO1xuICAgIH1cbiAgICBjb25zdCBmcyA9IG5ldyBGaWxlU3lzdGVtKF9mcyk7XG5cbiAgICBjb25zdCBhdXRob3IgPSBhd2FpdCBub3JtYWxpemVBdXRob3JPYmplY3QoeyBmcywgZ2l0ZGlyLCBhdXRob3I6IF9hdXRob3IgfSk7XG4gICAgaWYgKCFhdXRob3IpIHRocm93IG5ldyBNaXNzaW5nTmFtZUVycm9yKCdhdXRob3InKVxuXG4gICAgY29uc3QgY29tbWl0dGVyID0gYXdhaXQgbm9ybWFsaXplQ29tbWl0dGVyT2JqZWN0KHtcbiAgICAgIGZzLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgYXV0aG9yLFxuICAgICAgY29tbWl0dGVyOiBfY29tbWl0dGVyLFxuICAgIH0pO1xuICAgIGlmICghY29tbWl0dGVyKSB0aHJvdyBuZXcgTWlzc2luZ05hbWVFcnJvcignY29tbWl0dGVyJylcblxuICAgIHJldHVybiBhd2FpdCBfYWRkTm90ZSh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBvblNpZ24sXG4gICAgICBnaXRkaXIsXG4gICAgICByZWYsXG4gICAgICBvaWQsXG4gICAgICBub3RlLFxuICAgICAgZm9yY2UsXG4gICAgICBhdXRob3IsXG4gICAgICBjb21taXR0ZXIsXG4gICAgICBzaWduaW5nS2V5LFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmFkZE5vdGUnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlbW90ZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MudXJsXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFyZ3MuZm9yY2VcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9hZGRSZW1vdGUoeyBmcywgZ2l0ZGlyLCByZW1vdGUsIHVybCwgZm9yY2UgfSkge1xuICBpZiAocmVtb3RlICE9PSBjbGVhbkdpdFJlZi5jbGVhbihyZW1vdGUpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRSZWZOYW1lRXJyb3IocmVtb3RlLCBjbGVhbkdpdFJlZi5jbGVhbihyZW1vdGUpKVxuICB9XG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuZ2V0KHsgZnMsIGdpdGRpciB9KTtcbiAgaWYgKCFmb3JjZSkge1xuICAgIC8vIENoZWNrIHRoYXQgc2V0dGluZyBpdCB3b3VsZG4ndCBvdmVyd3JpdGUuXG4gICAgY29uc3QgcmVtb3RlTmFtZXMgPSBhd2FpdCBjb25maWcuZ2V0U3Vic2VjdGlvbnMoJ3JlbW90ZScpO1xuICAgIGlmIChyZW1vdGVOYW1lcy5pbmNsdWRlcyhyZW1vdGUpKSB7XG4gICAgICAvLyBUaHJvdyBhbiBlcnJvciBpZiBpdCB3b3VsZCBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgcmVtb3RlLFxuICAgICAgLy8gYnV0IG5vdCBpZiBpdCdzIHNpbXBseSBzZXR0aW5nIHRoZSBzYW1lIHZhbHVlIGFnYWluLlxuICAgICAgaWYgKHVybCAhPT0gKGF3YWl0IGNvbmZpZy5nZXQoYHJlbW90ZS4ke3JlbW90ZX0udXJsYCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBBbHJlYWR5RXhpc3RzRXJyb3IoJ3JlbW90ZScsIHJlbW90ZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYXdhaXQgY29uZmlnLnNldChgcmVtb3RlLiR7cmVtb3RlfS51cmxgLCB1cmwpO1xuICBhd2FpdCBjb25maWcuc2V0KFxuICAgIGByZW1vdGUuJHtyZW1vdGV9LmZldGNoYCxcbiAgICBgK3JlZnMvaGVhZHMvKjpyZWZzL3JlbW90ZXMvJHtyZW1vdGV9LypgXG4gICk7XG4gIGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuc2F2ZSh7IGZzLCBnaXRkaXIsIGNvbmZpZyB9KTtcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQWRkIG9yIHVwZGF0ZSBhIHJlbW90ZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXJdIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlbW90ZSAtIFRoZSBuYW1lIG9mIHRoZSByZW1vdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnVybCAtIFRoZSBVUkwgb2YgdGhlIHJlbW90ZVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JjZSA9IGZhbHNlXSAtIEluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3IgaWYgYSByZW1vdGUgbmFtZWQgYHJlbW90ZWAgYWxyZWFkeSBleGlzdHMsIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgcmVtb3RlLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC5hZGRSZW1vdGUoe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgcmVtb3RlOiAndXBzdHJlYW0nLFxuICogICB1cmw6ICdodHRwczovL2dpdGh1Yi5jb20vaXNvbW9ycGhpYy1naXQvaXNvbW9ycGhpYy1naXQnXG4gKiB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYWRkUmVtb3RlKHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlbW90ZSxcbiAgdXJsLFxuICBmb3JjZSA9IGZhbHNlLFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcigncmVtb3RlJywgcmVtb3RlKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3VybCcsIHVybCk7XG4gICAgcmV0dXJuIGF3YWl0IF9hZGRSZW1vdGUoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlbW90ZSxcbiAgICAgIHVybCxcbiAgICAgIGZvcmNlLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmFkZFJlbW90ZSc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQ3JlYXRlIGFuIGFubm90YXRlZCB0YWcuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge1NpZ25DYWxsYmFja30gW2FyZ3Mub25TaWduXVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWZcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5tZXNzYWdlID0gcmVmXVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLm9iamVjdCA9ICdIRUFEJ11cbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy50YWdnZXJdXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy50YWdnZXIubmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MudGFnZ2VyLmVtYWlsXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy50YWdnZXIudGltZXN0YW1wXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy50YWdnZXIudGltZXpvbmVPZmZzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5ncGdzaWddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3Muc2lnbmluZ0tleV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZm9yY2UgPSBmYWxzZV1cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gZmlsZXN5c3RlbSBvcGVyYXRpb25zIGFyZSBjb21wbGV0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBnaXQuYW5ub3RhdGVkVGFnKHtcbiAqICAgZGlyOiAnJGlucHV0KCgvKSknLFxuICogICByZWY6ICckaW5wdXQoKHRlc3QtdGFnKSknLFxuICogICBtZXNzYWdlOiAnJGlucHV0KChUaGlzIGNvbW1pdCBpcyBhd2Vzb21lKSknLFxuICogICB0YWdnZXI6IHtcbiAqICAgICBuYW1lOiAnJGlucHV0KChNci4gVGVzdCkpJyxcbiAqICAgICBlbWFpbDogJyRpbnB1dCgobXJ0ZXN0QGV4YW1wbGUuY29tKSknXG4gKiAgIH1cbiAqIH0pXG4gKiBjb25zb2xlLmxvZygnZG9uZScpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBfYW5ub3RhdGVkVGFnKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBvblNpZ24sXG4gIGdpdGRpcixcbiAgcmVmLFxuICB0YWdnZXIsXG4gIG1lc3NhZ2UgPSByZWYsXG4gIGdwZ3NpZyxcbiAgb2JqZWN0LFxuICBzaWduaW5nS2V5LFxuICBmb3JjZSA9IGZhbHNlLFxufSkge1xuICByZWYgPSByZWYuc3RhcnRzV2l0aCgncmVmcy90YWdzLycpID8gcmVmIDogYHJlZnMvdGFncy8ke3JlZn1gO1xuXG4gIGlmICghZm9yY2UgJiYgKGF3YWl0IEdpdFJlZk1hbmFnZXIuZXhpc3RzKHsgZnMsIGdpdGRpciwgcmVmIH0pKSkge1xuICAgIHRocm93IG5ldyBBbHJlYWR5RXhpc3RzRXJyb3IoJ3RhZycsIHJlZilcbiAgfVxuXG4gIC8vIFJlc29sdmUgcGFzc2VkIHZhbHVlXG4gIGNvbnN0IG9pZCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7XG4gICAgZnMsXG4gICAgZ2l0ZGlyLFxuICAgIHJlZjogb2JqZWN0IHx8ICdIRUFEJyxcbiAgfSk7XG5cbiAgY29uc3QgeyB0eXBlIH0gPSBhd2FpdCBfcmVhZE9iamVjdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG4gIGxldCB0YWdPYmplY3QgPSBHaXRBbm5vdGF0ZWRUYWcuZnJvbSh7XG4gICAgb2JqZWN0OiBvaWQsXG4gICAgdHlwZSxcbiAgICB0YWc6IHJlZi5yZXBsYWNlKCdyZWZzL3RhZ3MvJywgJycpLFxuICAgIHRhZ2dlcixcbiAgICBtZXNzYWdlLFxuICAgIGdwZ3NpZyxcbiAgfSk7XG4gIGlmIChzaWduaW5nS2V5KSB7XG4gICAgdGFnT2JqZWN0ID0gYXdhaXQgR2l0QW5ub3RhdGVkVGFnLnNpZ24odGFnT2JqZWN0LCBvblNpZ24sIHNpZ25pbmdLZXkpO1xuICB9XG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgX3dyaXRlT2JqZWN0KHtcbiAgICBmcyxcbiAgICBnaXRkaXIsXG4gICAgdHlwZTogJ3RhZycsXG4gICAgb2JqZWN0OiB0YWdPYmplY3QudG9PYmplY3QoKSxcbiAgfSk7XG5cbiAgYXdhaXQgR2l0UmVmTWFuYWdlci53cml0ZVJlZih7IGZzLCBnaXRkaXIsIHJlZiwgdmFsdWUgfSk7XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIENyZWF0ZSBhbiBhbm5vdGF0ZWQgdGFnLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtTaWduQ2FsbGJhY2t9IFthcmdzLm9uU2lnbl0gLSBhIFBHUCBzaWduaW5nIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWYgLSBXaGF0IHRvIG5hbWUgdGhlIHRhZ1xuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLm1lc3NhZ2UgPSByZWZdIC0gVGhlIHRhZyBtZXNzYWdlIHRvIHVzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5vYmplY3QgPSAnSEVBRCddIC0gVGhlIFNIQS0xIG9iamVjdCBpZCB0aGUgdGFnIHBvaW50cyB0by4gKFdpbGwgcmVzb2x2ZSB0byBhIFNIQS0xIG9iamVjdCBpZCBpZiB2YWx1ZSBpcyBhIHJlZi4pIEJ5IGRlZmF1bHQsIHRoZSBjb21taXQgb2JqZWN0IHdoaWNoIGlzIHJlZmVycmVkIGJ5IHRoZSBjdXJyZW50IGBIRUFEYCBpcyB1c2VkLlxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLnRhZ2dlcl0gLSBUaGUgZGV0YWlscyBhYm91dCB0aGUgdGFnZ2VyLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnRhZ2dlci5uYW1lXSAtIERlZmF1bHQgaXMgYHVzZXIubmFtZWAgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnRhZ2dlci5lbWFpbF0gLSBEZWZhdWx0IGlzIGB1c2VyLmVtYWlsYCBjb25maWcuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MudGFnZ2VyLnRpbWVzdGFtcD1NYXRoLmZsb29yKERhdGUubm93KCkvMTAwMCldIC0gU2V0IHRoZSB0YWdnZXIgdGltZXN0YW1wIGZpZWxkLiBUaGlzIGlzIHRoZSBpbnRlZ2VyIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBVbml4IGVwb2NoICgxOTcwLTAxLTAxIDAwOjAwOjAwKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy50YWdnZXIudGltZXpvbmVPZmZzZXRdIC0gU2V0IHRoZSB0YWdnZXIgdGltZXpvbmUgb2Zmc2V0IGZpZWxkLiBUaGlzIGlzIHRoZSBkaWZmZXJlbmNlLCBpbiBtaW51dGVzLCBmcm9tIHRoZSBjdXJyZW50IHRpbWV6b25lIHRvIFVUQy4gRGVmYXVsdCBpcyBgKG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KClgLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdwZ3NpZ10gLSBUaGUgZ3Bnc2lnIGF0dGF0Y2hlZCB0byB0aGUgdGFnIG9iamVjdC4gKE11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIHRoZSBgc2lnbmluZ0tleWAgb3B0aW9uLilcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5zaWduaW5nS2V5XSAtIFNpZ24gdGhlIHRhZyBvYmplY3QgdXNpbmcgdGhpcyBwcml2YXRlIFBHUCBrZXkuIChNdXR1YWxseSBleGNsdXNpdmUgd2l0aCB0aGUgYGdwZ3NpZ2Agb3B0aW9uLilcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZm9yY2UgPSBmYWxzZV0gLSBJbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yIGlmIGEgdGFnIG5hbWVkIGByZWZgIGFscmVhZHkgZXhpc3RzLCBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIHRhZy4gTm90ZSB0aGF0IHRoaXMgb3B0aW9uIGRvZXMgbm90IG1vZGlmeSB0aGUgb3JpZ2luYWwgdGFnIG9iamVjdCBpdHNlbGYuXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gZmlsZXN5c3RlbSBvcGVyYXRpb25zIGFyZSBjb21wbGV0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBnaXQuYW5ub3RhdGVkVGFnKHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIHJlZjogJ3Rlc3QtdGFnJyxcbiAqICAgbWVzc2FnZTogJ1RoaXMgY29tbWl0IGlzIGF3ZXNvbWUnLFxuICogICB0YWdnZXI6IHtcbiAqICAgICBuYW1lOiAnTXIuIFRlc3QnLFxuICogICAgIGVtYWlsOiAnbXJ0ZXN0QGV4YW1wbGUuY29tJ1xuICogICB9XG4gKiB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gYW5ub3RhdGVkVGFnKHtcbiAgZnM6IF9mcyxcbiAgb25TaWduLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICByZWYsXG4gIHRhZ2dlcjogX3RhZ2dlcixcbiAgbWVzc2FnZSA9IHJlZixcbiAgZ3Bnc2lnLFxuICBvYmplY3QsXG4gIHNpZ25pbmdLZXksXG4gIGZvcmNlID0gZmFsc2UsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIF9mcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcigncmVmJywgcmVmKTtcbiAgICBpZiAoc2lnbmluZ0tleSkge1xuICAgICAgYXNzZXJ0UGFyYW1ldGVyKCdvblNpZ24nLCBvblNpZ24pO1xuICAgIH1cbiAgICBjb25zdCBmcyA9IG5ldyBGaWxlU3lzdGVtKF9mcyk7XG5cbiAgICAvLyBGaWxsIGluIG1pc3NpbmcgYXJndW1lbnRzIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAgICBjb25zdCB0YWdnZXIgPSBhd2FpdCBub3JtYWxpemVBdXRob3JPYmplY3QoeyBmcywgZ2l0ZGlyLCBhdXRob3I6IF90YWdnZXIgfSk7XG4gICAgaWYgKCF0YWdnZXIpIHRocm93IG5ldyBNaXNzaW5nTmFtZUVycm9yKCd0YWdnZXInKVxuXG4gICAgcmV0dXJuIGF3YWl0IF9hbm5vdGF0ZWRUYWcoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIG9uU2lnbixcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZixcbiAgICAgIHRhZ2dlcixcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBncGdzaWcsXG4gICAgICBvYmplY3QsXG4gICAgICBzaWduaW5nS2V5LFxuICAgICAgZm9yY2UsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuYW5ub3RhdGVkVGFnJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBDcmVhdGUgYSBicmFuY2hcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWZcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuY2hlY2tvdXQgPSBmYWxzZV1cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gZmlsZXN5c3RlbSBvcGVyYXRpb25zIGFyZSBjb21wbGV0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBnaXQuYnJhbmNoKHsgZGlyOiAnJGlucHV0KCgvKSknLCByZWY6ICckaW5wdXQoKGRldmVsb3ApKScgfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9icmFuY2goeyBmcywgZ2l0ZGlyLCByZWYsIGNoZWNrb3V0ID0gZmFsc2UgfSkge1xuICBpZiAocmVmICE9PSBjbGVhbkdpdFJlZi5jbGVhbihyZWYpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRSZWZOYW1lRXJyb3IocmVmLCBjbGVhbkdpdFJlZi5jbGVhbihyZWYpKVxuICB9XG5cbiAgY29uc3QgZnVsbHJlZiA9IGByZWZzL2hlYWRzLyR7cmVmfWA7XG5cbiAgY29uc3QgZXhpc3QgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLmV4aXN0cyh7IGZzLCBnaXRkaXIsIHJlZjogZnVsbHJlZiB9KTtcbiAgaWYgKGV4aXN0KSB7XG4gICAgdGhyb3cgbmV3IEFscmVhZHlFeGlzdHNFcnJvcignYnJhbmNoJywgcmVmLCBmYWxzZSlcbiAgfVxuXG4gIC8vIEdldCBjdXJyZW50IEhFQUQgdHJlZSBvaWRcbiAgbGV0IG9pZDtcbiAgdHJ5IHtcbiAgICBvaWQgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoeyBmcywgZ2l0ZGlyLCByZWY6ICdIRUFEJyB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFByb2JhYmx5IGFuIGVtcHR5IHJlcG9cbiAgfVxuXG4gIC8vIENyZWF0ZSBhIG5ldyByZWYgdGhhdCBwb2ludHMgYXQgdGhlIGN1cnJlbnQgY29tbWl0XG4gIGlmIChvaWQpIHtcbiAgICBhd2FpdCBHaXRSZWZNYW5hZ2VyLndyaXRlUmVmKHsgZnMsIGdpdGRpciwgcmVmOiBmdWxscmVmLCB2YWx1ZTogb2lkIH0pO1xuICB9XG5cbiAgaWYgKGNoZWNrb3V0KSB7XG4gICAgLy8gVXBkYXRlIEhFQURcbiAgICBhd2FpdCBHaXRSZWZNYW5hZ2VyLndyaXRlU3ltYm9saWNSZWYoe1xuICAgICAgZnMsXG4gICAgICBnaXRkaXIsXG4gICAgICByZWY6ICdIRUFEJyxcbiAgICAgIHZhbHVlOiBmdWxscmVmLFxuICAgIH0pO1xuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIENyZWF0ZSBhIGJyYW5jaFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVmIC0gV2hhdCB0byBuYW1lIHRoZSBicmFuY2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuY2hlY2tvdXQgPSBmYWxzZV0gLSBVcGRhdGUgYEhFQURgIHRvIHBvaW50IGF0IHRoZSBuZXdseSBjcmVhdGVkIGJyYW5jaFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC5icmFuY2goeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgcmVmOiAnZGV2ZWxvcCcgfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGJyYW5jaCh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICByZWYsXG4gIGNoZWNrb3V0ID0gZmFsc2UsXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdyZWYnLCByZWYpO1xuICAgIHJldHVybiBhd2FpdCBfYnJhbmNoKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBnaXRkaXIsXG4gICAgICByZWYsXG4gICAgICBjaGVja291dCxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5icmFuY2gnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIGh0dHBzOi8vZGV2LnRvL25hbWlyc2FiL2NvbW1lbnQvMjA1MFxuZnVuY3Rpb24gYXJyYXlSYW5nZShzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGVuZCAtIHN0YXJ0O1xuICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aCB9LCAoXywgaSkgPT4gc3RhcnQgKyBpKVxufVxuXG4vLyBUT0RPOiBTaG91bGQgSSBqdXN0IHBvbHlmaWxsIEFycmF5LmZsYXQ/XG5jb25zdCBmbGF0ID1cbiAgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5mbGF0ID09PSAndW5kZWZpbmVkJ1xuICAgID8gZW50cmllcyA9PiBlbnRyaWVzLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MuY29uY2F0KHgpLCBbXSlcbiAgICA6IGVudHJpZXMgPT4gZW50cmllcy5mbGF0KCk7XG5cbi8vIFRoaXMgaXMgY29udmVuaWVudCBmb3IgY29tcHV0aW5nIHVuaW9ucy9qb2lucyBvZiBzb3J0ZWQgbGlzdHMuXG5jbGFzcyBSdW5uaW5nTWluaW11bSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIFVzaW5nIGEgZ2V0dGVyIGZvciAndmFsdWUnIHdvdWxkIGp1c3QgYmxvYXQgdGhlIGNvZGUuXG4gICAgLy8gWW91IGtub3cgYmV0dGVyIHRoYW4gdG8gc2V0IGl0IGRpcmVjdGx5IHJpZ2h0P1xuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICB9XG5cbiAgY29uc2lkZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gICAgaWYgKHRoaXMudmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIDwgdGhpcy52YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICB9XG59XG5cbi8vIFRha2UgYW4gYXJyYXkgb2YgbGVuZ3RoIE4gb2Zcbi8vICAgaXRlcmF0b3JzIG9mIGxlbmd0aCBRX25cbi8vICAgICBvZiBzdHJpbmdzXG4vLyBhbmQgcmV0dXJuIGFuIGl0ZXJhdG9yIG9mIGxlbmd0aCBtYXgoUV9uKSBmb3IgYWxsIG5cbi8vICAgb2YgYXJyYXlzIG9mIGxlbmd0aCBOXG4vLyAgICAgb2Ygc3RyaW5nfG51bGwgd2hvIGFsbCBoYXZlIHRoZSBzYW1lIHN0cmluZyB2YWx1ZVxuZnVuY3Rpb24qIHVuaW9uT2ZJdGVyYXRvcnMoc2V0cykge1xuICAvKiBOT1RFOiBXZSBjYW4gYXNzdW1lIGFsbCBhcnJheXMgYXJlIHNvcnRlZC5cbiAgICogSW5kZXhlcyBhcmUgc29ydGVkIGJlY2F1c2UgdGhleSBhcmUgZGVmaW5lZCB0aGF0IHdheTpcbiAgICpcbiAgICogPiBJbmRleCBlbnRyaWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyIG9uIHRoZSBuYW1lIGZpZWxkLFxuICAgKiA+IGludGVycHJldGVkIGFzIGEgc3RyaW5nIG9mIHVuc2lnbmVkIGJ5dGVzIChpLmUuIG1lbWNtcCgpIG9yZGVyLCBub1xuICAgKiA+IGxvY2FsaXphdGlvbiwgbm8gc3BlY2lhbCBjYXNpbmcgb2YgZGlyZWN0b3J5IHNlcGFyYXRvciAnLycpLiBFbnRyaWVzXG4gICAqID4gd2l0aCB0aGUgc2FtZSBuYW1lIGFyZSBzb3J0ZWQgYnkgdGhlaXIgc3RhZ2UgZmllbGQuXG4gICAqXG4gICAqIFRyZWVzIHNob3VsZCBiZSBzb3J0ZWQgYmVjYXVzZSB0aGV5IGFyZSBjcmVhdGVkIGRpcmVjdGx5IGZyb20gaW5kZXhlcy5cbiAgICogVGhleSBkZWZpbml0ZWx5IHNob3VsZCBiZSBzb3J0ZWQsIG9yIGVsc2UgdGhleSB3b3VsZG4ndCBoYXZlIGEgdW5pcXVlIFNIQTEuXG4gICAqIFNvIHRoYXQgd291bGQgYmUgdmVyeSBuYXVnaHR5IG9uIHRoZSBwYXJ0IG9mIHRoZSB0cmVlLWNyZWF0b3IuXG4gICAqXG4gICAqIExhc3RseSwgdGhlIHdvcmtpbmcgZGlyIGVudHJpZXMgYXJlIHNvcnRlZCBiZWNhdXNlIEkgY2hvb3NlIHRvIHNvcnQgdGhlbVxuICAgKiBpbiBteSBGaWxlU3lzdGVtLnJlYWRkaXIoKSBpbXBsZW1lbnRhdGlvbi5cbiAgICovXG5cbiAgLy8gSW5pdFxuICBjb25zdCBtaW4gPSBuZXcgUnVubmluZ01pbmltdW0oKTtcbiAgbGV0IG1pbmltdW07XG4gIGNvbnN0IGhlYWRzID0gW107XG4gIGNvbnN0IG51bXNldHMgPSBzZXRzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1zZXRzOyBpKyspIHtcbiAgICAvLyBBYnVzZSB0aGUgZmFjdCB0aGF0IGl0ZXJhdG9ycyBjb250aW51ZSB0byByZXR1cm4gJ3VuZGVmaW5lZCcgZm9yIHZhbHVlXG4gICAgLy8gb25jZSB0aGV5IGFyZSBkb25lXG4gICAgaGVhZHNbaV0gPSBzZXRzW2ldLm5leHQoKS52YWx1ZTtcbiAgICBpZiAoaGVhZHNbaV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgbWluLmNvbnNpZGVyKGhlYWRzW2ldKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1pbi52YWx1ZSA9PT0gbnVsbCkgcmV0dXJuXG4gIC8vIEl0ZXJhdGVcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBtaW5pbXVtID0gbWluLnZhbHVlO1xuICAgIG1pbi5yZXNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtc2V0czsgaSsrKSB7XG4gICAgICBpZiAoaGVhZHNbaV0gIT09IHVuZGVmaW5lZCAmJiBoZWFkc1tpXSA9PT0gbWluaW11bSkge1xuICAgICAgICByZXN1bHRbaV0gPSBoZWFkc1tpXTtcbiAgICAgICAgaGVhZHNbaV0gPSBzZXRzW2ldLm5leHQoKS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEEgbGl0dGxlIGhhY2t5LCBidXQgZWhcbiAgICAgICAgcmVzdWx0W2ldID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChoZWFkc1tpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1pbi5jb25zaWRlcihoZWFkc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHlpZWxkIHJlc3VsdDtcbiAgICBpZiAobWluLnZhbHVlID09PSBudWxsKSByZXR1cm5cbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtvYmplY3R9IGFyZ3MuY2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldXG4gKiBAcGFyYW0ge1dhbGtlcltdfSBhcmdzLnRyZWVzXG4gKiBAcGFyYW0ge1dhbGtlck1hcH0gW2FyZ3MubWFwXVxuICogQHBhcmFtIHtXYWxrZXJSZWR1Y2V9IFthcmdzLnJlZHVjZV1cbiAqIEBwYXJhbSB7V2Fsa2VySXRlcmF0ZX0gW2FyZ3MuaXRlcmF0ZV1cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgZmluaXNoZWQgdHJlZS13YWxraW5nIHJlc3VsdFxuICpcbiAqIEBzZWUge1dhbGtlck1hcH1cbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF93YWxrKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBkaXIsXG4gIGdpdGRpcixcbiAgdHJlZXMsXG4gIC8vIEB0cy1pZ25vcmVcbiAgbWFwID0gYXN5bmMgKF8sIGVudHJ5KSA9PiBlbnRyeSxcbiAgLy8gVGhlIGRlZmF1bHQgcmVkdWNlciBpcyBhIGZsYXRtYXAgdGhhdCBmaWx0ZXJzIG91dCB1bmRlZmluZWRzLlxuICByZWR1Y2UgPSBhc3luYyAocGFyZW50LCBjaGlsZHJlbikgPT4ge1xuICAgIGNvbnN0IGZsYXR0ZW4gPSBmbGF0KGNoaWxkcmVuKTtcbiAgICBpZiAocGFyZW50ICE9PSB1bmRlZmluZWQpIGZsYXR0ZW4udW5zaGlmdChwYXJlbnQpO1xuICAgIHJldHVybiBmbGF0dGVuXG4gIH0sXG4gIC8vIFRoZSBkZWZhdWx0IGl0ZXJhdGUgZnVuY3Rpb24gd2Fsa3MgYWxsIGNoaWxkcmVuIGNvbmN1cnJlbnRseVxuICBpdGVyYXRlID0gKHdhbGssIGNoaWxkcmVuKSA9PiBQcm9taXNlLmFsbChbLi4uY2hpbGRyZW5dLm1hcCh3YWxrKSksXG59KSB7XG4gIGNvbnN0IHdhbGtlcnMgPSB0cmVlcy5tYXAocHJveHkgPT5cbiAgICBwcm94eVtHaXRXYWxrU3ltYm9sXSh7IGZzLCBkaXIsIGdpdGRpciwgY2FjaGUgfSlcbiAgKTtcblxuICBjb25zdCByb290ID0gbmV3IEFycmF5KHdhbGtlcnMubGVuZ3RoKS5maWxsKCcuJyk7XG4gIGNvbnN0IHJhbmdlID0gYXJyYXlSYW5nZSgwLCB3YWxrZXJzLmxlbmd0aCk7XG4gIGNvbnN0IHVuaW9uV2Fsa2VyRnJvbVJlYWRkaXIgPSBhc3luYyBlbnRyaWVzID0+IHtcbiAgICByYW5nZS5tYXAoaSA9PiB7XG4gICAgICBlbnRyaWVzW2ldID0gZW50cmllc1tpXSAmJiBuZXcgd2Fsa2Vyc1tpXS5Db25zdHJ1Y3RFbnRyeShlbnRyaWVzW2ldKTtcbiAgICB9KTtcbiAgICBjb25zdCBzdWJkaXJzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICByYW5nZS5tYXAoaSA9PiAoZW50cmllc1tpXSA/IHdhbGtlcnNbaV0ucmVhZGRpcihlbnRyaWVzW2ldKSA6IFtdKSlcbiAgICApO1xuICAgIC8vIE5vdyBwcm9jZXNzIGNoaWxkIGRpcmVjdG9yaWVzXG4gICAgY29uc3QgaXRlcmF0b3JzID0gc3ViZGlyc1xuICAgICAgLm1hcChhcnJheSA9PiAoYXJyYXkgPT09IG51bGwgPyBbXSA6IGFycmF5KSlcbiAgICAgIC5tYXAoYXJyYXkgPT4gYXJyYXlbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbiAgICByZXR1cm4ge1xuICAgICAgZW50cmllcyxcbiAgICAgIGNoaWxkcmVuOiB1bmlvbk9mSXRlcmF0b3JzKGl0ZXJhdG9ycyksXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHdhbGsgPSBhc3luYyByb290ID0+IHtcbiAgICBjb25zdCB7IGVudHJpZXMsIGNoaWxkcmVuIH0gPSBhd2FpdCB1bmlvbldhbGtlckZyb21SZWFkZGlyKHJvb3QpO1xuICAgIGNvbnN0IGZ1bGxwYXRoID0gZW50cmllcy5maW5kKGVudHJ5ID0+IGVudHJ5ICYmIGVudHJ5Ll9mdWxscGF0aCkuX2Z1bGxwYXRoO1xuICAgIGNvbnN0IHBhcmVudCA9IGF3YWl0IG1hcChmdWxscGF0aCwgZW50cmllcyk7XG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgbGV0IHdhbGtlZENoaWxkcmVuID0gYXdhaXQgaXRlcmF0ZSh3YWxrLCBjaGlsZHJlbik7XG4gICAgICB3YWxrZWRDaGlsZHJlbiA9IHdhbGtlZENoaWxkcmVuLmZpbHRlcih4ID0+IHggIT09IHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gcmVkdWNlKHBhcmVudCwgd2Fsa2VkQ2hpbGRyZW4pXG4gICAgfVxuICB9O1xuICByZXR1cm4gd2Fsayhyb290KVxufVxuXG5jb25zdCB3b3J0aFdhbGtpbmcgPSAoZmlsZXBhdGgsIHJvb3QpID0+IHtcbiAgaWYgKGZpbGVwYXRoID09PSAnLicgfHwgcm9vdCA9PSBudWxsIHx8IHJvb3QubGVuZ3RoID09PSAwIHx8IHJvb3QgPT09ICcuJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHJvb3QubGVuZ3RoID49IGZpbGVwYXRoLmxlbmd0aCkge1xuICAgIHJldHVybiByb290LnN0YXJ0c1dpdGgoZmlsZXBhdGgpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbGVwYXRoLnN0YXJ0c1dpdGgocm9vdClcbiAgfVxufTtcblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge1Byb2dyZXNzQ2FsbGJhY2t9IFthcmdzLm9uUHJvZ3Jlc3NdXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5kaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVmXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbYXJncy5maWxlcGF0aHNdXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZW1vdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJncy5ub0NoZWNrb3V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLm5vVXBkYXRlSGVhZF1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZHJ5UnVuXVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JjZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MudHJhY2tdXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIGZpbGVzeXN0ZW0gb3BlcmF0aW9ucyBhcmUgY29tcGxldGVcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9jaGVja291dCh7XG4gIGZzLFxuICBjYWNoZSxcbiAgb25Qcm9ncmVzcyxcbiAgZGlyLFxuICBnaXRkaXIsXG4gIHJlbW90ZSxcbiAgcmVmLFxuICBmaWxlcGF0aHMsXG4gIG5vQ2hlY2tvdXQsXG4gIG5vVXBkYXRlSGVhZCxcbiAgZHJ5UnVuLFxuICBmb3JjZSxcbiAgdHJhY2sgPSB0cnVlLFxufSkge1xuICAvLyBHZXQgdHJlZSBvaWRcbiAgbGV0IG9pZDtcbiAgdHJ5IHtcbiAgICBvaWQgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoeyBmcywgZ2l0ZGlyLCByZWYgfSk7XG4gICAgLy8gVE9ETzogRmlndXJlIG91dCB3aGF0IHRvIGRvIGlmIGJvdGggJ3JlZicgYW5kICdyZW1vdGUnIGFyZSBzcGVjaWZpZWQsIHJlZiBhbHJlYWR5IGV4aXN0cyxcbiAgICAvLyBhbmQgaXMgY29uZmlndXJlZCB0byB0cmFjayBhIGRpZmZlcmVudCByZW1vdGUuXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChyZWYgPT09ICdIRUFEJykgdGhyb3cgZXJyXG4gICAgLy8gSWYgYHJlZmAgZG9lc24ndCBleGlzdCwgY3JlYXRlIGEgbmV3IHJlbW90ZSB0cmFja2luZyBicmFuY2hcbiAgICAvLyBGaWd1cmUgb3V0IHRoZSBjb21taXQgdG8gY2hlY2tvdXRcbiAgICBjb25zdCByZW1vdGVSZWYgPSBgJHtyZW1vdGV9LyR7cmVmfWA7XG4gICAgb2lkID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHtcbiAgICAgIGZzLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmOiByZW1vdGVSZWYsXG4gICAgfSk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICAvLyBTZXQgdXAgcmVtb3RlIHRyYWNraW5nIGJyYW5jaFxuICAgICAgY29uc3QgY29uZmlnID0gYXdhaXQgR2l0Q29uZmlnTWFuYWdlci5nZXQoeyBmcywgZ2l0ZGlyIH0pO1xuICAgICAgYXdhaXQgY29uZmlnLnNldChgYnJhbmNoLiR7cmVmfS5yZW1vdGVgLCByZW1vdGUpO1xuICAgICAgYXdhaXQgY29uZmlnLnNldChgYnJhbmNoLiR7cmVmfS5tZXJnZWAsIGByZWZzL2hlYWRzLyR7cmVmfWApO1xuICAgICAgYXdhaXQgR2l0Q29uZmlnTWFuYWdlci5zYXZlKHsgZnMsIGdpdGRpciwgY29uZmlnIH0pO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBuZXcgYnJhbmNoIHRoYXQgcG9pbnRzIGF0IHRoYXQgc2FtZSBjb21taXRcbiAgICBhd2FpdCBHaXRSZWZNYW5hZ2VyLndyaXRlUmVmKHtcbiAgICAgIGZzLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmOiBgcmVmcy9oZWFkcy8ke3JlZn1gLFxuICAgICAgdmFsdWU6IG9pZCxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFVwZGF0ZSB3b3JraW5nIGRpclxuICBpZiAoIW5vQ2hlY2tvdXQpIHtcbiAgICBsZXQgb3BzO1xuICAgIC8vIEZpcnN0IHBhc3MgLSBqdXN0IGFuYWx5emUgZmlsZXMgKG5vdCBkaXJlY3RvcmllcykgYW5kIGZpZ3VyZSBvdXQgd2hhdCBuZWVkcyB0byBiZSBkb25lXG4gICAgdHJ5IHtcbiAgICAgIG9wcyA9IGF3YWl0IGFuYWx5emUoe1xuICAgICAgICBmcyxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICAgIGRpcixcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICByZWYsXG4gICAgICAgIGZvcmNlLFxuICAgICAgICBmaWxlcGF0aHMsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFRocm93IGEgbW9yZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2UgZm9yIHRoaXMgY29tbW9uIG1pc3Rha2UuXG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvciAmJiBlcnIuZGF0YS53aGF0ID09PSBvaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbW1pdE5vdEZldGNoZWRFcnJvcihyZWYsIG9pZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlcG9ydCBjb25mbGljdHNcbiAgICBjb25zdCBjb25mbGljdHMgPSBvcHNcbiAgICAgIC5maWx0ZXIoKFttZXRob2RdKSA9PiBtZXRob2QgPT09ICdjb25mbGljdCcpXG4gICAgICAubWFwKChbbWV0aG9kLCBmdWxscGF0aF0pID0+IGZ1bGxwYXRoKTtcbiAgICBpZiAoY29uZmxpY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBDaGVja291dENvbmZsaWN0RXJyb3IoY29uZmxpY3RzKVxuICAgIH1cblxuICAgIC8vIENvbGxlY3QgZXJyb3JzXG4gICAgY29uc3QgZXJyb3JzID0gb3BzXG4gICAgICAuZmlsdGVyKChbbWV0aG9kXSkgPT4gbWV0aG9kID09PSAnZXJyb3InKVxuICAgICAgLm1hcCgoW21ldGhvZCwgZnVsbHBhdGhdKSA9PiBmdWxscGF0aCk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihlcnJvcnMuam9pbignLCAnKSlcbiAgICB9XG5cbiAgICBpZiAoZHJ5UnVuKSB7XG4gICAgICAvLyBTaW5jZSB0aGUgZm9ybWF0IG9mICdvcHMnIGlzIGluIGZsdXgsIEkgcmVhbGx5IHdvdWxkIHJhdGhlciBmb2xrIGJlc2lkZXMgbXlzZWxmIG5vdCBzdGFydCByZWx5aW5nIG9uIGl0XG4gICAgICAvLyByZXR1cm4gb3BzXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBTZWNvbmQgcGFzcyAtIGV4ZWN1dGUgcGxhbm5lZCBjaGFuZ2VzXG4gICAgLy8gVGhlIGNoZWFwZXN0IHNlbWktcGFyYWxsZWwgc29sdXRpb24gd2l0aG91dCBjb21wdXRpbmcgYSBmdWxsIGRlcGVuZGVuY3kgZ3JhcGggd2lsbCBiZVxuICAgIC8vIHRvIGp1c3QgZG8gb3BzIGluIDQgZHVtYiBwaGFzZXM6IGRlbGV0ZSBmaWxlcywgZGVsZXRlIGRpcnMsIGNyZWF0ZSBkaXJzLCB3cml0ZSBmaWxlc1xuXG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCB0b3RhbCA9IG9wcy5sZW5ndGg7XG4gICAgYXdhaXQgR2l0SW5kZXhNYW5hZ2VyLmFjcXVpcmUoeyBmcywgZ2l0ZGlyLCBjYWNoZSB9LCBhc3luYyBmdW5jdGlvbihpbmRleCkge1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIG9wc1xuICAgICAgICAgIC5maWx0ZXIoXG4gICAgICAgICAgICAoW21ldGhvZF0pID0+IG1ldGhvZCA9PT0gJ2RlbGV0ZScgfHwgbWV0aG9kID09PSAnZGVsZXRlLWluZGV4J1xuICAgICAgICAgIClcbiAgICAgICAgICAubWFwKGFzeW5jIGZ1bmN0aW9uKFttZXRob2QsIGZ1bGxwYXRoXSkge1xuICAgICAgICAgICAgY29uc3QgZmlsZXBhdGggPSBgJHtkaXJ9LyR7ZnVsbHBhdGh9YDtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgIGF3YWl0IGZzLnJtKGZpbGVwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4LmRlbGV0ZSh7IGZpbGVwYXRoOiBmdWxscGF0aCB9KTtcbiAgICAgICAgICAgIGlmIChvblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIGF3YWl0IG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgIHBoYXNlOiAnVXBkYXRpbmcgd29ya2RpcicsXG4gICAgICAgICAgICAgICAgbG9hZGVkOiArK2NvdW50LFxuICAgICAgICAgICAgICAgIHRvdGFsLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIE5vdGU6IHRoaXMgaXMgY2Fubm90IGJlIGRvbmUgbmFpdmVseSBpbiBwYXJhbGxlbFxuICAgIGF3YWl0IEdpdEluZGV4TWFuYWdlci5hY3F1aXJlKHsgZnMsIGdpdGRpciwgY2FjaGUgfSwgYXN5bmMgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGZvciAoY29uc3QgW21ldGhvZCwgZnVsbHBhdGhdIG9mIG9wcykge1xuICAgICAgICBpZiAobWV0aG9kID09PSAncm1kaXInIHx8IG1ldGhvZCA9PT0gJ3JtZGlyLWluZGV4Jykge1xuICAgICAgICAgIGNvbnN0IGZpbGVwYXRoID0gYCR7ZGlyfS8ke2Z1bGxwYXRofWA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdybWRpci1pbmRleCcpIHtcbiAgICAgICAgICAgICAgaW5kZXguZGVsZXRlKHsgZmlsZXBhdGg6IGZ1bGxwYXRoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgZnMucm1kaXIoZmlsZXBhdGgpO1xuICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgYXdhaXQgb25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgcGhhc2U6ICdVcGRhdGluZyB3b3JrZGlyJyxcbiAgICAgICAgICAgICAgICBsb2FkZWQ6ICsrY291bnQsXG4gICAgICAgICAgICAgICAgdG90YWwsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmNvZGUgPT09ICdFTk9URU1QVFknKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIGBEaWQgbm90IGRlbGV0ZSAke2Z1bGxwYXRofSBiZWNhdXNlIGRpcmVjdG9yeSBpcyBub3QgZW1wdHlgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIG9wc1xuICAgICAgICAuZmlsdGVyKChbbWV0aG9kXSkgPT4gbWV0aG9kID09PSAnbWtkaXInIHx8IG1ldGhvZCA9PT0gJ21rZGlyLWluZGV4JylcbiAgICAgICAgLm1hcChhc3luYyBmdW5jdGlvbihbXywgZnVsbHBhdGhdKSB7XG4gICAgICAgICAgY29uc3QgZmlsZXBhdGggPSBgJHtkaXJ9LyR7ZnVsbHBhdGh9YDtcbiAgICAgICAgICBhd2FpdCBmcy5ta2RpcihmaWxlcGF0aCk7XG4gICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGF3YWl0IG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICBwaGFzZTogJ1VwZGF0aW5nIHdvcmtkaXInLFxuICAgICAgICAgICAgICBsb2FkZWQ6ICsrY291bnQsXG4gICAgICAgICAgICAgIHRvdGFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICk7XG5cbiAgICBhd2FpdCBHaXRJbmRleE1hbmFnZXIuYWNxdWlyZSh7IGZzLCBnaXRkaXIsIGNhY2hlIH0sIGFzeW5jIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgb3BzXG4gICAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICAgIChbbWV0aG9kXSkgPT5cbiAgICAgICAgICAgICAgbWV0aG9kID09PSAnY3JlYXRlJyB8fFxuICAgICAgICAgICAgICBtZXRob2QgPT09ICdjcmVhdGUtaW5kZXgnIHx8XG4gICAgICAgICAgICAgIG1ldGhvZCA9PT0gJ3VwZGF0ZScgfHxcbiAgICAgICAgICAgICAgbWV0aG9kID09PSAnbWtkaXItaW5kZXgnXG4gICAgICAgICAgKVxuICAgICAgICAgIC5tYXAoYXN5bmMgZnVuY3Rpb24oW21ldGhvZCwgZnVsbHBhdGgsIG9pZCwgbW9kZSwgY2htb2RdKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlcGF0aCA9IGAke2Rpcn0vJHtmdWxscGF0aH1gO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKG1ldGhvZCAhPT0gJ2NyZWF0ZS1pbmRleCcgJiYgbWV0aG9kICE9PSAnbWtkaXItaW5kZXgnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvYmplY3QgfSA9IGF3YWl0IF9yZWFkT2JqZWN0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY2htb2QpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoZSBtb2RlIG9wdGlvbiBvZiBmcy53cml0ZSBvbmx5IHdvcmtzIHdoZW4gY3JlYXRpbmcgZmlsZXMsXG4gICAgICAgICAgICAgICAgICAvLyBub3QgdXBkYXRpbmcgdGhlbS4gU2luY2UgdGhlIGBmc2AgcGx1Z2luIGRvZXNuJ3QgZXhwb3NlIGBjaG1vZGAgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gaXMgb3VyIG9ubHkgb3B0aW9uLlxuICAgICAgICAgICAgICAgICAgYXdhaXQgZnMucm0oZmlsZXBhdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobW9kZSA9PT0gMG8xMDA2NDQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlZ3VsYXIgZmlsZVxuICAgICAgICAgICAgICAgICAgYXdhaXQgZnMud3JpdGUoZmlsZXBhdGgsIG9iamVjdCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAwbzEwMDc1NSkge1xuICAgICAgICAgICAgICAgICAgLy8gZXhlY3V0YWJsZSBmaWxlXG4gICAgICAgICAgICAgICAgICBhd2FpdCBmcy53cml0ZShmaWxlcGF0aCwgb2JqZWN0LCB7IG1vZGU6IDBvNzc3IH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kZSA9PT0gMG8xMjAwMDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIHN5bWxpbmtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IGZzLndyaXRlbGluayhmaWxlcGF0aCwgb2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludGVybmFsRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBJbnZhbGlkIG1vZGUgMG8ke21vZGUudG9TdHJpbmcoOCl9IGRldGVjdGVkIGluIGJsb2IgJHtvaWR9YFxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZnMubHN0YXQoZmlsZXBhdGgpO1xuICAgICAgICAgICAgICAvLyBXZSBjYW4ndCB0cnVzdCB0aGUgZXhlY3V0YWJsZSBiaXQgcmV0dXJuZWQgYnkgbHN0YXQgb24gV2luZG93cyxcbiAgICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBwcmVzZXJ2ZSB0aGlzIHZhbHVlIGZyb20gdGhlIFRSRUUuXG4gICAgICAgICAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgaG93IGdpdCBoYW5kbGVzIHRoaXMgaW50ZXJuYWxseS5cbiAgICAgICAgICAgICAgaWYgKG1vZGUgPT09IDBvMTAwNzU1KSB7XG4gICAgICAgICAgICAgICAgc3RhdHMubW9kZSA9IDBvNzU1O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFN1Ym1vZHVsZXMgYXJlIHByZXNlbnQgaW4gdGhlIGdpdCBpbmRleCBidXQgdXNlIGEgdW5pcXVlIG1vZGUgZGlmZmVyZW50IGZyb20gdHJlZXNcbiAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ21rZGlyLWluZGV4Jykge1xuICAgICAgICAgICAgICAgIHN0YXRzLm1vZGUgPSAwbzE2MDAwMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpbmRleC5pbnNlcnQoe1xuICAgICAgICAgICAgICAgIGZpbGVwYXRoOiBmdWxscGF0aCxcbiAgICAgICAgICAgICAgICBzdGF0cyxcbiAgICAgICAgICAgICAgICBvaWQsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgcGhhc2U6ICdVcGRhdGluZyB3b3JrZGlyJyxcbiAgICAgICAgICAgICAgICAgIGxvYWRlZDogKytjb3VudCxcbiAgICAgICAgICAgICAgICAgIHRvdGFsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVXBkYXRlIEhFQURcbiAgaWYgKCFub1VwZGF0ZUhlYWQpIHtcbiAgICBjb25zdCBmdWxsUmVmID0gYXdhaXQgR2l0UmVmTWFuYWdlci5leHBhbmQoeyBmcywgZ2l0ZGlyLCByZWYgfSk7XG4gICAgaWYgKGZ1bGxSZWYuc3RhcnRzV2l0aCgncmVmcy9oZWFkcycpKSB7XG4gICAgICBhd2FpdCBHaXRSZWZNYW5hZ2VyLndyaXRlU3ltYm9saWNSZWYoe1xuICAgICAgICBmcyxcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICByZWY6ICdIRUFEJyxcbiAgICAgICAgdmFsdWU6IGZ1bGxSZWYsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGV0YWNoZWQgaGVhZFxuICAgICAgYXdhaXQgR2l0UmVmTWFuYWdlci53cml0ZVJlZih7IGZzLCBnaXRkaXIsIHJlZjogJ0hFQUQnLCB2YWx1ZTogb2lkIH0pO1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBhbmFseXplKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBvblByb2dyZXNzLFxuICBkaXIsXG4gIGdpdGRpcixcbiAgcmVmLFxuICBmb3JjZSxcbiAgZmlsZXBhdGhzLFxufSkge1xuICBsZXQgY291bnQgPSAwO1xuICByZXR1cm4gX3dhbGsoe1xuICAgIGZzLFxuICAgIGNhY2hlLFxuICAgIGRpcixcbiAgICBnaXRkaXIsXG4gICAgdHJlZXM6IFtUUkVFKHsgcmVmIH0pLCBXT1JLRElSKCksIFNUQUdFKCldLFxuICAgIG1hcDogYXN5bmMgZnVuY3Rpb24oZnVsbHBhdGgsIFtjb21taXQsIHdvcmtkaXIsIHN0YWdlXSkge1xuICAgICAgaWYgKGZ1bGxwYXRoID09PSAnLicpIHJldHVyblxuICAgICAgLy8gbWF0Y2ggYWdhaW5zdCBiYXNlIHBhdGhzXG4gICAgICBpZiAoZmlsZXBhdGhzICYmICFmaWxlcGF0aHMuc29tZShiYXNlID0+IHdvcnRoV2Fsa2luZyhmdWxscGF0aCwgYmFzZSkpKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICAvLyBFbWl0IHByb2dyZXNzIGV2ZW50XG4gICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICBhd2FpdCBvblByb2dyZXNzKHsgcGhhc2U6ICdBbmFseXppbmcgd29ya2RpcicsIGxvYWRlZDogKytjb3VudCB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBpcyBhIGtpbmQgb2Ygc2lsbHkgcGF0dGVybiBidXQgaXQgd29ya2VkIHNvIHdlbGwgZm9yIG1lIGluIHRoZSBwYXN0XG4gICAgICAvLyBhbmQgaXQgbWFrZXMgaW50dWl0aXZlbHkgZGVtb25zdHJhdGluZyBleGhhdXN0aXZlbmVzcyBzbyAqZWFzeSouXG4gICAgICAvLyBUaGlzIGNoZWNrcyBmb3IgdGhlIHByZXNlbnNlIGFuZC9vciBhYnNlbnNlIG9mIGVhY2ggb2YgdGhlIDMgZW50cmllcyxcbiAgICAgIC8vIGNvbnZlcnRzIHRoYXQgdG8gYSAzLWJpdCBiaW5hcnkgcmVwcmVzZW50YXRpb24sIGFuZCB0aGVuIGhhbmRsZXNcbiAgICAgIC8vIGV2ZXJ5IHBvc3NpYmxlIGNvbWJpbmF0aW9uICgyXjMgb3IgOCBjYXNlcykgd2l0aCBhIGxvb2t1cCB0YWJsZS5cbiAgICAgIGNvbnN0IGtleSA9IFshIXN0YWdlLCAhIWNvbW1pdCwgISF3b3JrZGlyXS5tYXAoTnVtYmVyKS5qb2luKCcnKTtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIC8vIEltcG9zc2libGUgY2FzZS5cbiAgICAgICAgY2FzZSAnMDAwJzpcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgLy8gSWdub3JlIHdvcmtkaXIgZmlsZXMgdGhhdCBhcmUgbm90IHRyYWNrZWQgYW5kIG5vdCBwYXJ0IG9mIHRoZSBuZXcgY29tbWl0LlxuICAgICAgICBjYXNlICcwMDEnOlxuICAgICAgICAgIC8vIE9LLCBtYWtlIGFuIGV4Y2VwdGlvbiBmb3IgZXhwbGljaXRseSBuYW1lZCBmaWxlcy5cbiAgICAgICAgICBpZiAoZm9yY2UgJiYgZmlsZXBhdGhzICYmIGZpbGVwYXRocy5pbmNsdWRlcyhmdWxscGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2RlbGV0ZScsIGZ1bGxwYXRoXVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgLy8gTmV3IGVudHJpZXNcbiAgICAgICAgY2FzZSAnMDEwJzoge1xuICAgICAgICAgIHN3aXRjaCAoYXdhaXQgY29tbWl0LnR5cGUoKSkge1xuICAgICAgICAgICAgY2FzZSAndHJlZSc6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFsnbWtkaXInLCBmdWxscGF0aF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Jsb2InOiB7XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ2NyZWF0ZScsXG4gICAgICAgICAgICAgICAgZnVsbHBhdGgsXG4gICAgICAgICAgICAgICAgYXdhaXQgY29tbWl0Lm9pZCgpLFxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbW1pdC5tb2RlKCksXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2NvbW1pdCc6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAnbWtkaXItaW5kZXgnLFxuICAgICAgICAgICAgICAgIGZ1bGxwYXRoLFxuICAgICAgICAgICAgICAgIGF3YWl0IGNvbW1pdC5vaWQoKSxcbiAgICAgICAgICAgICAgICBhd2FpdCBjb21taXQubW9kZSgpLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBgbmV3IGVudHJ5IFVuaGFuZGxlZCB0eXBlICR7YXdhaXQgY29tbWl0LnR5cGUoKX1gLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5ldyBlbnRyaWVzIGJ1dCB0aGVyZSBpcyBhbHJlYWR5IHNvbWV0aGluZyBpbiB0aGUgd29ya2RpciB0aGVyZS5cbiAgICAgICAgY2FzZSAnMDExJzoge1xuICAgICAgICAgIHN3aXRjaCAoYCR7YXdhaXQgY29tbWl0LnR5cGUoKX0tJHthd2FpdCB3b3JrZGlyLnR5cGUoKX1gKSB7XG4gICAgICAgICAgICBjYXNlICd0cmVlLXRyZWUnOiB7XG4gICAgICAgICAgICAgIHJldHVybiAvLyBub29wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICd0cmVlLWJsb2InOlxuICAgICAgICAgICAgY2FzZSAnYmxvYi10cmVlJzoge1xuICAgICAgICAgICAgICByZXR1cm4gWydjb25mbGljdCcsIGZ1bGxwYXRoXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYmxvYi1ibG9iJzoge1xuICAgICAgICAgICAgICAvLyBJcyB0aGUgaW5jb21pbmcgZmlsZSBkaWZmZXJlbnQ/XG4gICAgICAgICAgICAgIGlmICgoYXdhaXQgY29tbWl0Lm9pZCgpKSAhPT0gKGF3YWl0IHdvcmtkaXIub2lkKCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAndXBkYXRlJyxcbiAgICAgICAgICAgICAgICAgICAgZnVsbHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNvbW1pdC5vaWQoKSxcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY29tbWl0Lm1vZGUoKSxcbiAgICAgICAgICAgICAgICAgICAgKGF3YWl0IGNvbW1pdC5tb2RlKCkpICE9PSAoYXdhaXQgd29ya2Rpci5tb2RlKCkpLFxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gWydjb25mbGljdCcsIGZ1bGxwYXRoXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGUgaW5jb21pbmcgZmlsZSBhIGRpZmZlcmVudCBtb2RlP1xuICAgICAgICAgICAgICAgIGlmICgoYXdhaXQgY29tbWl0Lm1vZGUoKSkgIT09IChhd2FpdCB3b3JrZGlyLm1vZGUoKSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICd1cGRhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgIGZ1bGxwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNvbW1pdC5vaWQoKSxcbiAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb21taXQubW9kZSgpLFxuICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2NvbmZsaWN0JywgZnVsbHBhdGhdXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICdjcmVhdGUtaW5kZXgnLFxuICAgICAgICAgICAgICAgICAgICBmdWxscGF0aCxcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY29tbWl0Lm9pZCgpLFxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjb21taXQubW9kZSgpLFxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29tbWl0LXRyZWUnOiB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IHN1Ym1vZHVsZVxuICAgICAgICAgICAgICAvLyBXZSdsbCBpZ25vcmUgc3VibW9kdWxlIGRpcmVjdG9yaWVzIGZvciBub3cuXG4gICAgICAgICAgICAgIC8vIFVzZXJzIHByZWZlciB3ZSBub3QgdGhyb3cgYW4gZXJyb3IgZm9yIGxhY2sgb2Ygc3VibW9kdWxlIHN1cHBvcnQuXG4gICAgICAgICAgICAgIC8vIGdpdGxpbmtzXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29tbWl0LWJsb2InOiB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IHN1Ym1vZHVsZVxuICAgICAgICAgICAgICAvLyBCdXQuLi4gd2UnbGwgY29tcGxhaW4gaWYgdGhlcmUgaXMgYSAqZmlsZSogd2hlcmUgd2Ugd291bGRcbiAgICAgICAgICAgICAgLy8gcHV0IGEgc3VibW9kdWxlIGlmIHdlIGhhZCBzdWJtb2R1bGUgc3VwcG9ydC5cbiAgICAgICAgICAgICAgcmV0dXJuIFsnY29uZmxpY3QnLCBmdWxscGF0aF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIFsnZXJyb3InLCBgbmV3IGVudHJ5IFVuaGFuZGxlZCB0eXBlICR7Y29tbWl0LnR5cGV9YF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZXRoaW5nIGluIHN0YWdlIGJ1dCBub3QgaW4gdGhlIGNvbW1pdCBPUiB0aGUgd29ya2Rpci5cbiAgICAgICAgLy8gTm90ZTogSSB2ZXJpZmllZCB0aGlzIGJlaGF2aW9yIGFnYWluc3QgY2Fub25pY2FsIGdpdC5cbiAgICAgICAgY2FzZSAnMTAwJzoge1xuICAgICAgICAgIHJldHVybiBbJ2RlbGV0ZS1pbmRleCcsIGZ1bGxwYXRoXVxuICAgICAgICB9XG4gICAgICAgIC8vIERlbGV0ZWQgZW50cmllc1xuICAgICAgICAvLyBUT0RPOiBIb3cgdG8gaGFuZGxlIGlmIHN0YWdlIHR5cGUgYW5kIHdvcmtkaXIgdHlwZSBtaXNtYXRjaD9cbiAgICAgICAgY2FzZSAnMTAxJzoge1xuICAgICAgICAgIHN3aXRjaCAoYXdhaXQgc3RhZ2UudHlwZSgpKSB7XG4gICAgICAgICAgICBjYXNlICd0cmVlJzoge1xuICAgICAgICAgICAgICByZXR1cm4gWydybWRpcicsIGZ1bGxwYXRoXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYmxvYic6IHtcbiAgICAgICAgICAgICAgLy8gR2l0IGNoZWNrcyB0aGF0IHRoZSB3b3JrZGlyLm9pZCA9PT0gc3RhZ2Uub2lkIGJlZm9yZSBkZWxldGluZyBmaWxlXG4gICAgICAgICAgICAgIGlmICgoYXdhaXQgc3RhZ2Uub2lkKCkpICE9PSAoYXdhaXQgd29ya2Rpci5vaWQoKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZm9yY2UpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBbJ2RlbGV0ZScsIGZ1bGxwYXRoXVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gWydjb25mbGljdCcsIGZ1bGxwYXRoXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydkZWxldGUnLCBmdWxscGF0aF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29tbWl0Jzoge1xuICAgICAgICAgICAgICByZXR1cm4gWydybWRpci1pbmRleCcsIGZ1bGxwYXRoXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgYGRlbGV0ZSBlbnRyeSBVbmhhbmRsZWQgdHlwZSAke2F3YWl0IHN0YWdlLnR5cGUoKX1gLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWZhbGx0aHJvdWdoICovXG4gICAgICAgIC8vIEZpbGUgbWlzc2luZyBmcm9tIHdvcmtkaXJcbiAgICAgICAgY2FzZSAnMTEwJzpcbiAgICAgICAgLy8gUG9zc2libHkgbW9kaWZpZWQgZW50cmllc1xuICAgICAgICBjYXNlICcxMTEnOiB7XG4gICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuICAgICAgICAgIHN3aXRjaCAoYCR7YXdhaXQgc3RhZ2UudHlwZSgpfS0ke2F3YWl0IGNvbW1pdC50eXBlKCl9YCkge1xuICAgICAgICAgICAgY2FzZSAndHJlZS10cmVlJzoge1xuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Jsb2ItYmxvYic6IHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGZpbGUgaGFzbid0IGNoYW5nZWQsIHRoZXJlIGlzIG5vIG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gICAgICAgICAgICAgIC8vIEV4aXN0aW5nIGZpbGUgbW9kaWZpY2F0aW9ucyBpbiB0aGUgd29ya2RpciBjYW4gYmUgYmUgbGVmdCBhcyBpcy5cbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChhd2FpdCBzdGFnZS5vaWQoKSkgPT09IChhd2FpdCBjb21taXQub2lkKCkpICYmXG4gICAgICAgICAgICAgICAgKGF3YWl0IHN0YWdlLm1vZGUoKSkgPT09IChhd2FpdCBjb21taXQubW9kZSgpKSAmJlxuICAgICAgICAgICAgICAgICFmb3JjZVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIENoZWNrIGZvciBsb2NhbCBjaGFuZ2VzIHRoYXQgd291bGQgYmUgbG9zdFxuICAgICAgICAgICAgICBpZiAod29ya2Rpcikge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IGNhbm9uaWNhbCBnaXQgb25seSBjb21wYXJlcyB3aXRoIHRoZSBzdGFnZS4gQnV0IHdlJ3JlIHNtYXJ0IGVub3VnaFxuICAgICAgICAgICAgICAgIC8vIHRvIGNvbXBhcmUgdG8gdGhlIHN0YWdlIEFORCB0aGUgaW5jb21pbmcgY29tbWl0LlxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgIChhd2FpdCB3b3JrZGlyLm9pZCgpKSAhPT0gKGF3YWl0IHN0YWdlLm9pZCgpKSAmJlxuICAgICAgICAgICAgICAgICAgKGF3YWl0IHdvcmtkaXIub2lkKCkpICE9PSAoYXdhaXQgY29tbWl0Lm9pZCgpKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgJ3VwZGF0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgZnVsbHBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgYXdhaXQgY29tbWl0Lm9pZCgpLFxuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNvbW1pdC5tb2RlKCksXG4gICAgICAgICAgICAgICAgICAgICAgKGF3YWl0IGNvbW1pdC5tb2RlKCkpICE9PSAoYXdhaXQgd29ya2Rpci5tb2RlKCkpLFxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydjb25mbGljdCcsIGZ1bGxwYXRoXVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAndXBkYXRlJyxcbiAgICAgICAgICAgICAgICAgIGZ1bGxwYXRoLFxuICAgICAgICAgICAgICAgICAgYXdhaXQgY29tbWl0Lm9pZCgpLFxuICAgICAgICAgICAgICAgICAgYXdhaXQgY29tbWl0Lm1vZGUoKSxcbiAgICAgICAgICAgICAgICAgIChhd2FpdCBjb21taXQubW9kZSgpKSAhPT0gKGF3YWl0IHN0YWdlLm1vZGUoKSksXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEhhcyBmaWxlIG1vZGUgY2hhbmdlZD9cbiAgICAgICAgICAgICAgaWYgKChhd2FpdCBjb21taXQubW9kZSgpKSAhPT0gKGF3YWl0IHN0YWdlLm1vZGUoKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgJ3VwZGF0ZScsXG4gICAgICAgICAgICAgICAgICBmdWxscGF0aCxcbiAgICAgICAgICAgICAgICAgIGF3YWl0IGNvbW1pdC5vaWQoKSxcbiAgICAgICAgICAgICAgICAgIGF3YWl0IGNvbW1pdC5tb2RlKCksXG4gICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBUT0RPOiBIQU5ETEUgU1lNTElOS1NcbiAgICAgICAgICAgICAgLy8gSGFzIHRoZSBmaWxlIGNvbnRlbnQgY2hhbmdlZD9cbiAgICAgICAgICAgICAgaWYgKChhd2FpdCBjb21taXQub2lkKCkpICE9PSAoYXdhaXQgc3RhZ2Uub2lkKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICd1cGRhdGUnLFxuICAgICAgICAgICAgICAgICAgZnVsbHBhdGgsXG4gICAgICAgICAgICAgICAgICBhd2FpdCBjb21taXQub2lkKCksXG4gICAgICAgICAgICAgICAgICBhd2FpdCBjb21taXQubW9kZSgpLFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICd0cmVlLWJsb2InOiB7XG4gICAgICAgICAgICAgIHJldHVybiBbJ3VwZGF0ZS1kaXItdG8tYmxvYicsIGZ1bGxwYXRoLCBhd2FpdCBjb21taXQub2lkKCldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdibG9iLXRyZWUnOiB7XG4gICAgICAgICAgICAgIHJldHVybiBbJ3VwZGF0ZS1ibG9iLXRvLXRyZWUnLCBmdWxscGF0aF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2NvbW1pdC1jb21taXQnOiB7XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgJ21rZGlyLWluZGV4JyxcbiAgICAgICAgICAgICAgICBmdWxscGF0aCxcbiAgICAgICAgICAgICAgICBhd2FpdCBjb21taXQub2lkKCksXG4gICAgICAgICAgICAgICAgYXdhaXQgY29tbWl0Lm1vZGUoKSxcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAgICAgYHVwZGF0ZSBlbnRyeSBVbmhhbmRsZWQgdHlwZSAke2F3YWl0IHN0YWdlLnR5cGUoKX0tJHthd2FpdCBjb21taXQudHlwZSgpfWAsXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIE1vZGlmeSB0aGUgZGVmYXVsdCBmbGF0IG1hcHBpbmdcbiAgICByZWR1Y2U6IGFzeW5jIGZ1bmN0aW9uKHBhcmVudCwgY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkcmVuID0gZmxhdChjaGlsZHJlbik7XG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5cbiAgICAgIH0gZWxzZSBpZiAocGFyZW50ICYmIHBhcmVudFswXSA9PT0gJ3JtZGlyJykge1xuICAgICAgICBjaGlsZHJlbi5wdXNoKHBhcmVudCk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRyZW4udW5zaGlmdChwYXJlbnQpO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5cbiAgICAgIH1cbiAgICB9LFxuICB9KVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBDaGVja291dCBhIGJyYW5jaFxuICpcbiAqIElmIHRoZSBicmFuY2ggYWxyZWFkeSBleGlzdHMgaXQgd2lsbCBjaGVjayBvdXQgdGhhdCBicmFuY2guIE90aGVyd2lzZSwgaXQgd2lsbCBjcmVhdGUgYSBuZXcgcmVtb3RlIHRyYWNraW5nIGJyYW5jaCBzZXQgdG8gdHJhY2sgdGhlIHJlbW90ZSBicmFuY2ggb2YgdGhhdCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtQcm9ncmVzc0NhbGxiYWNrfSBbYXJncy5vblByb2dyZXNzXSAtIG9wdGlvbmFsIHByb2dyZXNzIGV2ZW50IGNhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5kaXIgLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZiA9ICdIRUFEJ10gLSBTb3VyY2UgdG8gY2hlY2tvdXQgZmlsZXMgZnJvbVxuICogQHBhcmFtIHtzdHJpbmdbXX0gW2FyZ3MuZmlsZXBhdGhzXSAtIExpbWl0IHRoZSBjaGVja291dCB0byB0aGUgZ2l2ZW4gZmlsZXMgYW5kIGRpcmVjdG9yaWVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVtb3RlID0gJ29yaWdpbiddIC0gV2hpY2ggcmVtb3RlIHJlcG9zaXRvcnkgdG8gdXNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLm5vQ2hlY2tvdXQgPSBmYWxzZV0gLSBJZiB0cnVlLCB3aWxsIHVwZGF0ZSBIRUFEIGJ1dCB3b24ndCB1cGRhdGUgdGhlIHdvcmtpbmcgZGlyZWN0b3J5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLm5vVXBkYXRlSGVhZF0gLSBJZiB0cnVlLCB3aWxsIHVwZGF0ZSB0aGUgd29ya2luZyBkaXJlY3RvcnkgYnV0IHdvbid0IHVwZGF0ZSBIRUFELiBEZWZhdWx0cyB0byBgZmFsc2VgIHdoZW4gYHJlZmAgaXMgcHJvdmlkZWQsIGFuZCBgdHJ1ZWAgaWYgYHJlZmAgaXMgbm90IHByb3ZpZGVkLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5kcnlSdW4gPSBmYWxzZV0gLSBJZiB0cnVlLCBzaW11bGF0ZXMgYSBjaGVja291dCBzbyB5b3UgY2FuIHRlc3Qgd2hldGhlciBpdCB3b3VsZCBzdWNjZWVkLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JjZSA9IGZhbHNlXSAtIElmIHRydWUsIGNvbmZsaWN0cyB3aWxsIGJlIGlnbm9yZWQgYW5kIGZpbGVzIHdpbGwgYmUgb3ZlcndyaXR0ZW4gcmVnYXJkbGVzcyBvZiBsb2NhbCBjaGFuZ2VzLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy50cmFjayA9IHRydWVdIC0gSWYgZmFsc2UsIHdpbGwgbm90IHNldCB0aGUgcmVtb3RlIGJyYW5jaCB0cmFja2luZyBpbmZvcm1hdGlvbi4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIHN3aXRjaCB0byB0aGUgbWFpbiBicmFuY2hcbiAqIGF3YWl0IGdpdC5jaGVja291dCh7XG4gKiAgIGZzLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICByZWY6ICdtYWluJ1xuICogfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gcmVzdG9yZSB0aGUgJ2RvY3MnIGFuZCAnc3JjL2RvY3MnIGZvbGRlcnMgdG8gdGhlIHdheSB0aGV5IHdlcmUsIG92ZXJ3cml0aW5nIGFueSBjaGFuZ2VzXG4gKiBhd2FpdCBnaXQuY2hlY2tvdXQoe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgZm9yY2U6IHRydWUsXG4gKiAgIGZpbGVwYXRoczogWydkb2NzJywgJ3NyYy9kb2NzJ11cbiAqIH0pXG4gKiBjb25zb2xlLmxvZygnZG9uZScpXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIHJlc3RvcmUgdGhlICdkb2NzJyBhbmQgJ3NyYy9kb2NzJyBmb2xkZXJzIHRvIHRoZSB3YXkgdGhleSBhcmUgaW4gdGhlICdkZXZlbG9wJyBicmFuY2gsIG92ZXJ3cml0aW5nIGFueSBjaGFuZ2VzXG4gKiBhd2FpdCBnaXQuY2hlY2tvdXQoe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgcmVmOiAnZGV2ZWxvcCcsXG4gKiAgIG5vVXBkYXRlSGVhZDogdHJ1ZSxcbiAqICAgZm9yY2U6IHRydWUsXG4gKiAgIGZpbGVwYXRoczogWydkb2NzJywgJ3NyYy9kb2NzJ11cbiAqIH0pXG4gKiBjb25zb2xlLmxvZygnZG9uZScpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrb3V0KHtcbiAgZnMsXG4gIG9uUHJvZ3Jlc3MsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlbW90ZSA9ICdvcmlnaW4nLFxuICByZWY6IF9yZWYsXG4gIGZpbGVwYXRocyxcbiAgbm9DaGVja291dCA9IGZhbHNlLFxuICBub1VwZGF0ZUhlYWQgPSBfcmVmID09PSB1bmRlZmluZWQsXG4gIGRyeVJ1biA9IGZhbHNlLFxuICBmb3JjZSA9IGZhbHNlLFxuICB0cmFjayA9IHRydWUsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2RpcicsIGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuXG4gICAgY29uc3QgcmVmID0gX3JlZiB8fCAnSEVBRCc7XG4gICAgcmV0dXJuIGF3YWl0IF9jaGVja291dCh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgZGlyLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVtb3RlLFxuICAgICAgcmVmLFxuICAgICAgZmlsZXBhdGhzLFxuICAgICAgbm9DaGVja291dCxcbiAgICAgIG5vVXBkYXRlSGVhZCxcbiAgICAgIGRyeVJ1bixcbiAgICAgIGZvcmNlLFxuICAgICAgdHJhY2ssXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuY2hlY2tvdXQnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEBzZWUgaHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1yZXYtcGFyc2UuaHRtbCNfc3BlY2lmeWluZ19yZXZpc2lvbnNcbmNvbnN0IGFiYnJldmlhdGVSeCA9IG5ldyBSZWdFeHAoJ15yZWZzLyhoZWFkcy98dGFncy98cmVtb3Rlcy8pPyguKiknKTtcblxuZnVuY3Rpb24gYWJicmV2aWF0ZVJlZihyZWYpIHtcbiAgY29uc3QgbWF0Y2ggPSBhYmJyZXZpYXRlUnguZXhlYyhyZWYpO1xuICBpZiAobWF0Y2gpIHtcbiAgICBpZiAobWF0Y2hbMV0gPT09ICdyZW1vdGVzLycgJiYgcmVmLmVuZHNXaXRoKCcvSEVBRCcpKSB7XG4gICAgICByZXR1cm4gbWF0Y2hbMl0uc2xpY2UoMCwgLTUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBtYXRjaFsyXVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVmXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZnVsbG5hbWUgPSBmYWxzZV0gLSBSZXR1cm4gdGhlIGZ1bGwgcGF0aCAoZS5nLiBcInJlZnMvaGVhZHMvbWFpblwiKSBpbnN0ZWFkIG9mIHRoZSBhYmJyZXZpYXRlZCBmb3JtLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy50ZXN0ID0gZmFsc2VdIC0gSWYgdGhlIGN1cnJlbnQgYnJhbmNoIGRvZXNuJ3QgYWN0dWFsbHkgZXhpc3QgKHN1Y2ggYXMgcmlnaHQgYWZ0ZXIgZ2l0IGluaXQpIHRoZW4gcmV0dXJuIGB1bmRlZmluZWRgLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ3x2b2lkPn0gVGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgYnJhbmNoIG9yIHVuZGVmaW5lZCBpZiB0aGUgSEVBRCBpcyBkZXRhY2hlZC5cbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9jdXJyZW50QnJhbmNoKHtcbiAgZnMsXG4gIGdpdGRpcixcbiAgZnVsbG5hbWUgPSBmYWxzZSxcbiAgdGVzdCA9IGZhbHNlLFxufSkge1xuICBjb25zdCByZWYgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoe1xuICAgIGZzLFxuICAgIGdpdGRpcixcbiAgICByZWY6ICdIRUFEJyxcbiAgICBkZXB0aDogMixcbiAgfSk7XG4gIGlmICh0ZXN0KSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGZzLCBnaXRkaXIsIHJlZiB9KTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgLy8gUmV0dXJuIGB1bmRlZmluZWRgIGZvciBkZXRhY2hlZCBIRUFEXG4gIGlmICghcmVmLnN0YXJ0c1dpdGgoJ3JlZnMvJykpIHJldHVyblxuICByZXR1cm4gZnVsbG5hbWUgPyByZWYgOiBhYmJyZXZpYXRlUmVmKHJlZilcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlU1NIdG9IVFRQKHVybCkge1xuICAvLyBoYW5kbGUgXCJzaG9ydGVyIHNjcC1saWtlIHN5bnRheFwiXG4gIHVybCA9IHVybC5yZXBsYWNlKC9eZ2l0QChbXjpdKyk6LywgJ2h0dHBzOi8vJDEvJyk7XG4gIC8vIGhhbmRsZSBwcm9wZXIgU1NIIFVSTHNcbiAgdXJsID0gdXJsLnJlcGxhY2UoL15zc2g6XFwvXFwvLywgJ2h0dHBzOi8vJyk7XG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlQmFzaWNBdXRoSGVhZGVyKHsgdXNlcm5hbWUgPSAnJywgcGFzc3dvcmQgPSAnJyB9KSB7XG4gIHJldHVybiBgQmFzaWMgJHtCdWZmZXIuZnJvbShgJHt1c2VybmFtZX06JHtwYXNzd29yZH1gKS50b1N0cmluZygnYmFzZTY0Jyl9YFxufVxuXG4vLyBDdXJyZW50bHkgJ2ZvciBhd2FpdCcgdXBzZXRzIG15IGxpbnRlcnMuXG5hc3luYyBmdW5jdGlvbiBmb3JBd2FpdChpdGVyYWJsZSwgY2IpIHtcbiAgY29uc3QgaXRlciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBpdGVyLm5leHQoKTtcbiAgICBpZiAodmFsdWUpIGF3YWl0IGNiKHZhbHVlKTtcbiAgICBpZiAoZG9uZSkgYnJlYWtcbiAgfVxuICBpZiAoaXRlci5yZXR1cm4pIGl0ZXIucmV0dXJuKCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNvbGxlY3QoaXRlcmFibGUpIHtcbiAgbGV0IHNpemUgPSAwO1xuICBjb25zdCBidWZmZXJzID0gW107XG4gIC8vIFRoaXMgd2lsbCBiZSBlYXNpZXIgb25jZSBgZm9yIGF3YWl0IC4uLiBvZmAgbG9vcHMgYXJlIGF2YWlsYWJsZS5cbiAgYXdhaXQgZm9yQXdhaXQoaXRlcmFibGUsIHZhbHVlID0+IHtcbiAgICBidWZmZXJzLnB1c2godmFsdWUpO1xuICAgIHNpemUgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xuICAgIHJlc3VsdC5zZXQoYnVmZmVyLCBuZXh0SW5kZXgpO1xuICAgIG5leHRJbmRleCArPSBidWZmZXIuYnl0ZUxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBdXRoRnJvbVVybCh1cmwpIHtcbiAgLy8gRm9yIHdoYXRldmVyIHJlYXNvbiwgdGhlIGBmZXRjaGAgQVBJIGRvZXMgbm90IGNvbnZlcnQgY3JlZGVudGlhbHMgZW1iZWRkZWQgaW4gdGhlIFVSTFxuICAvLyBpbnRvIEJhc2ljIEF1dGhlbnRpY2F0aW9uIGhlYWRlcnMgYXV0b21hdGljYWxseS4gSW5zdGVhZCBpdCB0aHJvd3MgYW4gZXJyb3IhXG4gIC8vIFNvIHdlIG11c3QgbWFudWFsbHkgcGFyc2UgdGhlIFVSTCwgcmlwIG91dCB0aGUgdXNlcjpwYXNzd29yZCBwb3J0aW9uIGlmIGl0IGlzIHByZXNlbnRcbiAgLy8gYW5kIGNvbXB1dGUgdGhlIEF1dGhvcml6YXRpb24gaGVhZGVyLlxuICAvLyBOb3RlOiBJIHRyaWVkIHVzaW5nIG5ldyBVUkwodXJsKSBidXQgdGhhdCB0aHJvd3MgYSBzZWN1cml0eSBleGNlcHRpb24gaW4gRWRnZS4gOnJvbGxleWVzOlxuICBsZXQgdXNlcnBhc3MgPSB1cmwubWF0Y2goL15odHRwcz86XFwvXFwvKFteL10rKUAvKTtcbiAgLy8gTm8gY3JlZGVudGlhbHMsIHJldHVybiB0aGUgdXJsIHVubW9kaWZpZWQgYW5kIGFuIGVtcHR5IGF1dGggb2JqZWN0XG4gIGlmICh1c2VycGFzcyA9PSBudWxsKSByZXR1cm4geyB1cmwsIGF1dGg6IHt9IH1cbiAgdXNlcnBhc3MgPSB1c2VycGFzc1sxXTtcbiAgY29uc3QgW3VzZXJuYW1lLCBwYXNzd29yZF0gPSB1c2VycGFzcy5zcGxpdCgnOicpO1xuICAvLyBSZW1vdmUgY3JlZGVudGlhbHMgZnJvbSBVUkxcbiAgdXJsID0gdXJsLnJlcGxhY2UoYCR7dXNlcnBhc3N9QGAsICcnKTtcbiAgLy8gSGFzIGNyZWRlbnRpYWxzLCByZXR1cm4gdGhlIGZldGNoLXNhZmUgVVJMIGFuZCB0aGUgcGFyc2VkIGNyZWRlbnRpYWxzXG4gIHJldHVybiB7IHVybCwgYXV0aDogeyB1c2VybmFtZSwgcGFzc3dvcmQgfSB9XG59XG5cbmZ1bmN0aW9uIHBhZEhleChiLCBuKSB7XG4gIGNvbnN0IHMgPSBuLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuICcwJy5yZXBlYXQoYiAtIHMubGVuZ3RoKSArIHNcbn1cblxuLyoqXG5wa3QtbGluZSBGb3JtYXRcbi0tLS0tLS0tLS0tLS0tLVxuXG5NdWNoIChidXQgbm90IGFsbCkgb2YgdGhlIHBheWxvYWQgaXMgZGVzY3JpYmVkIGFyb3VuZCBwa3QtbGluZXMuXG5cbkEgcGt0LWxpbmUgaXMgYSB2YXJpYWJsZSBsZW5ndGggYmluYXJ5IHN0cmluZy4gIFRoZSBmaXJzdCBmb3VyIGJ5dGVzXG5vZiB0aGUgbGluZSwgdGhlIHBrdC1sZW4sIGluZGljYXRlcyB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBsaW5lLFxuaW4gaGV4YWRlY2ltYWwuICBUaGUgcGt0LWxlbiBpbmNsdWRlcyB0aGUgNCBieXRlcyB1c2VkIHRvIGNvbnRhaW5cbnRoZSBsZW5ndGgncyBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbi5cblxuQSBwa3QtbGluZSBNQVkgY29udGFpbiBiaW5hcnkgZGF0YSwgc28gaW1wbGVtZW50b3JzIE1VU1QgZW5zdXJlXG5wa3QtbGluZSBwYXJzaW5nL2Zvcm1hdHRpbmcgcm91dGluZXMgYXJlIDgtYml0IGNsZWFuLlxuXG5BIG5vbi1iaW5hcnkgbGluZSBTSE9VTEQgQkUgdGVybWluYXRlZCBieSBhbiBMRiwgd2hpY2ggaWYgcHJlc2VudFxuTVVTVCBiZSBpbmNsdWRlZCBpbiB0aGUgdG90YWwgbGVuZ3RoLiBSZWNlaXZlcnMgTVVTVCB0cmVhdCBwa3QtbGluZXNcbndpdGggbm9uLWJpbmFyeSBkYXRhIHRoZSBzYW1lIHdoZXRoZXIgb3Igbm90IHRoZXkgY29udGFpbiB0aGUgdHJhaWxpbmdcbkxGIChzdHJpcHBpbmcgdGhlIExGIGlmIHByZXNlbnQsIGFuZCBub3QgY29tcGxhaW5pbmcgd2hlbiBpdCBpc1xubWlzc2luZykuXG5cblRoZSBtYXhpbXVtIGxlbmd0aCBvZiBhIHBrdC1saW5lJ3MgZGF0YSBjb21wb25lbnQgaXMgNjU1MTYgYnl0ZXMuXG5JbXBsZW1lbnRhdGlvbnMgTVVTVCBOT1Qgc2VuZCBwa3QtbGluZSB3aG9zZSBsZW5ndGggZXhjZWVkcyA2NTUyMFxuKDY1NTE2IGJ5dGVzIG9mIHBheWxvYWQgKyA0IGJ5dGVzIG9mIGxlbmd0aCBkYXRhKS5cblxuSW1wbGVtZW50YXRpb25zIFNIT1VMRCBOT1Qgc2VuZCBhbiBlbXB0eSBwa3QtbGluZSAoXCIwMDA0XCIpLlxuXG5BIHBrdC1saW5lIHdpdGggYSBsZW5ndGggZmllbGQgb2YgMCAoXCIwMDAwXCIpLCBjYWxsZWQgYSBmbHVzaC1wa3QsXG5pcyBhIHNwZWNpYWwgY2FzZSBhbmQgTVVTVCBiZSBoYW5kbGVkIGRpZmZlcmVudGx5IHRoYW4gYW4gZW1wdHlcbnBrdC1saW5lIChcIjAwMDRcIikuXG5cbi0tLS1cbiAgcGt0LWxpbmUgICAgID0gIGRhdGEtcGt0IC8gZmx1c2gtcGt0XG5cbiAgZGF0YS1wa3QgICAgID0gIHBrdC1sZW4gcGt0LXBheWxvYWRcbiAgcGt0LWxlbiAgICAgID0gIDQqKEhFWERJRylcbiAgcGt0LXBheWxvYWQgID0gIChwa3QtbGVuIC0gNCkqKE9DVEVUKVxuXG4gIGZsdXNoLXBrdCAgICA9IFwiMDAwMFwiXG4tLS0tXG5cbkV4YW1wbGVzIChhcyBDLXN0eWxlIHN0cmluZ3MpOlxuXG4tLS0tXG4gIHBrdC1saW5lICAgICAgICAgIGFjdHVhbCB2YWx1ZVxuICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgXCIwMDA2YVxcblwiICAgICAgICAgXCJhXFxuXCJcbiAgXCIwMDA1YVwiICAgICAgICAgICBcImFcIlxuICBcIjAwMGJmb29iYXJcXG5cIiAgICBcImZvb2JhclxcblwiXG4gIFwiMDAwNFwiICAgICAgICAgICAgXCJcIlxuLS0tLVxuKi9cblxuLy8gSSdtIHJlYWxseSB1c2luZyB0aGlzIG1vcmUgYXMgYSBuYW1lc3BhY2UuXG4vLyBUaGVyZSdzIG5vdCBhIGxvdCBvZiBcInN0YXRlXCIgaW4gYSBwa3QtbGluZVxuXG5jbGFzcyBHaXRQa3RMaW5lIHtcbiAgc3RhdGljIGZsdXNoKCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSgnMDAwMCcsICd1dGY4JylcbiAgfVxuXG4gIHN0YXRpYyBkZWxpbSgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oJzAwMDEnLCAndXRmOCcpXG4gIH1cblxuICBzdGF0aWMgZW5jb2RlKGxpbmUpIHtcbiAgICBpZiAodHlwZW9mIGxpbmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsaW5lID0gQnVmZmVyLmZyb20obGluZSk7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGxpbmUubGVuZ3RoICsgNDtcbiAgICBjb25zdCBoZXhsZW5ndGggPSBwYWRIZXgoNCwgbGVuZ3RoKTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oaGV4bGVuZ3RoLCAndXRmOCcpLCBsaW5lXSlcbiAgfVxuXG4gIHN0YXRpYyBzdHJlYW1SZWFkZXIoc3RyZWFtKSB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFN0cmVhbVJlYWRlcihzdHJlYW0pO1xuICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGxlbmd0aCA9IGF3YWl0IHJlYWRlci5yZWFkKDQpO1xuICAgICAgICBpZiAobGVuZ3RoID09IG51bGwpIHJldHVybiB0cnVlXG4gICAgICAgIGxlbmd0aCA9IHBhcnNlSW50KGxlbmd0aC50b1N0cmluZygndXRmOCcpLCAxNik7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybiBudWxsXG4gICAgICAgIGlmIChsZW5ndGggPT09IDEpIHJldHVybiBudWxsIC8vIGRlbGltIHBhY2tldHNcbiAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgcmVhZGVyLnJlYWQobGVuZ3RoIC0gNCk7XG4gICAgICAgIGlmIChidWZmZXIgPT0gbnVsbCkgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIGJ1ZmZlclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdlcnJvcicsIGVycik7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHJlYWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VDYXBhYmlsaXRpZXNWMihyZWFkKSB7XG4gIC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgc3RyaW5nIHwgdHJ1ZT59ICovXG4gIGNvbnN0IGNhcGFiaWxpdGllczIgPSB7fTtcblxuICBsZXQgbGluZTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBsaW5lID0gYXdhaXQgcmVhZCgpO1xuICAgIGlmIChsaW5lID09PSB0cnVlKSBicmVha1xuICAgIGlmIChsaW5lID09PSBudWxsKSBjb250aW51ZVxuICAgIGxpbmUgPSBsaW5lLnRvU3RyaW5nKCd1dGY4JykucmVwbGFjZSgvXFxuJC8sICcnKTtcbiAgICBjb25zdCBpID0gbGluZS5pbmRleE9mKCc9Jyk7XG4gICAgaWYgKGkgPiAtMSkge1xuICAgICAgY29uc3Qga2V5ID0gbGluZS5zbGljZSgwLCBpKTtcbiAgICAgIGNvbnN0IHZhbHVlID0gbGluZS5zbGljZShpICsgMSk7XG4gICAgICBjYXBhYmlsaXRpZXMyW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FwYWJpbGl0aWVzMltsaW5lXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHByb3RvY29sVmVyc2lvbjogMiwgY2FwYWJpbGl0aWVzMiB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlUmVmc0FkUmVzcG9uc2Uoc3RyZWFtLCB7IHNlcnZpY2UgfSkge1xuICBjb25zdCBjYXBhYmlsaXRpZXMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHJlZnMgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHN5bXJlZnMgPSBuZXcgTWFwKCk7XG5cbiAgLy8gVGhlcmUgaXMgcHJvYmFibHkgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXMsIGJ1dCBmb3Igbm93XG4gIC8vIGxldCdzIGp1c3QgdGhyb3cgdGhlIHJlc3VsdCBwYXJzZXIgaW5saW5lIGhlcmUuXG4gIGNvbnN0IHJlYWQgPSBHaXRQa3RMaW5lLnN0cmVhbVJlYWRlcihzdHJlYW0pO1xuICBsZXQgbGluZU9uZSA9IGF3YWl0IHJlYWQoKTtcbiAgLy8gc2tpcCBwYXN0IGFueSBmbHVzaGVzXG4gIHdoaWxlIChsaW5lT25lID09PSBudWxsKSBsaW5lT25lID0gYXdhaXQgcmVhZCgpO1xuXG4gIGlmIChsaW5lT25lID09PSB0cnVlKSB0aHJvdyBuZXcgRW1wdHlTZXJ2ZXJSZXNwb25zZUVycm9yKClcblxuICAvLyBIYW5kbGUgcHJvdG9jb2wgdjIgcmVzcG9uc2VzIChCaXRidWNrZXQgU2VydmVyIGRvZXNuJ3QgaW5jbHVkZSBhIGAjIHNlcnZpY2U9YCBsaW5lKVxuICBpZiAobGluZU9uZS5pbmNsdWRlcygndmVyc2lvbiAyJykpIHtcbiAgICByZXR1cm4gcGFyc2VDYXBhYmlsaXRpZXNWMihyZWFkKVxuICB9XG5cbiAgLy8gQ2xpZW50cyBNVVNUIGlnbm9yZSBhbiBMRiBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lLlxuICBpZiAobGluZU9uZS50b1N0cmluZygndXRmOCcpLnJlcGxhY2UoL1xcbiQvLCAnJykgIT09IGAjIHNlcnZpY2U9JHtzZXJ2aWNlfWApIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihgIyBzZXJ2aWNlPSR7c2VydmljZX1cXFxcbmAsIGxpbmVPbmUudG9TdHJpbmcoJ3V0ZjgnKSlcbiAgfVxuICBsZXQgbGluZVR3byA9IGF3YWl0IHJlYWQoKTtcbiAgLy8gc2tpcCBwYXN0IGFueSBmbHVzaGVzXG4gIHdoaWxlIChsaW5lVHdvID09PSBudWxsKSBsaW5lVHdvID0gYXdhaXQgcmVhZCgpO1xuICAvLyBJbiB0aGUgZWRnZSBjYXNlIG9mIGEgYnJhbmQgbmV3IHJlcG8sIHplcm8gcmVmcyAoYW5kIHplcm8gY2FwYWJpbGl0aWVzKVxuICAvLyBhcmUgcmV0dXJuZWQuXG4gIGlmIChsaW5lVHdvID09PSB0cnVlKSByZXR1cm4geyBjYXBhYmlsaXRpZXMsIHJlZnMsIHN5bXJlZnMgfVxuICBsaW5lVHdvID0gbGluZVR3by50b1N0cmluZygndXRmOCcpO1xuXG4gIC8vIEhhbmRsZSBwcm90b2NvbCB2MiByZXNwb25zZXNcbiAgaWYgKGxpbmVUd28uaW5jbHVkZXMoJ3ZlcnNpb24gMicpKSB7XG4gICAgcmV0dXJuIHBhcnNlQ2FwYWJpbGl0aWVzVjIocmVhZClcbiAgfVxuXG4gIGNvbnN0IFtmaXJzdFJlZiwgY2FwYWJpbGl0aWVzTGluZV0gPSBzcGxpdEFuZEFzc2VydChsaW5lVHdvLCAnXFx4MDAnLCAnXFxcXHgwMCcpO1xuICBjYXBhYmlsaXRpZXNMaW5lLnNwbGl0KCcgJykubWFwKHggPT4gY2FwYWJpbGl0aWVzLmFkZCh4KSk7XG4gIGNvbnN0IFtyZWYsIG5hbWVdID0gc3BsaXRBbmRBc3NlcnQoZmlyc3RSZWYsICcgJywgJyAnKTtcbiAgcmVmcy5zZXQobmFtZSwgcmVmKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBsaW5lID0gYXdhaXQgcmVhZCgpO1xuICAgIGlmIChsaW5lID09PSB0cnVlKSBicmVha1xuICAgIGlmIChsaW5lICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBbcmVmLCBuYW1lXSA9IHNwbGl0QW5kQXNzZXJ0KGxpbmUudG9TdHJpbmcoJ3V0ZjgnKSwgJyAnLCAnICcpO1xuICAgICAgcmVmcy5zZXQobmFtZSwgcmVmKTtcbiAgICB9XG4gIH1cbiAgLy8gU3ltcmVmcyBhcmUgdGhyb3duIGludG8gdGhlIFwiY2FwYWJpbGl0aWVzXCIgdW5mb3J0dW5hdGVseS5cbiAgZm9yIChjb25zdCBjYXAgb2YgY2FwYWJpbGl0aWVzKSB7XG4gICAgaWYgKGNhcC5zdGFydHNXaXRoKCdzeW1yZWY9JykpIHtcbiAgICAgIGNvbnN0IG0gPSBjYXAubWF0Y2goL3N5bXJlZj0oW146XSspOiguKikvKTtcbiAgICAgIGlmIChtLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBzeW1yZWZzLnNldChtWzFdLCBtWzJdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgcHJvdG9jb2xWZXJzaW9uOiAxLCBjYXBhYmlsaXRpZXMsIHJlZnMsIHN5bXJlZnMgfVxufVxuXG5mdW5jdGlvbiBzcGxpdEFuZEFzc2VydChsaW5lLCBzZXAsIGV4cGVjdGVkKSB7XG4gIGNvbnN0IHNwbGl0ID0gbGluZS50cmltKCkuc3BsaXQoc2VwKTtcbiAgaWYgKHNwbGl0Lmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgYFR3byBzdHJpbmdzIHNlcGFyYXRlZCBieSAnJHtleHBlY3RlZH0nYCxcbiAgICAgIGxpbmUudG9TdHJpbmcoJ3V0ZjgnKVxuICAgIClcbiAgfVxuICByZXR1cm4gc3BsaXRcbn1cblxuLy8gVHJ5IHRvIGFjY29tb2RhdGUga25vd24gQ09SUyBwcm94eSBpbXBsZW1lbnRhdGlvbnM6XG4vLyAtIGh0dHBzOi8vamN1YmljLnBsL3Byb3h5LnBocD8gIDwtLSB1c2VzIHF1ZXJ5IHN0cmluZ1xuLy8gLSBodHRwczovL2NvcnMuaXNvbW9ycGhpYy1naXQub3JnICA8LS0gdXNlcyBwYXRoXG5jb25zdCBjb3JzUHJveGlmeSA9IChjb3JzUHJveHksIHVybCkgPT5cbiAgY29yc1Byb3h5LmVuZHNXaXRoKCc/JylcbiAgICA/IGAke2NvcnNQcm94eX0ke3VybH1gXG4gICAgOiBgJHtjb3JzUHJveHl9LyR7dXJsLnJlcGxhY2UoL15odHRwcz86XFwvXFwvLywgJycpfWA7XG5cbmNvbnN0IHVwZGF0ZUhlYWRlcnMgPSAoaGVhZGVycywgYXV0aCkgPT4ge1xuICAvLyBVcGRhdGUgdGhlIGJhc2ljIGF1dGggaGVhZGVyXG4gIGlmIChhdXRoLnVzZXJuYW1lIHx8IGF1dGgucGFzc3dvcmQpIHtcbiAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBjYWxjdWxhdGVCYXNpY0F1dGhIZWFkZXIoYXV0aCk7XG4gIH1cbiAgLy8gYnV0IGFueSBtYW51YWxseSBwcm92aWRlZCBoZWFkZXJzIHRha2UgcHJlY2VkZW5jZVxuICBpZiAoYXV0aC5oZWFkZXJzKSB7XG4gICAgT2JqZWN0LmFzc2lnbihoZWFkZXJzLCBhdXRoLmhlYWRlcnMpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7R2l0SHR0cFJlc3BvbnNlfSByZXNcbiAqXG4gKiBAcmV0dXJucyB7eyBwcmV2aWV3OiBzdHJpbmcsIHJlc3BvbnNlOiBzdHJpbmcsIGRhdGE6IEJ1ZmZlciB9fVxuICovXG5jb25zdCBzdHJpbmdpZnlCb2R5ID0gYXN5bmMgcmVzID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBTb21lIHNlcnZpY2VzIHByb3ZpZGUgYSBtZWFuaW5nZnVsIGVycm9yIG1lc3NhZ2UgaW4gdGhlIGJvZHkgb2YgNDAzcyBsaWtlIFwidG9rZW4gbGFja3MgdGhlIHNjb3BlcyBuZWNlc3NhcnkgdG8gcGVyZm9ybSB0aGlzIGFjdGlvblwiXG4gICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKGF3YWl0IGNvbGxlY3QocmVzLmJvZHkpKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGRhdGEudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICBjb25zdCBwcmV2aWV3ID1cbiAgICAgIHJlc3BvbnNlLmxlbmd0aCA8IDI1NiA/IHJlc3BvbnNlIDogcmVzcG9uc2Uuc2xpY2UoMCwgMjU2KSArICcuLi4nO1xuICAgIHJldHVybiB7IHByZXZpZXcsIHJlc3BvbnNlLCBkYXRhIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7fVxuICB9XG59O1xuXG5jbGFzcyBHaXRSZW1vdGVIVFRQIHtcbiAgc3RhdGljIGFzeW5jIGNhcGFiaWxpdGllcygpIHtcbiAgICByZXR1cm4gWydkaXNjb3ZlcicsICdjb25uZWN0J11cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICAgKiBAcGFyYW0ge0h0dHBDbGllbnR9IGFyZ3MuaHR0cFxuICAgKiBAcGFyYW0ge1Byb2dyZXNzQ2FsbGJhY2t9IFthcmdzLm9uUHJvZ3Jlc3NdXG4gICAqIEBwYXJhbSB7QXV0aENhbGxiYWNrfSBbYXJncy5vbkF1dGhdXG4gICAqIEBwYXJhbSB7QXV0aEZhaWx1cmVDYWxsYmFja30gW2FyZ3Mub25BdXRoRmFpbHVyZV1cbiAgICogQHBhcmFtIHtBdXRoU3VjY2Vzc0NhbGxiYWNrfSBbYXJncy5vbkF1dGhTdWNjZXNzXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY29yc1Byb3h5XVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXJncy5zZXJ2aWNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnVybFxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIHN0cmluZz59IGFyZ3MuaGVhZGVyc1xuICAgKiBAcGFyYW0gezEgfCAyfSBhcmdzLnByb3RvY29sVmVyc2lvbiAtIEdpdCBQcm90b2NvbCBWZXJzaW9uXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZGlzY292ZXIoe1xuICAgIGh0dHAsXG4gICAgb25Qcm9ncmVzcyxcbiAgICBvbkF1dGgsXG4gICAgb25BdXRoU3VjY2VzcyxcbiAgICBvbkF1dGhGYWlsdXJlLFxuICAgIGNvcnNQcm94eSxcbiAgICBzZXJ2aWNlLFxuICAgIHVybDogX29yaWdVcmwsXG4gICAgaGVhZGVycyxcbiAgICBwcm90b2NvbFZlcnNpb24sXG4gIH0pIHtcbiAgICBsZXQgeyB1cmwsIGF1dGggfSA9IGV4dHJhY3RBdXRoRnJvbVVybChfb3JpZ1VybCk7XG4gICAgY29uc3QgcHJveGlmaWVkVVJMID0gY29yc1Byb3h5ID8gY29yc1Byb3hpZnkoY29yc1Byb3h5LCB1cmwpIDogdXJsO1xuICAgIGlmIChhdXRoLnVzZXJuYW1lIHx8IGF1dGgucGFzc3dvcmQpIHtcbiAgICAgIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGNhbGN1bGF0ZUJhc2ljQXV0aEhlYWRlcihhdXRoKTtcbiAgICB9XG4gICAgaWYgKHByb3RvY29sVmVyc2lvbiA9PT0gMikge1xuICAgICAgaGVhZGVyc1snR2l0LVByb3RvY29sJ10gPSAndmVyc2lvbj0yJztcbiAgICB9XG5cbiAgICBsZXQgcmVzO1xuICAgIGxldCB0cnlBZ2FpbjtcbiAgICBsZXQgcHJvdmlkZWRBdXRoQmVmb3JlID0gZmFsc2U7XG4gICAgZG8ge1xuICAgICAgcmVzID0gYXdhaXQgaHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgb25Qcm9ncmVzcyxcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgdXJsOiBgJHtwcm94aWZpZWRVUkx9L2luZm8vcmVmcz9zZXJ2aWNlPSR7c2VydmljZX1gLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIHRoZSBkZWZhdWx0IGxvb3AgYmVoYXZpb3JcbiAgICAgIHRyeUFnYWluID0gZmFsc2U7XG5cbiAgICAgIC8vIDQwMSBpcyB0aGUgXCJjb3JyZWN0XCIgcmVzcG9uc2UgZm9yIGFjY2VzcyBkZW5pZWQuIDIwMyBpcyBOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvbiBhbmQgY29tZXMgZnJvbSBBenVyZSBEZXZPcHMsIHdoaWNoXG4gICAgICAvLyBhcHBhcmVudGx5IGRvZXNuJ3QgcmVhbGl6ZSB0aGlzIGlzIGEgZ2l0IHJlcXVlc3QgYW5kIGlzIHJldHVybmluZyB0aGUgSFRNTCBmb3IgdGhlIFwiQXp1cmUgRGV2T3BzIFNlcnZpY2VzIHwgU2lnbiBJblwiIHBhZ2UuXG4gICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPT09IDQwMSB8fCByZXMuc3RhdHVzQ29kZSA9PT0gMjAzKSB7XG4gICAgICAgIC8vIE9uIHN1YnNlcXVlbnQgNDAxcywgY2FsbCBgb25BdXRoRmFpbHVyZWAgaW5zdGVhZCBvZiBgb25BdXRoYC5cbiAgICAgICAgLy8gVGhpcyBpcyBzbyB0aGF0IG5haXZlIGBvbkF1dGhgIGNhbGxiYWNrcyB0aGF0IHJldHVybiBhIGZpeGVkIHZhbHVlIGRvbid0IGNyZWF0ZSBhbiBpbmZpbml0ZSBsb29wIG9mIHJldHJ5aW5nLlxuICAgICAgICBjb25zdCBnZXRBdXRoID0gcHJvdmlkZWRBdXRoQmVmb3JlID8gb25BdXRoRmFpbHVyZSA6IG9uQXV0aDtcbiAgICAgICAgaWYgKGdldEF1dGgpIHtcbiAgICAgICAgICAvLyBBY3F1aXJlIGNyZWRlbnRpYWxzIGFuZCB0cnkgYWdhaW5cbiAgICAgICAgICAvLyBUT0RPOiByZWFkIGB1c2VIdHRwUGF0aGAgdmFsdWUgZnJvbSBnaXQgY29uZmlnIGFuZCBwYXNzIGFsb25nP1xuICAgICAgICAgIGF1dGggPSBhd2FpdCBnZXRBdXRoKHVybCwge1xuICAgICAgICAgICAgLi4uYXV0aCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgLi4uaGVhZGVycyB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChhdXRoICYmIGF1dGguY2FuY2VsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVXNlckNhbmNlbGVkRXJyb3IoKVxuICAgICAgICAgIH0gZWxzZSBpZiAoYXV0aCkge1xuICAgICAgICAgICAgdXBkYXRlSGVhZGVycyhoZWFkZXJzLCBhdXRoKTtcbiAgICAgICAgICAgIHByb3ZpZGVkQXV0aEJlZm9yZSA9IHRydWU7XG4gICAgICAgICAgICB0cnlBZ2FpbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICByZXMuc3RhdHVzQ29kZSA9PT0gMjAwICYmXG4gICAgICAgIHByb3ZpZGVkQXV0aEJlZm9yZSAmJlxuICAgICAgICBvbkF1dGhTdWNjZXNzXG4gICAgICApIHtcbiAgICAgICAgYXdhaXQgb25BdXRoU3VjY2Vzcyh1cmwsIGF1dGgpO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRyeUFnYWluKVxuXG4gICAgaWYgKHJlcy5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgIGNvbnN0IHsgcmVzcG9uc2UgfSA9IGF3YWl0IHN0cmluZ2lmeUJvZHkocmVzKTtcbiAgICAgIHRocm93IG5ldyBIdHRwRXJyb3IocmVzLnN0YXR1c0NvZGUsIHJlcy5zdGF0dXNNZXNzYWdlLCByZXNwb25zZSlcbiAgICB9XG4gICAgLy8gR2l0IFwic21hcnRcIiBIVFRQIHNlcnZlcnMgc2hvdWxkIHJlc3BvbmQgd2l0aCB0aGUgY29ycmVjdCBDb250ZW50LVR5cGUgaGVhZGVyLlxuICAgIGlmIChcbiAgICAgIHJlcy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9PT0gYGFwcGxpY2F0aW9uL3gtJHtzZXJ2aWNlfS1hZHZlcnRpc2VtZW50YFxuICAgICkge1xuICAgICAgY29uc3QgcmVtb3RlSFRUUCA9IGF3YWl0IHBhcnNlUmVmc0FkUmVzcG9uc2UocmVzLmJvZHksIHsgc2VydmljZSB9KTtcbiAgICAgIHJlbW90ZUhUVFAuYXV0aCA9IGF1dGg7XG4gICAgICByZXR1cm4gcmVtb3RlSFRUUFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGV5IGRvbid0IHNlbmQgdGhlIGNvcnJlY3QgY29udGVudC10eXBlIGhlYWRlciwgdGhhdCdzIGEgZ29vZCBpbmRpY2F0b3IgaXQgaXMgZWl0aGVyIGEgXCJkdW1iXCIgSFRUUFxuICAgICAgLy8gc2VydmVyLCBvciB0aGUgdXNlciBzcGVjaWZpZWQgYW4gaW5jb3JyZWN0IHJlbW90ZSBVUkwgYW5kIHRoZSByZXNwb25zZSBpcyBhY3R1YWxseSBhbiBIVE1MIHBhZ2UuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIHNhdmUgdGhlIHJlc3BvbnNlIGFzIHBsYWluIHRleHQgc28gd2UgY2FuIGdlbmVyYXRlIGEgYmV0dGVyIGVycm9yIG1lc3NhZ2UgaWYgbmVlZGVkLlxuICAgICAgY29uc3QgeyBwcmV2aWV3LCByZXNwb25zZSwgZGF0YSB9ID0gYXdhaXQgc3RyaW5naWZ5Qm9keShyZXMpO1xuICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LCB0cnkgdG8gcGFyc2UgaXQgYW55d2F5LlxuICAgICAgLy8gVE9ETzogbWF5YmUganVzdCB0aHJvdyBpbnN0ZWFkIG9mIHRyeWluZz9cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlbW90ZUhUVFAgPSBhd2FpdCBwYXJzZVJlZnNBZFJlc3BvbnNlKFtkYXRhXSwgeyBzZXJ2aWNlIH0pO1xuICAgICAgICByZW1vdGVIVFRQLmF1dGggPSBhdXRoO1xuICAgICAgICByZXR1cm4gcmVtb3RlSFRUUFxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgU21hcnRIdHRwRXJyb3IocHJldmlldywgcmVzcG9uc2UpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gICAqIEBwYXJhbSB7SHR0cENsaWVudH0gYXJncy5odHRwXG4gICAqIEBwYXJhbSB7UHJvZ3Jlc3NDYWxsYmFja30gW2FyZ3Mub25Qcm9ncmVzc11cbiAgICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvcnNQcm94eV1cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Muc2VydmljZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXJncy51cmxcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbYXJncy5oZWFkZXJzXVxuICAgKiBAcGFyYW0ge2FueX0gYXJncy5ib2R5XG4gICAqIEBwYXJhbSB7YW55fSBhcmdzLmF1dGhcbiAgICovXG4gIHN0YXRpYyBhc3luYyBjb25uZWN0KHtcbiAgICBodHRwLFxuICAgIG9uUHJvZ3Jlc3MsXG4gICAgY29yc1Byb3h5LFxuICAgIHNlcnZpY2UsXG4gICAgdXJsLFxuICAgIGF1dGgsXG4gICAgYm9keSxcbiAgICBoZWFkZXJzLFxuICB9KSB7XG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIHRoZSBcImNvcnJlY3RcIiBhdXRoIHZhbHVlIGF0IHRoaXMgcG9pbnQsIGJ1dFxuICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IHRoZSB1c2VybmFtZS9wYXNzd29yZCBmcm9tIHRoZSBVUkwgeWV0IGFnYWluLlxuICAgIGNvbnN0IHVybEF1dGggPSBleHRyYWN0QXV0aEZyb21VcmwodXJsKTtcbiAgICBpZiAodXJsQXV0aCkgdXJsID0gdXJsQXV0aC51cmw7XG5cbiAgICBpZiAoY29yc1Byb3h5KSB1cmwgPSBjb3JzUHJveGlmeShjb3JzUHJveHksIHVybCk7XG5cbiAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IGBhcHBsaWNhdGlvbi94LSR7c2VydmljZX0tcmVxdWVzdGA7XG4gICAgaGVhZGVycy5hY2NlcHQgPSBgYXBwbGljYXRpb24veC0ke3NlcnZpY2V9LXJlc3VsdGA7XG4gICAgdXBkYXRlSGVhZGVycyhoZWFkZXJzLCBhdXRoKTtcblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHAucmVxdWVzdCh7XG4gICAgICBvblByb2dyZXNzLFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB1cmw6IGAke3VybH0vJHtzZXJ2aWNlfWAsXG4gICAgICBib2R5LFxuICAgICAgaGVhZGVycyxcbiAgICB9KTtcbiAgICBpZiAocmVzLnN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgY29uc3QgeyByZXNwb25zZSB9ID0gc3RyaW5naWZ5Qm9keShyZXMpO1xuICAgICAgdGhyb3cgbmV3IEh0dHBFcnJvcihyZXMuc3RhdHVzQ29kZSwgcmVzLnN0YXR1c01lc3NhZ2UsIHJlc3BvbnNlKVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VSZW1vdGVVcmwoeyB1cmwgfSkge1xuICAvLyB0aGUgc3R1cGlkIFwic2hvcnRlciBzY3AtbGlrZSBzeW50YXhcIlxuICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2dpdEAnKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc3BvcnQ6ICdzc2gnLFxuICAgICAgYWRkcmVzczogdXJsLFxuICAgIH1cbiAgfVxuICBjb25zdCBtYXRjaGVzID0gdXJsLm1hdGNoKC8oXFx3KykoOlxcL1xcL3w6OikoLiopLyk7XG4gIGlmIChtYXRjaGVzID09PSBudWxsKSByZXR1cm5cbiAgLypcbiAgICogV2hlbiBnaXQgZW5jb3VudGVycyBhIFVSTCBvZiB0aGUgZm9ybSA8dHJhbnNwb3J0PjovLzxhZGRyZXNzPiwgd2hlcmUgPHRyYW5zcG9ydD4gaXNcbiAgICogYSBwcm90b2NvbCB0aGF0IGl0IGNhbm5vdCBoYW5kbGUgbmF0aXZlbHksIGl0IGF1dG9tYXRpY2FsbHkgaW52b2tlcyBnaXQgcmVtb3RlLTx0cmFuc3BvcnQ+XG4gICAqIHdpdGggdGhlIGZ1bGwgVVJMIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1yZW1vdGUtaGVscGVyc1xuICAgKi9cbiAgaWYgKG1hdGNoZXNbMl0gPT09ICc6Ly8nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYW5zcG9ydDogbWF0Y2hlc1sxXSxcbiAgICAgIGFkZHJlc3M6IG1hdGNoZXNbMF0sXG4gICAgfVxuICB9XG4gIC8qXG4gICAqIEEgVVJMIG9mIHRoZSBmb3JtIDx0cmFuc3BvcnQ+Ojo8YWRkcmVzcz4gZXhwbGljaXRseSBpbnN0cnVjdHMgZ2l0IHRvIGludm9rZVxuICAgKiBnaXQgcmVtb3RlLTx0cmFuc3BvcnQ+IHdpdGggPGFkZHJlc3M+IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1yZW1vdGUtaGVscGVyc1xuICAgKi9cbiAgaWYgKG1hdGNoZXNbMl0gPT09ICc6OicpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNwb3J0OiBtYXRjaGVzWzFdLFxuICAgICAgYWRkcmVzczogbWF0Y2hlc1szXSxcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgR2l0UmVtb3RlTWFuYWdlciB7XG4gIHN0YXRpYyBnZXRSZW1vdGVIZWxwZXJGb3IoeyB1cmwgfSkge1xuICAgIC8vIFRPRE86IGNsZWFuIHVwIHRoZSByZW1vdGVIZWxwZXIgQVBJIGFuZCBtb3ZlIGludG8gUGx1Z2luQ29yZVxuICAgIGNvbnN0IHJlbW90ZUhlbHBlcnMgPSBuZXcgTWFwKCk7XG4gICAgcmVtb3RlSGVscGVycy5zZXQoJ2h0dHAnLCBHaXRSZW1vdGVIVFRQKTtcbiAgICByZW1vdGVIZWxwZXJzLnNldCgnaHR0cHMnLCBHaXRSZW1vdGVIVFRQKTtcblxuICAgIGNvbnN0IHBhcnRzID0gcGFyc2VSZW1vdGVVcmwoeyB1cmwgfSk7XG4gICAgaWYgKCFwYXJ0cykge1xuICAgICAgdGhyb3cgbmV3IFVybFBhcnNlRXJyb3IodXJsKVxuICAgIH1cbiAgICBpZiAocmVtb3RlSGVscGVycy5oYXMocGFydHMudHJhbnNwb3J0KSkge1xuICAgICAgcmV0dXJuIHJlbW90ZUhlbHBlcnMuZ2V0KHBhcnRzLnRyYW5zcG9ydClcbiAgICB9XG4gICAgdGhyb3cgbmV3IFVua25vd25UcmFuc3BvcnRFcnJvcihcbiAgICAgIHVybCxcbiAgICAgIHBhcnRzLnRyYW5zcG9ydCxcbiAgICAgIHBhcnRzLnRyYW5zcG9ydCA9PT0gJ3NzaCcgPyB0cmFuc2xhdGVTU0h0b0hUVFAodXJsKSA6IHVuZGVmaW5lZFxuICAgIClcbiAgfVxufVxuXG5sZXQgbG9jayQxID0gbnVsbDtcblxuY2xhc3MgR2l0U2hhbGxvd01hbmFnZXIge1xuICBzdGF0aWMgYXN5bmMgcmVhZCh7IGZzLCBnaXRkaXIgfSkge1xuICAgIGlmIChsb2NrJDEgPT09IG51bGwpIGxvY2skMSA9IG5ldyBBc3luY0xvY2soKTtcbiAgICBjb25zdCBmaWxlcGF0aCA9IGpvaW4oZ2l0ZGlyLCAnc2hhbGxvdycpO1xuICAgIGNvbnN0IG9pZHMgPSBuZXcgU2V0KCk7XG4gICAgYXdhaXQgbG9jayQxLmFjcXVpcmUoZmlsZXBhdGgsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IGZzLnJlYWQoZmlsZXBhdGgsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KTtcbiAgICAgIGlmICh0ZXh0ID09PSBudWxsKSByZXR1cm4gb2lkcyAvLyBubyBmaWxlXG4gICAgICBpZiAodGV4dC50cmltKCkgPT09ICcnKSByZXR1cm4gb2lkcyAvLyBlbXB0eSBmaWxlXG4gICAgICB0ZXh0XG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKG9pZCA9PiBvaWRzLmFkZChvaWQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2lkc1xuICB9XG5cbiAgc3RhdGljIGFzeW5jIHdyaXRlKHsgZnMsIGdpdGRpciwgb2lkcyB9KSB7XG4gICAgaWYgKGxvY2skMSA9PT0gbnVsbCkgbG9jayQxID0gbmV3IEFzeW5jTG9jaygpO1xuICAgIGNvbnN0IGZpbGVwYXRoID0gam9pbihnaXRkaXIsICdzaGFsbG93Jyk7XG4gICAgaWYgKG9pZHMuc2l6ZSA+IDApIHtcbiAgICAgIGNvbnN0IHRleHQgPSBbLi4ub2lkc10uam9pbignXFxuJykgKyAnXFxuJztcbiAgICAgIGF3YWl0IGxvY2skMS5hY3F1aXJlKGZpbGVwYXRoLCBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgICAgYXdhaXQgZnMud3JpdGUoZmlsZXBhdGgsIHRleHQsIHtcbiAgICAgICAgICBlbmNvZGluZzogJ3V0ZjgnLFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBzaGFsbG93c1xuICAgICAgYXdhaXQgbG9jayQxLmFjcXVpcmUoZmlsZXBhdGgsIGFzeW5jIGZ1bmN0aW9uKCkge1xuICAgICAgICBhd2FpdCBmcy5ybShmaWxlcGF0aCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFzT2JqZWN0TG9vc2UoeyBmcywgZ2l0ZGlyLCBvaWQgfSkge1xuICBjb25zdCBzb3VyY2UgPSBgb2JqZWN0cy8ke29pZC5zbGljZSgwLCAyKX0vJHtvaWQuc2xpY2UoMil9YDtcbiAgcmV0dXJuIGZzLmV4aXN0cyhgJHtnaXRkaXJ9LyR7c291cmNlfWApXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhc09iamVjdFBhY2tlZCh7XG4gIGZzLFxuICBjYWNoZSxcbiAgZ2l0ZGlyLFxuICBvaWQsXG4gIGdldEV4dGVybmFsUmVmRGVsdGEsXG59KSB7XG4gIC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIGluIGEgcGFja2ZpbGUuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgdGhlIC5pZHggZmlsZXNcbiAgbGV0IGxpc3QgPSBhd2FpdCBmcy5yZWFkZGlyKGpvaW4oZ2l0ZGlyLCAnb2JqZWN0cy9wYWNrJykpO1xuICBsaXN0ID0gbGlzdC5maWx0ZXIoeCA9PiB4LmVuZHNXaXRoKCcuaWR4JykpO1xuICBmb3IgKGNvbnN0IGZpbGVuYW1lIG9mIGxpc3QpIHtcbiAgICBjb25zdCBpbmRleEZpbGUgPSBgJHtnaXRkaXJ9L29iamVjdHMvcGFjay8ke2ZpbGVuYW1lfWA7XG4gICAgY29uc3QgcCA9IGF3YWl0IHJlYWRQYWNrSW5kZXgoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGZpbGVuYW1lOiBpbmRleEZpbGUsXG4gICAgICBnZXRFeHRlcm5hbFJlZkRlbHRhLFxuICAgIH0pO1xuICAgIGlmIChwLmVycm9yKSB0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihwLmVycm9yKVxuICAgIC8vIElmIHRoZSBwYWNrZmlsZSBET0VTIGhhdmUgdGhlIG9pZCB3ZSdyZSBsb29raW5nIGZvci4uLlxuICAgIGlmIChwLm9mZnNldHMuaGFzKG9pZCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8vIEZhaWxlZCB0byBmaW5kIGl0XG4gIHJldHVybiBmYWxzZVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYXNPYmplY3Qoe1xuICBmcyxcbiAgY2FjaGUsXG4gIGdpdGRpcixcbiAgb2lkLFxuICBmb3JtYXQgPSAnY29udGVudCcsXG59KSB7XG4gIC8vIEN1cnJ5IHRoZSBjdXJyZW50IHJlYWQgbWV0aG9kIHNvIHRoYXQgdGhlIHBhY2tmaWxlIHVuLWRlbHRpZmljYXRpb25cbiAgLy8gcHJvY2VzcyBjYW4gYWNxdWlyZSBleHRlcm5hbCByZWYtZGVsdGFzLlxuICBjb25zdCBnZXRFeHRlcm5hbFJlZkRlbHRhID0gb2lkID0+IF9yZWFkT2JqZWN0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcblxuICAvLyBMb29rIGZvciBpdCBpbiB0aGUgbG9vc2Ugb2JqZWN0IGRpcmVjdG9yeS5cbiAgbGV0IHJlc3VsdCA9IGF3YWl0IGhhc09iamVjdExvb3NlKHsgZnMsIGdpdGRpciwgb2lkIH0pO1xuICAvLyBDaGVjayB0byBzZWUgaWYgaXQncyBpbiBhIHBhY2tmaWxlLlxuICBpZiAoIXJlc3VsdCkge1xuICAgIHJlc3VsdCA9IGF3YWl0IGhhc09iamVjdFBhY2tlZCh7XG4gICAgICBmcyxcbiAgICAgIGNhY2hlLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgb2lkLFxuICAgICAgZ2V0RXh0ZXJuYWxSZWZEZWx0YSxcbiAgICB9KTtcbiAgfVxuICAvLyBGaW5hbGx5XG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gVE9ETzogbWFrZSBhIGZ1bmN0aW9uIHRoYXQganVzdCByZXR1cm5zIG9iQ291bnQuIHRoZW4gZW1wdHlQYWNrZmlsZSA9ICgpID0+IHNpemVQYWNrKHBhY2spID09PSAwXG5mdW5jdGlvbiBlbXB0eVBhY2tmaWxlKHBhY2spIHtcbiAgY29uc3QgcGhlYWRlciA9ICc1MDQxNDM0Yic7XG4gIGNvbnN0IHZlcnNpb24gPSAnMDAwMDAwMDInO1xuICBjb25zdCBvYkNvdW50ID0gJzAwMDAwMDAwJztcbiAgY29uc3QgaGVhZGVyID0gcGhlYWRlciArIHZlcnNpb24gKyBvYkNvdW50O1xuICByZXR1cm4gcGFjay5zbGljZSgwLCAxMikudG9TdHJpbmcoJ2hleCcpID09PSBoZWFkZXJcbn1cblxuZnVuY3Rpb24gZmlsdGVyQ2FwYWJpbGl0aWVzKHNlcnZlciwgY2xpZW50KSB7XG4gIGNvbnN0IHNlcnZlck5hbWVzID0gc2VydmVyLm1hcChjYXAgPT4gY2FwLnNwbGl0KCc9JywgMSlbMF0pO1xuICByZXR1cm4gY2xpZW50LmZpbHRlcihjYXAgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBjYXAuc3BsaXQoJz0nLCAxKVswXTtcbiAgICByZXR1cm4gc2VydmVyTmFtZXMuaW5jbHVkZXMobmFtZSlcbiAgfSlcbn1cblxuY29uc3QgcGtnID0ge1xuICBuYW1lOiAnaXNvbW9ycGhpYy1naXQnLFxuICB2ZXJzaW9uOiAnMS4xMS4xJyxcbiAgYWdlbnQ6ICdnaXQvaXNvbW9ycGhpYy1naXRAMS4xMS4xJyxcbn07XG5cbmNsYXNzIEZJRk8ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICB9XG5cbiAgd3JpdGUoY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZW5kZWQpIHtcbiAgICAgIHRocm93IEVycm9yKCdZb3UgY2Fubm90IHdyaXRlIHRvIGEgRklGTyB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZW5kZWQhJylcbiAgICB9XG4gICAgaWYgKHRoaXMuX3dhaXRpbmcpIHtcbiAgICAgIGNvbnN0IHJlc29sdmUgPSB0aGlzLl93YWl0aW5nO1xuICAgICAgdGhpcy5fd2FpdGluZyA9IG51bGw7XG4gICAgICByZXNvbHZlKHsgdmFsdWU6IGNodW5rIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZS5wdXNoKGNodW5rKTtcbiAgICB9XG4gIH1cblxuICBlbmQoKSB7XG4gICAgdGhpcy5fZW5kZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLl93YWl0aW5nKSB7XG4gICAgICBjb25zdCByZXNvbHZlID0gdGhpcy5fd2FpdGluZztcbiAgICAgIHRoaXMuX3dhaXRpbmcgPSBudWxsO1xuICAgICAgcmVzb2x2ZSh7IGRvbmU6IHRydWUgfSk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveShlcnIpIHtcbiAgICB0aGlzLl9lbmRlZCA9IHRydWU7XG4gICAgdGhpcy5lcnJvciA9IGVycjtcbiAgfVxuXG4gIGFzeW5jIG5leHQoKSB7XG4gICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB7IHZhbHVlOiB0aGlzLl9xdWV1ZS5zaGlmdCgpIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX2VuZGVkKSB7XG4gICAgICByZXR1cm4geyBkb25lOiB0cnVlIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuX3dhaXRpbmcpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAnWW91IGNhbm5vdCBjYWxsIHJlYWQgdW50aWwgdGhlIHByZXZpb3VzIGNhbGwgdG8gcmVhZCBoYXMgcmV0dXJuZWQhJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLl93YWl0aW5nID0gcmVzb2x2ZTtcbiAgICB9KVxuICB9XG59XG5cbi8vIE5vdGU6IHByb2dyZXNzIG1lc3NhZ2VzIGFyZSBkZXNpZ25lZCB0byBiZSB3cml0dGVuIGRpcmVjdGx5IHRvIHRoZSB0ZXJtaW5hbCxcbi8vIHNvIHRoZXkgYXJlIG9mdGVuIHNlbnQgd2l0aCBqdXN0IGEgY2FycmlhZ2UgcmV0dXJuIHRvIG92ZXJ3cml0ZSB0aGUgbGFzdCBsaW5lIG9mIG91dHB1dC5cbi8vIEJ1dCB0aGVyZSBhcmUgYWxzbyBtZXNzYWdlcyBkZWxpbWl0ZWQgd2l0aCBuZXdsaW5lcy5cbi8vIEkgYWxzbyBpbmNsdWRlIENSTEYganVzdCBpbiBjYXNlLlxuZnVuY3Rpb24gZmluZFNwbGl0KHN0cikge1xuICBjb25zdCByID0gc3RyLmluZGV4T2YoJ1xccicpO1xuICBjb25zdCBuID0gc3RyLmluZGV4T2YoJ1xcbicpO1xuICBpZiAociA9PT0gLTEgJiYgbiA9PT0gLTEpIHJldHVybiAtMVxuICBpZiAociA9PT0gLTEpIHJldHVybiBuICsgMSAvLyBcXG5cbiAgaWYgKG4gPT09IC0xKSByZXR1cm4gciArIDEgLy8gXFxyXG4gIGlmIChuID09PSByICsgMSkgcmV0dXJuIG4gKyAxIC8vIFxcclxcblxuICByZXR1cm4gTWF0aC5taW4ociwgbikgKyAxIC8vIFxcciBvciBcXG5cbn1cblxuZnVuY3Rpb24gc3BsaXRMaW5lcyhpbnB1dCkge1xuICBjb25zdCBvdXRwdXQgPSBuZXcgRklGTygpO1xuICBsZXQgdG1wID0gJydcbiAgOyhhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZm9yQXdhaXQoaW5wdXQsIGNodW5rID0+IHtcbiAgICAgIGNodW5rID0gY2h1bmsudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgICAgIHRtcCArPSBjaHVuaztcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGkgPSBmaW5kU3BsaXQodG1wKTtcbiAgICAgICAgaWYgKGkgPT09IC0xKSBicmVha1xuICAgICAgICBvdXRwdXQud3JpdGUodG1wLnNsaWNlKDAsIGkpKTtcbiAgICAgICAgdG1wID0gdG1wLnNsaWNlKGkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0bXAubGVuZ3RoID4gMCkge1xuICAgICAgb3V0cHV0LndyaXRlKHRtcCk7XG4gICAgfVxuICAgIG91dHB1dC5lbmQoKTtcbiAgfSkoKTtcbiAgcmV0dXJuIG91dHB1dFxufVxuXG4vKlxuSWYgJ3NpZGUtYmFuZCcgb3IgJ3NpZGUtYmFuZC02NGsnIGNhcGFiaWxpdGllcyBoYXZlIGJlZW4gc3BlY2lmaWVkIGJ5XG50aGUgY2xpZW50LCB0aGUgc2VydmVyIHdpbGwgc2VuZCB0aGUgcGFja2ZpbGUgZGF0YSBtdWx0aXBsZXhlZC5cblxuRWFjaCBwYWNrZXQgc3RhcnRpbmcgd2l0aCB0aGUgcGFja2V0LWxpbmUgbGVuZ3RoIG9mIHRoZSBhbW91bnQgb2YgZGF0YVxudGhhdCBmb2xsb3dzLCBmb2xsb3dlZCBieSBhIHNpbmdsZSBieXRlIHNwZWNpZnlpbmcgdGhlIHNpZGViYW5kIHRoZVxuZm9sbG93aW5nIGRhdGEgaXMgY29taW5nIGluIG9uLlxuXG5JbiAnc2lkZS1iYW5kJyBtb2RlLCBpdCB3aWxsIHNlbmQgdXAgdG8gOTk5IGRhdGEgYnl0ZXMgcGx1cyAxIGNvbnRyb2xcbmNvZGUsIGZvciBhIHRvdGFsIG9mIHVwIHRvIDEwMDAgYnl0ZXMgaW4gYSBwa3QtbGluZS4gIEluICdzaWRlLWJhbmQtNjRrJ1xubW9kZSBpdCB3aWxsIHNlbmQgdXAgdG8gNjU1MTkgZGF0YSBieXRlcyBwbHVzIDEgY29udHJvbCBjb2RlLCBmb3IgYVxudG90YWwgb2YgdXAgdG8gNjU1MjAgYnl0ZXMgaW4gYSBwa3QtbGluZS5cblxuVGhlIHNpZGViYW5kIGJ5dGUgd2lsbCBiZSBhICcxJywgJzInIG9yIGEgJzMnLiBTaWRlYmFuZCAnMScgd2lsbCBjb250YWluXG5wYWNrZmlsZSBkYXRhLCBzaWRlYmFuZCAnMicgd2lsbCBiZSB1c2VkIGZvciBwcm9ncmVzcyBpbmZvcm1hdGlvbiB0aGF0IHRoZVxuY2xpZW50IHdpbGwgZ2VuZXJhbGx5IHByaW50IHRvIHN0ZGVyciBhbmQgc2lkZWJhbmQgJzMnIGlzIHVzZWQgZm9yIGVycm9yXG5pbmZvcm1hdGlvbi5cblxuSWYgbm8gJ3NpZGUtYmFuZCcgY2FwYWJpbGl0eSB3YXMgc3BlY2lmaWVkLCB0aGUgc2VydmVyIHdpbGwgc3RyZWFtIHRoZVxuZW50aXJlIHBhY2tmaWxlIHdpdGhvdXQgbXVsdGlwbGV4aW5nLlxuKi9cblxuY2xhc3MgR2l0U2lkZUJhbmQge1xuICBzdGF0aWMgZGVtdXgoaW5wdXQpIHtcbiAgICBjb25zdCByZWFkID0gR2l0UGt0TGluZS5zdHJlYW1SZWFkZXIoaW5wdXQpO1xuICAgIC8vIEFuZCBub3cgZm9yIHRoZSByaWRpY3Vsb3VzIHNpZGUtYmFuZCBvciBzaWRlLWJhbmQtNjRrIHByb3RvY29sXG4gICAgY29uc3QgcGFja2V0bGluZXMgPSBuZXcgRklGTygpO1xuICAgIGNvbnN0IHBhY2tmaWxlID0gbmV3IEZJRk8oKTtcbiAgICBjb25zdCBwcm9ncmVzcyA9IG5ldyBGSUZPKCk7XG4gICAgLy8gVE9ETzogVXNlIGEgcHJvcGVyIHRocm91Z2ggc3RyZWFtP1xuICAgIGNvbnN0IG5leHRCaXQgPSBhc3luYyBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBhd2FpdCByZWFkKCk7XG4gICAgICAvLyBTa2lwIG92ZXIgZmx1c2ggcGFja2V0c1xuICAgICAgaWYgKGxpbmUgPT09IG51bGwpIHJldHVybiBuZXh0Qml0KClcbiAgICAgIC8vIEEgbWFkZSB1cCBjb252ZW50aW9uIHRvIHNpZ25hbCB0aGVyZSdzIG5vIG1vcmUgdG8gcmVhZC5cbiAgICAgIGlmIChsaW5lID09PSB0cnVlKSB7XG4gICAgICAgIHBhY2tldGxpbmVzLmVuZCgpO1xuICAgICAgICBwcm9ncmVzcy5lbmQoKTtcbiAgICAgICAgcGFja2ZpbGUuZW5kKCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gRXhhbWluZSBmaXJzdCBieXRlIHRvIGRldGVybWluZSB3aGljaCBvdXRwdXQgXCJzdHJlYW1cIiB0byB1c2VcbiAgICAgIHN3aXRjaCAobGluZVswXSkge1xuICAgICAgICBjYXNlIDE6IHtcbiAgICAgICAgICAvLyBwYWNrIGRhdGFcbiAgICAgICAgICBwYWNrZmlsZS53cml0ZShsaW5lLnNsaWNlKDEpKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjoge1xuICAgICAgICAgIC8vIHByb2dyZXNzIG1lc3NhZ2VcbiAgICAgICAgICBwcm9ncmVzcy53cml0ZShsaW5lLnNsaWNlKDEpKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgIC8vIGZhdGFsIGVycm9yIG1lc3NhZ2UganVzdCBiZWZvcmUgc3RyZWFtIGFib3J0c1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gbGluZS5zbGljZSgxKTtcbiAgICAgICAgICBwcm9ncmVzcy53cml0ZShlcnJvcik7XG4gICAgICAgICAgcGFja2ZpbGUuZGVzdHJveShuZXcgRXJyb3IoZXJyb3IudG9TdHJpbmcoJ3V0ZjgnKSkpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAvLyBOb3QgcGFydCBvZiB0aGUgc2lkZS1iYW5kLTY0ayBwcm90b2NvbFxuICAgICAgICAgIHBhY2tldGxpbmVzLndyaXRlKGxpbmUuc2xpY2UoMCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDYXJlZnVsIG5vdCB0byBibG93IHVwIHRoZSBzdGFjay5cbiAgICAgIC8vIEkgdGhpbmsgUHJvbWlzZXMgaW4gYSB0YWlsLWNhbGwgcG9zaXRpb24gc2hvdWxkIGJlIE9LLlxuICAgICAgbmV4dEJpdCgpO1xuICAgIH07XG4gICAgbmV4dEJpdCgpO1xuICAgIHJldHVybiB7XG4gICAgICBwYWNrZXRsaW5lcyxcbiAgICAgIHBhY2tmaWxlLFxuICAgICAgcHJvZ3Jlc3MsXG4gICAgfVxuICB9XG4gIC8vIHN0YXRpYyBtdXggKHtcbiAgLy8gICBwcm90b2NvbCwgLy8gJ3NpZGUtYmFuZCcgb3IgJ3NpZGUtYmFuZC02NGsnXG4gIC8vICAgcGFja2V0bGluZXMsXG4gIC8vICAgcGFja2ZpbGUsXG4gIC8vICAgcHJvZ3Jlc3MsXG4gIC8vICAgZXJyb3JcbiAgLy8gfSkge1xuICAvLyAgIGNvbnN0IE1BWF9QQUNLRVRfTEVOR1RIID0gcHJvdG9jb2wgPT09ICdzaWRlLWJhbmQtNjRrJyA/IDk5OSA6IDY1NTE5XG4gIC8vICAgbGV0IG91dHB1dCA9IG5ldyBQYXNzVGhyb3VnaCgpXG4gIC8vICAgcGFja2V0bGluZXMub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgLy8gICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gIC8vICAgICAgIG91dHB1dC53cml0ZShHaXRQa3RMaW5lLmZsdXNoKCkpXG4gIC8vICAgICB9IGVsc2Uge1xuICAvLyAgICAgICBvdXRwdXQud3JpdGUoR2l0UGt0TGluZS5lbmNvZGUoZGF0YSkpXG4gIC8vICAgICB9XG4gIC8vICAgfSlcbiAgLy8gICBsZXQgcGFja2ZpbGVXYXNFbXB0eSA9IHRydWVcbiAgLy8gICBsZXQgcGFja2ZpbGVFbmRlZCA9IGZhbHNlXG4gIC8vICAgbGV0IHByb2dyZXNzRW5kZWQgPSBmYWxzZVxuICAvLyAgIGxldCBlcnJvckVuZGVkID0gZmFsc2VcbiAgLy8gICBsZXQgZ29vZGJ5ZSA9IEJ1ZmZlci5jb25jYXQoW1xuICAvLyAgICAgR2l0UGt0TGluZS5lbmNvZGUoQnVmZmVyLmZyb20oJzAxMEEnLCAnaGV4JykpLFxuICAvLyAgICAgR2l0UGt0TGluZS5mbHVzaCgpXG4gIC8vICAgXSlcbiAgLy8gICBwYWNrZmlsZVxuICAvLyAgICAgLm9uKCdkYXRhJywgZGF0YSA9PiB7XG4gIC8vICAgICAgIHBhY2tmaWxlV2FzRW1wdHkgPSBmYWxzZVxuICAvLyAgICAgICBjb25zdCBidWZmZXJzID0gc3BsaXRCdWZmZXIoZGF0YSwgTUFYX1BBQ0tFVF9MRU5HVEgpXG4gIC8vICAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIGJ1ZmZlcnMpIHtcbiAgLy8gICAgICAgICBvdXRwdXQud3JpdGUoXG4gIC8vICAgICAgICAgICBHaXRQa3RMaW5lLmVuY29kZShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSgnMDEnLCAnaGV4JyksIGJ1ZmZlcl0pKVxuICAvLyAgICAgICAgIClcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfSlcbiAgLy8gICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAvLyAgICAgICBwYWNrZmlsZUVuZGVkID0gdHJ1ZVxuICAvLyAgICAgICBpZiAoIXBhY2tmaWxlV2FzRW1wdHkpIG91dHB1dC53cml0ZShnb29kYnllKVxuICAvLyAgICAgICBpZiAocHJvZ3Jlc3NFbmRlZCAmJiBlcnJvckVuZGVkKSBvdXRwdXQuZW5kKClcbiAgLy8gICAgIH0pXG4gIC8vICAgcHJvZ3Jlc3NcbiAgLy8gICAgIC5vbignZGF0YScsIGRhdGEgPT4ge1xuICAvLyAgICAgICBjb25zdCBidWZmZXJzID0gc3BsaXRCdWZmZXIoZGF0YSwgTUFYX1BBQ0tFVF9MRU5HVEgpXG4gIC8vICAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIGJ1ZmZlcnMpIHtcbiAgLy8gICAgICAgICBvdXRwdXQud3JpdGUoXG4gIC8vICAgICAgICAgICBHaXRQa3RMaW5lLmVuY29kZShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSgnMDInLCAnaGV4JyksIGJ1ZmZlcl0pKVxuICAvLyAgICAgICAgIClcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfSlcbiAgLy8gICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAvLyAgICAgICBwcm9ncmVzc0VuZGVkID0gdHJ1ZVxuICAvLyAgICAgICBpZiAocGFja2ZpbGVFbmRlZCAmJiBlcnJvckVuZGVkKSBvdXRwdXQuZW5kKClcbiAgLy8gICAgIH0pXG4gIC8vICAgZXJyb3JcbiAgLy8gICAgIC5vbignZGF0YScsIGRhdGEgPT4ge1xuICAvLyAgICAgICBjb25zdCBidWZmZXJzID0gc3BsaXRCdWZmZXIoZGF0YSwgTUFYX1BBQ0tFVF9MRU5HVEgpXG4gIC8vICAgICAgIGZvciAoY29uc3QgYnVmZmVyIG9mIGJ1ZmZlcnMpIHtcbiAgLy8gICAgICAgICBvdXRwdXQud3JpdGUoXG4gIC8vICAgICAgICAgICBHaXRQa3RMaW5lLmVuY29kZShCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSgnMDMnLCAnaGV4JyksIGJ1ZmZlcl0pKVxuICAvLyAgICAgICAgIClcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfSlcbiAgLy8gICAgIC5vbignZW5kJywgKCkgPT4ge1xuICAvLyAgICAgICBlcnJvckVuZGVkID0gdHJ1ZVxuICAvLyAgICAgICBpZiAocHJvZ3Jlc3NFbmRlZCAmJiBwYWNrZmlsZUVuZGVkKSBvdXRwdXQuZW5kKClcbiAgLy8gICAgIH0pXG4gIC8vICAgcmV0dXJuIG91dHB1dFxuICAvLyB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlVXBsb2FkUGFja1Jlc3BvbnNlKHN0cmVhbSkge1xuICBjb25zdCB7IHBhY2tldGxpbmVzLCBwYWNrZmlsZSwgcHJvZ3Jlc3MgfSA9IEdpdFNpZGVCYW5kLmRlbXV4KHN0cmVhbSk7XG4gIGNvbnN0IHNoYWxsb3dzID0gW107XG4gIGNvbnN0IHVuc2hhbGxvd3MgPSBbXTtcbiAgY29uc3QgYWNrcyA9IFtdO1xuICBsZXQgbmFrID0gZmFsc2U7XG4gIGxldCBkb25lID0gZmFsc2U7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgLy8gUGFyc2UgdGhlIHJlc3BvbnNlXG4gICAgZm9yQXdhaXQocGFja2V0bGluZXMsIGRhdGEgPT4ge1xuICAgICAgY29uc3QgbGluZSA9IGRhdGEudG9TdHJpbmcoJ3V0ZjgnKS50cmltKCk7XG4gICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdzaGFsbG93JykpIHtcbiAgICAgICAgY29uc3Qgb2lkID0gbGluZS5zbGljZSgtNDEpLnRyaW0oKTtcbiAgICAgICAgaWYgKG9pZC5sZW5ndGggIT09IDQwKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBJbnZhbGlkT2lkRXJyb3Iob2lkKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2hhbGxvd3MucHVzaChvaWQpO1xuICAgICAgfSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ3Vuc2hhbGxvdycpKSB7XG4gICAgICAgIGNvbnN0IG9pZCA9IGxpbmUuc2xpY2UoLTQxKS50cmltKCk7XG4gICAgICAgIGlmIChvaWQubGVuZ3RoICE9PSA0MCkge1xuICAgICAgICAgIHJlamVjdChuZXcgSW52YWxpZE9pZEVycm9yKG9pZCkpO1xuICAgICAgICB9XG4gICAgICAgIHVuc2hhbGxvd3MucHVzaChvaWQpO1xuICAgICAgfSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoJ0FDSycpKSB7XG4gICAgICAgIGNvbnN0IFssIG9pZCwgc3RhdHVzXSA9IGxpbmUuc3BsaXQoJyAnKTtcbiAgICAgICAgYWNrcy5wdXNoKHsgb2lkLCBzdGF0dXMgfSk7XG4gICAgICAgIGlmICghc3RhdHVzKSBkb25lID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKCdOQUsnKSkge1xuICAgICAgICBuYWsgPSB0cnVlO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJlc29sdmUoeyBzaGFsbG93cywgdW5zaGFsbG93cywgYWNrcywgbmFrLCBwYWNrZmlsZSwgcHJvZ3Jlc3MgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHdyaXRlVXBsb2FkUGFja1JlcXVlc3Qoe1xuICBjYXBhYmlsaXRpZXMgPSBbXSxcbiAgd2FudHMgPSBbXSxcbiAgaGF2ZXMgPSBbXSxcbiAgc2hhbGxvd3MgPSBbXSxcbiAgZGVwdGggPSBudWxsLFxuICBzaW5jZSA9IG51bGwsXG4gIGV4Y2x1ZGUgPSBbXSxcbn0pIHtcbiAgY29uc3QgcGFja3N0cmVhbSA9IFtdO1xuICB3YW50cyA9IFsuLi5uZXcgU2V0KHdhbnRzKV07IC8vIHJlbW92ZSBkdXBsaWNhdGVzXG4gIGxldCBmaXJzdExpbmVDYXBhYmlsaXRpZXMgPSBgICR7Y2FwYWJpbGl0aWVzLmpvaW4oJyAnKX1gO1xuICBmb3IgKGNvbnN0IG9pZCBvZiB3YW50cykge1xuICAgIHBhY2tzdHJlYW0ucHVzaChHaXRQa3RMaW5lLmVuY29kZShgd2FudCAke29pZH0ke2ZpcnN0TGluZUNhcGFiaWxpdGllc31cXG5gKSk7XG4gICAgZmlyc3RMaW5lQ2FwYWJpbGl0aWVzID0gJyc7XG4gIH1cbiAgZm9yIChjb25zdCBvaWQgb2Ygc2hhbGxvd3MpIHtcbiAgICBwYWNrc3RyZWFtLnB1c2goR2l0UGt0TGluZS5lbmNvZGUoYHNoYWxsb3cgJHtvaWR9XFxuYCkpO1xuICB9XG4gIGlmIChkZXB0aCAhPT0gbnVsbCkge1xuICAgIHBhY2tzdHJlYW0ucHVzaChHaXRQa3RMaW5lLmVuY29kZShgZGVlcGVuICR7ZGVwdGh9XFxuYCkpO1xuICB9XG4gIGlmIChzaW5jZSAhPT0gbnVsbCkge1xuICAgIHBhY2tzdHJlYW0ucHVzaChcbiAgICAgIEdpdFBrdExpbmUuZW5jb2RlKGBkZWVwZW4tc2luY2UgJHtNYXRoLmZsb29yKHNpbmNlLnZhbHVlT2YoKSAvIDEwMDApfVxcbmApXG4gICAgKTtcbiAgfVxuICBmb3IgKGNvbnN0IG9pZCBvZiBleGNsdWRlKSB7XG4gICAgcGFja3N0cmVhbS5wdXNoKEdpdFBrdExpbmUuZW5jb2RlKGBkZWVwZW4tbm90ICR7b2lkfVxcbmApKTtcbiAgfVxuICBwYWNrc3RyZWFtLnB1c2goR2l0UGt0TGluZS5mbHVzaCgpKTtcbiAgZm9yIChjb25zdCBvaWQgb2YgaGF2ZXMpIHtcbiAgICBwYWNrc3RyZWFtLnB1c2goR2l0UGt0TGluZS5lbmNvZGUoYGhhdmUgJHtvaWR9XFxuYCkpO1xuICB9XG4gIHBhY2tzdHJlYW0ucHVzaChHaXRQa3RMaW5lLmVuY29kZShgZG9uZVxcbmApKTtcbiAgcmV0dXJuIHBhY2tzdHJlYW1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEZldGNoUmVzdWx0IC0gVGhlIG9iamVjdCByZXR1cm5lZCBoYXMgdGhlIGZvbGxvd2luZyBzY2hlbWE6XG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGx9IGRlZmF1bHRCcmFuY2ggLSBUaGUgYnJhbmNoIHRoYXQgaXMgY2xvbmVkIGlmIG5vIGJyYW5jaCBpcyBzcGVjaWZpZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbH0gZmV0Y2hIZWFkIC0gVGhlIFNIQS0xIG9iamVjdCBpZCBvZiB0aGUgZmV0Y2hlZCBoZWFkIGNvbW1pdFxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsfSBmZXRjaEhlYWREZXNjcmlwdGlvbiAtIGEgdGV4dHVhbCBkZXNjcmlwdGlvbiBvZiB0aGUgYnJhbmNoIHRoYXQgd2FzIGZldGNoZWRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2hlYWRlcnNdIC0gVGhlIEhUVFAgcmVzcG9uc2UgaGVhZGVycyByZXR1cm5lZCBieSB0aGUgZ2l0IHNlcnZlclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gW3BydW5lZF0gLSBBIGxpc3Qgb2YgYnJhbmNoZXMgdGhhdCB3ZXJlIHBydW5lZCwgaWYgeW91IHByb3ZpZGVkIHRoZSBgcHJ1bmVgIHBhcmFtZXRlclxuICpcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge2FueX0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtIdHRwQ2xpZW50fSBhcmdzLmh0dHBcbiAqIEBwYXJhbSB7UHJvZ3Jlc3NDYWxsYmFja30gW2FyZ3Mub25Qcm9ncmVzc11cbiAqIEBwYXJhbSB7TWVzc2FnZUNhbGxiYWNrfSBbYXJncy5vbk1lc3NhZ2VdXG4gKiBAcGFyYW0ge0F1dGhDYWxsYmFja30gW2FyZ3Mub25BdXRoXVxuICogQHBhcmFtIHtBdXRoRmFpbHVyZUNhbGxiYWNrfSBbYXJncy5vbkF1dGhGYWlsdXJlXVxuICogQHBhcmFtIHtBdXRoU3VjY2Vzc0NhbGxiYWNrfSBbYXJncy5vbkF1dGhTdWNjZXNzXVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ3x2b2lkfSBbYXJncy51cmxdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY29yc1Byb3h5XVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZW1vdGVSZWZdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVtb3RlXVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5zaW5nbGVCcmFuY2ggPSBmYWxzZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MudGFncyA9IGZhbHNlXVxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmRlcHRoXVxuICogQHBhcmFtIHtEYXRlfSBbYXJncy5zaW5jZV1cbiAqIEBwYXJhbSB7c3RyaW5nW119IFthcmdzLmV4Y2x1ZGUgPSBbXV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MucmVsYXRpdmUgPSBmYWxzZV1cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2FyZ3MuaGVhZGVyc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MucHJ1bmVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLnBydW5lVGFnc11cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxGZXRjaFJlc3VsdD59XG4gKiBAc2VlIEZldGNoUmVzdWx0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9mZXRjaCh7XG4gIGZzLFxuICBjYWNoZSxcbiAgaHR0cCxcbiAgb25Qcm9ncmVzcyxcbiAgb25NZXNzYWdlLFxuICBvbkF1dGgsXG4gIG9uQXV0aFN1Y2Nlc3MsXG4gIG9uQXV0aEZhaWx1cmUsXG4gIGdpdGRpcixcbiAgcmVmOiBfcmVmLFxuICByZW1vdGVSZWY6IF9yZW1vdGVSZWYsXG4gIHJlbW90ZTogX3JlbW90ZSxcbiAgdXJsOiBfdXJsLFxuICBjb3JzUHJveHksXG4gIGRlcHRoID0gbnVsbCxcbiAgc2luY2UgPSBudWxsLFxuICBleGNsdWRlID0gW10sXG4gIHJlbGF0aXZlID0gZmFsc2UsXG4gIHRhZ3MgPSBmYWxzZSxcbiAgc2luZ2xlQnJhbmNoID0gZmFsc2UsXG4gIGhlYWRlcnMgPSB7fSxcbiAgcHJ1bmUgPSBmYWxzZSxcbiAgcHJ1bmVUYWdzID0gZmFsc2UsXG59KSB7XG4gIGNvbnN0IHJlZiA9IF9yZWYgfHwgKGF3YWl0IF9jdXJyZW50QnJhbmNoKHsgZnMsIGdpdGRpciwgdGVzdDogdHJ1ZSB9KSk7XG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuZ2V0KHsgZnMsIGdpdGRpciB9KTtcbiAgLy8gRmlndXJlIG91dCB3aGF0IHJlbW90ZSB0byB1c2UuXG4gIGNvbnN0IHJlbW90ZSA9XG4gICAgX3JlbW90ZSB8fCAocmVmICYmIChhd2FpdCBjb25maWcuZ2V0KGBicmFuY2guJHtyZWZ9LnJlbW90ZWApKSkgfHwgJ29yaWdpbic7XG4gIC8vIExvb2t1cCB0aGUgVVJMIGZvciB0aGUgZ2l2ZW4gcmVtb3RlLlxuICBjb25zdCB1cmwgPSBfdXJsIHx8IChhd2FpdCBjb25maWcuZ2V0KGByZW1vdGUuJHtyZW1vdGV9LnVybGApKTtcbiAgaWYgKHR5cGVvZiB1cmwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IE1pc3NpbmdQYXJhbWV0ZXJFcnJvcigncmVtb3RlIE9SIHVybCcpXG4gIH1cbiAgLy8gRmlndXJlIG91dCB3aGF0IHJlbW90ZSByZWYgdG8gdXNlLlxuICBjb25zdCByZW1vdGVSZWYgPVxuICAgIF9yZW1vdGVSZWYgfHxcbiAgICAocmVmICYmIChhd2FpdCBjb25maWcuZ2V0KGBicmFuY2guJHtyZWZ9Lm1lcmdlYCkpKSB8fFxuICAgIF9yZWYgfHxcbiAgICAnSEVBRCc7XG5cbiAgaWYgKGNvcnNQcm94eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29yc1Byb3h5ID0gYXdhaXQgY29uZmlnLmdldCgnaHR0cC5jb3JzUHJveHknKTtcbiAgfVxuXG4gIGNvbnN0IEdpdFJlbW90ZUhUVFAgPSBHaXRSZW1vdGVNYW5hZ2VyLmdldFJlbW90ZUhlbHBlckZvcih7IHVybCB9KTtcbiAgY29uc3QgcmVtb3RlSFRUUCA9IGF3YWl0IEdpdFJlbW90ZUhUVFAuZGlzY292ZXIoe1xuICAgIGh0dHAsXG4gICAgb25BdXRoLFxuICAgIG9uQXV0aFN1Y2Nlc3MsXG4gICAgb25BdXRoRmFpbHVyZSxcbiAgICBjb3JzUHJveHksXG4gICAgc2VydmljZTogJ2dpdC11cGxvYWQtcGFjaycsXG4gICAgdXJsLFxuICAgIGhlYWRlcnMsXG4gICAgcHJvdG9jb2xWZXJzaW9uOiAxLFxuICB9KTtcbiAgY29uc3QgYXV0aCA9IHJlbW90ZUhUVFAuYXV0aDsgLy8gaGFjayB0byBnZXQgbmV3IGNyZWRlbnRpYWxzIGZyb20gQ3JlZGVudGlhbE1hbmFnZXIgQVBJXG4gIGNvbnN0IHJlbW90ZVJlZnMgPSByZW1vdGVIVFRQLnJlZnM7XG4gIC8vIEZvciB0aGUgc3BlY2lhbCBjYXNlIG9mIGFuIGVtcHR5IHJlcG9zaXRvcnkgd2l0aCBubyByZWZzLCByZXR1cm4gbnVsbC5cbiAgaWYgKHJlbW90ZVJlZnMuc2l6ZSA9PT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZWZhdWx0QnJhbmNoOiBudWxsLFxuICAgICAgZmV0Y2hIZWFkOiBudWxsLFxuICAgICAgZmV0Y2hIZWFkRGVzY3JpcHRpb246IG51bGwsXG4gICAgfVxuICB9XG4gIC8vIENoZWNrIHRoYXQgdGhlIHJlbW90ZSBzdXBwb3J0cyB0aGUgcmVxdWVzdGVkIGZlYXR1cmVzXG4gIGlmIChkZXB0aCAhPT0gbnVsbCAmJiAhcmVtb3RlSFRUUC5jYXBhYmlsaXRpZXMuaGFzKCdzaGFsbG93JykpIHtcbiAgICB0aHJvdyBuZXcgUmVtb3RlQ2FwYWJpbGl0eUVycm9yKCdzaGFsbG93JywgJ2RlcHRoJylcbiAgfVxuICBpZiAoc2luY2UgIT09IG51bGwgJiYgIXJlbW90ZUhUVFAuY2FwYWJpbGl0aWVzLmhhcygnZGVlcGVuLXNpbmNlJykpIHtcbiAgICB0aHJvdyBuZXcgUmVtb3RlQ2FwYWJpbGl0eUVycm9yKCdkZWVwZW4tc2luY2UnLCAnc2luY2UnKVxuICB9XG4gIGlmIChleGNsdWRlLmxlbmd0aCA+IDAgJiYgIXJlbW90ZUhUVFAuY2FwYWJpbGl0aWVzLmhhcygnZGVlcGVuLW5vdCcpKSB7XG4gICAgdGhyb3cgbmV3IFJlbW90ZUNhcGFiaWxpdHlFcnJvcignZGVlcGVuLW5vdCcsICdleGNsdWRlJylcbiAgfVxuICBpZiAocmVsYXRpdmUgPT09IHRydWUgJiYgIXJlbW90ZUhUVFAuY2FwYWJpbGl0aWVzLmhhcygnZGVlcGVuLXJlbGF0aXZlJykpIHtcbiAgICB0aHJvdyBuZXcgUmVtb3RlQ2FwYWJpbGl0eUVycm9yKCdkZWVwZW4tcmVsYXRpdmUnLCAncmVsYXRpdmUnKVxuICB9XG4gIC8vIEZpZ3VyZSBvdXQgdGhlIFNIQSBmb3IgdGhlIHJlcXVlc3RlZCByZWZcbiAgY29uc3QgeyBvaWQsIGZ1bGxyZWYgfSA9IEdpdFJlZk1hbmFnZXIucmVzb2x2ZUFnYWluc3RNYXAoe1xuICAgIHJlZjogcmVtb3RlUmVmLFxuICAgIG1hcDogcmVtb3RlUmVmcyxcbiAgfSk7XG4gIC8vIEZpbHRlciBvdXQgcmVmcyB3ZSB3YW50IHRvIGlnbm9yZTogb25seSBrZWVwIHJlZiB3ZSdyZSBjbG9uaW5nLCBIRUFELCBicmFuY2hlcywgYW5kIHRhZ3MgKGlmIHdlJ3JlIGtlZXBpbmcgdGhlbSlcbiAgZm9yIChjb25zdCByZW1vdGVSZWYgb2YgcmVtb3RlUmVmcy5rZXlzKCkpIHtcbiAgICBpZiAoXG4gICAgICByZW1vdGVSZWYgPT09IGZ1bGxyZWYgfHxcbiAgICAgIHJlbW90ZVJlZiA9PT0gJ0hFQUQnIHx8XG4gICAgICByZW1vdGVSZWYuc3RhcnRzV2l0aCgncmVmcy9oZWFkcy8nKSB8fFxuICAgICAgKHRhZ3MgJiYgcmVtb3RlUmVmLnN0YXJ0c1dpdGgoJ3JlZnMvdGFncy8nKSlcbiAgICApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHJlbW90ZVJlZnMuZGVsZXRlKHJlbW90ZVJlZik7XG4gIH1cbiAgLy8gQXNzZW1ibGUgdGhlIGFwcGxpY2F0aW9uL3gtZ2l0LXVwbG9hZC1wYWNrLXJlcXVlc3RcbiAgY29uc3QgY2FwYWJpbGl0aWVzID0gZmlsdGVyQ2FwYWJpbGl0aWVzKFxuICAgIFsuLi5yZW1vdGVIVFRQLmNhcGFiaWxpdGllc10sXG4gICAgW1xuICAgICAgJ211bHRpX2Fja19kZXRhaWxlZCcsXG4gICAgICAnbm8tZG9uZScsXG4gICAgICAnc2lkZS1iYW5kLTY0aycsXG4gICAgICAvLyBOb3RlOiBJIHJlbW92ZWQgJ3RoaW4tcGFjaycgb3B0aW9uIHNpbmNlIG91ciBjb2RlIGRvZXNuJ3QgXCJmYXR0ZW5cIiBwYWNrZmlsZXMsXG4gICAgICAvLyB3aGljaCBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBnaXQuIEl0IHdhcyB0aGUgY2F1c2Ugb2YgbXlzdGVyaW91c1xuICAgICAgLy8gJ2ZhdGFsOiBwYWNrIGhhcyBbeF0gdW5yZXNvbHZlZCBkZWx0YXMnIGVycm9ycyB0aGF0IHBsYWd1ZWQgdXMgZm9yIHNvbWUgdGltZS5cbiAgICAgIC8vIGlzb21vcnBoaWMtZ2l0IGlzIHBlcmZlY3RseSBoYXBweSB3aXRoIHRoaW4gcGFja2ZpbGVzIGluIC5naXQvb2JqZWN0cy9wYWNrIGJ1dFxuICAgICAgLy8gY2Fub25pY2FsIGdpdCBpdCB0dXJucyBvdXQgaXMgTk9ULlxuICAgICAgJ29mcy1kZWx0YScsXG4gICAgICBgYWdlbnQ9JHtwa2cuYWdlbnR9YCxcbiAgICBdXG4gICk7XG4gIGlmIChyZWxhdGl2ZSkgY2FwYWJpbGl0aWVzLnB1c2goJ2RlZXBlbi1yZWxhdGl2ZScpO1xuICAvLyBTdGFydCBmaWd1cmluZyBvdXQgd2hpY2ggb2lkcyBmcm9tIHRoZSByZW1vdGUgd2Ugd2FudCB0byByZXF1ZXN0XG4gIGNvbnN0IHdhbnRzID0gc2luZ2xlQnJhbmNoID8gW29pZF0gOiByZW1vdGVSZWZzLnZhbHVlcygpO1xuICAvLyBDb21lIHVwIHdpdGggYSByZWFzb25hYmxlIGxpc3Qgb2Ygb2lkcyB0byB0ZWxsIHRoZSByZW1vdGUgd2UgYWxyZWFkeSBoYXZlXG4gIC8vIChwcmVmZXJhYmx5IG9pZHMgdGhhdCBhcmUgY2xvc2UgYW5jZXN0b3JzIG9mIHRoZSBicmFuY2ggaGVhZHMgd2UncmUgZmV0Y2hpbmcpXG4gIGNvbnN0IGhhdmVSZWZzID0gc2luZ2xlQnJhbmNoXG4gICAgPyBbcmVmXVxuICAgIDogYXdhaXQgR2l0UmVmTWFuYWdlci5saXN0UmVmcyh7XG4gICAgICAgIGZzLFxuICAgICAgICBnaXRkaXIsXG4gICAgICAgIGZpbGVwYXRoOiBgcmVmc2AsXG4gICAgICB9KTtcbiAgbGV0IGhhdmVzID0gW107XG4gIGZvciAobGV0IHJlZiBvZiBoYXZlUmVmcykge1xuICAgIHRyeSB7XG4gICAgICByZWYgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLmV4cGFuZCh7IGZzLCBnaXRkaXIsIHJlZiB9KTtcbiAgICAgIGNvbnN0IG9pZCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGZzLCBnaXRkaXIsIHJlZiB9KTtcbiAgICAgIGlmIChhd2FpdCBoYXNPYmplY3QoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pKSB7XG4gICAgICAgIGhhdmVzLnB1c2gob2lkKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIH1cbiAgaGF2ZXMgPSBbLi4ubmV3IFNldChoYXZlcyldO1xuICBjb25zdCBvaWRzID0gYXdhaXQgR2l0U2hhbGxvd01hbmFnZXIucmVhZCh7IGZzLCBnaXRkaXIgfSk7XG4gIGNvbnN0IHNoYWxsb3dzID0gcmVtb3RlSFRUUC5jYXBhYmlsaXRpZXMuaGFzKCdzaGFsbG93JykgPyBbLi4ub2lkc10gOiBbXTtcbiAgY29uc3QgcGFja3N0cmVhbSA9IHdyaXRlVXBsb2FkUGFja1JlcXVlc3Qoe1xuICAgIGNhcGFiaWxpdGllcyxcbiAgICB3YW50cyxcbiAgICBoYXZlcyxcbiAgICBzaGFsbG93cyxcbiAgICBkZXB0aCxcbiAgICBzaW5jZSxcbiAgICBleGNsdWRlLFxuICB9KTtcbiAgLy8gQ29kZUNvbW1pdCB3aWxsIGhhbmcgdXAgaWYgd2UgZG9uJ3Qgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlclxuICAvLyBzbyB3ZSBjYW4ndCBzdHJlYW0gdGhlIGJvZHkuXG4gIGNvbnN0IHBhY2tidWZmZXIgPSBCdWZmZXIuZnJvbShhd2FpdCBjb2xsZWN0KHBhY2tzdHJlYW0pKTtcbiAgY29uc3QgcmF3ID0gYXdhaXQgR2l0UmVtb3RlSFRUUC5jb25uZWN0KHtcbiAgICBodHRwLFxuICAgIG9uUHJvZ3Jlc3MsXG4gICAgY29yc1Byb3h5LFxuICAgIHNlcnZpY2U6ICdnaXQtdXBsb2FkLXBhY2snLFxuICAgIHVybCxcbiAgICBhdXRoLFxuICAgIGJvZHk6IFtwYWNrYnVmZmVyXSxcbiAgICBoZWFkZXJzLFxuICB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBwYXJzZVVwbG9hZFBhY2tSZXNwb25zZShyYXcuYm9keSk7XG4gIGlmIChyYXcuaGVhZGVycykge1xuICAgIHJlc3BvbnNlLmhlYWRlcnMgPSByYXcuaGVhZGVycztcbiAgfVxuICAvLyBBcHBseSBhbGwgdGhlICdzaGFsbG93JyBhbmQgJ3Vuc2hhbGxvdycgY29tbWFuZHNcbiAgZm9yIChjb25zdCBvaWQgb2YgcmVzcG9uc2Uuc2hhbGxvd3MpIHtcbiAgICBpZiAoIW9pZHMuaGFzKG9pZCkpIHtcbiAgICAgIC8vIHRoaXMgaXMgaW4gYSB0cnkvY2F0Y2ggbW9zdGx5IGJlY2F1c2UgbXkgb2xkIHRlc3QgZml4dHVyZXMgYXJlIG1pc3Npbmcgb2JqZWN0c1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gc2VydmVyIHNheXMgaXQncyBzaGFsbG93LCBidXQgZG8gd2UgaGF2ZSB0aGUgcGFyZW50cz9cbiAgICAgICAgY29uc3QgeyBvYmplY3QgfSA9IGF3YWl0IF9yZWFkT2JqZWN0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcbiAgICAgICAgY29uc3QgY29tbWl0ID0gbmV3IEdpdENvbW1pdChvYmplY3QpO1xuICAgICAgICBjb25zdCBoYXNQYXJlbnRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgY29tbWl0XG4gICAgICAgICAgICAuaGVhZGVycygpXG4gICAgICAgICAgICAucGFyZW50Lm1hcChvaWQgPT4gaGFzT2JqZWN0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KSlcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgaGF2ZUFsbFBhcmVudHMgPVxuICAgICAgICAgIGhhc1BhcmVudHMubGVuZ3RoID09PSAwIHx8IGhhc1BhcmVudHMuZXZlcnkoaGFzID0+IGhhcyk7XG4gICAgICAgIGlmICghaGF2ZUFsbFBhcmVudHMpIHtcbiAgICAgICAgICBvaWRzLmFkZChvaWQpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgb2lkcy5hZGQob2lkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBvaWQgb2YgcmVzcG9uc2UudW5zaGFsbG93cykge1xuICAgIG9pZHMuZGVsZXRlKG9pZCk7XG4gIH1cbiAgYXdhaXQgR2l0U2hhbGxvd01hbmFnZXIud3JpdGUoeyBmcywgZ2l0ZGlyLCBvaWRzIH0pO1xuICAvLyBVcGRhdGUgbG9jYWwgcmVtb3RlIHJlZnNcbiAgaWYgKHNpbmdsZUJyYW5jaCkge1xuICAgIGNvbnN0IHJlZnMgPSBuZXcgTWFwKFtbZnVsbHJlZiwgb2lkXV0pO1xuICAgIC8vIEJ1dCB3YWl0LCBtYXliZSBpdCB3YXMgYSBzeW1yZWYsIGxpa2UgJ0hFQUQnIVxuICAgIC8vIFdlIG5lZWQgdG8gc2F2ZSBhbGwgdGhlIHJlZnMgaW4gdGhlIHN5bXJlZiBjaGFpbiAoc2lnaCkuXG4gICAgY29uc3Qgc3ltcmVmcyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgYmFpbCA9IDEwO1xuICAgIGxldCBrZXkgPSBmdWxscmVmO1xuICAgIHdoaWxlIChiYWlsLS0pIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcmVtb3RlSFRUUC5zeW1yZWZzLmdldChrZXkpO1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIGJyZWFrXG4gICAgICBzeW1yZWZzLnNldChrZXksIHZhbHVlKTtcbiAgICAgIGtleSA9IHZhbHVlO1xuICAgIH1cbiAgICAvLyBmaW5hbCB2YWx1ZSBtdXN0IG5vdCBiZSBhIHN5bXJlZiBidXQgYSByZWFsIHJlZlxuICAgIGNvbnN0IHJlYWxSZWYgPSByZW1vdGVSZWZzLmdldChrZXkpO1xuICAgIC8vIFRoZXJlIG1heSBiZSBubyByZWYgYXQgYWxsIGlmIHdlJ3ZlIGZldGNoZWQgYSBzcGVjaWZpYyBjb21taXQgaGFzaFxuICAgIGlmIChyZWFsUmVmKSB7XG4gICAgICByZWZzLnNldChrZXksIHJlYWxSZWYpO1xuICAgIH1cbiAgICBjb25zdCB7IHBydW5lZCB9ID0gYXdhaXQgR2l0UmVmTWFuYWdlci51cGRhdGVSZW1vdGVSZWZzKHtcbiAgICAgIGZzLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVtb3RlLFxuICAgICAgcmVmcyxcbiAgICAgIHN5bXJlZnMsXG4gICAgICB0YWdzLFxuICAgICAgcHJ1bmUsXG4gICAgfSk7XG4gICAgaWYgKHBydW5lKSB7XG4gICAgICByZXNwb25zZS5wcnVuZWQgPSBwcnVuZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHsgcHJ1bmVkIH0gPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnVwZGF0ZVJlbW90ZVJlZnMoe1xuICAgICAgZnMsXG4gICAgICBnaXRkaXIsXG4gICAgICByZW1vdGUsXG4gICAgICByZWZzOiByZW1vdGVSZWZzLFxuICAgICAgc3ltcmVmczogcmVtb3RlSFRUUC5zeW1yZWZzLFxuICAgICAgdGFncyxcbiAgICAgIHBydW5lLFxuICAgICAgcHJ1bmVUYWdzLFxuICAgIH0pO1xuICAgIGlmIChwcnVuZSkge1xuICAgICAgcmVzcG9uc2UucHJ1bmVkID0gcHJ1bmVkO1xuICAgIH1cbiAgfVxuICAvLyBXZSBuZWVkIHRoaXMgdmFsdWUgbGF0ZXIgZm9yIHRoZSBgY2xvbmVgIGNvbW1hbmQuXG4gIHJlc3BvbnNlLkhFQUQgPSByZW1vdGVIVFRQLnN5bXJlZnMuZ2V0KCdIRUFEJyk7XG4gIC8vIEFXUyBDb2RlQ29tbWl0IGRvZXNuJ3QgbGlzdCBIRUFEIGFzIGEgc3ltcmVmLCBidXQgd2UgY2FuIHJldmVyc2UgZW5naW5lZXIgaXRcbiAgLy8gRmluZCB0aGUgU0hBIG9mIHRoZSBicmFuY2ggY2FsbGVkIEhFQURcbiAgaWYgKHJlc3BvbnNlLkhFQUQgPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHsgb2lkIH0gPSBHaXRSZWZNYW5hZ2VyLnJlc29sdmVBZ2FpbnN0TWFwKHtcbiAgICAgIHJlZjogJ0hFQUQnLFxuICAgICAgbWFwOiByZW1vdGVSZWZzLFxuICAgIH0pO1xuICAgIC8vIFVzZSB0aGUgbmFtZSBvZiB0aGUgZmlyc3QgYnJhbmNoIHRoYXQncyBub3QgY2FsbGVkIEhFQUQgdGhhdCBoYXNcbiAgICAvLyB0aGUgc2FtZSBTSEEgYXMgdGhlIGJyYW5jaCBjYWxsZWQgSEVBRC5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiByZW1vdGVSZWZzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGtleSAhPT0gJ0hFQUQnICYmIHZhbHVlID09PSBvaWQpIHtcbiAgICAgICAgcmVzcG9uc2UuSEVBRCA9IGtleTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3Qgbm91biA9IGZ1bGxyZWYuc3RhcnRzV2l0aCgncmVmcy90YWdzJykgPyAndGFnJyA6ICdicmFuY2gnO1xuICByZXNwb25zZS5GRVRDSF9IRUFEID0ge1xuICAgIG9pZCxcbiAgICBkZXNjcmlwdGlvbjogYCR7bm91bn0gJyR7YWJicmV2aWF0ZVJlZihmdWxscmVmKX0nIG9mICR7dXJsfWAsXG4gIH07XG5cbiAgaWYgKG9uUHJvZ3Jlc3MgfHwgb25NZXNzYWdlKSB7XG4gICAgY29uc3QgbGluZXMgPSBzcGxpdExpbmVzKHJlc3BvbnNlLnByb2dyZXNzKTtcbiAgICBmb3JBd2FpdChsaW5lcywgYXN5bmMgbGluZSA9PiB7XG4gICAgICBpZiAob25NZXNzYWdlKSBhd2FpdCBvbk1lc3NhZ2UobGluZSk7XG4gICAgICBpZiAob25Qcm9ncmVzcykge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gbGluZS5tYXRjaCgvKFteOl0qKS4qXFwoKFxcZCs/KVxcLyhcXGQrPylcXCkvKTtcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICBhd2FpdCBvblByb2dyZXNzKHtcbiAgICAgICAgICAgIHBoYXNlOiBtYXRjaGVzWzFdLnRyaW0oKSxcbiAgICAgICAgICAgIGxvYWRlZDogcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApLFxuICAgICAgICAgICAgdG90YWw6IHBhcnNlSW50KG1hdGNoZXNbM10sIDEwKSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHBhY2tmaWxlID0gQnVmZmVyLmZyb20oYXdhaXQgY29sbGVjdChyZXNwb25zZS5wYWNrZmlsZSkpO1xuICBjb25zdCBwYWNrZmlsZVNoYSA9IHBhY2tmaWxlLnNsaWNlKC0yMCkudG9TdHJpbmcoJ2hleCcpO1xuICBjb25zdCByZXMgPSB7XG4gICAgZGVmYXVsdEJyYW5jaDogcmVzcG9uc2UuSEVBRCxcbiAgICBmZXRjaEhlYWQ6IHJlc3BvbnNlLkZFVENIX0hFQUQub2lkLFxuICAgIGZldGNoSGVhZERlc2NyaXB0aW9uOiByZXNwb25zZS5GRVRDSF9IRUFELmRlc2NyaXB0aW9uLFxuICB9O1xuICBpZiAocmVzcG9uc2UuaGVhZGVycykge1xuICAgIHJlcy5oZWFkZXJzID0gcmVzcG9uc2UuaGVhZGVycztcbiAgfVxuICBpZiAocHJ1bmUpIHtcbiAgICByZXMucHJ1bmVkID0gcmVzcG9uc2UucHJ1bmVkO1xuICB9XG4gIC8vIFRoaXMgaXMgYSBxdWljayBmaXggZm9yIHRoZSBlbXB0eSAuZ2l0L29iamVjdHMvcGFjay9wYWNrLS5wYWNrIGZpbGUgZXJyb3IsXG4gIC8vIHdoaWNoIGR1ZSB0byB0aGUgd2F5IGBnaXQtbGlzdC1wYWNrYCB3b3JrcyBjYXVzZXMgdGhlIHByb2dyYW0gdG8gaGFuZyB3aGVuIGl0IHRyaWVzIHRvIHJlYWQgaXQuXG4gIC8vIFRPRE86IExvbmdlciB0ZXJtLCB3ZSBzaG91bGQgYWN0dWFsbHk6XG4gIC8vIGEpIE5PVCBjb25jYXRlbmF0ZSB0aGUgZW50aXJlIHBhY2tmaWxlIGludG8gbWVtb3J5IChsaW5lIDc4KSxcbiAgLy8gYikgY29tcHV0ZSB0aGUgU0hBIG9mIHRoZSBzdHJlYW0gZXhjZXB0IGZvciB0aGUgbGFzdCAyMCBieXRlcywgdXNpbmcgdGhlIHNhbWUgbGlicmFyeSB1c2VkIGluIHB1c2guanMsIGFuZFxuICAvLyBjKSBjb21wYXJlIHRoZSBjb21wdXRlZCBTSEEgd2l0aCB0aGUgbGFzdCAyMCBieXRlcyBvZiB0aGUgc3RyZWFtIGJlZm9yZSBzYXZpbmcgdG8gZGlzaywgYW5kIHRocm93aW5nIGEgXCJwYWNrZmlsZSBnb3QgY29ycnVwdGVkIGR1cmluZyBkb3dubG9hZFwiIGVycm9yIGlmIHRoZSBTSEEgZG9lc24ndCBtYXRjaC5cbiAgaWYgKHBhY2tmaWxlU2hhICE9PSAnJyAmJiAhZW1wdHlQYWNrZmlsZShwYWNrZmlsZSkpIHtcbiAgICByZXMucGFja2ZpbGUgPSBgb2JqZWN0cy9wYWNrL3BhY2stJHtwYWNrZmlsZVNoYX0ucGFja2A7XG4gICAgY29uc3QgZnVsbHBhdGggPSBqb2luKGdpdGRpciwgcmVzLnBhY2tmaWxlKTtcbiAgICBhd2FpdCBmcy53cml0ZShmdWxscGF0aCwgcGFja2ZpbGUpO1xuICAgIGNvbnN0IGdldEV4dGVybmFsUmVmRGVsdGEgPSBvaWQgPT4gX3JlYWRPYmplY3QoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pO1xuICAgIGNvbnN0IGlkeCA9IGF3YWl0IEdpdFBhY2tJbmRleC5mcm9tUGFjayh7XG4gICAgICBwYWNrOiBwYWNrZmlsZSxcbiAgICAgIGdldEV4dGVybmFsUmVmRGVsdGEsXG4gICAgICBvblByb2dyZXNzLFxuICAgIH0pO1xuICAgIGF3YWl0IGZzLndyaXRlKGZ1bGxwYXRoLnJlcGxhY2UoL1xcLnBhY2skLywgJy5pZHgnKSwgYXdhaXQgaWR4LnRvQnVmZmVyKCkpO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyByZXBvc2l0b3J5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyXVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5iYXJlID0gZmFsc2VdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGVmYXVsdEJyYW5jaCA9ICdtYXN0ZXInXVxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9pbml0KHtcbiAgZnMsXG4gIGJhcmUgPSBmYWxzZSxcbiAgZGlyLFxuICBnaXRkaXIgPSBiYXJlID8gZGlyIDogam9pbihkaXIsICcuZ2l0JyksXG4gIGRlZmF1bHRCcmFuY2ggPSAnbWFzdGVyJyxcbn0pIHtcbiAgLy8gRG9uJ3Qgb3ZlcndyaXRlIGFuIGV4aXN0aW5nIGNvbmZpZ1xuICBpZiAoYXdhaXQgZnMuZXhpc3RzKGdpdGRpciArICcvY29uZmlnJykpIHJldHVyblxuXG4gIGxldCBmb2xkZXJzID0gW1xuICAgICdob29rcycsXG4gICAgJ2luZm8nLFxuICAgICdvYmplY3RzL2luZm8nLFxuICAgICdvYmplY3RzL3BhY2snLFxuICAgICdyZWZzL2hlYWRzJyxcbiAgICAncmVmcy90YWdzJyxcbiAgXTtcbiAgZm9sZGVycyA9IGZvbGRlcnMubWFwKGRpciA9PiBnaXRkaXIgKyAnLycgKyBkaXIpO1xuICBmb3IgKGNvbnN0IGZvbGRlciBvZiBmb2xkZXJzKSB7XG4gICAgYXdhaXQgZnMubWtkaXIoZm9sZGVyKTtcbiAgfVxuXG4gIGF3YWl0IGZzLndyaXRlKFxuICAgIGdpdGRpciArICcvY29uZmlnJyxcbiAgICAnW2NvcmVdXFxuJyArXG4gICAgICAnXFx0cmVwb3NpdG9yeWZvcm1hdHZlcnNpb24gPSAwXFxuJyArXG4gICAgICAnXFx0ZmlsZW1vZGUgPSBmYWxzZVxcbicgK1xuICAgICAgYFxcdGJhcmUgPSAke2JhcmV9XFxuYCArXG4gICAgICAoYmFyZSA/ICcnIDogJ1xcdGxvZ2FsbHJlZnVwZGF0ZXMgPSB0cnVlXFxuJykgK1xuICAgICAgJ1xcdHN5bWxpbmtzID0gZmFsc2VcXG4nICtcbiAgICAgICdcXHRpZ25vcmVjYXNlID0gdHJ1ZVxcbidcbiAgKTtcbiAgYXdhaXQgZnMud3JpdGUoZ2l0ZGlyICsgJy9IRUFEJywgYHJlZjogcmVmcy9oZWFkcy8ke2RlZmF1bHRCcmFuY2h9XFxuYCk7XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge29iamVjdH0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtIdHRwQ2xpZW50fSBhcmdzLmh0dHBcbiAqIEBwYXJhbSB7UHJvZ3Jlc3NDYWxsYmFja30gW2FyZ3Mub25Qcm9ncmVzc11cbiAqIEBwYXJhbSB7TWVzc2FnZUNhbGxiYWNrfSBbYXJncy5vbk1lc3NhZ2VdXG4gKiBAcGFyYW0ge0F1dGhDYWxsYmFja30gW2FyZ3Mub25BdXRoXVxuICogQHBhcmFtIHtBdXRoRmFpbHVyZUNhbGxiYWNrfSBbYXJncy5vbkF1dGhGYWlsdXJlXVxuICogQHBhcmFtIHtBdXRoU3VjY2Vzc0NhbGxiYWNrfSBbYXJncy5vbkF1dGhTdWNjZXNzXVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MudXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5jb3JzUHJveHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlZlxuICogQHBhcmFtIHtib29sZWFufSBhcmdzLnNpbmdsZUJyYW5jaFxuICogQHBhcmFtIHtib29sZWFufSBhcmdzLm5vQ2hlY2tvdXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJncy5ub1RhZ3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlbW90ZVxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuZGVwdGhcbiAqIEBwYXJhbSB7RGF0ZX0gYXJncy5zaW5jZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gYXJncy5leGNsdWRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFyZ3MucmVsYXRpdmVcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gYXJncy5oZWFkZXJzXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIGNsb25lIGNvbXBsZXRlc1xuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2Nsb25lKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBodHRwLFxuICBvblByb2dyZXNzLFxuICBvbk1lc3NhZ2UsXG4gIG9uQXV0aCxcbiAgb25BdXRoU3VjY2VzcyxcbiAgb25BdXRoRmFpbHVyZSxcbiAgZGlyLFxuICBnaXRkaXIsXG4gIHVybCxcbiAgY29yc1Byb3h5LFxuICByZWYsXG4gIHJlbW90ZSxcbiAgZGVwdGgsXG4gIHNpbmNlLFxuICBleGNsdWRlLFxuICByZWxhdGl2ZSxcbiAgc2luZ2xlQnJhbmNoLFxuICBub0NoZWNrb3V0LFxuICBub1RhZ3MsXG4gIGhlYWRlcnMsXG59KSB7XG4gIHRyeSB7XG4gICAgYXdhaXQgX2luaXQoeyBmcywgZ2l0ZGlyIH0pO1xuICAgIGF3YWl0IF9hZGRSZW1vdGUoeyBmcywgZ2l0ZGlyLCByZW1vdGUsIHVybCwgZm9yY2U6IGZhbHNlIH0pO1xuICAgIGlmIChjb3JzUHJveHkpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuZ2V0KHsgZnMsIGdpdGRpciB9KTtcbiAgICAgIGF3YWl0IGNvbmZpZy5zZXQoYGh0dHAuY29yc1Byb3h5YCwgY29yc1Byb3h5KTtcbiAgICAgIGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuc2F2ZSh7IGZzLCBnaXRkaXIsIGNvbmZpZyB9KTtcbiAgICB9XG4gICAgY29uc3QgeyBkZWZhdWx0QnJhbmNoLCBmZXRjaEhlYWQgfSA9IGF3YWl0IF9mZXRjaCh7XG4gICAgICBmcyxcbiAgICAgIGNhY2hlLFxuICAgICAgaHR0cCxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBvbk1lc3NhZ2UsXG4gICAgICBvbkF1dGgsXG4gICAgICBvbkF1dGhTdWNjZXNzLFxuICAgICAgb25BdXRoRmFpbHVyZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZixcbiAgICAgIHJlbW90ZSxcbiAgICAgIGNvcnNQcm94eSxcbiAgICAgIGRlcHRoLFxuICAgICAgc2luY2UsXG4gICAgICBleGNsdWRlLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBzaW5nbGVCcmFuY2gsXG4gICAgICBoZWFkZXJzLFxuICAgICAgdGFnczogIW5vVGFncyxcbiAgICB9KTtcbiAgICBpZiAoZmV0Y2hIZWFkID09PSBudWxsKSByZXR1cm5cbiAgICByZWYgPSByZWYgfHwgZGVmYXVsdEJyYW5jaDtcbiAgICByZWYgPSByZWYucmVwbGFjZSgncmVmcy9oZWFkcy8nLCAnJyk7XG4gICAgLy8gQ2hlY2tvdXQgdGhhdCBicmFuY2hcbiAgICBhd2FpdCBfY2hlY2tvdXQoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBkaXIsXG4gICAgICBnaXRkaXIsXG4gICAgICByZWYsXG4gICAgICByZW1vdGUsXG4gICAgICBub0NoZWNrb3V0LFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBSZW1vdmUgcGFydGlhbCBsb2NhbCByZXBvc2l0b3J5LCBzZWUgIzEyODNcbiAgICAvLyBJZ25vcmUgYW55IGVycm9yIGFzIHdlIGFyZSBhbHJlYWR5IGZhaWxpbmcuXG4gICAgLy8gVGhlIGNhdGNoIGlzIG5lY2Vzc2FyeSBzbyB0aGUgb3JpZ2luYWwgZXJyb3IgaXMgbm90IG1hc2tlZC5cbiAgICBhd2FpdCBmc1xuICAgICAgLnJtZGlyKGdpdGRpciwgeyByZWN1cnNpdmU6IHRydWUsIG1heFJldHJpZXM6IDEwIH0pXG4gICAgICAuY2F0Y2goKCkgPT4gdW5kZWZpbmVkKTtcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBDbG9uZSBhIHJlcG9zaXRvcnlcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7SHR0cENsaWVudH0gYXJncy5odHRwIC0gYW4gSFRUUCBjbGllbnRcbiAqIEBwYXJhbSB7UHJvZ3Jlc3NDYWxsYmFja30gW2FyZ3Mub25Qcm9ncmVzc10gLSBvcHRpb25hbCBwcm9ncmVzcyBldmVudCBjYWxsYmFja1xuICogQHBhcmFtIHtNZXNzYWdlQ2FsbGJhY2t9IFthcmdzLm9uTWVzc2FnZV0gLSBvcHRpb25hbCBtZXNzYWdlIGV2ZW50IGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhDYWxsYmFja30gW2FyZ3Mub25BdXRoXSAtIG9wdGlvbmFsIGF1dGggZmlsbCBjYWxsYmFja1xuICogQHBhcmFtIHtBdXRoRmFpbHVyZUNhbGxiYWNrfSBbYXJncy5vbkF1dGhGYWlsdXJlXSAtIG9wdGlvbmFsIGF1dGggcmVqZWN0ZWQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXV0aFN1Y2Nlc3NDYWxsYmFja30gW2FyZ3Mub25BdXRoU3VjY2Vzc10gLSBvcHRpb25hbCBhdXRoIGFwcHJvdmVkIGNhbGxiYWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5kaXIgLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MudXJsIC0gVGhlIFVSTCBvZiB0aGUgcmVtb3RlIHJlcG9zaXRvcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb3JzUHJveHldIC0gT3B0aW9uYWwgW0NPUlMgcHJveHldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS8lNDBpc29tb3JwaGljLWdpdC9jb3JzLXByb3h5KS4gVmFsdWUgaXMgc3RvcmVkIGluIHRoZSBnaXQgY29uZmlnIGZpbGUgZm9yIHRoYXQgcmVwby5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZWZdIC0gV2hpY2ggYnJhbmNoIHRvIGNoZWNrb3V0LiBCeSBkZWZhdWx0IHRoaXMgaXMgdGhlIGRlc2lnbmF0ZWQgXCJtYWluIGJyYW5jaFwiIG9mIHRoZSByZXBvc2l0b3J5LlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5zaW5nbGVCcmFuY2ggPSBmYWxzZV0gLSBJbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGZldGNoaW5nIGFsbCB0aGUgYnJhbmNoZXMsIG9ubHkgZmV0Y2ggYSBzaW5nbGUgYnJhbmNoLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5ub0NoZWNrb3V0ID0gZmFsc2VdIC0gSWYgdHJ1ZSwgY2xvbmUgd2lsbCBvbmx5IGZldGNoIHRoZSByZXBvLCBub3QgY2hlY2sgb3V0IGEgYnJhbmNoLiBTa2lwcGluZyBjaGVja291dCBjYW4gc2F2ZSBhIGxvdCBvZiB0aW1lIG5vcm1hbGx5IHNwZW50IHdyaXRpbmcgZmlsZXMgdG8gZGlzay5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3Mubm9UYWdzID0gZmFsc2VdIC0gQnkgZGVmYXVsdCBjbG9uZSB3aWxsIGZldGNoIGFsbCB0YWdzLiBgbm9UYWdzYCBkaXNhYmxlcyB0aGF0IGJlaGF2aW9yLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlbW90ZSA9ICdvcmlnaW4nXSAtIFdoYXQgdG8gbmFtZSB0aGUgcmVtb3RlIHRoYXQgaXMgY3JlYXRlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5kZXB0aF0gLSBJbnRlZ2VyLiBEZXRlcm1pbmVzIGhvdyBtdWNoIG9mIHRoZSBnaXQgcmVwb3NpdG9yeSdzIGhpc3RvcnkgdG8gcmV0cmlldmVcbiAqIEBwYXJhbSB7RGF0ZX0gW2FyZ3Muc2luY2VdIC0gT25seSBmZXRjaCBjb21taXRzIGNyZWF0ZWQgYWZ0ZXIgdGhlIGdpdmVuIGRhdGUuIE11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIGBkZXB0aGAuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbYXJncy5leGNsdWRlID0gW11dIC0gQSBsaXN0IG9mIGJyYW5jaGVzIG9yIHRhZ3MuIEluc3RydWN0cyB0aGUgcmVtb3RlIHNlcnZlciBub3QgdG8gc2VuZCB1cyBhbnkgY29tbWl0cyByZWFjaGFibGUgZnJvbSB0aGVzZSByZWZzLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5yZWxhdGl2ZSA9IGZhbHNlXSAtIENoYW5nZXMgdGhlIG1lYW5pbmcgb2YgYGRlcHRoYCB0byBiZSBtZWFzdXJlZCBmcm9tIHRoZSBjdXJyZW50IHNoYWxsb3cgZGVwdGggcmF0aGVyIHRoYW4gZnJvbSB0aGUgYnJhbmNoIHRpcC5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2FyZ3MuaGVhZGVycyA9IHt9XSAtIEFkZGl0aW9uYWwgaGVhZGVycyB0byBpbmNsdWRlIGluIEhUVFAgcmVxdWVzdHMsIHNpbWlsYXIgdG8gZ2l0J3MgYGV4dHJhSGVhZGVyYCBjb25maWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBjbG9uZSBjb21wbGV0ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZ2l0LmNsb25lKHtcbiAqICAgZnMsXG4gKiAgIGh0dHAsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIGNvcnNQcm94eTogJ2h0dHBzOi8vY29ycy5pc29tb3JwaGljLWdpdC5vcmcnLFxuICogICB1cmw6ICdodHRwczovL2dpdGh1Yi5jb20vaXNvbW9ycGhpYy1naXQvaXNvbW9ycGhpYy1naXQnLFxuICogICBzaW5nbGVCcmFuY2g6IHRydWUsXG4gKiAgIGRlcHRoOiAxXG4gKiB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gY2xvbmUoe1xuICBmcyxcbiAgaHR0cCxcbiAgb25Qcm9ncmVzcyxcbiAgb25NZXNzYWdlLFxuICBvbkF1dGgsXG4gIG9uQXV0aFN1Y2Nlc3MsXG4gIG9uQXV0aEZhaWx1cmUsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHVybCxcbiAgY29yc1Byb3h5ID0gdW5kZWZpbmVkLFxuICByZWYgPSB1bmRlZmluZWQsXG4gIHJlbW90ZSA9ICdvcmlnaW4nLFxuICBkZXB0aCA9IHVuZGVmaW5lZCxcbiAgc2luY2UgPSB1bmRlZmluZWQsXG4gIGV4Y2x1ZGUgPSBbXSxcbiAgcmVsYXRpdmUgPSBmYWxzZSxcbiAgc2luZ2xlQnJhbmNoID0gZmFsc2UsXG4gIG5vQ2hlY2tvdXQgPSBmYWxzZSxcbiAgbm9UYWdzID0gZmFsc2UsXG4gIGhlYWRlcnMgPSB7fSxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignaHR0cCcsIGh0dHApO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBpZiAoIW5vQ2hlY2tvdXQpIHtcbiAgICAgIGFzc2VydFBhcmFtZXRlcignZGlyJywgZGlyKTtcbiAgICB9XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCd1cmwnLCB1cmwpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9jbG9uZSh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBodHRwLFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIG9uTWVzc2FnZSxcbiAgICAgIG9uQXV0aCxcbiAgICAgIG9uQXV0aFN1Y2Nlc3MsXG4gICAgICBvbkF1dGhGYWlsdXJlLFxuICAgICAgZGlyLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgdXJsLFxuICAgICAgY29yc1Byb3h5LFxuICAgICAgcmVmLFxuICAgICAgcmVtb3RlLFxuICAgICAgZGVwdGgsXG4gICAgICBzaW5jZSxcbiAgICAgIGV4Y2x1ZGUsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHNpbmdsZUJyYW5jaCxcbiAgICAgIG5vQ2hlY2tvdXQsXG4gICAgICBub1RhZ3MsXG4gICAgICBoZWFkZXJzLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmNsb25lJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY29tbWl0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge1NpZ25DYWxsYmFja30gW2FyZ3Mub25TaWduXSAtIGEgUEdQIHNpZ25pbmcgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm1lc3NhZ2UgLSBUaGUgY29tbWl0IG1lc3NhZ2UgdG8gdXNlLlxuICogQHBhcmFtIHtPYmplY3R9IFthcmdzLmF1dGhvcl0gLSBUaGUgZGV0YWlscyBhYm91dCB0aGUgYXV0aG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmF1dGhvci5uYW1lXSAtIERlZmF1bHQgaXMgYHVzZXIubmFtZWAgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmF1dGhvci5lbWFpbF0gLSBEZWZhdWx0IGlzIGB1c2VyLmVtYWlsYCBjb25maWcuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuYXV0aG9yLnRpbWVzdGFtcD1NYXRoLmZsb29yKERhdGUubm93KCkvMTAwMCldIC0gU2V0IHRoZSBhdXRob3IgdGltZXN0YW1wIGZpZWxkLiBUaGlzIGlzIHRoZSBpbnRlZ2VyIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBVbml4IGVwb2NoICgxOTcwLTAxLTAxIDAwOjAwOjAwKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5hdXRob3IudGltZXpvbmVPZmZzZXRdIC0gU2V0IHRoZSBhdXRob3IgdGltZXpvbmUgb2Zmc2V0IGZpZWxkLiBUaGlzIGlzIHRoZSBkaWZmZXJlbmNlLCBpbiBtaW51dGVzLCBmcm9tIHRoZSBjdXJyZW50IHRpbWV6b25lIHRvIFVUQy4gRGVmYXVsdCBpcyBgKG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KClgLlxuICogQHBhcmFtIHtPYmplY3R9IFthcmdzLmNvbW1pdHRlciA9IGF1dGhvcl0gLSBUaGUgZGV0YWlscyBhYm91dCB0aGUgY29tbWl0IGNvbW1pdHRlciwgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSBhdXRob3IgcGFyYW1ldGVyLiBJZiBub3Qgc3BlY2lmaWVkLCB0aGUgYXV0aG9yIGRldGFpbHMgYXJlIHVzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY29tbWl0dGVyLm5hbWVdIC0gRGVmYXVsdCBpcyBgdXNlci5uYW1lYCBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY29tbWl0dGVyLmVtYWlsXSAtIERlZmF1bHQgaXMgYHVzZXIuZW1haWxgIGNvbmZpZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5jb21taXR0ZXIudGltZXN0YW1wPU1hdGguZmxvb3IoRGF0ZS5ub3coKS8xMDAwKV0gLSBTZXQgdGhlIGNvbW1pdHRlciB0aW1lc3RhbXAgZmllbGQuIFRoaXMgaXMgdGhlIGludGVnZXIgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIFVuaXggZXBvY2ggKDE5NzAtMDEtMDEgMDA6MDA6MDApLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmNvbW1pdHRlci50aW1lem9uZU9mZnNldF0gLSBTZXQgdGhlIGNvbW1pdHRlciB0aW1lem9uZSBvZmZzZXQgZmllbGQuIFRoaXMgaXMgdGhlIGRpZmZlcmVuY2UsIGluIG1pbnV0ZXMsIGZyb20gdGhlIGN1cnJlbnQgdGltZXpvbmUgdG8gVVRDLiBEZWZhdWx0IGlzIGAobmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKWAuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3Muc2lnbmluZ0tleV0gLSBTaWduIHRoZSB0YWcgb2JqZWN0IHVzaW5nIHRoaXMgcHJpdmF0ZSBQR1Aga2V5LlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5kcnlSdW4gPSBmYWxzZV0gLSBJZiB0cnVlLCBzaW11bGF0ZXMgbWFraW5nIGEgY29tbWl0IHNvIHlvdSBjYW4gdGVzdCB3aGV0aGVyIGl0IHdvdWxkIHN1Y2NlZWQuIEltcGxpZXMgYG5vVXBkYXRlQnJhbmNoYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3Mubm9VcGRhdGVCcmFuY2ggPSBmYWxzZV0gLSBJZiB0cnVlLCBkb2VzIG5vdCB1cGRhdGUgdGhlIGJyYW5jaCBwb2ludGVyIGFmdGVyIGNyZWF0aW5nIHRoZSBjb21taXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVmXSAtIFRoZSBmdWxseSBleHBhbmRlZCBuYW1lIG9mIHRoZSBicmFuY2ggdG8gY29tbWl0IHRvLiBEZWZhdWx0IGlzIHRoZSBjdXJyZW50IGJyYW5jaCBwb2ludGVkIHRvIGJ5IEhFQUQuIChUT0RPOiBmaXggaXQgc28gaXQgY2FuIGV4cGFuZCBicmFuY2ggbmFtZXMgd2l0aG91dCB0aHJvd2luZyBpZiB0aGUgYnJhbmNoIGRvZXNuJ3QgZXhpc3QgeWV0LilcbiAqIEBwYXJhbSB7c3RyaW5nW119IFthcmdzLnBhcmVudF0gLSBUaGUgU0hBLTEgb2JqZWN0IGlkcyBvZiB0aGUgY29tbWl0cyB0byB1c2UgYXMgcGFyZW50cy4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGNvbW1pdCBwb2ludGVkIHRvIGJ5IGByZWZgIGlzIHVzZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MudHJlZV0gLSBUaGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSB0cmVlIHRvIHVzZS4gSWYgbm90IHNwZWNpZmllZCwgYSBuZXcgdHJlZSBvYmplY3QgaXMgY3JlYXRlZCBmcm9tIHRoZSBjdXJyZW50IGdpdCBpbmRleC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIHRoZSBTSEEtMSBvYmplY3QgaWQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgY29tbWl0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgc2hhID0gYXdhaXQgZ2l0LmNvbW1pdCh7XG4gKiAgIGZzLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICBhdXRob3I6IHtcbiAqICAgICBuYW1lOiAnTXIuIFRlc3QnLFxuICogICAgIGVtYWlsOiAnbXJ0ZXN0QGV4YW1wbGUuY29tJyxcbiAqICAgfSxcbiAqICAgbWVzc2FnZTogJ0FkZGVkIHRoZSBhLnR4dCBmaWxlJ1xuICogfSlcbiAqIGNvbnNvbGUubG9nKHNoYSlcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbW1pdCh7XG4gIGZzOiBfZnMsXG4gIG9uU2lnbixcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgbWVzc2FnZSxcbiAgYXV0aG9yOiBfYXV0aG9yLFxuICBjb21taXR0ZXI6IF9jb21taXR0ZXIsXG4gIHNpZ25pbmdLZXksXG4gIGRyeVJ1biA9IGZhbHNlLFxuICBub1VwZGF0ZUJyYW5jaCA9IGZhbHNlLFxuICByZWYsXG4gIHBhcmVudCxcbiAgdHJlZSxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgX2ZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBpZiAoc2lnbmluZ0tleSkge1xuICAgICAgYXNzZXJ0UGFyYW1ldGVyKCdvblNpZ24nLCBvblNpZ24pO1xuICAgIH1cbiAgICBjb25zdCBmcyA9IG5ldyBGaWxlU3lzdGVtKF9mcyk7XG5cbiAgICBjb25zdCBhdXRob3IgPSBhd2FpdCBub3JtYWxpemVBdXRob3JPYmplY3QoeyBmcywgZ2l0ZGlyLCBhdXRob3I6IF9hdXRob3IgfSk7XG4gICAgaWYgKCFhdXRob3IpIHRocm93IG5ldyBNaXNzaW5nTmFtZUVycm9yKCdhdXRob3InKVxuXG4gICAgY29uc3QgY29tbWl0dGVyID0gYXdhaXQgbm9ybWFsaXplQ29tbWl0dGVyT2JqZWN0KHtcbiAgICAgIGZzLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgYXV0aG9yLFxuICAgICAgY29tbWl0dGVyOiBfY29tbWl0dGVyLFxuICAgIH0pO1xuICAgIGlmICghY29tbWl0dGVyKSB0aHJvdyBuZXcgTWlzc2luZ05hbWVFcnJvcignY29tbWl0dGVyJylcblxuICAgIHJldHVybiBhd2FpdCBfY29tbWl0KHtcbiAgICAgIGZzLFxuICAgICAgY2FjaGUsXG4gICAgICBvblNpZ24sXG4gICAgICBnaXRkaXIsXG4gICAgICBtZXNzYWdlLFxuICAgICAgYXV0aG9yLFxuICAgICAgY29tbWl0dGVyLFxuICAgICAgc2lnbmluZ0tleSxcbiAgICAgIGRyeVJ1bixcbiAgICAgIG5vVXBkYXRlQnJhbmNoLFxuICAgICAgcmVmLFxuICAgICAgcGFyZW50LFxuICAgICAgdHJlZSxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5jb21taXQnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEdldCB0aGUgbmFtZSBvZiB0aGUgYnJhbmNoIGN1cnJlbnRseSBwb2ludGVkIHRvIGJ5IC5naXQvSEVBRFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mdWxsbmFtZSA9IGZhbHNlXSAtIFJldHVybiB0aGUgZnVsbCBwYXRoIChlLmcuIFwicmVmcy9oZWFkcy9tYWluXCIpIGluc3RlYWQgb2YgdGhlIGFiYnJldmlhdGVkIGZvcm0uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLnRlc3QgPSBmYWxzZV0gLSBJZiB0aGUgY3VycmVudCBicmFuY2ggZG9lc24ndCBhY3R1YWxseSBleGlzdCAoc3VjaCBhcyByaWdodCBhZnRlciBnaXQgaW5pdCkgdGhlbiByZXR1cm4gYHVuZGVmaW5lZGAuXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nfHZvaWQ+fSBUaGUgbmFtZSBvZiB0aGUgY3VycmVudCBicmFuY2ggb3IgdW5kZWZpbmVkIGlmIHRoZSBIRUFEIGlzIGRldGFjaGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBHZXQgdGhlIGN1cnJlbnQgYnJhbmNoIG5hbWVcbiAqIGxldCBicmFuY2ggPSBhd2FpdCBnaXQuY3VycmVudEJyYW5jaCh7XG4gKiAgIGZzLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICBmdWxsbmFtZTogZmFsc2VcbiAqIH0pXG4gKiBjb25zb2xlLmxvZyhicmFuY2gpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBjdXJyZW50QnJhbmNoKHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIGZ1bGxuYW1lID0gZmFsc2UsXG4gIHRlc3QgPSBmYWxzZSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICByZXR1cm4gYXdhaXQgX2N1cnJlbnRCcmFuY2goe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGdpdGRpcixcbiAgICAgIGZ1bGxuYW1lLFxuICAgICAgdGVzdCxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5jdXJyZW50QnJhbmNoJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWZcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2RlbGV0ZUJyYW5jaCh7IGZzLCBnaXRkaXIsIHJlZiB9KSB7XG4gIGNvbnN0IGV4aXN0ID0gYXdhaXQgR2l0UmVmTWFuYWdlci5leGlzdHMoeyBmcywgZ2l0ZGlyLCByZWYgfSk7XG4gIGlmICghZXhpc3QpIHtcbiAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcihyZWYpXG4gIH1cblxuICBjb25zdCBmdWxsUmVmID0gYXdhaXQgR2l0UmVmTWFuYWdlci5leHBhbmQoeyBmcywgZ2l0ZGlyLCByZWYgfSk7XG4gIGNvbnN0IGN1cnJlbnRSZWYgPSBhd2FpdCBfY3VycmVudEJyYW5jaCh7IGZzLCBnaXRkaXIsIGZ1bGxuYW1lOiB0cnVlIH0pO1xuICBpZiAoZnVsbFJlZiA9PT0gY3VycmVudFJlZikge1xuICAgIC8vIGRldGFjaCBIRUFEXG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoeyBmcywgZ2l0ZGlyLCByZWY6IGZ1bGxSZWYgfSk7XG4gICAgYXdhaXQgR2l0UmVmTWFuYWdlci53cml0ZVJlZih7IGZzLCBnaXRkaXIsIHJlZjogJ0hFQUQnLCB2YWx1ZSB9KTtcbiAgfVxuXG4gIC8vIERlbGV0ZSBhIHNwZWNpZmllZCBicmFuY2hcbiAgYXdhaXQgR2l0UmVmTWFuYWdlci5kZWxldGVSZWYoeyBmcywgZ2l0ZGlyLCByZWY6IGZ1bGxSZWYgfSk7XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIERlbGV0ZSBhIGxvY2FsIGJyYW5jaFxuICpcbiAqID4gTm90ZTogVGhpcyBvbmx5IGRlbGV0ZXMgbG9vc2UgYnJhbmNoZXMgLSBpdCBzaG91bGQgYmUgZml4ZWQgaW4gdGhlIGZ1dHVyZSB0byBkZWxldGUgcGFja2VkIGJyYW5jaGVzIGFzIHdlbGwuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWYgLSBUaGUgYnJhbmNoIHRvIGRlbGV0ZVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC5kZWxldGVCcmFuY2goeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgcmVmOiAnbG9jYWwtYnJhbmNoJyB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlQnJhbmNoKHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlZixcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcigncmVmJywgcmVmKTtcbiAgICByZXR1cm4gYXdhaXQgX2RlbGV0ZUJyYW5jaCh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmRlbGV0ZUJyYW5jaCc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogRGVsZXRlIGEgbG9jYWwgcmVmXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWYgLSBUaGUgcmVmIHRvIGRlbGV0ZVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC5kZWxldGVSZWYoeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgcmVmOiAncmVmcy90YWdzL3Rlc3QtdGFnJyB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlUmVmKHsgZnMsIGRpciwgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksIHJlZiB9KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlZicsIHJlZik7XG4gICAgYXdhaXQgR2l0UmVmTWFuYWdlci5kZWxldGVSZWYoeyBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLCBnaXRkaXIsIHJlZiB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuZGVsZXRlUmVmJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZW1vdGVcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2RlbGV0ZVJlbW90ZSh7IGZzLCBnaXRkaXIsIHJlbW90ZSB9KSB7XG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuZ2V0KHsgZnMsIGdpdGRpciB9KTtcbiAgYXdhaXQgY29uZmlnLmRlbGV0ZVNlY3Rpb24oJ3JlbW90ZScsIHJlbW90ZSk7XG4gIGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuc2F2ZSh7IGZzLCBnaXRkaXIsIGNvbmZpZyB9KTtcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgbG9jYWwgY29uZmlnIGVudHJ5IGZvciBhIGdpdmVuIHJlbW90ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVtb3RlIC0gVGhlIG5hbWUgb2YgdGhlIHJlbW90ZSB0byBkZWxldGVcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gZmlsZXN5c3RlbSBvcGVyYXRpb25zIGFyZSBjb21wbGV0ZVxuICpcbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBnaXQuZGVsZXRlUmVtb3RlKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIHJlbW90ZTogJ3Vwc3RyZWFtJyB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlUmVtb3RlKHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlbW90ZSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcigncmVtb3RlJywgcmVtb3RlKTtcbiAgICByZXR1cm4gYXdhaXQgX2RlbGV0ZVJlbW90ZSh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVtb3RlLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmRlbGV0ZVJlbW90ZSc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogRGVsZXRlIGEgbG9jYWwgdGFnIHJlZlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlZiAtIFRoZSB0YWcgdG8gZGVsZXRlXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIGZpbGVzeXN0ZW0gb3BlcmF0aW9ucyBhcmUgY29tcGxldGVcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZ2l0LmRlbGV0ZVRhZyh7IGRpcjogJyRpbnB1dCgoLykpJywgcmVmOiAnJGlucHV0KCh0ZXN0LXRhZykpJyB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2RlbGV0ZVRhZyh7IGZzLCBnaXRkaXIsIHJlZiB9KSB7XG4gIHJlZiA9IHJlZi5zdGFydHNXaXRoKCdyZWZzL3RhZ3MvJykgPyByZWYgOiBgcmVmcy90YWdzLyR7cmVmfWA7XG4gIGF3YWl0IEdpdFJlZk1hbmFnZXIuZGVsZXRlUmVmKHsgZnMsIGdpdGRpciwgcmVmIH0pO1xufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBEZWxldGUgYSBsb2NhbCB0YWcgcmVmXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWYgLSBUaGUgdGFnIHRvIGRlbGV0ZVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC5kZWxldGVUYWcoeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgcmVmOiAndGVzdC10YWcnIH0pXG4gKiBjb25zb2xlLmxvZygnZG9uZScpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBkZWxldGVUYWcoeyBmcywgZGlyLCBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSwgcmVmIH0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcigncmVmJywgcmVmKTtcbiAgICByZXR1cm4gYXdhaXQgX2RlbGV0ZVRhZyh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmRlbGV0ZVRhZyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZXhwYW5kT2lkTG9vc2UoeyBmcywgZ2l0ZGlyLCBvaWQ6IHNob3J0IH0pIHtcbiAgY29uc3QgcHJlZml4ID0gc2hvcnQuc2xpY2UoMCwgMik7XG4gIGNvbnN0IG9iamVjdHNTdWZmaXhlcyA9IGF3YWl0IGZzLnJlYWRkaXIoYCR7Z2l0ZGlyfS9vYmplY3RzLyR7cHJlZml4fWApO1xuICByZXR1cm4gb2JqZWN0c1N1ZmZpeGVzXG4gICAgLm1hcChzdWZmaXggPT4gYCR7cHJlZml4fSR7c3VmZml4fWApXG4gICAgLmZpbHRlcihfb2lkID0+IF9vaWQuc3RhcnRzV2l0aChzaG9ydCkpXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGV4cGFuZE9pZFBhY2tlZCh7XG4gIGZzLFxuICBjYWNoZSxcbiAgZ2l0ZGlyLFxuICBvaWQ6IHNob3J0LFxuICBnZXRFeHRlcm5hbFJlZkRlbHRhLFxufSkge1xuICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIHRoZSAucGFjayBmaWxlc1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGxldCBsaXN0ID0gYXdhaXQgZnMucmVhZGRpcihqb2luKGdpdGRpciwgJ29iamVjdHMvcGFjaycpKTtcbiAgbGlzdCA9IGxpc3QuZmlsdGVyKHggPT4geC5lbmRzV2l0aCgnLmlkeCcpKTtcbiAgZm9yIChjb25zdCBmaWxlbmFtZSBvZiBsaXN0KSB7XG4gICAgY29uc3QgaW5kZXhGaWxlID0gYCR7Z2l0ZGlyfS9vYmplY3RzL3BhY2svJHtmaWxlbmFtZX1gO1xuICAgIGNvbnN0IHAgPSBhd2FpdCByZWFkUGFja0luZGV4KHtcbiAgICAgIGZzLFxuICAgICAgY2FjaGUsXG4gICAgICBmaWxlbmFtZTogaW5kZXhGaWxlLFxuICAgICAgZ2V0RXh0ZXJuYWxSZWZEZWx0YSxcbiAgICB9KTtcbiAgICBpZiAocC5lcnJvcikgdGhyb3cgbmV3IEludGVybmFsRXJyb3IocC5lcnJvcilcbiAgICAvLyBTZWFyY2ggdGhyb3VnaCB0aGUgbGlzdCBvZiBvaWRzIGluIHRoZSBwYWNrZmlsZVxuICAgIGZvciAoY29uc3Qgb2lkIG9mIHAub2Zmc2V0cy5rZXlzKCkpIHtcbiAgICAgIGlmIChvaWQuc3RhcnRzV2l0aChzaG9ydCkpIHJlc3VsdHMucHVzaChvaWQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0c1xufVxuXG5hc3luYyBmdW5jdGlvbiBfZXhwYW5kT2lkKHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZDogc2hvcnQgfSkge1xuICAvLyBDdXJyeSB0aGUgY3VycmVudCByZWFkIG1ldGhvZCBzbyB0aGF0IHRoZSBwYWNrZmlsZSB1bi1kZWx0aWZpY2F0aW9uXG4gIC8vIHByb2Nlc3MgY2FuIGFjcXVpcmUgZXh0ZXJuYWwgcmVmLWRlbHRhcy5cbiAgY29uc3QgZ2V0RXh0ZXJuYWxSZWZEZWx0YSA9IG9pZCA9PiBfcmVhZE9iamVjdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG5cbiAgY29uc3QgcmVzdWx0czEgPSBhd2FpdCBleHBhbmRPaWRMb29zZSh7IGZzLCBnaXRkaXIsIG9pZDogc2hvcnQgfSk7XG4gIGNvbnN0IHJlc3VsdHMyID0gYXdhaXQgZXhwYW5kT2lkUGFja2VkKHtcbiAgICBmcyxcbiAgICBjYWNoZSxcbiAgICBnaXRkaXIsXG4gICAgb2lkOiBzaG9ydCxcbiAgICBnZXRFeHRlcm5hbFJlZkRlbHRhLFxuICB9KTtcbiAgY29uc3QgcmVzdWx0cyA9IHJlc3VsdHMxLmNvbmNhdChyZXN1bHRzMik7XG5cbiAgaWYgKHJlc3VsdHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHJlc3VsdHNbMF1cbiAgfVxuICBpZiAocmVzdWx0cy5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IEFtYmlndW91c0Vycm9yKCdvaWRzJywgc2hvcnQsIHJlc3VsdHMpXG4gIH1cbiAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IoYGFuIG9iamVjdCBtYXRjaGluZyBcIiR7c2hvcnR9XCJgKVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBFeHBhbmQgYW5kIHJlc29sdmUgYSBzaG9ydCBvaWQgaW50byBhIGZ1bGwgb2lkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5vaWQgLSBUaGUgc2hvcnRlbmVkIG9pZCBwcmVmaXggdG8gZXhwYW5kIChsaWtlIFwiMDQxNGQyYVwiKVxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggdGhlIGZ1bGwgb2lkIChsaWtlIFwiMDQxNGQyYTI4NmQ3YmJjN2E0YTMyNmE2MWMxZjlmODg4YThhYjg3ZlwiKVxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgb2lkID0gYXdhaXQgZ2l0LmV4cGFuZE9pZCh7IGZzLCBkaXI6ICcvdHV0b3JpYWwnLCBvaWQ6ICcwNDE0ZDJhJ30pXG4gKiBjb25zb2xlLmxvZyhvaWQpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBleHBhbmRPaWQoe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgb2lkLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignb2lkJywgb2lkKTtcbiAgICByZXR1cm4gYXdhaXQgX2V4cGFuZE9pZCh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBvaWQsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuZXhwYW5kT2lkJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBFeHBhbmQgYW4gYWJicmV2aWF0ZWQgcmVmIHRvIGl0cyBmdWxsIG5hbWVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlZiAtIFRoZSByZWYgdG8gZXhwYW5kIChsaWtlIFwidjEuMC4wXCIpXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYSBmdWxsIHJlZiBuYW1lIChcInJlZnMvdGFncy92MS4wLjBcIilcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IGZ1bGxSZWYgPSBhd2FpdCBnaXQuZXhwYW5kUmVmKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIHJlZjogJ21haW4nfSlcbiAqIGNvbnNvbGUubG9nKGZ1bGxSZWYpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBleHBhbmRSZWYoeyBmcywgZGlyLCBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSwgcmVmIH0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlZicsIHJlZik7XG4gICAgcmV0dXJuIGF3YWl0IEdpdFJlZk1hbmFnZXIuZXhwYW5kKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBnaXRkaXIsXG4gICAgICByZWYsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuZXhwYW5kUmVmJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHthbnl9IGFyZ3MuY2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmdbXX0gYXJncy5vaWRzXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBfZmluZE1lcmdlQmFzZSh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWRzIH0pIHtcbiAgLy8gTm90ZTogcmlnaHQgbm93LCB0aGUgdGVzdHMgYXJlIGdlYXJlZCBzbyB0aGF0IHRoZSBvdXRwdXQgc2hvdWxkIG1hdGNoIHRoYXQgb2ZcbiAgLy8gYGdpdCBtZXJnZS1iYXNlIC0tYWxsIC0tb2N0b3B1c2BcbiAgLy8gYmVjYXVzZSB3aXRob3V0IHRoZSAtLW9jdG9wdXMgZmxhZywgZ2l0J3Mgb3V0cHV0IHNlZW1zIHRvIGRlcGVuZCBvbiB0aGUgT1JERVIgb2YgdGhlIG9pZHMsXG4gIC8vIGFuZCBjb21wdXRpbmcgdmlydHVhbCBtZXJnZSBiYXNlcyBpcyBqdXN0IHRvbyBtdWNoIGZvciBtZSB0byBmYXRob20gcmlnaHQgbm93LlxuXG4gIC8vIElmIHdlIHN0YXJ0IE4gaW5kZXBlbmRlbnQgd2Fsa2Vycywgb25lIGF0IGVhY2ggb2YgdGhlIGdpdmVuIGBvaWRzYCwgYW5kIHdhbGsgYmFja3dhcmRzXG4gIC8vIHRocm91Z2ggYW5jZXN0b3JzLCBldmVudHVhbGx5IHdlJ2xsIGRpc2NvdmVyIGEgY29tbWl0IHdoZXJlIGVhY2ggb25lIG9mIHRoZXNlIE4gd2Fsa2Vyc1xuICAvLyBoYXMgcGFzc2VkIHRocm91Z2guIFNvIHdlIGp1c3QgbmVlZCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIHdhbGtlcnMgaGF2ZSB2aXNpdGVkIGVhY2ggY29tbWl0XG4gIC8vIHVudGlsIHdlIGZpbmQgYSBjb21taXQgdGhhdCBOIGRpc3RpbmN0IHdhbGtlcnMgaGFzIHZpc2l0ZWQuXG4gIGNvbnN0IHZpc2l0cyA9IHt9O1xuICBjb25zdCBwYXNzZXMgPSBvaWRzLmxlbmd0aDtcbiAgbGV0IGhlYWRzID0gb2lkcy5tYXAoKG9pZCwgaW5kZXgpID0+ICh7IGluZGV4LCBvaWQgfSkpO1xuICB3aGlsZSAoaGVhZHMubGVuZ3RoKSB7XG4gICAgLy8gQ291bnQgaG93IG1hbnkgdGltZXMgd2UndmUgcGFzc2VkIGVhY2ggY29tbWl0XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgeyBvaWQsIGluZGV4IH0gb2YgaGVhZHMpIHtcbiAgICAgIGlmICghdmlzaXRzW29pZF0pIHZpc2l0c1tvaWRdID0gbmV3IFNldCgpO1xuICAgICAgdmlzaXRzW29pZF0uYWRkKGluZGV4KTtcbiAgICAgIGlmICh2aXNpdHNbb2lkXS5zaXplID09PSBwYXNzZXMpIHtcbiAgICAgICAgcmVzdWx0LmFkZChvaWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzdWx0LnNpemUgPiAwKSB7XG4gICAgICByZXR1cm4gWy4uLnJlc3VsdF1cbiAgICB9XG4gICAgLy8gV2UgaGF2ZW4ndCBmb3VuZCBhIGNvbW1vbiBhbmNlc3RvciB5ZXRcbiAgICBjb25zdCBuZXdoZWFkcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHsgb2lkLCBpbmRleCB9IG9mIGhlYWRzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IG9iamVjdCB9ID0gYXdhaXQgX3JlYWRPYmplY3QoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pO1xuICAgICAgICBjb25zdCBjb21taXQgPSBHaXRDb21taXQuZnJvbShvYmplY3QpO1xuICAgICAgICBjb25zdCB7IHBhcmVudCB9ID0gY29tbWl0LnBhcnNlSGVhZGVycygpO1xuICAgICAgICBmb3IgKGNvbnN0IG9pZCBvZiBwYXJlbnQpIHtcbiAgICAgICAgICBpZiAoIXZpc2l0c1tvaWRdIHx8ICF2aXNpdHNbb2lkXS5oYXMoaW5kZXgpKSB7XG4gICAgICAgICAgICBuZXdoZWFkcy5zZXQob2lkICsgJzonICsgaW5kZXgsIHsgb2lkLCBpbmRleCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICB9XG4gICAgfVxuICAgIGhlYWRzID0gQXJyYXkuZnJvbShuZXdoZWFkcy52YWx1ZXMoKSk7XG4gIH1cbiAgcmV0dXJuIFtdXG59XG5cbmNvbnN0IExJTkVCUkVBS1MgPSAvXi4qKFxccj9cXG58JCkvZ207XG5cbmZ1bmN0aW9uIG1lcmdlRmlsZSh7XG4gIG91ckNvbnRlbnQsXG4gIGJhc2VDb250ZW50LFxuICB0aGVpckNvbnRlbnQsXG4gIG91ck5hbWUgPSAnb3VycycsXG4gIGJhc2VOYW1lID0gJ2Jhc2UnLFxuICB0aGVpck5hbWUgPSAndGhlaXJzJyxcbiAgZm9ybWF0ID0gJ2RpZmYnLFxuICBtYXJrZXJTaXplID0gNyxcbn0pIHtcbiAgY29uc3Qgb3VycyA9IG91ckNvbnRlbnQubWF0Y2goTElORUJSRUFLUyk7XG4gIGNvbnN0IGJhc2UgPSBiYXNlQ29udGVudC5tYXRjaChMSU5FQlJFQUtTKTtcbiAgY29uc3QgdGhlaXJzID0gdGhlaXJDb250ZW50Lm1hdGNoKExJTkVCUkVBS1MpO1xuXG4gIC8vIEhlcmUgd2UgbGV0IHRoZSBkaWZmMyBsaWJyYXJ5IGRvIHRoZSBoZWF2eSBsaWZ0aW5nLlxuICBjb25zdCByZXN1bHQgPSBkaWZmM01lcmdlKG91cnMsIGJhc2UsIHRoZWlycyk7XG5cbiAgLy8gSGVyZSB3ZSBub3RlIHdoZXRoZXIgdGhlcmUgYXJlIGNvbmZsaWN0cyBhbmQgZm9ybWF0IHRoZSByZXN1bHRzXG4gIGxldCBtZXJnZWRUZXh0ID0gJyc7XG4gIGxldCBjbGVhbk1lcmdlID0gdHJ1ZTtcbiAgZm9yIChjb25zdCBpdGVtIG9mIHJlc3VsdCkge1xuICAgIGlmIChpdGVtLm9rKSB7XG4gICAgICBtZXJnZWRUZXh0ICs9IGl0ZW0ub2suam9pbignJyk7XG4gICAgfVxuICAgIGlmIChpdGVtLmNvbmZsaWN0KSB7XG4gICAgICBjbGVhbk1lcmdlID0gZmFsc2U7XG4gICAgICBtZXJnZWRUZXh0ICs9IGAkeyc8Jy5yZXBlYXQobWFya2VyU2l6ZSl9ICR7b3VyTmFtZX1cXG5gO1xuICAgICAgbWVyZ2VkVGV4dCArPSBpdGVtLmNvbmZsaWN0LmEuam9pbignJyk7XG4gICAgICBpZiAoZm9ybWF0ID09PSAnZGlmZjMnKSB7XG4gICAgICAgIG1lcmdlZFRleHQgKz0gYCR7J3wnLnJlcGVhdChtYXJrZXJTaXplKX0gJHtiYXNlTmFtZX1cXG5gO1xuICAgICAgICBtZXJnZWRUZXh0ICs9IGl0ZW0uY29uZmxpY3Quby5qb2luKCcnKTtcbiAgICAgIH1cbiAgICAgIG1lcmdlZFRleHQgKz0gYCR7Jz0nLnJlcGVhdChtYXJrZXJTaXplKX1cXG5gO1xuICAgICAgbWVyZ2VkVGV4dCArPSBpdGVtLmNvbmZsaWN0LmIuam9pbignJyk7XG4gICAgICBtZXJnZWRUZXh0ICs9IGAkeyc+Jy5yZXBlYXQobWFya2VyU2l6ZSl9ICR7dGhlaXJOYW1lfVxcbmA7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGNsZWFuTWVyZ2UsIG1lcmdlZFRleHQgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBDcmVhdGUgYSBtZXJnZWQgdHJlZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge29iamVjdH0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Mub3VyT2lkIC0gVGhlIFNIQS0xIG9iamVjdCBpZCBvZiBvdXIgdHJlZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuYmFzZU9pZCAtIFRoZSBTSEEtMSBvYmplY3QgaWQgb2YgdGhlIGJhc2UgdHJlZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MudGhlaXJPaWQgLSBUaGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZWlyIHRyZWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5vdXJOYW1lPSdvdXJzJ10gLSBUaGUgbmFtZSB0byB1c2UgaW4gY29uZmxpY3RlZCBmaWxlcyBmb3Igb3VyIGh1bmtzXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuYmFzZU5hbWU9J2Jhc2UnXSAtIFRoZSBuYW1lIHRvIHVzZSBpbiBjb25mbGljdGVkIGZpbGVzIChpbiBkaWZmMyBmb3JtYXQpIGZvciB0aGUgYmFzZSBodW5rc1xuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnRoZWlyTmFtZT0ndGhlaXJzJ10gLSBUaGUgbmFtZSB0byB1c2UgaW4gY29uZmxpY3RlZCBmaWxlcyBmb3IgdGhlaXIgaHVua3NcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZHJ5UnVuPWZhbHNlXVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gVGhlIFNIQS0xIG9iamVjdCBpZCBvZiB0aGUgbWVyZ2VkIHRyZWVcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1lcmdlVHJlZSh7XG4gIGZzLFxuICBjYWNoZSxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgb3VyT2lkLFxuICBiYXNlT2lkLFxuICB0aGVpck9pZCxcbiAgb3VyTmFtZSA9ICdvdXJzJyxcbiAgYmFzZU5hbWUgPSAnYmFzZScsXG4gIHRoZWlyTmFtZSA9ICd0aGVpcnMnLFxuICBkcnlSdW4gPSBmYWxzZSxcbn0pIHtcbiAgY29uc3Qgb3VyVHJlZSA9IFRSRUUoeyByZWY6IG91ck9pZCB9KTtcbiAgY29uc3QgYmFzZVRyZWUgPSBUUkVFKHsgcmVmOiBiYXNlT2lkIH0pO1xuICBjb25zdCB0aGVpclRyZWUgPSBUUkVFKHsgcmVmOiB0aGVpck9pZCB9KTtcblxuICBjb25zdCByZXN1bHRzID0gYXdhaXQgX3dhbGsoe1xuICAgIGZzLFxuICAgIGNhY2hlLFxuICAgIGRpcixcbiAgICBnaXRkaXIsXG4gICAgdHJlZXM6IFtvdXJUcmVlLCBiYXNlVHJlZSwgdGhlaXJUcmVlXSxcbiAgICBtYXA6IGFzeW5jIGZ1bmN0aW9uKGZpbGVwYXRoLCBbb3VycywgYmFzZSwgdGhlaXJzXSkge1xuICAgICAgY29uc3QgcGF0aCA9IGJhc2VuYW1lKGZpbGVwYXRoKTtcbiAgICAgIC8vIFdoYXQgd2UgZGlkLCB3aGF0IHRoZXkgZGlkXG4gICAgICBjb25zdCBvdXJDaGFuZ2UgPSBhd2FpdCBtb2RpZmllZChvdXJzLCBiYXNlKTtcbiAgICAgIGNvbnN0IHRoZWlyQ2hhbmdlID0gYXdhaXQgbW9kaWZpZWQodGhlaXJzLCBiYXNlKTtcbiAgICAgIHN3aXRjaCAoYCR7b3VyQ2hhbmdlfS0ke3RoZWlyQ2hhbmdlfWApIHtcbiAgICAgICAgY2FzZSAnZmFsc2UtZmFsc2UnOiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGU6IGF3YWl0IGJhc2UubW9kZSgpLFxuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIG9pZDogYXdhaXQgYmFzZS5vaWQoKSxcbiAgICAgICAgICAgIHR5cGU6IGF3YWl0IGJhc2UudHlwZSgpLFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlICdmYWxzZS10cnVlJzoge1xuICAgICAgICAgIHJldHVybiB0aGVpcnNcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIG1vZGU6IGF3YWl0IHRoZWlycy5tb2RlKCksXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICBvaWQ6IGF3YWl0IHRoZWlycy5vaWQoKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBhd2FpdCB0aGVpcnMudHlwZSgpLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3RydWUtZmFsc2UnOiB7XG4gICAgICAgICAgcmV0dXJuIG91cnNcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIG1vZGU6IGF3YWl0IG91cnMubW9kZSgpLFxuICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgICAgb2lkOiBhd2FpdCBvdXJzLm9pZCgpLFxuICAgICAgICAgICAgICAgIHR5cGU6IGF3YWl0IG91cnMudHlwZSgpLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3RydWUtdHJ1ZSc6IHtcbiAgICAgICAgICAvLyBNb2RpZmljYXRpb25zXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgb3VycyAmJlxuICAgICAgICAgICAgYmFzZSAmJlxuICAgICAgICAgICAgdGhlaXJzICYmXG4gICAgICAgICAgICAoYXdhaXQgb3Vycy50eXBlKCkpID09PSAnYmxvYicgJiZcbiAgICAgICAgICAgIChhd2FpdCBiYXNlLnR5cGUoKSkgPT09ICdibG9iJyAmJlxuICAgICAgICAgICAgKGF3YWl0IHRoZWlycy50eXBlKCkpID09PSAnYmxvYidcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZUJsb2JzKHtcbiAgICAgICAgICAgICAgZnMsXG4gICAgICAgICAgICAgIGdpdGRpcixcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgb3VycyxcbiAgICAgICAgICAgICAgYmFzZSxcbiAgICAgICAgICAgICAgdGhlaXJzLFxuICAgICAgICAgICAgICBvdXJOYW1lLFxuICAgICAgICAgICAgICBiYXNlTmFtZSxcbiAgICAgICAgICAgICAgdGhlaXJOYW1lLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYWxsIG90aGVyIHR5cGVzIG9mIGNvbmZsaWN0cyBmYWlsXG4gICAgICAgICAgdGhyb3cgbmV3IE1lcmdlTm90U3VwcG9ydGVkRXJyb3IoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RyZWVFbnRyeX0gW3BhcmVudF1cbiAgICAgKiBAcGFyYW0ge0FycmF5PFRyZWVFbnRyeT59IGNoaWxkcmVuXG4gICAgICovXG4gICAgcmVkdWNlOiBhc3luYyAocGFyZW50LCBjaGlsZHJlbikgPT4ge1xuICAgICAgY29uc3QgZW50cmllcyA9IGNoaWxkcmVuLmZpbHRlcihCb29sZWFuKTsgLy8gcmVtb3ZlIHVuZGVmaW5lZHNcblxuICAgICAgLy8gaWYgdGhlIHBhcmVudCB3YXMgZGVsZXRlZCwgdGhlIGNoaWxkcmVuIGhhdmUgdG8gZ29cbiAgICAgIGlmICghcGFyZW50KSByZXR1cm5cblxuICAgICAgLy8gYXV0b21hdGljYWxseSBkZWxldGUgZGlyZWN0b3JpZXMgaWYgdGhleSBoYXZlIGJlZW4gZW1wdGllZFxuICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gJ3RyZWUnICYmIGVudHJpZXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCB0cmVlID0gbmV3IEdpdFRyZWUoZW50cmllcyk7XG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHRyZWUudG9PYmplY3QoKTtcbiAgICAgICAgY29uc3Qgb2lkID0gYXdhaXQgX3dyaXRlT2JqZWN0KHtcbiAgICAgICAgICBmcyxcbiAgICAgICAgICBnaXRkaXIsXG4gICAgICAgICAgdHlwZTogJ3RyZWUnLFxuICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICBkcnlSdW4sXG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQub2lkID0gb2lkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudFxuICAgIH0sXG4gIH0pO1xuICByZXR1cm4gcmVzdWx0cy5vaWRcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtXYWxrZXJFbnRyeX0gZW50cnlcbiAqIEBwYXJhbSB7V2Fsa2VyRW50cnl9IGJhc2VcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1vZGlmaWVkKGVudHJ5LCBiYXNlKSB7XG4gIGlmICghZW50cnkgJiYgIWJhc2UpIHJldHVybiBmYWxzZVxuICBpZiAoZW50cnkgJiYgIWJhc2UpIHJldHVybiB0cnVlXG4gIGlmICghZW50cnkgJiYgYmFzZSkgcmV0dXJuIHRydWVcbiAgaWYgKChhd2FpdCBlbnRyeS50eXBlKCkpID09PSAndHJlZScgJiYgKGF3YWl0IGJhc2UudHlwZSgpKSA9PT0gJ3RyZWUnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKFxuICAgIChhd2FpdCBlbnRyeS50eXBlKCkpID09PSAoYXdhaXQgYmFzZS50eXBlKCkpICYmXG4gICAgKGF3YWl0IGVudHJ5Lm1vZGUoKSkgPT09IChhd2FpdCBiYXNlLm1vZGUoKSkgJiZcbiAgICAoYXdhaXQgZW50cnkub2lkKCkpID09PSAoYXdhaXQgYmFzZS5vaWQoKSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbScpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucGF0aFxuICogQHBhcmFtIHtXYWxrZXJFbnRyeX0gYXJncy5vdXJzXG4gKiBAcGFyYW0ge1dhbGtlckVudHJ5fSBhcmdzLmJhc2VcbiAqIEBwYXJhbSB7V2Fsa2VyRW50cnl9IGFyZ3MudGhlaXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3Mub3VyTmFtZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5iYXNlTmFtZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy50aGVpck5hbWVdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZm9ybWF0XVxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLm1hcmtlclNpemVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmRyeVJ1biA9IGZhbHNlXVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbWVyZ2VCbG9icyh7XG4gIGZzLFxuICBnaXRkaXIsXG4gIHBhdGgsXG4gIG91cnMsXG4gIGJhc2UsXG4gIHRoZWlycyxcbiAgb3VyTmFtZSxcbiAgdGhlaXJOYW1lLFxuICBiYXNlTmFtZSxcbiAgZm9ybWF0LFxuICBtYXJrZXJTaXplLFxuICBkcnlSdW4sXG59KSB7XG4gIGNvbnN0IHR5cGUgPSAnYmxvYic7XG4gIC8vIENvbXB1dGUgdGhlIG5ldyBtb2RlLlxuICAvLyBTaW5jZSB0aGVyZSBhcmUgT05MWSB0d28gdmFsaWQgYmxvYiBtb2RlcyAoJzEwMDc1NScgYW5kICcxMDA2NDQnKSBpdCBib2lscyBkb3duIHRvIHRoaXNcbiAgY29uc3QgbW9kZSA9XG4gICAgKGF3YWl0IGJhc2UubW9kZSgpKSA9PT0gKGF3YWl0IG91cnMubW9kZSgpKVxuICAgICAgPyBhd2FpdCB0aGVpcnMubW9kZSgpXG4gICAgICA6IGF3YWl0IG91cnMubW9kZSgpO1xuICAvLyBUaGUgdHJpdmlhbCBjYXNlOiBub3RoaW5nIHRvIG1lcmdlIGV4Y2VwdCBtYXliZSBtb2RlXG4gIGlmICgoYXdhaXQgb3Vycy5vaWQoKSkgPT09IChhd2FpdCB0aGVpcnMub2lkKCkpKSB7XG4gICAgcmV0dXJuIHsgbW9kZSwgcGF0aCwgb2lkOiBhd2FpdCBvdXJzLm9pZCgpLCB0eXBlIH1cbiAgfVxuICAvLyBpZiBvbmx5IG9uZSBzaWRlIG1hZGUgb2lkIGNoYW5nZXMsIHJldHVybiB0aGF0IHNpZGUncyBvaWRcbiAgaWYgKChhd2FpdCBvdXJzLm9pZCgpKSA9PT0gKGF3YWl0IGJhc2Uub2lkKCkpKSB7XG4gICAgcmV0dXJuIHsgbW9kZSwgcGF0aCwgb2lkOiBhd2FpdCB0aGVpcnMub2lkKCksIHR5cGUgfVxuICB9XG4gIGlmICgoYXdhaXQgdGhlaXJzLm9pZCgpKSA9PT0gKGF3YWl0IGJhc2Uub2lkKCkpKSB7XG4gICAgcmV0dXJuIHsgbW9kZSwgcGF0aCwgb2lkOiBhd2FpdCBvdXJzLm9pZCgpLCB0eXBlIH1cbiAgfVxuICAvLyBpZiBib3RoIHNpZGVzIG1hZGUgY2hhbmdlcyBkbyBhIG1lcmdlXG4gIGNvbnN0IHsgbWVyZ2VkVGV4dCwgY2xlYW5NZXJnZSB9ID0gbWVyZ2VGaWxlKHtcbiAgICBvdXJDb250ZW50OiBCdWZmZXIuZnJvbShhd2FpdCBvdXJzLmNvbnRlbnQoKSkudG9TdHJpbmcoJ3V0ZjgnKSxcbiAgICBiYXNlQ29udGVudDogQnVmZmVyLmZyb20oYXdhaXQgYmFzZS5jb250ZW50KCkpLnRvU3RyaW5nKCd1dGY4JyksXG4gICAgdGhlaXJDb250ZW50OiBCdWZmZXIuZnJvbShhd2FpdCB0aGVpcnMuY29udGVudCgpKS50b1N0cmluZygndXRmOCcpLFxuICAgIG91ck5hbWUsXG4gICAgdGhlaXJOYW1lLFxuICAgIGJhc2VOYW1lLFxuICAgIGZvcm1hdCxcbiAgICBtYXJrZXJTaXplLFxuICB9KTtcbiAgaWYgKCFjbGVhbk1lcmdlKSB7XG4gICAgLy8gYWxsIG90aGVyIHR5cGVzIG9mIGNvbmZsaWN0cyBmYWlsXG4gICAgdGhyb3cgbmV3IE1lcmdlTm90U3VwcG9ydGVkRXJyb3IoKVxuICB9XG4gIGNvbnN0IG9pZCA9IGF3YWl0IF93cml0ZU9iamVjdCh7XG4gICAgZnMsXG4gICAgZ2l0ZGlyLFxuICAgIHR5cGU6ICdibG9iJyxcbiAgICBvYmplY3Q6IEJ1ZmZlci5mcm9tKG1lcmdlZFRleHQsICd1dGY4JyksXG4gICAgZHJ5UnVuLFxuICB9KTtcbiAgcmV0dXJuIHsgbW9kZSwgcGF0aCwgb2lkLCB0eXBlIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8vIGltcG9ydCBkaWZmMyBmcm9tICdub2RlLWRpZmYzJ1xuLyoqXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gTWVyZ2VSZXN1bHQgLSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgc2NoZW1hIGxpa2UgdGhpczpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb2lkXSAtIFRoZSBTSEEtMSBvYmplY3QgaWQgdGhhdCBpcyBub3cgYXQgdGhlIGhlYWQgb2YgdGhlIGJyYW5jaC4gQWJzZW50IG9ubHkgaWYgYGRyeVJ1bmAgd2FzIHNwZWNpZmllZCBhbmQgYG1lcmdlQ29tbWl0YCBpcyB0cnVlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWxyZWFkeU1lcmdlZF0gLSBUcnVlIGlmIHRoZSBicmFuY2ggd2FzIGFscmVhZHkgbWVyZ2VkIHNvIG5vIGNoYW5nZXMgd2VyZSBtYWRlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmYXN0Rm9yd2FyZF0gLSBUcnVlIGlmIGl0IHdhcyBhIGZhc3QtZm9yd2FyZCBtZXJnZVxuICogQHByb3BlcnR5IHtib29sZWFufSBbbWVyZ2VDb21taXRdIC0gVHJ1ZSBpZiBtZXJnZSByZXN1bHRlZCBpbiBhIG1lcmdlIGNvbW1pdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0cmVlXSAtIFRoZSBTSEEtMSBvYmplY3QgaWQgb2YgdGhlIHRyZWUgcmVzdWx0aW5nIGZyb20gYSBtZXJnZSBjb21taXRcbiAqXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtvYmplY3R9IGFyZ3MuY2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLm91cnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy50aGVpcnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJncy5mYXN0Rm9yd2FyZE9ubHlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJncy5kcnlSdW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJncy5ub1VwZGF0ZUJyYW5jaFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLm1lc3NhZ2VdXG4gKiBAcGFyYW0ge09iamVjdH0gYXJncy5hdXRob3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmF1dGhvci5uYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5hdXRob3IuZW1haWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmF1dGhvci50aW1lc3RhbXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmF1dGhvci50aW1lem9uZU9mZnNldFxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3MuY29tbWl0dGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5jb21taXR0ZXIubmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuY29tbWl0dGVyLmVtYWlsXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy5jb21taXR0ZXIudGltZXN0YW1wXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy5jb21taXR0ZXIudGltZXpvbmVPZmZzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5zaWduaW5nS2V5XVxuICogQHBhcmFtIHtTaWduQ2FsbGJhY2t9IFthcmdzLm9uU2lnbl0gLSBhIFBHUCBzaWduaW5nIGltcGxlbWVudGF0aW9uXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8TWVyZ2VSZXN1bHQ+fSBSZXNvbHZlcyB0byBhIGRlc2NyaXB0aW9uIG9mIHRoZSBtZXJnZSBvcGVyYXRpb25cbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9tZXJnZSh7XG4gIGZzLFxuICBjYWNoZSxcbiAgZ2l0ZGlyLFxuICBvdXJzLFxuICB0aGVpcnMsXG4gIGZhc3RGb3J3YXJkT25seSA9IGZhbHNlLFxuICBkcnlSdW4gPSBmYWxzZSxcbiAgbm9VcGRhdGVCcmFuY2ggPSBmYWxzZSxcbiAgbWVzc2FnZSxcbiAgYXV0aG9yLFxuICBjb21taXR0ZXIsXG4gIHNpZ25pbmdLZXksXG4gIG9uU2lnbixcbn0pIHtcbiAgaWYgKG91cnMgPT09IHVuZGVmaW5lZCkge1xuICAgIG91cnMgPSBhd2FpdCBfY3VycmVudEJyYW5jaCh7IGZzLCBnaXRkaXIsIGZ1bGxuYW1lOiB0cnVlIH0pO1xuICB9XG4gIG91cnMgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLmV4cGFuZCh7XG4gICAgZnMsXG4gICAgZ2l0ZGlyLFxuICAgIHJlZjogb3VycyxcbiAgfSk7XG4gIHRoZWlycyA9IGF3YWl0IEdpdFJlZk1hbmFnZXIuZXhwYW5kKHtcbiAgICBmcyxcbiAgICBnaXRkaXIsXG4gICAgcmVmOiB0aGVpcnMsXG4gIH0pO1xuICBjb25zdCBvdXJPaWQgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoe1xuICAgIGZzLFxuICAgIGdpdGRpcixcbiAgICByZWY6IG91cnMsXG4gIH0pO1xuICBjb25zdCB0aGVpck9pZCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7XG4gICAgZnMsXG4gICAgZ2l0ZGlyLFxuICAgIHJlZjogdGhlaXJzLFxuICB9KTtcbiAgLy8gZmluZCBtb3N0IHJlY2VudCBjb21tb24gYW5jZXN0b3Igb2YgcmVmIGEgYW5kIHJlZiBiXG4gIGNvbnN0IGJhc2VPaWRzID0gYXdhaXQgX2ZpbmRNZXJnZUJhc2Uoe1xuICAgIGZzLFxuICAgIGNhY2hlLFxuICAgIGdpdGRpcixcbiAgICBvaWRzOiBbb3VyT2lkLCB0aGVpck9pZF0sXG4gIH0pO1xuICBpZiAoYmFzZU9pZHMubGVuZ3RoICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IE1lcmdlTm90U3VwcG9ydGVkRXJyb3IoKVxuICB9XG4gIGNvbnN0IGJhc2VPaWQgPSBiYXNlT2lkc1swXTtcbiAgLy8gaGFuZGxlIGZhc3QtZm9yd2FyZCBjYXNlXG4gIGlmIChiYXNlT2lkID09PSB0aGVpck9pZCkge1xuICAgIHJldHVybiB7XG4gICAgICBvaWQ6IG91ck9pZCxcbiAgICAgIGFscmVhZHlNZXJnZWQ6IHRydWUsXG4gICAgfVxuICB9XG4gIGlmIChiYXNlT2lkID09PSBvdXJPaWQpIHtcbiAgICBpZiAoIWRyeVJ1biAmJiAhbm9VcGRhdGVCcmFuY2gpIHtcbiAgICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIud3JpdGVSZWYoeyBmcywgZ2l0ZGlyLCByZWY6IG91cnMsIHZhbHVlOiB0aGVpck9pZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG9pZDogdGhlaXJPaWQsXG4gICAgICBmYXN0Rm9yd2FyZDogdHJ1ZSxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbm90IGEgc2ltcGxlIGZhc3QtZm9yd2FyZFxuICAgIGlmIChmYXN0Rm9yd2FyZE9ubHkpIHtcbiAgICAgIHRocm93IG5ldyBGYXN0Rm9yd2FyZEVycm9yKClcbiAgICB9XG4gICAgLy8gdHJ5IGEgZmFuY2llciBtZXJnZVxuICAgIGNvbnN0IHRyZWUgPSBhd2FpdCBtZXJnZVRyZWUoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIG91ck9pZCxcbiAgICAgIHRoZWlyT2lkLFxuICAgICAgYmFzZU9pZCxcbiAgICAgIG91ck5hbWU6IG91cnMsXG4gICAgICBiYXNlTmFtZTogJ2Jhc2UnLFxuICAgICAgdGhlaXJOYW1lOiB0aGVpcnMsXG4gICAgICBkcnlSdW4sXG4gICAgfSk7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICBtZXNzYWdlID0gYE1lcmdlIGJyYW5jaCAnJHthYmJyZXZpYXRlUmVmKHRoZWlycyl9JyBpbnRvICR7YWJicmV2aWF0ZVJlZihcbiAgICAgICAgb3Vyc1xuICAgICAgKX1gO1xuICAgIH1cbiAgICBjb25zdCBvaWQgPSBhd2FpdCBfY29tbWl0KHtcbiAgICAgIGZzLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBtZXNzYWdlLFxuICAgICAgcmVmOiBvdXJzLFxuICAgICAgdHJlZSxcbiAgICAgIHBhcmVudDogW291ck9pZCwgdGhlaXJPaWRdLFxuICAgICAgYXV0aG9yLFxuICAgICAgY29tbWl0dGVyLFxuICAgICAgc2lnbmluZ0tleSxcbiAgICAgIG9uU2lnbixcbiAgICAgIGRyeVJ1bixcbiAgICAgIG5vVXBkYXRlQnJhbmNoLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBvaWQsXG4gICAgICB0cmVlLFxuICAgICAgbWVyZ2VDb21taXQ6IHRydWUsXG4gICAgfVxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge29iamVjdH0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtIdHRwQ2xpZW50fSBhcmdzLmh0dHBcbiAqIEBwYXJhbSB7UHJvZ3Jlc3NDYWxsYmFja30gW2FyZ3Mub25Qcm9ncmVzc11cbiAqIEBwYXJhbSB7TWVzc2FnZUNhbGxiYWNrfSBbYXJncy5vbk1lc3NhZ2VdXG4gKiBAcGFyYW0ge0F1dGhDYWxsYmFja30gW2FyZ3Mub25BdXRoXVxuICogQHBhcmFtIHtBdXRoRmFpbHVyZUNhbGxiYWNrfSBbYXJncy5vbkF1dGhGYWlsdXJlXVxuICogQHBhcmFtIHtBdXRoU3VjY2Vzc0NhbGxiYWNrfSBbYXJncy5vbkF1dGhTdWNjZXNzXVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlZlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnVybF1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZW1vdGVdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVtb3RlUmVmXVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvcnNQcm94eV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJncy5zaW5nbGVCcmFuY2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYXJncy5mYXN0Rm9yd2FyZE9ubHlcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2FyZ3MuaGVhZGVyc11cbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzLmF1dGhvclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuYXV0aG9yLm5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmF1dGhvci5lbWFpbFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuYXV0aG9yLnRpbWVzdGFtcFxuICogQHBhcmFtIHtudW1iZXJ9IGFyZ3MuYXV0aG9yLnRpbWV6b25lT2Zmc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gYXJncy5jb21taXR0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmNvbW1pdHRlci5uYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5jb21taXR0ZXIuZW1haWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmNvbW1pdHRlci50aW1lc3RhbXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmNvbW1pdHRlci50aW1lem9uZU9mZnNldFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnNpZ25pbmdLZXldXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIHB1bGwgb3BlcmF0aW9uIGNvbXBsZXRlc1xuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3B1bGwoe1xuICBmcyxcbiAgY2FjaGUsXG4gIGh0dHAsXG4gIG9uUHJvZ3Jlc3MsXG4gIG9uTWVzc2FnZSxcbiAgb25BdXRoLFxuICBvbkF1dGhTdWNjZXNzLFxuICBvbkF1dGhGYWlsdXJlLFxuICBkaXIsXG4gIGdpdGRpcixcbiAgcmVmLFxuICB1cmwsXG4gIHJlbW90ZSxcbiAgcmVtb3RlUmVmLFxuICBmYXN0Rm9yd2FyZE9ubHksXG4gIGNvcnNQcm94eSxcbiAgc2luZ2xlQnJhbmNoLFxuICBoZWFkZXJzLFxuICBhdXRob3IsXG4gIGNvbW1pdHRlcixcbiAgc2lnbmluZ0tleSxcbn0pIHtcbiAgdHJ5IHtcbiAgICAvLyBJZiByZWYgaXMgdW5kZWZpbmVkLCB1c2UgJ0hFQUQnXG4gICAgaWYgKCFyZWYpIHtcbiAgICAgIGNvbnN0IGhlYWQgPSBhd2FpdCBfY3VycmVudEJyYW5jaCh7IGZzLCBnaXRkaXIgfSk7XG4gICAgICAvLyBUT0RPOiB1c2UgYSBiZXR0ZXIgZXJyb3IuXG4gICAgICBpZiAoIWhlYWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdQYXJhbWV0ZXJFcnJvcigncmVmJylcbiAgICAgIH1cbiAgICAgIHJlZiA9IGhlYWQ7XG4gICAgfVxuXG4gICAgY29uc3QgeyBmZXRjaEhlYWQsIGZldGNoSGVhZERlc2NyaXB0aW9uIH0gPSBhd2FpdCBfZmV0Y2goe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGh0dHAsXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgb25NZXNzYWdlLFxuICAgICAgb25BdXRoLFxuICAgICAgb25BdXRoU3VjY2VzcyxcbiAgICAgIG9uQXV0aEZhaWx1cmUsXG4gICAgICBnaXRkaXIsXG4gICAgICBjb3JzUHJveHksXG4gICAgICByZWYsXG4gICAgICB1cmwsXG4gICAgICByZW1vdGUsXG4gICAgICByZW1vdGVSZWYsXG4gICAgICBzaW5nbGVCcmFuY2gsXG4gICAgICBoZWFkZXJzLFxuICAgIH0pO1xuICAgIC8vIE1lcmdlIHRoZSByZW1vdGUgdHJhY2tpbmcgYnJhbmNoIGludG8gdGhlIGxvY2FsIG9uZS5cbiAgICBhd2FpdCBfbWVyZ2Uoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIG91cnM6IHJlZixcbiAgICAgIHRoZWlyczogZmV0Y2hIZWFkLFxuICAgICAgZmFzdEZvcndhcmRPbmx5LFxuICAgICAgbWVzc2FnZTogYE1lcmdlICR7ZmV0Y2hIZWFkRGVzY3JpcHRpb259YCxcbiAgICAgIGF1dGhvcixcbiAgICAgIGNvbW1pdHRlcixcbiAgICAgIHNpZ25pbmdLZXksXG4gICAgICBkcnlSdW46IGZhbHNlLFxuICAgICAgbm9VcGRhdGVCcmFuY2g6IGZhbHNlLFxuICAgIH0pO1xuICAgIGF3YWl0IF9jaGVja291dCh7XG4gICAgICBmcyxcbiAgICAgIGNhY2hlLFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIGRpcixcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZixcbiAgICAgIHJlbW90ZSxcbiAgICAgIG5vQ2hlY2tvdXQ6IGZhbHNlLFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5wdWxsJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBMaWtlIGBwdWxsYCwgYnV0IGhhcmQtY29kZWQgd2l0aCBgZmFzdEZvcndhcmQ6IHRydWVgIHNvIHRoZXJlIGlzIG5vIG5lZWQgZm9yIGFuIGBhdXRob3JgIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge0h0dHBDbGllbnR9IGFyZ3MuaHR0cCAtIGFuIEhUVFAgY2xpZW50XG4gKiBAcGFyYW0ge1Byb2dyZXNzQ2FsbGJhY2t9IFthcmdzLm9uUHJvZ3Jlc3NdIC0gb3B0aW9uYWwgcHJvZ3Jlc3MgZXZlbnQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7TWVzc2FnZUNhbGxiYWNrfSBbYXJncy5vbk1lc3NhZ2VdIC0gb3B0aW9uYWwgbWVzc2FnZSBldmVudCBjYWxsYmFja1xuICogQHBhcmFtIHtBdXRoQ2FsbGJhY2t9IFthcmdzLm9uQXV0aF0gLSBvcHRpb25hbCBhdXRoIGZpbGwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXV0aEZhaWx1cmVDYWxsYmFja30gW2FyZ3Mub25BdXRoRmFpbHVyZV0gLSBvcHRpb25hbCBhdXRoIHJlamVjdGVkIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhTdWNjZXNzQ2FsbGJhY2t9IFthcmdzLm9uQXV0aFN1Y2Nlc3NdIC0gb3B0aW9uYWwgYXV0aCBhcHByb3ZlZCBjYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVmXSAtIFdoaWNoIGJyYW5jaCB0byBtZXJnZSBpbnRvLiBCeSBkZWZhdWx0IHRoaXMgaXMgdGhlIGN1cnJlbnRseSBjaGVja2VkIG91dCBicmFuY2guXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MudXJsXSAtIChBZGRlZCBpbiAxLjEuMCkgVGhlIFVSTCBvZiB0aGUgcmVtb3RlIHJlcG9zaXRvcnkuIFRoZSBkZWZhdWx0IGlzIHRoZSB2YWx1ZSBzZXQgaW4gdGhlIGdpdCBjb25maWcgZm9yIHRoYXQgcmVtb3RlLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlbW90ZV0gLSAoQWRkZWQgaW4gMS4xLjApIElmIFVSTCBpcyBub3Qgc3BlY2lmaWVkLCBkZXRlcm1pbmVzIHdoaWNoIHJlbW90ZSB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVtb3RlUmVmXSAtIChBZGRlZCBpbiAxLjEuMCkgVGhlIG5hbWUgb2YgdGhlIGJyYW5jaCBvbiB0aGUgcmVtb3RlIHRvIGZldGNoLiBCeSBkZWZhdWx0IHRoaXMgaXMgdGhlIGNvbmZpZ3VyZWQgcmVtb3RlIHRyYWNraW5nIGJyYW5jaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb3JzUHJveHldIC0gT3B0aW9uYWwgW0NPUlMgcHJveHldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS8lNDBpc29tb3JwaGljLWdpdC9jb3JzLXByb3h5KS4gT3ZlcnJpZGVzIHZhbHVlIGluIHJlcG8gY29uZmlnLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5zaW5nbGVCcmFuY2ggPSBmYWxzZV0gLSBJbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGZldGNoaW5nIGFsbCB0aGUgYnJhbmNoZXMsIG9ubHkgZmV0Y2ggYSBzaW5nbGUgYnJhbmNoLlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbYXJncy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgaGVhZGVycyB0byBpbmNsdWRlIGluIEhUVFAgcmVxdWVzdHMsIHNpbWlsYXIgdG8gZ2l0J3MgYGV4dHJhSGVhZGVyYCBjb25maWdcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBwdWxsIG9wZXJhdGlvbiBjb21wbGV0ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZ2l0LmZhc3RGb3J3YXJkKHtcbiAqICAgZnMsXG4gKiAgIGh0dHAsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIHJlZjogJ21haW4nLFxuICogICBzaW5nbGVCcmFuY2g6IHRydWVcbiAqIH0pXG4gKiBjb25zb2xlLmxvZygnZG9uZScpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBmYXN0Rm9yd2FyZCh7XG4gIGZzLFxuICBodHRwLFxuICBvblByb2dyZXNzLFxuICBvbk1lc3NhZ2UsXG4gIG9uQXV0aCxcbiAgb25BdXRoU3VjY2VzcyxcbiAgb25BdXRoRmFpbHVyZSxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgcmVmLFxuICB1cmwsXG4gIHJlbW90ZSxcbiAgcmVtb3RlUmVmLFxuICBjb3JzUHJveHksXG4gIHNpbmdsZUJyYW5jaCxcbiAgaGVhZGVycyA9IHt9LFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdodHRwJywgaHR0cCk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuXG4gICAgY29uc3QgdGhpc1dpbGxOb3RCZVVzZWQgPSB7XG4gICAgICBuYW1lOiAnJyxcbiAgICAgIGVtYWlsOiAnJyxcbiAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgIHRpbWV6b25lT2Zmc2V0OiAwLFxuICAgIH07XG5cbiAgICByZXR1cm4gYXdhaXQgX3B1bGwoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGNhY2hlLFxuICAgICAgaHR0cCxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBvbk1lc3NhZ2UsXG4gICAgICBvbkF1dGgsXG4gICAgICBvbkF1dGhTdWNjZXNzLFxuICAgICAgb25BdXRoRmFpbHVyZSxcbiAgICAgIGRpcixcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZixcbiAgICAgIHVybCxcbiAgICAgIHJlbW90ZSxcbiAgICAgIHJlbW90ZVJlZixcbiAgICAgIGZhc3RGb3J3YXJkT25seTogdHJ1ZSxcbiAgICAgIGNvcnNQcm94eSxcbiAgICAgIHNpbmdsZUJyYW5jaCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBhdXRob3I6IHRoaXNXaWxsTm90QmVVc2VkLFxuICAgICAgY29tbWl0dGVyOiB0aGlzV2lsbE5vdEJlVXNlZCxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5mYXN0Rm9yd2FyZCc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEZldGNoUmVzdWx0IC0gVGhlIG9iamVjdCByZXR1cm5lZCBoYXMgdGhlIGZvbGxvd2luZyBzY2hlbWE6XG4gKiBAcHJvcGVydHkge3N0cmluZyB8IG51bGx9IGRlZmF1bHRCcmFuY2ggLSBUaGUgYnJhbmNoIHRoYXQgaXMgY2xvbmVkIGlmIG5vIGJyYW5jaCBpcyBzcGVjaWZpZWRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbH0gZmV0Y2hIZWFkIC0gVGhlIFNIQS0xIG9iamVjdCBpZCBvZiB0aGUgZmV0Y2hlZCBoZWFkIGNvbW1pdFxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsfSBmZXRjaEhlYWREZXNjcmlwdGlvbiAtIGEgdGV4dHVhbCBkZXNjcmlwdGlvbiBvZiB0aGUgYnJhbmNoIHRoYXQgd2FzIGZldGNoZWRcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2hlYWRlcnNdIC0gVGhlIEhUVFAgcmVzcG9uc2UgaGVhZGVycyByZXR1cm5lZCBieSB0aGUgZ2l0IHNlcnZlclxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gW3BydW5lZF0gLSBBIGxpc3Qgb2YgYnJhbmNoZXMgdGhhdCB3ZXJlIHBydW5lZCwgaWYgeW91IHByb3ZpZGVkIHRoZSBgcHJ1bmVgIHBhcmFtZXRlclxuICpcbiAqL1xuXG4vKipcbiAqIEZldGNoIGNvbW1pdHMgZnJvbSBhIHJlbW90ZSByZXBvc2l0b3J5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtIdHRwQ2xpZW50fSBhcmdzLmh0dHAgLSBhbiBIVFRQIGNsaWVudFxuICogQHBhcmFtIHtQcm9ncmVzc0NhbGxiYWNrfSBbYXJncy5vblByb2dyZXNzXSAtIG9wdGlvbmFsIHByb2dyZXNzIGV2ZW50IGNhbGxiYWNrXG4gKiBAcGFyYW0ge01lc3NhZ2VDYWxsYmFja30gW2FyZ3Mub25NZXNzYWdlXSAtIG9wdGlvbmFsIG1lc3NhZ2UgZXZlbnQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXV0aENhbGxiYWNrfSBbYXJncy5vbkF1dGhdIC0gb3B0aW9uYWwgYXV0aCBmaWxsIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhGYWlsdXJlQ2FsbGJhY2t9IFthcmdzLm9uQXV0aEZhaWx1cmVdIC0gb3B0aW9uYWwgYXV0aCByZWplY3RlZCBjYWxsYmFja1xuICogQHBhcmFtIHtBdXRoU3VjY2Vzc0NhbGxiYWNrfSBbYXJncy5vbkF1dGhTdWNjZXNzXSAtIG9wdGlvbmFsIGF1dGggYXBwcm92ZWQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy51cmxdIC0gVGhlIFVSTCBvZiB0aGUgcmVtb3RlIHJlcG9zaXRvcnkuIFRoZSBkZWZhdWx0IGlzIHRoZSB2YWx1ZSBzZXQgaW4gdGhlIGdpdCBjb25maWcgZm9yIHRoYXQgcmVtb3RlLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlbW90ZV0gLSBJZiBVUkwgaXMgbm90IHNwZWNpZmllZCwgZGV0ZXJtaW5lcyB3aGljaCByZW1vdGUgdG8gdXNlLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5zaW5nbGVCcmFuY2ggPSBmYWxzZV0gLSBJbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9mIGZldGNoaW5nIGFsbCB0aGUgYnJhbmNoZXMsIG9ubHkgZmV0Y2ggYSBzaW5nbGUgYnJhbmNoLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZl0gLSBXaGljaCBicmFuY2ggdG8gZmV0Y2ggaWYgYHNpbmdsZUJyYW5jaGAgaXMgdHJ1ZS4gQnkgZGVmYXVsdCB0aGlzIGlzIHRoZSBjdXJyZW50IGJyYW5jaCBvciB0aGUgcmVtb3RlJ3MgZGVmYXVsdCBicmFuY2guXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVtb3RlUmVmXSAtIFRoZSBuYW1lIG9mIHRoZSBicmFuY2ggb24gdGhlIHJlbW90ZSB0byBmZXRjaCBpZiBgc2luZ2xlQnJhbmNoYCBpcyB0cnVlLiBCeSBkZWZhdWx0IHRoaXMgaXMgdGhlIGNvbmZpZ3VyZWQgcmVtb3RlIHRyYWNraW5nIGJyYW5jaC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MudGFncyA9IGZhbHNlXSAtIEFsc28gZmV0Y2ggdGFnc1xuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmRlcHRoXSAtIEludGVnZXIuIERldGVybWluZXMgaG93IG11Y2ggb2YgdGhlIGdpdCByZXBvc2l0b3J5J3MgaGlzdG9yeSB0byByZXRyaWV2ZVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5yZWxhdGl2ZSA9IGZhbHNlXSAtIENoYW5nZXMgdGhlIG1lYW5pbmcgb2YgYGRlcHRoYCB0byBiZSBtZWFzdXJlZCBmcm9tIHRoZSBjdXJyZW50IHNoYWxsb3cgZGVwdGggcmF0aGVyIHRoYW4gZnJvbSB0aGUgYnJhbmNoIHRpcC5cbiAqIEBwYXJhbSB7RGF0ZX0gW2FyZ3Muc2luY2VdIC0gT25seSBmZXRjaCBjb21taXRzIGNyZWF0ZWQgYWZ0ZXIgdGhlIGdpdmVuIGRhdGUuIE11dHVhbGx5IGV4Y2x1c2l2ZSB3aXRoIGBkZXB0aGAuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbYXJncy5leGNsdWRlID0gW11dIC0gQSBsaXN0IG9mIGJyYW5jaGVzIG9yIHRhZ3MuIEluc3RydWN0cyB0aGUgcmVtb3RlIHNlcnZlciBub3QgdG8gc2VuZCB1cyBhbnkgY29tbWl0cyByZWFjaGFibGUgZnJvbSB0aGVzZSByZWZzLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5wcnVuZV0gLSBEZWxldGUgbG9jYWwgcmVtb3RlLXRyYWNraW5nIGJyYW5jaGVzIHRoYXQgYXJlIG5vdCBwcmVzZW50IG9uIHRoZSByZW1vdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MucHJ1bmVUYWdzXSAtIFBydW5lIGxvY2FsIHRhZ3MgdGhhdCBkb27igJl0IGV4aXN0IG9uIHRoZSByZW1vdGUsIGFuZCBmb3JjZS11cGRhdGUgdGhvc2UgdGFncyB0aGF0IGRpZmZlclxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvcnNQcm94eV0gLSBPcHRpb25hbCBbQ09SUyBwcm94eV0oaHR0cHM6Ly93d3cubnBtanMuY29tLyU0MGlzb21vcnBoaWMtZ2l0L2NvcnMtcHJveHkpLiBPdmVycmlkZXMgdmFsdWUgaW4gcmVwbyBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIHN0cmluZz59IFthcmdzLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBoZWFkZXJzIHRvIGluY2x1ZGUgaW4gSFRUUCByZXF1ZXN0cywgc2ltaWxhciB0byBnaXQncyBgZXh0cmFIZWFkZXJgIGNvbmZpZ1xuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8RmV0Y2hSZXN1bHQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmZXRjaCBjb21wbGV0ZXNcbiAqIEBzZWUgRmV0Y2hSZXN1bHRcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHJlc3VsdCA9IGF3YWl0IGdpdC5mZXRjaCh7XG4gKiAgIGZzLFxuICogICBodHRwLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICBjb3JzUHJveHk6ICdodHRwczovL2NvcnMuaXNvbW9ycGhpYy1naXQub3JnJyxcbiAqICAgdXJsOiAnaHR0cHM6Ly9naXRodWIuY29tL2lzb21vcnBoaWMtZ2l0L2lzb21vcnBoaWMtZ2l0JyxcbiAqICAgcmVmOiAnbWFpbicsXG4gKiAgIGRlcHRoOiAxLFxuICogICBzaW5nbGVCcmFuY2g6IHRydWUsXG4gKiAgIHRhZ3M6IGZhbHNlXG4gKiB9KVxuICogY29uc29sZS5sb2cocmVzdWx0KVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2goe1xuICBmcyxcbiAgaHR0cCxcbiAgb25Qcm9ncmVzcyxcbiAgb25NZXNzYWdlLFxuICBvbkF1dGgsXG4gIG9uQXV0aFN1Y2Nlc3MsXG4gIG9uQXV0aEZhaWx1cmUsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlZixcbiAgcmVtb3RlLFxuICByZW1vdGVSZWYsXG4gIHVybCxcbiAgY29yc1Byb3h5LFxuICBkZXB0aCA9IG51bGwsXG4gIHNpbmNlID0gbnVsbCxcbiAgZXhjbHVkZSA9IFtdLFxuICByZWxhdGl2ZSA9IGZhbHNlLFxuICB0YWdzID0gZmFsc2UsXG4gIHNpbmdsZUJyYW5jaCA9IGZhbHNlLFxuICBoZWFkZXJzID0ge30sXG4gIHBydW5lID0gZmFsc2UsXG4gIHBydW5lVGFncyA9IGZhbHNlLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdodHRwJywgaHR0cCk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9mZXRjaCh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBodHRwLFxuICAgICAgb25Qcm9ncmVzcyxcbiAgICAgIG9uTWVzc2FnZSxcbiAgICAgIG9uQXV0aCxcbiAgICAgIG9uQXV0aFN1Y2Nlc3MsXG4gICAgICBvbkF1dGhGYWlsdXJlLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmLFxuICAgICAgcmVtb3RlLFxuICAgICAgcmVtb3RlUmVmLFxuICAgICAgdXJsLFxuICAgICAgY29yc1Byb3h5LFxuICAgICAgZGVwdGgsXG4gICAgICBzaW5jZSxcbiAgICAgIGV4Y2x1ZGUsXG4gICAgICByZWxhdGl2ZSxcbiAgICAgIHRhZ3MsXG4gICAgICBzaW5nbGVCcmFuY2gsXG4gICAgICBoZWFkZXJzLFxuICAgICAgcHJ1bmUsXG4gICAgICBwcnVuZVRhZ3MsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuZmV0Y2gnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEZpbmQgdGhlIG1lcmdlIGJhc2UgZm9yIGEgc2V0IG9mIGNvbW1pdHNcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhcmdzLm9pZHMgLSBXaGljaCBjb21taXRzXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpbmRNZXJnZUJhc2Uoe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgb2lkcyxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ29pZHMnLCBvaWRzKTtcblxuICAgIHJldHVybiBhd2FpdCBfZmluZE1lcmdlQmFzZSh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBvaWRzLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmZpbmRNZXJnZUJhc2UnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEZpbmQgdGhlIHJvb3QgZ2l0IGRpcmVjdG9yeVxuICpcbiAqIFN0YXJ0aW5nIGF0IGBmaWxlcGF0aGAsIHdhbGtzIHVwd2FyZCB1bnRpbCBpdCBmaW5kcyBhIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGEgc3ViZGlyZWN0b3J5IGNhbGxlZCAnLmdpdCcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmZpbGVwYXRoXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYSByb290IGdpdCBkaXJlY3RvcnkgcGF0aFxuICovXG5hc3luYyBmdW5jdGlvbiBfZmluZFJvb3QoeyBmcywgZmlsZXBhdGggfSkge1xuICBpZiAoYXdhaXQgZnMuZXhpc3RzKGpvaW4oZmlsZXBhdGgsICcuZ2l0JykpKSB7XG4gICAgcmV0dXJuIGZpbGVwYXRoXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcGFyZW50ID0gZGlybmFtZShmaWxlcGF0aCk7XG4gICAgaWYgKHBhcmVudCA9PT0gZmlsZXBhdGgpIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKGBnaXQgcm9vdCBmb3IgJHtmaWxlcGF0aH1gKVxuICAgIH1cbiAgICByZXR1cm4gX2ZpbmRSb290KHsgZnMsIGZpbGVwYXRoOiBwYXJlbnQgfSlcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBGaW5kIHRoZSByb290IGdpdCBkaXJlY3RvcnlcbiAqXG4gKiBTdGFydGluZyBhdCBgZmlsZXBhdGhgLCB3YWxrcyB1cHdhcmQgdW50aWwgaXQgZmluZHMgYSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBhIHN1YmRpcmVjdG9yeSBjYWxsZWQgJy5naXQnLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmZpbGVwYXRoIC0gVGhlIGZpbGUgZGlyZWN0b3J5IHRvIHN0YXJ0IHNlYXJjaGluZyBpbi5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCBhIHJvb3QgZ2l0IGRpcmVjdG9yeSBwYXRoXG4gKiBAdGhyb3dzIHtOb3RGb3VuZEVycm9yfVxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgZ2l0cm9vdCA9IGF3YWl0IGdpdC5maW5kUm9vdCh7XG4gKiAgIGZzLFxuICogICBmaWxlcGF0aDogJy90dXRvcmlhbC9zcmMvdXRpbHMnXG4gKiB9KVxuICogY29uc29sZS5sb2coZ2l0cm9vdClcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpbmRSb290KHsgZnMsIGZpbGVwYXRoIH0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZmlsZXBhdGgnLCBmaWxlcGF0aCk7XG5cbiAgICByZXR1cm4gYXdhaXQgX2ZpbmRSb290KHsgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSwgZmlsZXBhdGggfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuZmluZFJvb3QnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFJlYWQgYW4gZW50cnkgZnJvbSB0aGUgZ2l0IGNvbmZpZyBmaWxlcy5cbiAqXG4gKiAqQ2F2ZWF0czoqXG4gKiAtIEN1cnJlbnRseSBvbmx5IHRoZSBsb2NhbCBgJEdJVF9ESVIvY29uZmlnYCBmaWxlIGNhbiBiZSByZWFkIG9yIHdyaXR0ZW4uIEhvd2V2ZXIgc3VwcG9ydCBmb3IgdGhlIGdsb2JhbCBgfi8uZ2l0Y29uZmlnYCBhbmQgc3lzdGVtIGAkKHByZWZpeCkvZXRjL2dpdGNvbmZpZ2Agd2lsbCBiZSBhZGRlZCBpbiB0aGUgZnV0dXJlLlxuICogLSBUaGUgY3VycmVudCBwYXJzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgbW9yZSBleG90aWMgZmVhdHVyZXMgb2YgdGhlIGdpdC1jb25maWcgZmlsZSBmb3JtYXQgc3VjaCBhcyBgW2luY2x1ZGVdYCBhbmQgYFtpbmNsdWRlSWZdYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnBhdGggLSBUaGUga2V5IG9mIHRoZSBnaXQgY29uZmlnIGVudHJ5XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gUmVzb2x2ZXMgd2l0aCB0aGUgY29uZmlnIHZhbHVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFJlYWQgY29uZmlnIHZhbHVlXG4gKiBsZXQgdmFsdWUgPSBhd2FpdCBnaXQuZ2V0Q29uZmlnKHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIHBhdGg6ICdyZW1vdGUub3JpZ2luLnVybCdcbiAqIH0pXG4gKiBjb25zb2xlLmxvZyh2YWx1ZSlcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldENvbmZpZyh7IGZzLCBkaXIsIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLCBwYXRoIH0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3BhdGgnLCBwYXRoKTtcblxuICAgIHJldHVybiBhd2FpdCBfZ2V0Q29uZmlnKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBnaXRkaXIsXG4gICAgICBwYXRoLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmdldENvbmZpZyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucGF0aFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PGFueT4+fSBSZXNvbHZlcyB3aXRoIGFuIGFycmF5IG9mIHRoZSBjb25maWcgdmFsdWVcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9nZXRDb25maWdBbGwoeyBmcywgZ2l0ZGlyLCBwYXRoIH0pIHtcbiAgY29uc3QgY29uZmlnID0gYXdhaXQgR2l0Q29uZmlnTWFuYWdlci5nZXQoeyBmcywgZ2l0ZGlyIH0pO1xuICByZXR1cm4gY29uZmlnLmdldGFsbChwYXRoKVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBSZWFkIGEgbXVsdGktdmFsdWVkIGVudHJ5IGZyb20gdGhlIGdpdCBjb25maWcgZmlsZXMuXG4gKlxuICogKkNhdmVhdHM6KlxuICogLSBDdXJyZW50bHkgb25seSB0aGUgbG9jYWwgYCRHSVRfRElSL2NvbmZpZ2AgZmlsZSBjYW4gYmUgcmVhZCBvciB3cml0dGVuLiBIb3dldmVyIHN1cHBvcnQgZm9yIHRoZSBnbG9iYWwgYH4vLmdpdGNvbmZpZ2AgYW5kIHN5c3RlbSBgJChwcmVmaXgpL2V0Yy9naXRjb25maWdgIHdpbGwgYmUgYWRkZWQgaW4gdGhlIGZ1dHVyZS5cbiAqIC0gVGhlIGN1cnJlbnQgcGFyc2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIG1vcmUgZXhvdGljIGZlYXR1cmVzIG9mIHRoZSBnaXQtY29uZmlnIGZpbGUgZm9ybWF0IHN1Y2ggYXMgYFtpbmNsdWRlXWAgYW5kIGBbaW5jbHVkZUlmXWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5wYXRoIC0gVGhlIGtleSBvZiB0aGUgZ2l0IGNvbmZpZyBlbnRyeVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PGFueT4+fSBSZXNvbHZlcyB3aXRoIHRoZSBjb25maWcgdmFsdWVcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldENvbmZpZ0FsbCh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICBwYXRoLFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcigncGF0aCcsIHBhdGgpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9nZXRDb25maWdBbGwoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGdpdGRpcixcbiAgICAgIHBhdGgsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuZ2V0Q29uZmlnQWxsJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gR2V0UmVtb3RlSW5mb1Jlc3VsdCAtIFRoZSBvYmplY3QgcmV0dXJuZWQgaGFzIHRoZSBmb2xsb3dpbmcgc2NoZW1hOlxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0gY2FwYWJpbGl0aWVzIC0gVGhlIGxpc3Qgb2YgY2FwYWJpbGl0aWVzIHJldHVybmVkIGJ5IHRoZSBzZXJ2ZXIgKHBhcnQgb2YgdGhlIEdpdCBwcm90b2NvbClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbcmVmc11cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbSEVBRF0gLSBUaGUgZGVmYXVsdCBicmFuY2ggb2YgdGhlIHJlbW90ZVxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbcmVmcy5oZWFkc10gLSBUaGUgYnJhbmNoZXMgb24gdGhlIHJlbW90ZVxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbcmVmcy5wdWxsXSAtIFRoZSBzcGVjaWFsIGJyYW5jaGVzIHJlcHJlc2VudGluZyBwdWxsIHJlcXVlc3RzIChub24tc3RhbmRhcmQpXG4gKiBAcHJvcGVydHkge09iamVjdDxzdHJpbmcsIHN0cmluZz59IFtyZWZzLnRhZ3NdIC0gVGhlIHRhZ3Mgb24gdGhlIHJlbW90ZVxuICpcbiAqL1xuXG4vKipcbiAqIExpc3QgYSByZW1vdGUgc2VydmVycyBicmFuY2hlcywgdGFncywgYW5kIGNhcGFiaWxpdGllcy5cbiAqXG4gKiBUaGlzIGlzIGEgcmFyZSBjb21tYW5kIHRoYXQgZG9lc24ndCByZXF1aXJlIGFuIGBmc2AsIGBkaXJgLCBvciBldmVuIGBnaXRkaXJgIGFyZ3VtZW50LlxuICogSXQganVzdCBjb21tdW5pY2F0ZXMgdG8gYSByZW1vdGUgZ2l0IHNlcnZlciwgdXNpbmcgdGhlIGZpcnN0IHN0ZXAgb2YgdGhlIGBnaXQtdXBsb2FkLXBhY2tgIGhhbmRzaGFrZSwgYnV0IHN0b3BwaW5nIHNob3J0IG9mIGZldGNoaW5nIHRoZSBwYWNrZmlsZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtIdHRwQ2xpZW50fSBhcmdzLmh0dHAgLSBhbiBIVFRQIGNsaWVudFxuICogQHBhcmFtIHtBdXRoQ2FsbGJhY2t9IFthcmdzLm9uQXV0aF0gLSBvcHRpb25hbCBhdXRoIGZpbGwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXV0aEZhaWx1cmVDYWxsYmFja30gW2FyZ3Mub25BdXRoRmFpbHVyZV0gLSBvcHRpb25hbCBhdXRoIHJlamVjdGVkIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhTdWNjZXNzQ2FsbGJhY2t9IFthcmdzLm9uQXV0aFN1Y2Nlc3NdIC0gb3B0aW9uYWwgYXV0aCBhcHByb3ZlZCBjYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MudXJsIC0gVGhlIFVSTCBvZiB0aGUgcmVtb3RlIHJlcG9zaXRvcnkuIFdpbGwgYmUgZ290dGVuIGZyb20gZ2l0Y29uZmlnIGlmIGFic2VudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb3JzUHJveHldIC0gT3B0aW9uYWwgW0NPUlMgcHJveHldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS8lNDBpc29tb3JwaGljLWdpdC9jb3JzLXByb3h5KS4gT3ZlcnJpZGVzIHZhbHVlIGluIHJlcG8gY29uZmlnLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JQdXNoID0gZmFsc2VdIC0gQnkgZGVmYXVsdCwgdGhlIGNvbW1hbmQgcXVlcmllcyB0aGUgJ2ZldGNoJyBjYXBhYmlsaXRpZXMuIElmIHRydWUsIGl0IHdpbGwgYXNrIGZvciB0aGUgJ3B1c2gnIGNhcGFiaWxpdGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2FyZ3MuaGVhZGVyc10gLSBBZGRpdGlvbmFsIGhlYWRlcnMgdG8gaW5jbHVkZSBpbiBIVFRQIHJlcXVlc3RzLCBzaW1pbGFyIHRvIGdpdCdzIGBleHRyYUhlYWRlcmAgY29uZmlnXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8R2V0UmVtb3RlSW5mb1Jlc3VsdD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIGFuIG9iamVjdCBsaXN0aW5nIHRoZSBicmFuY2hlcywgdGFncywgYW5kIGNhcGFiaWxpdGllcyBvZiB0aGUgcmVtb3RlLlxuICogQHNlZSBHZXRSZW1vdGVJbmZvUmVzdWx0XG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBpbmZvID0gYXdhaXQgZ2l0LmdldFJlbW90ZUluZm8oe1xuICogICBodHRwLFxuICogICB1cmw6XG4gKiAgICAgXCJodHRwczovL2NvcnMuaXNvbW9ycGhpYy1naXQub3JnL2dpdGh1Yi5jb20vaXNvbW9ycGhpYy1naXQvaXNvbW9ycGhpYy1naXQuZ2l0XCJcbiAqIH0pO1xuICogY29uc29sZS5sb2coaW5mbyk7XG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRSZW1vdGVJbmZvKHtcbiAgaHR0cCxcbiAgb25BdXRoLFxuICBvbkF1dGhTdWNjZXNzLFxuICBvbkF1dGhGYWlsdXJlLFxuICBjb3JzUHJveHksXG4gIHVybCxcbiAgaGVhZGVycyA9IHt9LFxuICBmb3JQdXNoID0gZmFsc2UsXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdodHRwJywgaHR0cCk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCd1cmwnLCB1cmwpO1xuXG4gICAgY29uc3QgR2l0UmVtb3RlSFRUUCA9IEdpdFJlbW90ZU1hbmFnZXIuZ2V0UmVtb3RlSGVscGVyRm9yKHsgdXJsIH0pO1xuICAgIGNvbnN0IHJlbW90ZSA9IGF3YWl0IEdpdFJlbW90ZUhUVFAuZGlzY292ZXIoe1xuICAgICAgaHR0cCxcbiAgICAgIG9uQXV0aCxcbiAgICAgIG9uQXV0aFN1Y2Nlc3MsXG4gICAgICBvbkF1dGhGYWlsdXJlLFxuICAgICAgY29yc1Byb3h5LFxuICAgICAgc2VydmljZTogZm9yUHVzaCA/ICdnaXQtcmVjZWl2ZS1wYWNrJyA6ICdnaXQtdXBsb2FkLXBhY2snLFxuICAgICAgdXJsLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHByb3RvY29sVmVyc2lvbjogMSxcbiAgICB9KTtcblxuICAgIC8vIE5vdGU6IHJlbW90ZS5jYXBhYmlsaXRpZXMsIHJlbW90ZS5yZWZzLCBhbmQgcmVtb3RlLnN5bXJlZnMgYXJlIFNldCBhbmQgTWFwIG9iamVjdHMsXG4gICAgLy8gYnV0IG9uZSBvZiB0aGUgb2JqZWN0aXZlcyBvZiB0aGUgcHVibGljIEFQSSBpcyB0byBhbHdheXMgcmV0dXJuIEpTT04tY29tcGF0aWJsZSBvYmplY3RzXG4gICAgLy8gc28gd2UgbXVzdCBKU09OaWZ5IHRoZW0uXG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgY2FwYWJpbGl0aWVzOiBbLi4ucmVtb3RlLmNhcGFiaWxpdGllc10sXG4gICAgfTtcbiAgICAvLyBDb252ZXJ0IHRoZSBmbGF0IGxpc3QgaW50byBhbiBvYmplY3QgdHJlZSwgYmVjYXVzZSBJIGZpZ3VyZSA5OSUgb2YgdGhlIHRpbWVcbiAgICAvLyB0aGF0IHdpbGwgYmUgZWFzaWVyIHRvIHVzZS5cbiAgICBmb3IgKGNvbnN0IFtyZWYsIG9pZF0gb2YgcmVtb3RlLnJlZnMpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gcmVmLnNwbGl0KCcvJyk7XG4gICAgICBjb25zdCBsYXN0ID0gcGFydHMucG9wKCk7XG4gICAgICBsZXQgbyA9IHJlc3VsdDtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICBvW3BhcnRdID0gb1twYXJ0XSB8fCB7fTtcbiAgICAgICAgbyA9IG9bcGFydF07XG4gICAgICB9XG4gICAgICBvW2xhc3RdID0gb2lkO1xuICAgIH1cbiAgICAvLyBNZXJnZSBzeW1yZWZzIG9uIHRvcCBvZiByZWZzIHRvIG1vcmUgY2xvc2VseSBtYXRjaCBhY3R1YWwgZ2l0IHJlcG8gbGF5b3V0c1xuICAgIGZvciAoY29uc3QgW3N5bXJlZiwgcmVmXSBvZiByZW1vdGUuc3ltcmVmcykge1xuICAgICAgY29uc3QgcGFydHMgPSBzeW1yZWYuc3BsaXQoJy8nKTtcbiAgICAgIGNvbnN0IGxhc3QgPSBwYXJ0cy5wb3AoKTtcbiAgICAgIGxldCBvID0gcmVzdWx0O1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgICAgIG9bcGFydF0gPSBvW3BhcnRdIHx8IHt9O1xuICAgICAgICBvID0gb1twYXJ0XTtcbiAgICAgIH1cbiAgICAgIG9bbGFzdF0gPSByZWY7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuZ2V0UmVtb3RlSW5mbyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHJlbW90ZVxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeFxuICogQHBhcmFtIHtib29sZWFufSBzeW1yZWZzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBlZWxUYWdzXG4gKiBAcmV0dXJucyB7U2VydmVyUmVmW119XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdEluZm9SZWZzKHJlbW90ZSwgcHJlZml4LCBzeW1yZWZzLCBwZWVsVGFncykge1xuICBjb25zdCByZWZzID0gW107XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHJlbW90ZS5yZWZzKSB7XG4gICAgaWYgKHByZWZpeCAmJiAha2V5LnN0YXJ0c1dpdGgocHJlZml4KSkgY29udGludWVcblxuICAgIGlmIChrZXkuZW5kc1dpdGgoJ157fScpKSB7XG4gICAgICBpZiAocGVlbFRhZ3MpIHtcbiAgICAgICAgY29uc3QgX2tleSA9IGtleS5yZXBsYWNlKCdee30nLCAnJyk7XG4gICAgICAgIC8vIFBlZWxlZCB0YWdzIGFyZSBhbG1vc3QgYWx3YXlzIGxpc3RlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgb3JpZ2luYWwgdGFnXG4gICAgICAgIGNvbnN0IGxhc3QgPSByZWZzW3JlZnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHIgPSBsYXN0LnJlZiA9PT0gX2tleSA/IGxhc3QgOiByZWZzLmZpbmQoeCA9PiB4LnJlZiA9PT0gX2tleSk7XG4gICAgICAgIGlmIChyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0kgZGlkIG5vdCBleHBlY3QgdGhpcyB0byBoYXBwZW4nKVxuICAgICAgICB9XG4gICAgICAgIHIucGVlbGVkID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICAvKiogQHR5cGUgU2VydmVyUmVmICovXG4gICAgY29uc3QgcmVmID0geyByZWY6IGtleSwgb2lkOiB2YWx1ZSB9O1xuICAgIGlmIChzeW1yZWZzKSB7XG4gICAgICBpZiAocmVtb3RlLnN5bXJlZnMuaGFzKGtleSkpIHtcbiAgICAgICAgcmVmLnRhcmdldCA9IHJlbW90ZS5zeW1yZWZzLmdldChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZWZzLnB1c2gocmVmKTtcbiAgfVxuICByZXR1cm4gcmVmc1xufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBHZXRSZW1vdGVJbmZvMlJlc3VsdCAtIFRoaXMgb2JqZWN0IGhhcyB0aGUgZm9sbG93aW5nIHNjaGVtYTpcbiAqIEBwcm9wZXJ0eSB7MSB8IDJ9IHByb3RvY29sVmVyc2lvbiAtIEdpdCBwcm90b2NvbCB2ZXJzaW9uIHRoZSBzZXJ2ZXIgc3VwcG9ydHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0PHN0cmluZywgc3RyaW5nIHwgdHJ1ZT59IGNhcGFiaWxpdGllcyAtIEFuIG9iamVjdCBvZiBjYXBhYmlsaXRpZXMgcmVwcmVzZW50ZWQgYXMga2V5cyBhbmQgdmFsdWVzXG4gKiBAcHJvcGVydHkge1NlcnZlclJlZltdfSBbcmVmc10gLSBTZXJ2ZXIgcmVmcyAodGhleSBnZXQgcmV0dXJuZWQgYnkgcHJvdG9jb2wgdmVyc2lvbiAxIHdoZXRoZXIgeW91IHdhbnQgdGhlbSBvciBub3QpXG4gKi9cblxuLyoqXG4gKiBMaXN0IGEgcmVtb3RlIHNlcnZlcidzIGNhcGFiaWxpdGllcy5cbiAqXG4gKiBUaGlzIGlzIGEgcmFyZSBjb21tYW5kIHRoYXQgZG9lc24ndCByZXF1aXJlIGFuIGBmc2AsIGBkaXJgLCBvciBldmVuIGBnaXRkaXJgIGFyZ3VtZW50LlxuICogSXQganVzdCBjb21tdW5pY2F0ZXMgdG8gYSByZW1vdGUgZ2l0IHNlcnZlciwgZGV0ZXJtaW5pbmcgd2hhdCBwcm90b2NvbCB2ZXJzaW9uLCBjb21tYW5kcywgYW5kIGZlYXR1cmVzIGl0IHN1cHBvcnRzLlxuICpcbiAqID4gVGhlIHN1Y2Nlc3NvciB0byBbYGdldFJlbW90ZUluZm9gXSguL2dldFJlbW90ZUluZm8ubWQpLCB0aGlzIGNvbW1hbmQgc3VwcG9ydHMgR2l0IFdpcmUgUHJvdG9jb2wgVmVyc2lvbiAyLlxuICogPiBUaGVyZWZvcmUgaXRzIHJldHVybiB0eXBlIGlzIG1vcmUgY29tcGxpY2F0ZWQgYXMgZWl0aGVyOlxuICogPlxuICogPiAtIHYxIGNhcGFiaWxpdGllcyAoYW5kIHJlZnMpIG9yXG4gKiA+IC0gdjIgY2FwYWJpbGl0aWVzIChhbmQgbm8gcmVmcylcbiAqID5cbiAqID4gYXJlIHJldHVybmVkLlxuICogPiBJZiB5b3UganVzdCBjYXJlIGFib3V0IHJlZnMsIHVzZSBbYGxpc3RTZXJ2ZXJSZWZzYF0oLi9saXN0U2VydmVyUmVmcy5tZClcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtIdHRwQ2xpZW50fSBhcmdzLmh0dHAgLSBhbiBIVFRQIGNsaWVudFxuICogQHBhcmFtIHtBdXRoQ2FsbGJhY2t9IFthcmdzLm9uQXV0aF0gLSBvcHRpb25hbCBhdXRoIGZpbGwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXV0aEZhaWx1cmVDYWxsYmFja30gW2FyZ3Mub25BdXRoRmFpbHVyZV0gLSBvcHRpb25hbCBhdXRoIHJlamVjdGVkIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhTdWNjZXNzQ2FsbGJhY2t9IFthcmdzLm9uQXV0aFN1Y2Nlc3NdIC0gb3B0aW9uYWwgYXV0aCBhcHByb3ZlZCBjYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MudXJsIC0gVGhlIFVSTCBvZiB0aGUgcmVtb3RlIHJlcG9zaXRvcnkuIFdpbGwgYmUgZ290dGVuIGZyb20gZ2l0Y29uZmlnIGlmIGFic2VudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb3JzUHJveHldIC0gT3B0aW9uYWwgW0NPUlMgcHJveHldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS8lNDBpc29tb3JwaGljLWdpdC9jb3JzLXByb3h5KS4gT3ZlcnJpZGVzIHZhbHVlIGluIHJlcG8gY29uZmlnLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JQdXNoID0gZmFsc2VdIC0gQnkgZGVmYXVsdCwgdGhlIGNvbW1hbmQgcXVlcmllcyB0aGUgJ2ZldGNoJyBjYXBhYmlsaXRpZXMuIElmIHRydWUsIGl0IHdpbGwgYXNrIGZvciB0aGUgJ3B1c2gnIGNhcGFiaWxpdGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2FyZ3MuaGVhZGVyc10gLSBBZGRpdGlvbmFsIGhlYWRlcnMgdG8gaW5jbHVkZSBpbiBIVFRQIHJlcXVlc3RzLCBzaW1pbGFyIHRvIGdpdCdzIGBleHRyYUhlYWRlcmAgY29uZmlnXG4gKiBAcGFyYW0gezEgfCAyfSBbYXJncy5wcm90b2NvbFZlcnNpb24gPSAyXSAtIFdoaWNoIHZlcnNpb24gb2YgdGhlIEdpdCBQcm90b2NvbCB0byB1c2UuXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8R2V0UmVtb3RlSW5mbzJSZXN1bHQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCBhbiBvYmplY3QgbGlzdGluZyB0aGUgY2FwYWJpbGl0aWVzIG9mIHRoZSByZW1vdGUuXG4gKiBAc2VlIEdldFJlbW90ZUluZm8yUmVzdWx0XG4gKiBAc2VlIFNlcnZlclJlZlxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgaW5mbyA9IGF3YWl0IGdpdC5nZXRSZW1vdGVJbmZvMih7XG4gKiAgIGh0dHAsXG4gKiAgIGNvcnNQcm94eTogXCJodHRwczovL2NvcnMuaXNvbW9ycGhpYy1naXQub3JnXCIsXG4gKiAgIHVybDogXCJodHRwczovL2dpdGh1Yi5jb20vaXNvbW9ycGhpYy1naXQvaXNvbW9ycGhpYy1naXQuZ2l0XCJcbiAqIH0pO1xuICogY29uc29sZS5sb2coaW5mbyk7XG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRSZW1vdGVJbmZvMih7XG4gIGh0dHAsXG4gIG9uQXV0aCxcbiAgb25BdXRoU3VjY2VzcyxcbiAgb25BdXRoRmFpbHVyZSxcbiAgY29yc1Byb3h5LFxuICB1cmwsXG4gIGhlYWRlcnMgPSB7fSxcbiAgZm9yUHVzaCA9IGZhbHNlLFxuICBwcm90b2NvbFZlcnNpb24gPSAyLFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignaHR0cCcsIGh0dHApO1xuICAgIGFzc2VydFBhcmFtZXRlcigndXJsJywgdXJsKTtcblxuICAgIGNvbnN0IEdpdFJlbW90ZUhUVFAgPSBHaXRSZW1vdGVNYW5hZ2VyLmdldFJlbW90ZUhlbHBlckZvcih7IHVybCB9KTtcbiAgICBjb25zdCByZW1vdGUgPSBhd2FpdCBHaXRSZW1vdGVIVFRQLmRpc2NvdmVyKHtcbiAgICAgIGh0dHAsXG4gICAgICBvbkF1dGgsXG4gICAgICBvbkF1dGhTdWNjZXNzLFxuICAgICAgb25BdXRoRmFpbHVyZSxcbiAgICAgIGNvcnNQcm94eSxcbiAgICAgIHNlcnZpY2U6IGZvclB1c2ggPyAnZ2l0LXJlY2VpdmUtcGFjaycgOiAnZ2l0LXVwbG9hZC1wYWNrJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwcm90b2NvbFZlcnNpb24sXG4gICAgfSk7XG5cbiAgICBpZiAocmVtb3RlLnByb3RvY29sVmVyc2lvbiA9PT0gMikge1xuICAgICAgLyoqIEB0eXBlIEdldFJlbW90ZUluZm8yUmVzdWx0ICovXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm90b2NvbFZlcnNpb246IHJlbW90ZS5wcm90b2NvbFZlcnNpb24sXG4gICAgICAgIGNhcGFiaWxpdGllczogcmVtb3RlLmNhcGFiaWxpdGllczIsXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTm90ZTogcmVtb3RlLmNhcGFiaWxpdGllcywgcmVtb3RlLnJlZnMsIGFuZCByZW1vdGUuc3ltcmVmcyBhcmUgU2V0IGFuZCBNYXAgb2JqZWN0cyxcbiAgICAvLyBidXQgb25lIG9mIHRoZSBvYmplY3RpdmVzIG9mIHRoZSBwdWJsaWMgQVBJIGlzIHRvIGFsd2F5cyByZXR1cm4gSlNPTi1jb21wYXRpYmxlIG9iamVjdHNcbiAgICAvLyBzbyB3ZSBtdXN0IEpTT05pZnkgdGhlbS5cbiAgICAvKiogQHR5cGUgT2JqZWN0PHN0cmluZywgdHJ1ZT4gKi9cbiAgICBjb25zdCBjYXBhYmlsaXRpZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGNhcCBvZiByZW1vdGUuY2FwYWJpbGl0aWVzKSB7XG4gICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBjYXAuc3BsaXQoJz0nKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBjYXBhYmlsaXRpZXNba2V5XSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FwYWJpbGl0aWVzW2tleV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQHR5cGUgR2V0UmVtb3RlSW5mbzJSZXN1bHQgKi9cbiAgICByZXR1cm4ge1xuICAgICAgcHJvdG9jb2xWZXJzaW9uOiAxLFxuICAgICAgY2FwYWJpbGl0aWVzLFxuICAgICAgcmVmczogZm9ybWF0SW5mb1JlZnMocmVtb3RlLCB1bmRlZmluZWQsIHRydWUsIHRydWUpLFxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuZ2V0UmVtb3RlSW5mbzInO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhc2hPYmplY3Qoe1xuICB0eXBlLFxuICBvYmplY3QsXG4gIGZvcm1hdCA9ICdjb250ZW50JyxcbiAgb2lkID0gdW5kZWZpbmVkLFxufSkge1xuICBpZiAoZm9ybWF0ICE9PSAnZGVmbGF0ZWQnKSB7XG4gICAgaWYgKGZvcm1hdCAhPT0gJ3dyYXBwZWQnKSB7XG4gICAgICBvYmplY3QgPSBHaXRPYmplY3Qud3JhcCh7IHR5cGUsIG9iamVjdCB9KTtcbiAgICB9XG4gICAgb2lkID0gYXdhaXQgc2hhc3VtKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHsgb2lkLCBvYmplY3QgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gSGFzaEJsb2JSZXN1bHQgLSBUaGUgb2JqZWN0IHJldHVybmVkIGhhcyB0aGUgZm9sbG93aW5nIHNjaGVtYTpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWQgLSBUaGUgU0hBLTEgb2JqZWN0IGlkXG4gKiBAcHJvcGVydHkgeydibG9iJ30gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gb2JqZWN0IC0gVGhlIHdyYXBwZWQgZ2l0IG9iamVjdCAodGhlIHRoaW5nIHRoYXQgaXMgaGFzaGVkKVxuICogQHByb3BlcnR5IHsnd3JhcHBlZCd9IGZvcm1hdCAtIFRoZSBmb3JtYXQgb2YgdGhlIG9iamVjdFxuICpcbiAqL1xuXG4vKipcbiAqIENvbXB1dGUgd2hhdCB0aGUgU0hBLTEgb2JqZWN0IGlkIG9mIGEgZmlsZSB3b3VsZCBiZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8c3RyaW5nfSBhcmdzLm9iamVjdCAtIFRoZSBvYmplY3QgdG8gd3JpdGUuIElmIGBvYmplY3RgIGlzIGEgU3RyaW5nIHRoZW4gaXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBVaW50OEFycmF5IHVzaW5nIFVURi04IGVuY29kaW5nLlxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPEhhc2hCbG9iUmVzdWx0Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggdGhlIFNIQS0xIG9iamVjdCBpZCBhbmQgdGhlIHdyYXBwZWQgb2JqZWN0IFVpbnQ4QXJyYXkuXG4gKiBAc2VlIEhhc2hCbG9iUmVzdWx0XG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCB7IG9pZCwgdHlwZSwgb2JqZWN0LCBmb3JtYXQgfSA9IGF3YWl0IGdpdC5oYXNoQmxvYih7XG4gKiAgIG9iamVjdDogJ0hlbGxvIHdvcmxkIScsXG4gKiB9KVxuICpcbiAqIGNvbnNvbGUubG9nKCdvaWQnLCBvaWQpXG4gKiBjb25zb2xlLmxvZygndHlwZScsIHR5cGUpXG4gKiBjb25zb2xlLmxvZygnb2JqZWN0Jywgb2JqZWN0KVxuICogY29uc29sZS5sb2coJ2Zvcm1hdCcsIGZvcm1hdClcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhc2hCbG9iKHsgb2JqZWN0IH0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ29iamVjdCcsIG9iamVjdCk7XG5cbiAgICAvLyBDb252ZXJ0IG9iamVjdCB0byBidWZmZXJcbiAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9iamVjdCA9IEJ1ZmZlci5mcm9tKG9iamVjdCwgJ3V0ZjgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0ID0gQnVmZmVyLmZyb20ob2JqZWN0KTtcbiAgICB9XG5cbiAgICBjb25zdCB0eXBlID0gJ2Jsb2InO1xuICAgIGNvbnN0IHsgb2lkLCBvYmplY3Q6IF9vYmplY3QgfSA9IGF3YWl0IGhhc2hPYmplY3Qoe1xuICAgICAgdHlwZTogJ2Jsb2InLFxuICAgICAgZm9ybWF0OiAnY29udGVudCcsXG4gICAgICBvYmplY3QsXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgb2lkLCB0eXBlLCBvYmplY3Q6IG5ldyBVaW50OEFycmF5KF9vYmplY3QpLCBmb3JtYXQ6ICd3cmFwcGVkJyB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0Lmhhc2hCbG9iJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHthbnl9IGFyZ3MuY2FjaGVcbiAqIEBwYXJhbSB7UHJvZ3Jlc3NDYWxsYmFja30gW2FyZ3Mub25Qcm9ncmVzc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5maWxlcGF0aFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHtvaWRzOiBzdHJpbmdbXX0+fVxuICovXG5hc3luYyBmdW5jdGlvbiBfaW5kZXhQYWNrKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBvblByb2dyZXNzLFxuICBkaXIsXG4gIGdpdGRpcixcbiAgZmlsZXBhdGgsXG59KSB7XG4gIHRyeSB7XG4gICAgZmlsZXBhdGggPSBqb2luKGRpciwgZmlsZXBhdGgpO1xuICAgIGNvbnN0IHBhY2sgPSBhd2FpdCBmcy5yZWFkKGZpbGVwYXRoKTtcbiAgICBjb25zdCBnZXRFeHRlcm5hbFJlZkRlbHRhID0gb2lkID0+IF9yZWFkT2JqZWN0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcbiAgICBjb25zdCBpZHggPSBhd2FpdCBHaXRQYWNrSW5kZXguZnJvbVBhY2soe1xuICAgICAgcGFjayxcbiAgICAgIGdldEV4dGVybmFsUmVmRGVsdGEsXG4gICAgICBvblByb2dyZXNzLFxuICAgIH0pO1xuICAgIGF3YWl0IGZzLndyaXRlKGZpbGVwYXRoLnJlcGxhY2UoL1xcLnBhY2skLywgJy5pZHgnKSwgYXdhaXQgaWR4LnRvQnVmZmVyKCkpO1xuICAgIHJldHVybiB7XG4gICAgICBvaWRzOiBbLi4uaWR4Lmhhc2hlc10sXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5pbmRleFBhY2snO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIENyZWF0ZSB0aGUgLmlkeCBmaWxlIGZvciBhIGdpdmVuIC5wYWNrIGZpbGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge1Byb2dyZXNzQ2FsbGJhY2t9IFthcmdzLm9uUHJvZ3Jlc3NdIC0gb3B0aW9uYWwgcHJvZ3Jlc3MgZXZlbnQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmRpciAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5maWxlcGF0aCAtIFRoZSBwYXRoIHRvIHRoZSAucGFjayBmaWxlIHRvIGluZGV4XG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx7b2lkczogc3RyaW5nW119Pn0gUmVzb2x2ZXMgd2l0aCBhIGxpc3Qgb2YgdGhlIFNIQS0xIG9iamVjdCBpZHMgY29udGFpbmVkIGluIHRoZSBwYWNrZmlsZVxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgcGFja2ZpbGVzID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZGRpcignL3R1dG9yaWFsLy5naXQvb2JqZWN0cy9wYWNrJylcbiAqIHBhY2tmaWxlcyA9IHBhY2tmaWxlcy5maWx0ZXIobmFtZSA9PiBuYW1lLmVuZHNXaXRoKCcucGFjaycpKVxuICogY29uc29sZS5sb2coJ3BhY2tmaWxlcycsIHBhY2tmaWxlcylcbiAqXG4gKiBjb25zdCB7IG9pZHMgfSA9IGF3YWl0IGdpdC5pbmRleFBhY2soe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgZmlsZXBhdGg6IGAuZ2l0L29iamVjdHMvcGFjay8ke3BhY2tmaWxlc1swXX1gLFxuICogICBhc3luYyBvblByb2dyZXNzIChldnQpIHtcbiAqICAgICBjb25zb2xlLmxvZyhgJHtldnQucGhhc2V9OiAke2V2dC5sb2FkZWR9IC8gJHtldnQudG90YWx9YClcbiAqICAgfVxuICogfSlcbiAqIGNvbnNvbGUubG9nKG9pZHMpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBpbmRleFBhY2soe1xuICBmcyxcbiAgb25Qcm9ncmVzcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgZmlsZXBhdGgsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2RpcicsIGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZmlsZXBhdGgnLCBmaWxlcGF0aCk7XG5cbiAgICByZXR1cm4gYXdhaXQgX2luZGV4UGFjayh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgZGlyLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgZmlsZXBhdGgsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuaW5kZXhQYWNrJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IHJlcG9zaXRvcnlcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmJhcmUgPSBmYWxzZV0gLSBJbml0aWFsaXplIGEgYmFyZSByZXBvc2l0b3J5XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGVmYXVsdEJyYW5jaCA9ICdtYXN0ZXInXSAtIFRoZSBuYW1lIG9mIHRoZSBkZWZhdWx0IGJyYW5jaCAobWlnaHQgYmUgY2hhbmdlZCB0byBhIHJlcXVpcmVkIGFyZ3VtZW50IGluIDIuMC4wKVxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59ICBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC5pbml0KHsgZnMsIGRpcjogJy90dXRvcmlhbCcgfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGluaXQoe1xuICBmcyxcbiAgYmFyZSA9IGZhbHNlLFxuICBkaXIsXG4gIGdpdGRpciA9IGJhcmUgPyBkaXIgOiBqb2luKGRpciwgJy5naXQnKSxcbiAgZGVmYXVsdEJyYW5jaCA9ICdtYXN0ZXInLFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGlmICghYmFyZSkge1xuICAgICAgYXNzZXJ0UGFyYW1ldGVyKCdkaXInLCBkaXIpO1xuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBfaW5pdCh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgYmFyZSxcbiAgICAgIGRpcixcbiAgICAgIGdpdGRpcixcbiAgICAgIGRlZmF1bHRCcmFuY2gsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuaW5pdCc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9pZFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuYW5jZXN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmRlcHRoIC0gTWF4aW11bSBkZXB0aCB0byBzZWFyY2ggYmVmb3JlIGdpdmluZyB1cC4gLTEgbWVhbnMgbm8gbWF4aW11bSBkZXB0aC5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2lzRGVzY2VuZGVudCh7XG4gIGZzLFxuICBjYWNoZSxcbiAgZ2l0ZGlyLFxuICBvaWQsXG4gIGFuY2VzdG9yLFxuICBkZXB0aCxcbn0pIHtcbiAgY29uc3Qgc2hhbGxvd3MgPSBhd2FpdCBHaXRTaGFsbG93TWFuYWdlci5yZWFkKHsgZnMsIGdpdGRpciB9KTtcbiAgaWYgKCFvaWQpIHtcbiAgICB0aHJvdyBuZXcgTWlzc2luZ1BhcmFtZXRlckVycm9yKCdvaWQnKVxuICB9XG4gIGlmICghYW5jZXN0b3IpIHtcbiAgICB0aHJvdyBuZXcgTWlzc2luZ1BhcmFtZXRlckVycm9yKCdhbmNlc3RvcicpXG4gIH1cbiAgLy8gSWYgeW91IGRvbid0IGxpa2UgdGhpcyBiZWhhdmlvciwgYWRkIHlvdXIgb3duIGNoZWNrLlxuICAvLyBFZGdlIGNhc2VzIGFyZSBoYXJkIHRvIGRlZmluZSBhIHBlcmZlY3Qgc29sdXRpb24uXG4gIGlmIChvaWQgPT09IGFuY2VzdG9yKSByZXR1cm4gZmFsc2VcbiAgLy8gV2UgZG8gbm90IHVzZSByZWN1cnNpb24gaGVyZSwgYmVjYXVzZSB0aGF0IHdvdWxkIGxlYWQgdG8gZGVwdGgtZmlyc3QgdHJhdmVyc2FsLFxuICAvLyBhbmQgd2Ugd2FudCB0byBtYWludGFpbiBhIGJyZWFkdGgtZmlyc3QgdHJhdmVyc2FsIHRvIGF2b2lkIGhpdHRpbmcgc2hhbGxvdyBjbG9uZSBkZXB0aCBjdXRvZmZzLlxuICBjb25zdCBxdWV1ZSA9IFtvaWRdO1xuICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICBsZXQgc2VhcmNoZGVwdGggPSAwO1xuICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgaWYgKHNlYXJjaGRlcHRoKysgPT09IGRlcHRoKSB7XG4gICAgICB0aHJvdyBuZXcgTWF4RGVwdGhFcnJvcihkZXB0aClcbiAgICB9XG4gICAgY29uc3Qgb2lkID0gcXVldWUuc2hpZnQoKTtcbiAgICBjb25zdCB7IHR5cGUsIG9iamVjdCB9ID0gYXdhaXQgX3JlYWRPYmplY3Qoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIG9pZCxcbiAgICB9KTtcbiAgICBpZiAodHlwZSAhPT0gJ2NvbW1pdCcpIHtcbiAgICAgIHRocm93IG5ldyBPYmplY3RUeXBlRXJyb3Iob2lkLCB0eXBlLCAnY29tbWl0JylcbiAgICB9XG4gICAgY29uc3QgY29tbWl0ID0gR2l0Q29tbWl0LmZyb20ob2JqZWN0KS5wYXJzZSgpO1xuICAgIC8vIEFyZSBhbnkgb2YgdGhlIHBhcmVudHMgdGhlIHNvdWdodC1hZnRlciBhbmNlc3Rvcj9cbiAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiBjb21taXQucGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50ID09PSBhbmNlc3RvcikgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgLy8gSWYgbm90LCBhZGQgdGhlbSB0byBoZWFkcyAodW5sZXNzIHdlIGtub3cgdGhpcyBpcyBhIHNoYWxsb3cgY29tbWl0KVxuICAgIGlmICghc2hhbGxvd3MuaGFzKG9pZCkpIHtcbiAgICAgIGZvciAoY29uc3QgcGFyZW50IG9mIGNvbW1pdC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhwYXJlbnQpKSB7XG4gICAgICAgICAgcXVldWUucHVzaChwYXJlbnQpO1xuICAgICAgICAgIHZpc2l0ZWQuYWRkKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRXZlbnR1YWxseSwgd2UnbGwgdHJhdmVsIGVudGlyZSB0cmVlIHRvIHRoZSByb290cyB3aGVyZSBhbGwgdGhlIHBhcmVudHMgYXJlIGVtcHR5IGFycmF5cyxcbiAgICAvLyBvciBoaXQgdGhlIHNoYWxsb3cgZGVwdGggYW5kIHRocm93IGFuIGVycm9yLiBFeGNsdWRpbmcgdGhlIHBvc3NpYmlsaXR5IG9mIGdyYWZ0cywgb3JcbiAgICAvLyBkaWZmZXJlbnQgYnJhbmNoZXMgY2xvbmVkIHRvIGRpZmZlcmVudCBkZXB0aHMsIHlvdSB3b3VsZCBoaXQgdGhpcyBlcnJvciBhdCB0aGUgc2FtZSB0aW1lXG4gICAgLy8gZm9yIGFsbCBwYXJlbnRzLCBzbyB0cnlpbmcgdG8gY29udGludWUgaXMgZnV0aWxlLlxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgZ2l0IGNvbW1pdCBpcyBkZXNjZW5kZWQgZnJvbSBhbm90aGVyXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Mub2lkIC0gVGhlIGRlc2NlbmRlbnQgY29tbWl0XG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5hbmNlc3RvciAtIFRoZSAocHJvcG9zZWQpIGFuY2VzdG9yIGNvbW1pdFxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmRlcHRoID0gLTFdIC0gTWF4aW11bSBkZXB0aCB0byBzZWFyY2ggYmVmb3JlIGdpdmluZyB1cC4gLTEgbWVhbnMgbm8gbWF4aW11bSBkZXB0aC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBSZXNvbHZlcyB0byB0cnVlIGlmIGBvaWRgIGlzIGEgZGVzY2VuZGVudCBvZiBgYW5jZXN0b3JgXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBvaWQgPSBhd2FpdCBnaXQucmVzb2x2ZVJlZih7IGZzLCBkaXI6ICcvdHV0b3JpYWwnLCByZWY6ICdtYWluJyB9KVxuICogbGV0IGFuY2VzdG9yID0gYXdhaXQgZ2l0LnJlc29sdmVSZWYoeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgcmVmOiAndjAuMjAuMCcgfSlcbiAqIGNvbnNvbGUubG9nKG9pZCwgYW5jZXN0b3IpXG4gKiBhd2FpdCBnaXQuaXNEZXNjZW5kZW50KHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIG9pZCwgYW5jZXN0b3IsIGRlcHRoOiAtMSB9KVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaXNEZXNjZW5kZW50KHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIG9pZCxcbiAgYW5jZXN0b3IsXG4gIGRlcHRoID0gLTEsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdvaWQnLCBvaWQpO1xuICAgIGFzc2VydFBhcmFtZXRlcignYW5jZXN0b3InLCBhbmNlc3Rvcik7XG5cbiAgICByZXR1cm4gYXdhaXQgX2lzRGVzY2VuZGVudCh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBvaWQsXG4gICAgICBhbmNlc3RvcixcbiAgICAgIGRlcHRoLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LmlzRGVzY2VuZGVudCc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgZmlsZXBhdGggc2hvdWxkIGJlIGlnbm9yZWQgKGJlY2F1c2Ugb2YgLmdpdGlnbm9yZSBvciAuZ2l0L2V4Y2x1ZGUpXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZGlyIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCAnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5maWxlcGF0aCAtIFRoZSBmaWxlcGF0aCB0byB0ZXN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IFJlc29sdmVzIHRvIHRydWUgaWYgdGhlIGZpbGUgc2hvdWxkIGJlIGlnbm9yZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZ2l0LmlzSWdub3JlZCh7IGZzLCBkaXI6ICcvdHV0b3JpYWwnLCBmaWxlcGF0aDogJ2RvY3MvYWRkLm1kJyB9KVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaXNJZ25vcmVkKHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIGZpbGVwYXRoLFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdkaXInLCBkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZpbGVwYXRoJywgZmlsZXBhdGgpO1xuXG4gICAgcmV0dXJuIEdpdElnbm9yZU1hbmFnZXIuaXNJZ25vcmVkKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBkaXIsXG4gICAgICBnaXRkaXIsXG4gICAgICBmaWxlcGF0aCxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5pc0lnbm9yZWQnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIExpc3QgYnJhbmNoZXNcbiAqXG4gKiBCeSBkZWZhdWx0IGl0IGxpc3RzIGxvY2FsIGJyYW5jaGVzLiBJZiBhICdyZW1vdGUnIGlzIHNwZWNpZmllZCwgaXQgbGlzdHMgdGhlIHJlbW90ZSdzIGJyYW5jaGVzLiBXaGVuIGxpc3RpbmcgcmVtb3RlIGJyYW5jaGVzLCB0aGUgSEVBRCBicmFuY2ggaXMgbm90IGZpbHRlcmVkIG91dCwgc28gaXQgbWF5IGJlIGluY2x1ZGVkIGluIHRoZSBsaXN0IG9mIHJlc3VsdHMuXG4gKlxuICogTm90ZSB0aGF0IHNwZWNpZnlpbmcgYSByZW1vdGUgZG9lcyBub3QgYWN0dWFsbHkgY29udGFjdCB0aGUgc2VydmVyIGFuZCB1cGRhdGUgdGhlIGxpc3Qgb2YgYnJhbmNoZXMuXG4gKiBJZiB5b3Ugd2FudCBhbiB1cC10by1kYXRlIGxpc3QsIGZpcnN0IGRvIGEgYGZldGNoYCB0byB0aGF0IHJlbW90ZS5cbiAqIChXaGljaCBicmFuY2ggeW91IGZldGNoIGRvZXNuJ3QgbWF0dGVyIC0gdGhlIGxpc3Qgb2YgYnJhbmNoZXMgYXZhaWxhYmxlIG9uIHRoZSByZW1vdGUgaXMgdXBkYXRlZCBkdXJpbmcgdGhlIGZldGNoIGhhbmRzaGFrZS4pXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlbW90ZV0gLSBJbnN0ZWFkIG9mIHRoZSBicmFuY2hlcyBpbiBgcmVmcy9oZWFkc2AsIGxpc3QgdGhlIGJyYW5jaGVzIGluIGByZWZzL3JlbW90ZXMvJHtyZW1vdGV9YC5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxzdHJpbmc+Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYW4gYXJyYXkgb2YgYnJhbmNoIG5hbWVzXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBicmFuY2hlcyA9IGF3YWl0IGdpdC5saXN0QnJhbmNoZXMoeyBmcywgZGlyOiAnL3R1dG9yaWFsJyB9KVxuICogY29uc29sZS5sb2coYnJhbmNoZXMpXG4gKiBsZXQgcmVtb3RlQnJhbmNoZXMgPSBhd2FpdCBnaXQubGlzdEJyYW5jaGVzKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIHJlbW90ZTogJ29yaWdpbicgfSlcbiAqIGNvbnNvbGUubG9nKHJlbW90ZUJyYW5jaGVzKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbGlzdEJyYW5jaGVzKHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlbW90ZSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcblxuICAgIHJldHVybiBHaXRSZWZNYW5hZ2VyLmxpc3RCcmFuY2hlcyh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVtb3RlLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0Lmxpc3RCcmFuY2hlcyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZWZdXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8c3RyaW5nPj59XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9saXN0RmlsZXMoeyBmcywgZ2l0ZGlyLCByZWYsIGNhY2hlIH0pIHtcbiAgaWYgKHJlZikge1xuICAgIGNvbnN0IG9pZCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGdpdGRpciwgZnMsIHJlZiB9KTtcbiAgICBjb25zdCBmaWxlbmFtZXMgPSBbXTtcbiAgICBhd2FpdCBhY2N1bXVsYXRlRmlsZXNGcm9tT2lkKHtcbiAgICAgIGZzLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBvaWQsXG4gICAgICBmaWxlbmFtZXMsXG4gICAgICBwcmVmaXg6ICcnLFxuICAgIH0pO1xuICAgIHJldHVybiBmaWxlbmFtZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gR2l0SW5kZXhNYW5hZ2VyLmFjcXVpcmUoeyBmcywgZ2l0ZGlyLCBjYWNoZSB9LCBhc3luYyBmdW5jdGlvbihcbiAgICAgIGluZGV4XG4gICAgKSB7XG4gICAgICByZXR1cm4gaW5kZXguZW50cmllcy5tYXAoeCA9PiB4LnBhdGgpXG4gICAgfSlcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBhY2N1bXVsYXRlRmlsZXNGcm9tT2lkKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBnaXRkaXIsXG4gIG9pZCxcbiAgZmlsZW5hbWVzLFxuICBwcmVmaXgsXG59KSB7XG4gIGNvbnN0IHsgdHJlZSB9ID0gYXdhaXQgX3JlYWRUcmVlKHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcbiAgLy8gVE9ETzogVXNlIGB3YWxrYCB0byBkbyB0aGlzLiBTaG91bGQgYmUgZmFzdGVyLlxuICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRyZWUpIHtcbiAgICBpZiAoZW50cnkudHlwZSA9PT0gJ3RyZWUnKSB7XG4gICAgICBhd2FpdCBhY2N1bXVsYXRlRmlsZXNGcm9tT2lkKHtcbiAgICAgICAgZnMsXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBnaXRkaXIsXG4gICAgICAgIG9pZDogZW50cnkub2lkLFxuICAgICAgICBmaWxlbmFtZXMsXG4gICAgICAgIHByZWZpeDogam9pbihwcmVmaXgsIGVudHJ5LnBhdGgpLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbGVuYW1lcy5wdXNoKGpvaW4ocHJlZml4LCBlbnRyeS5wYXRoKSk7XG4gICAgfVxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIExpc3QgYWxsIHRoZSBmaWxlcyBpbiB0aGUgZ2l0IGluZGV4IG9yIGEgY29tbWl0XG4gKlxuICogPiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIGVmZmljaWVudCBmb3IgbGlzdGluZyB0aGUgZmlsZXMgaW4gdGhlIHN0YWdpbmcgYXJlYSwgYnV0IGxpc3RpbmcgYWxsIHRoZSBmaWxlcyBpbiBhIGNvbW1pdCByZXF1aXJlcyByZWN1cnNpdmVseSB3YWxraW5nIHRocm91Z2ggdGhlIGdpdCBvYmplY3Qgc3RvcmUuXG4gKiA+IElmIHlvdSBkbyBub3QgcmVxdWlyZSBhIGNvbXBsZXRlIGxpc3Qgb2YgZXZlcnkgZmlsZSwgYmV0dGVyIHBlcmZvcm1hbmNlIGNhbiBiZSBhY2hpZXZlZCBieSB1c2luZyBbd2Fsa10oLi93YWxrKSBhbmQgaWdub3Jpbmcgc3ViZGlyZWN0b3JpZXMgeW91IGRvbid0IGNhcmUgYWJvdXQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZl0gLSBSZXR1cm4gYSBsaXN0IG9mIGFsbCB0aGUgZmlsZXMgaW4gdGhlIGNvbW1pdCBhdCBgcmVmYCBpbnN0ZWFkIG9mIHRoZSBmaWxlcyBjdXJyZW50bHkgaW4gdGhlIGdpdCBpbmRleCAoYWthIHN0YWdpbmcgYXJlYSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PHN0cmluZz4+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCBhbiBhcnJheSBvZiBmaWxlcGF0aHNcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQWxsIHRoZSBmaWxlcyBpbiB0aGUgcHJldmlvdXMgY29tbWl0XG4gKiBsZXQgZmlsZXMgPSBhd2FpdCBnaXQubGlzdEZpbGVzKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIHJlZjogJ0hFQUQnIH0pXG4gKiBjb25zb2xlLmxvZyhmaWxlcylcbiAqIC8vIEFsbCB0aGUgZmlsZXMgaW4gdGhlIGN1cnJlbnQgc3RhZ2luZyBhcmVhXG4gKiBmaWxlcyA9IGF3YWl0IGdpdC5saXN0RmlsZXMoeyBmcywgZGlyOiAnL3R1dG9yaWFsJyB9KVxuICogY29uc29sZS5sb2coZmlsZXMpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBsaXN0RmlsZXMoe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgcmVmLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9saXN0RmlsZXMoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGNhY2hlLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0Lmxpc3RGaWxlcyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogTGlzdCBhbGwgdGhlIG9iamVjdCBub3Rlc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge2FueX0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWZcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTx7dGFyZ2V0OiBzdHJpbmcsIG5vdGU6IHN0cmluZ30+Pn1cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBfbGlzdE5vdGVzKHsgZnMsIGNhY2hlLCBnaXRkaXIsIHJlZiB9KSB7XG4gIC8vIEdldCB0aGUgY3VycmVudCBub3RlIGNvbW1pdFxuICBsZXQgcGFyZW50O1xuICB0cnkge1xuICAgIHBhcmVudCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGdpdGRpciwgZnMsIHJlZiB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIE5vdEZvdW5kRXJyb3IpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSB0aGUgY3VycmVudCBub3RlIHRyZWVcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX3JlYWRUcmVlKHtcbiAgICBmcyxcbiAgICBjYWNoZSxcbiAgICBnaXRkaXIsXG4gICAgb2lkOiBwYXJlbnQsXG4gIH0pO1xuXG4gIC8vIEZvcm1hdCB0aGUgdHJlZSBlbnRyaWVzXG4gIGNvbnN0IG5vdGVzID0gcmVzdWx0LnRyZWUubWFwKGVudHJ5ID0+ICh7XG4gICAgdGFyZ2V0OiBlbnRyeS5wYXRoLFxuICAgIG5vdGU6IGVudHJ5Lm9pZCxcbiAgfSkpO1xuICByZXR1cm4gbm90ZXNcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogTGlzdCBhbGwgdGhlIG9iamVjdCBub3Rlc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZWZdIC0gVGhlIG5vdGVzIHJlZiB0byBsb29rIHVuZGVyXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTx7dGFyZ2V0OiBzdHJpbmcsIG5vdGU6IHN0cmluZ30+Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYW4gYXJyYXkgb2YgZW50cmllcyBjb250YWluaW5nIFNIQS0xIG9iamVjdCBpZHMgb2YgdGhlIG5vdGUgYW5kIHRoZSBvYmplY3QgdGhlIG5vdGUgdGFyZ2V0c1xuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGxpc3ROb3Rlcyh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICByZWYgPSAncmVmcy9ub3Rlcy9jb21taXRzJyxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlZicsIHJlZik7XG5cbiAgICByZXR1cm4gYXdhaXQgX2xpc3ROb3Rlcyh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICByZWYsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQubGlzdE5vdGVzJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8e3JlbW90ZTogc3RyaW5nLCB1cmw6IHN0cmluZ30+Pn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2xpc3RSZW1vdGVzKHsgZnMsIGdpdGRpciB9KSB7XG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuZ2V0KHsgZnMsIGdpdGRpciB9KTtcbiAgY29uc3QgcmVtb3RlTmFtZXMgPSBhd2FpdCBjb25maWcuZ2V0U3Vic2VjdGlvbnMoJ3JlbW90ZScpO1xuICBjb25zdCByZW1vdGVzID0gUHJvbWlzZS5hbGwoXG4gICAgcmVtb3RlTmFtZXMubWFwKGFzeW5jIHJlbW90ZSA9PiB7XG4gICAgICBjb25zdCB1cmwgPSBhd2FpdCBjb25maWcuZ2V0KGByZW1vdGUuJHtyZW1vdGV9LnVybGApO1xuICAgICAgcmV0dXJuIHsgcmVtb3RlLCB1cmwgfVxuICAgIH0pXG4gICk7XG4gIHJldHVybiByZW1vdGVzXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIExpc3QgcmVtb3Rlc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTx7cmVtb3RlOiBzdHJpbmcsIHVybDogc3RyaW5nfT4+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCBhbiBhcnJheSBvZiBge3JlbW90ZSwgdXJsfWAgb2JqZWN0c1xuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgcmVtb3RlcyA9IGF3YWl0IGdpdC5saXN0UmVtb3Rlcyh7IGZzLCBkaXI6ICcvdHV0b3JpYWwnIH0pXG4gKiBjb25zb2xlLmxvZyhyZW1vdGVzKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbGlzdFJlbW90ZXMoeyBmcywgZGlyLCBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSB9KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG5cbiAgICByZXR1cm4gYXdhaXQgX2xpc3RSZW1vdGVzKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBnaXRkaXIsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQubGlzdFJlbW90ZXMnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2VydmVyUmVmIC0gVGhpcyBvYmplY3QgaGFzIHRoZSBmb2xsb3dpbmcgc2NoZW1hOlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlZiAtIFRoZSBuYW1lIG9mIHRoZSByZWZcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWQgLSBUaGUgU0hBLTEgb2JqZWN0IGlkIHRoZSByZWYgcG9pbnRzIHRvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RhcmdldF0gLSBUaGUgdGFyZ2V0IHJlZiBwb2ludGVkIHRvIGJ5IGEgc3ltYm9saWMgcmVmXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BlZWxlZF0gLSBJZiB0aGUgb2lkIGlzIHRoZSBTSEEtMSBvYmplY3QgaWQgb2YgYW4gYW5ub3RhdGVkIHRhZywgdGhpcyBpcyB0aGUgU0hBLTEgb2JqZWN0IGlkIHRoYXQgdGhlIGFubm90YXRlZCB0YWcgcG9pbnRzIHRvXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gcGFyc2VMaXN0UmVmc1Jlc3BvbnNlKHN0cmVhbSkge1xuICBjb25zdCByZWFkID0gR2l0UGt0TGluZS5zdHJlYW1SZWFkZXIoc3RyZWFtKTtcblxuICAvLyBUT0RPOiB3aGVuIHdlIHJlLXdyaXRlIGV2ZXJ5dGhpbmcgdG8gbWluaW1pemUgbWVtb3J5IHVzYWdlLFxuICAvLyB3ZSBjb3VsZCBtYWtlIHRoaXMgYSBnZW5lcmF0b3JcbiAgY29uc3QgcmVmcyA9IFtdO1xuXG4gIGxldCBsaW5lO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxpbmUgPSBhd2FpdCByZWFkKCk7XG4gICAgaWYgKGxpbmUgPT09IHRydWUpIGJyZWFrXG4gICAgaWYgKGxpbmUgPT09IG51bGwpIGNvbnRpbnVlXG4gICAgbGluZSA9IGxpbmUudG9TdHJpbmcoJ3V0ZjgnKS5yZXBsYWNlKC9cXG4kLywgJycpO1xuICAgIGNvbnN0IFtvaWQsIHJlZiwgLi4uYXR0cnNdID0gbGluZS5zcGxpdCgnICcpO1xuICAgIGNvbnN0IHIgPSB7IHJlZiwgb2lkIH07XG4gICAgZm9yIChjb25zdCBhdHRyIG9mIGF0dHJzKSB7XG4gICAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0gYXR0ci5zcGxpdCgnOicpO1xuICAgICAgaWYgKG5hbWUgPT09ICdzeW1yZWYtdGFyZ2V0Jykge1xuICAgICAgICByLnRhcmdldCA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAncGVlbGVkJykge1xuICAgICAgICByLnBlZWxlZCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZWZzLnB1c2gocik7XG4gIH1cblxuICByZXR1cm4gcmVmc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucHJlZml4XSAtIE9ubHkgbGlzdCByZWZzIHRoYXQgc3RhcnQgd2l0aCB0aGlzIHByZWZpeFxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5zeW1yZWZzID0gZmFsc2VdIC0gSW5jbHVkZSBzeW1ib2xpYyByZWYgdGFyZ2V0c1xuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5wZWVsVGFncyA9IGZhbHNlXSAtIEluY2x1ZGUgcGVlbGVkIHRhZ3MgdmFsdWVzXG4gKiBAcmV0dXJucyB7VWludDhBcnJheVtdfVxuICovXG5hc3luYyBmdW5jdGlvbiB3cml0ZUxpc3RSZWZzUmVxdWVzdCh7IHByZWZpeCwgc3ltcmVmcywgcGVlbFRhZ3MgfSkge1xuICBjb25zdCBwYWNrc3RyZWFtID0gW107XG4gIC8vIGNvbW1hbmRcbiAgcGFja3N0cmVhbS5wdXNoKEdpdFBrdExpbmUuZW5jb2RlKCdjb21tYW5kPWxzLXJlZnNcXG4nKSk7XG4gIC8vIGNhcGFiaWxpdHktbGlzdFxuICBwYWNrc3RyZWFtLnB1c2goR2l0UGt0TGluZS5lbmNvZGUoYGFnZW50PSR7cGtnLmFnZW50fVxcbmApKTtcbiAgLy8gW2NvbW1hbmQtYXJnc11cbiAgaWYgKHBlZWxUYWdzIHx8IHN5bXJlZnMgfHwgcHJlZml4KSB7XG4gICAgcGFja3N0cmVhbS5wdXNoKEdpdFBrdExpbmUuZGVsaW0oKSk7XG4gIH1cbiAgaWYgKHBlZWxUYWdzKSBwYWNrc3RyZWFtLnB1c2goR2l0UGt0TGluZS5lbmNvZGUoJ3BlZWwnKSk7XG4gIGlmIChzeW1yZWZzKSBwYWNrc3RyZWFtLnB1c2goR2l0UGt0TGluZS5lbmNvZGUoJ3N5bXJlZnMnKSk7XG4gIGlmIChwcmVmaXgpIHBhY2tzdHJlYW0ucHVzaChHaXRQa3RMaW5lLmVuY29kZShgcmVmLXByZWZpeCAke3ByZWZpeH1gKSk7XG4gIHBhY2tzdHJlYW0ucHVzaChHaXRQa3RMaW5lLmZsdXNoKCkpO1xuICByZXR1cm4gcGFja3N0cmVhbVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBGZXRjaCBhIGxpc3Qgb2YgcmVmcyAoYnJhbmNoZXMsIHRhZ3MsIGV0YykgZnJvbSBhIHNlcnZlci5cbiAqXG4gKiBUaGlzIGlzIGEgcmFyZSBjb21tYW5kIHRoYXQgZG9lc24ndCByZXF1aXJlIGFuIGBmc2AsIGBkaXJgLCBvciBldmVuIGBnaXRkaXJgIGFyZ3VtZW50LlxuICogSXQganVzdCByZXF1aXJlcyBhbiBgaHR0cGAgYXJndW1lbnQuXG4gKlxuICogIyMjIEFib3V0IGBwcm90b2NvbFZlcnNpb25gXG4gKlxuICogVGhlcmUncyBhIHJhdGhlciBmdW4gdHJhZGUtb2ZmIGJldHdlZW4gR2l0IFByb3RvY29sIFZlcnNpb24gMSBhbmQgR2l0IFByb3RvY29sIFZlcnNpb24gMi5cbiAqIFZlcnNpb24gMiBhY3R1YWxseSByZXF1aXJlcyAyIEhUVFAgcmVxdWVzdHMgaW5zdGVhZCBvZiAxLCBtYWtpbmcgaXQgc2ltaWxhciB0byBmZXRjaCBvciBwdXNoIGluIHRoYXQgcmVnYXJkLlxuICogSG93ZXZlciwgdmVyc2lvbiAyIHN1cHBvcnRzIHNlcnZlci1zaWRlIGZpbHRlcmluZyBieSBwcmVmaXgsIHdoZXJlYXMgdGhhdCBmaWx0ZXJpbmcgaXMgZG9uZSBjbGllbnQtc2lkZSBpbiB2ZXJzaW9uIDEuXG4gKiBXaGljaCBwcm90b2NvbCBpcyBtb3N0IGVmZmljaWVudCB0aGVyZWZvcmUgZGVwZW5kcyBvbiB0aGUgbnVtYmVyIG9mIHJlZnMgb24gdGhlIHJlbW90ZSwgdGhlIGxhdGVuY3kgb2YgdGhlIHNlcnZlciwgYW5kIHNwZWVkIG9mIHRoZSBuZXR3b3JrIGNvbm5lY3Rpb24uXG4gKiBGb3IgYW4gc21hbGwgcmVwb3MgKG9yIGZhc3QgSW50ZXJuZXQgY29ubmVjdGlvbnMpLCB0aGUgcmVxdWlyZW1lbnQgdG8gbWFrZSB0d28gdHJpcHMgdG8gdGhlIHNlcnZlciBtYWtlcyBwcm90b2NvbCAyIHNsb3dlci5cbiAqIEJ1dCBmb3IgbGFyZ2UgcmVwb3MgKG9yIHNsb3cgSW50ZXJuZXQgY29ubmVjdGlvbnMpLCB0aGUgZGVjcmVhc2VkIHBheWxvYWQgc2l6ZSBvZiB0aGUgc2Vjb25kIHJlcXVlc3QgbWFrZXMgdXAgZm9yIHRoZSBhZGRpdGlvbmFsIHJlcXVlc3QuXG4gKlxuICogSGFyZCBudW1iZXJzIHZhcnkgYnkgc2l0dWF0aW9uLCBidXQgaGVyZSdzIHNvbWUgbnVtYmVycyBmcm9tIG15IG1hY2hpbmU6XG4gKlxuICogVXNpbmcgaXNvbW9ycGhpYy1naXQgaW4gYSBicm93c2VyLCB3aXRoIGEgQ09SUyBwcm94eSwgbGlzdGluZyBvbmx5IHRoZSBicmFuY2hlcyAocmVmcy9oZWFkcykgb2YgaHR0cHM6Ly9naXRodWIuY29tL2lzb21vcnBoaWMtZ2l0L2lzb21vcnBoaWMtZ2l0XG4gKiAtIFByb3RvY29sIFZlcnNpb24gMSB0b29rIH4zMDBtcyBhbmQgdHJhbnNmZXJlZCA4NCBLQi5cbiAqIC0gUHJvdG9jb2wgVmVyc2lvbiAyIHRvb2sgfjUwMG1zIGFuZCB0cmFuc2ZlcmVkIDQuMSBLQi5cbiAqXG4gKiBVc2luZyBpc29tb3JwaGljLWdpdCBpbiBhIGJyb3dzZXIsIHdpdGggYSBDT1JTIHByb3h5LCBsaXN0aW5nIG9ubHkgdGhlIGJyYW5jaGVzIChyZWZzL2hlYWRzKSBvZiBodHRwczovL2dpdGxhYi5jb20vZ2l0bGFiLW9yZy9naXRsYWJcbiAqIC0gUHJvdG9jb2wgVmVyc2lvbiAxIHRvb2sgfjQ5MDBtcyBhbmQgdHJhbnNmZXJlZCA5LjQxIE1CLlxuICogLSBQcm90b2NvbCBWZXJzaW9uIDIgdG9vayB+MTI4MG1zIGFuZCB0cmFuc2ZlcmVkIDQzMyBLQi5cbiAqXG4gKiBGaW5hbGx5LCB0aGVyZSBpcyBhIGZ1biBxdWlyayByZWdhcmRpbmcgdGhlIGBzeW1yZWZzYCBwYXJhbWV0ZXIuXG4gKiBQcm90b2NvbCBWZXJzaW9uIDEgd2lsbCBnZW5lcmFsbHkgb25seSByZXR1cm4gdGhlIGBIRUFEYCBzeW1yZWYgYW5kIG5vdCBvdGhlcnMuXG4gKiBIaXN0b3JpY2FsbHksIHRoaXMgbWVhbnQgdGhhdCBzZXJ2ZXJzIGRvbid0IHVzZSBzeW1ib2xpYyByZWZzIGV4Y2VwdCBmb3IgYEhFQURgLCB3aGljaCBpcyB1c2VkIHRvIHBvaW50IGF0IHRoZSBcImRlZmF1bHQgYnJhbmNoXCIuXG4gKiBIb3dldmVyIFByb3RvY29sIFZlcnNpb24gMiBjYW4gcmV0dXJuICphbGwqIHRoZSBzeW1ib2xpYyByZWZzIG9uIHRoZSBzZXJ2ZXIuXG4gKiBTbyBpZiB5b3UgYXJlIHJ1bm5pbmcgeW91ciBvd24gZ2l0IHNlcnZlciwgeW91IGNvdWxkIHRha2UgYWR2YW50YWdlIG9mIHRoYXQgSSBndWVzcy5cbiAqXG4gKiAjIyMjIFRMO0RSXG4gKiBJZiB5b3UgYXJlIF9ub3RfIHRha2luZyBhZHZhbnRhZ2Ugb2YgYHByZWZpeGAgSSB3b3VsZCByZWNvbW1lbmQgYHByb3RvY29sVmVyc2lvbjogMWAuXG4gKiBPdGhlcndpc2UsIEkgcmVjb21tZW5kIHRvIHVzZSB0aGUgZGVmYXVsdCB3aGljaCBpcyBgcHJvdG9jb2xWZXJzaW9uOiAyYC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtIdHRwQ2xpZW50fSBhcmdzLmh0dHAgLSBhbiBIVFRQIGNsaWVudFxuICogQHBhcmFtIHtBdXRoQ2FsbGJhY2t9IFthcmdzLm9uQXV0aF0gLSBvcHRpb25hbCBhdXRoIGZpbGwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXV0aEZhaWx1cmVDYWxsYmFja30gW2FyZ3Mub25BdXRoRmFpbHVyZV0gLSBvcHRpb25hbCBhdXRoIHJlamVjdGVkIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhTdWNjZXNzQ2FsbGJhY2t9IFthcmdzLm9uQXV0aFN1Y2Nlc3NdIC0gb3B0aW9uYWwgYXV0aCBhcHByb3ZlZCBjYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MudXJsIC0gVGhlIFVSTCBvZiB0aGUgcmVtb3RlIHJlcG9zaXRvcnkuIFdpbGwgYmUgZ290dGVuIGZyb20gZ2l0Y29uZmlnIGlmIGFic2VudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb3JzUHJveHldIC0gT3B0aW9uYWwgW0NPUlMgcHJveHldKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS8lNDBpc29tb3JwaGljLWdpdC9jb3JzLXByb3h5KS4gT3ZlcnJpZGVzIHZhbHVlIGluIHJlcG8gY29uZmlnLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JQdXNoID0gZmFsc2VdIC0gQnkgZGVmYXVsdCwgdGhlIGNvbW1hbmQgcXVlcmllcyB0aGUgJ2ZldGNoJyBjYXBhYmlsaXRpZXMuIElmIHRydWUsIGl0IHdpbGwgYXNrIGZvciB0aGUgJ3B1c2gnIGNhcGFiaWxpdGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2FyZ3MuaGVhZGVyc10gLSBBZGRpdGlvbmFsIGhlYWRlcnMgdG8gaW5jbHVkZSBpbiBIVFRQIHJlcXVlc3RzLCBzaW1pbGFyIHRvIGdpdCdzIGBleHRyYUhlYWRlcmAgY29uZmlnXG4gKiBAcGFyYW0gezEgfCAyfSBbYXJncy5wcm90b2NvbFZlcnNpb24gPSAyXSAtIFdoaWNoIHZlcnNpb24gb2YgdGhlIEdpdCBQcm90b2NvbCB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucHJlZml4XSAtIE9ubHkgbGlzdCByZWZzIHRoYXQgc3RhcnQgd2l0aCB0aGlzIHByZWZpeFxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5zeW1yZWZzID0gZmFsc2VdIC0gSW5jbHVkZSBzeW1ib2xpYyByZWYgdGFyZ2V0c1xuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5wZWVsVGFncyA9IGZhbHNlXSAtIEluY2x1ZGUgYW5ub3RhdGVkIHRhZyBwZWVsZWQgdGFyZ2V0c1xuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFNlcnZlclJlZltdPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYW4gYXJyYXkgb2YgU2VydmVyUmVmIG9iamVjdHNcbiAqIEBzZWUgU2VydmVyUmVmXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIExpc3QgYWxsIHRoZSBicmFuY2hlcyBvbiBhIHJlcG9cbiAqIGxldCByZWZzID0gYXdhaXQgZ2l0Lmxpc3RTZXJ2ZXJSZWZzKHtcbiAqICAgaHR0cCxcbiAqICAgY29yc1Byb3h5OiBcImh0dHBzOi8vY29ycy5pc29tb3JwaGljLWdpdC5vcmdcIixcbiAqICAgdXJsOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9pc29tb3JwaGljLWdpdC9pc29tb3JwaGljLWdpdC5naXRcIixcbiAqICAgcHJlZml4OiBcInJlZnMvaGVhZHMvXCIsXG4gKiB9KTtcbiAqIGNvbnNvbGUubG9nKHJlZnMpO1xuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBHZXQgdGhlIGRlZmF1bHQgYnJhbmNoIG9uIGEgcmVwb1xuICogbGV0IHJlZnMgPSBhd2FpdCBnaXQubGlzdFNlcnZlclJlZnMoe1xuICogICBodHRwLFxuICogICBjb3JzUHJveHk6IFwiaHR0cHM6Ly9jb3JzLmlzb21vcnBoaWMtZ2l0Lm9yZ1wiLFxuICogICB1cmw6IFwiaHR0cHM6Ly9naXRodWIuY29tL2lzb21vcnBoaWMtZ2l0L2lzb21vcnBoaWMtZ2l0LmdpdFwiLFxuICogICBwcmVmaXg6IFwiSEVBRFwiLFxuICogICBzeW1yZWZzOiB0cnVlLFxuICogfSk7XG4gKiBjb25zb2xlLmxvZyhyZWZzKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gTGlzdCBhbGwgdGhlIHRhZ3Mgb24gYSByZXBvXG4gKiBsZXQgcmVmcyA9IGF3YWl0IGdpdC5saXN0U2VydmVyUmVmcyh7XG4gKiAgIGh0dHAsXG4gKiAgIGNvcnNQcm94eTogXCJodHRwczovL2NvcnMuaXNvbW9ycGhpYy1naXQub3JnXCIsXG4gKiAgIHVybDogXCJodHRwczovL2dpdGh1Yi5jb20vaXNvbW9ycGhpYy1naXQvaXNvbW9ycGhpYy1naXQuZ2l0XCIsXG4gKiAgIHByZWZpeDogXCJyZWZzL3RhZ3MvXCIsXG4gKiAgIHBlZWxUYWdzOiB0cnVlLFxuICogfSk7XG4gKiBjb25zb2xlLmxvZyhyZWZzKTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gTGlzdCBhbGwgdGhlIHB1bGwgcmVxdWVzdHMgb24gYSByZXBvXG4gKiBsZXQgcmVmcyA9IGF3YWl0IGdpdC5saXN0U2VydmVyUmVmcyh7XG4gKiAgIGh0dHAsXG4gKiAgIGNvcnNQcm94eTogXCJodHRwczovL2NvcnMuaXNvbW9ycGhpYy1naXQub3JnXCIsXG4gKiAgIHVybDogXCJodHRwczovL2dpdGh1Yi5jb20vaXNvbW9ycGhpYy1naXQvaXNvbW9ycGhpYy1naXQuZ2l0XCIsXG4gKiAgIHByZWZpeDogXCJyZWZzL3B1bGwvXCIsXG4gKiB9KTtcbiAqIGNvbnNvbGUubG9nKHJlZnMpO1xuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gbGlzdFNlcnZlclJlZnMoe1xuICBodHRwLFxuICBvbkF1dGgsXG4gIG9uQXV0aFN1Y2Nlc3MsXG4gIG9uQXV0aEZhaWx1cmUsXG4gIGNvcnNQcm94eSxcbiAgdXJsLFxuICBoZWFkZXJzID0ge30sXG4gIGZvclB1c2ggPSBmYWxzZSxcbiAgcHJvdG9jb2xWZXJzaW9uID0gMixcbiAgcHJlZml4LFxuICBzeW1yZWZzLFxuICBwZWVsVGFncyxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2h0dHAnLCBodHRwKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3VybCcsIHVybCk7XG5cbiAgICBjb25zdCByZW1vdGUgPSBhd2FpdCBHaXRSZW1vdGVIVFRQLmRpc2NvdmVyKHtcbiAgICAgIGh0dHAsXG4gICAgICBvbkF1dGgsXG4gICAgICBvbkF1dGhTdWNjZXNzLFxuICAgICAgb25BdXRoRmFpbHVyZSxcbiAgICAgIGNvcnNQcm94eSxcbiAgICAgIHNlcnZpY2U6IGZvclB1c2ggPyAnZ2l0LXJlY2VpdmUtcGFjaycgOiAnZ2l0LXVwbG9hZC1wYWNrJyxcbiAgICAgIHVybCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBwcm90b2NvbFZlcnNpb24sXG4gICAgfSk7XG5cbiAgICBpZiAocmVtb3RlLnByb3RvY29sVmVyc2lvbiA9PT0gMSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEluZm9SZWZzKHJlbW90ZSwgcHJlZml4LCBzeW1yZWZzLCBwZWVsVGFncylcbiAgICB9XG5cbiAgICAvLyBQcm90b2NvbCBWZXJzaW9uIDJcbiAgICBjb25zdCBib2R5ID0gYXdhaXQgd3JpdGVMaXN0UmVmc1JlcXVlc3QoeyBwcmVmaXgsIHN5bXJlZnMsIHBlZWxUYWdzIH0pO1xuXG4gICAgY29uc3QgcmVzID0gYXdhaXQgR2l0UmVtb3RlSFRUUC5jb25uZWN0KHtcbiAgICAgIGh0dHAsXG4gICAgICBhdXRoOiByZW1vdGUuYXV0aCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBjb3JzUHJveHksXG4gICAgICBzZXJ2aWNlOiBmb3JQdXNoID8gJ2dpdC1yZWNlaXZlLXBhY2snIDogJ2dpdC11cGxvYWQtcGFjaycsXG4gICAgICB1cmwsXG4gICAgICBib2R5LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBhcnNlTGlzdFJlZnNSZXNwb25zZShyZXMuYm9keSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQubGlzdFNlcnZlclJlZnMnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIExpc3QgdGFnc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxzdHJpbmc+Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYW4gYXJyYXkgb2YgdGFnIG5hbWVzXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCB0YWdzID0gYXdhaXQgZ2l0Lmxpc3RUYWdzKHsgZnMsIGRpcjogJy90dXRvcmlhbCcgfSlcbiAqIGNvbnNvbGUubG9nKHRhZ3MpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBsaXN0VGFncyh7IGZzLCBkaXIsIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpIH0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICByZXR1cm4gR2l0UmVmTWFuYWdlci5saXN0VGFncyh7IGZzOiBuZXcgRmlsZVN5c3RlbShmcyksIGdpdGRpciB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5saXN0VGFncyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUNvbW1pdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSkge1xuICBjb25zdCB7IHR5cGUsIG9iamVjdCB9ID0gYXdhaXQgX3JlYWRPYmplY3QoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pO1xuICAvLyBSZXNvbHZlIGFubm90YXRlZCB0YWcgb2JqZWN0cyB0byB3aGF0ZXZlclxuICBpZiAodHlwZSA9PT0gJ3RhZycpIHtcbiAgICBvaWQgPSBHaXRBbm5vdGF0ZWRUYWcuZnJvbShvYmplY3QpLnBhcnNlKCkub2JqZWN0O1xuICAgIHJldHVybiByZXNvbHZlQ29tbWl0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KVxuICB9XG4gIGlmICh0eXBlICE9PSAnY29tbWl0Jykge1xuICAgIHRocm93IG5ldyBPYmplY3RUeXBlRXJyb3Iob2lkLCB0eXBlLCAnY29tbWl0JylcbiAgfVxuICByZXR1cm4geyBjb21taXQ6IEdpdENvbW1pdC5mcm9tKG9iamVjdCksIG9pZCB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge2FueX0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5vaWRcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSZWFkQ29tbWl0UmVzdWx0Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYSBnaXQgY29tbWl0IG9iamVjdFxuICogQHNlZSBSZWFkQ29tbWl0UmVzdWx0XG4gKiBAc2VlIENvbW1pdE9iamVjdFxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3JlYWRDb21taXQoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pIHtcbiAgY29uc3QgeyBjb21taXQsIG9pZDogY29tbWl0T2lkIH0gPSBhd2FpdCByZXNvbHZlQ29tbWl0KHtcbiAgICBmcyxcbiAgICBjYWNoZSxcbiAgICBnaXRkaXIsXG4gICAgb2lkLFxuICB9KTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIG9pZDogY29tbWl0T2lkLFxuICAgIGNvbW1pdDogY29tbWl0LnBhcnNlKCksXG4gICAgcGF5bG9hZDogY29tbWl0LndpdGhvdXRTaWduYXR1cmUoKSxcbiAgfTtcbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVBZ2UoYSwgYikge1xuICByZXR1cm4gYS5jb21taXR0ZXIudGltZXN0YW1wIC0gYi5jb21taXR0ZXIudGltZXN0YW1wXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vLyB0aGUgZW1wdHkgZmlsZSBjb250ZW50IG9iamVjdCBpZFxuY29uc3QgRU1QVFlfT0lEID0gJ2U2OWRlMjliYjJkMWQ2NDM0YjhiMjlhZTc3NWFkOGMyZTQ4YzUzOTEnO1xuXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlRmlsZUlkSW5UcmVlKHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCwgZmlsZUlkIH0pIHtcbiAgaWYgKGZpbGVJZCA9PT0gRU1QVFlfT0lEKSByZXR1cm5cbiAgY29uc3QgX29pZCA9IG9pZDtcbiAgbGV0IGZpbGVwYXRoO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNvbHZlVHJlZSh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG4gIGNvbnN0IHRyZWUgPSByZXN1bHQudHJlZTtcbiAgaWYgKGZpbGVJZCA9PT0gcmVzdWx0Lm9pZCkge1xuICAgIGZpbGVwYXRoID0gcmVzdWx0LnBhdGg7XG4gIH0gZWxzZSB7XG4gICAgZmlsZXBhdGggPSBhd2FpdCBfcmVzb2x2ZUZpbGVJZCh7XG4gICAgICBmcyxcbiAgICAgIGNhY2hlLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgdHJlZSxcbiAgICAgIGZpbGVJZCxcbiAgICAgIG9pZDogX29pZCxcbiAgICB9KTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWxlcGF0aCkpIHtcbiAgICAgIGlmIChmaWxlcGF0aC5sZW5ndGggPT09IDApIGZpbGVwYXRoID0gdW5kZWZpbmVkO1xuICAgICAgZWxzZSBpZiAoZmlsZXBhdGgubGVuZ3RoID09PSAxKSBmaWxlcGF0aCA9IGZpbGVwYXRoWzBdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmlsZXBhdGhcbn1cblxuYXN5bmMgZnVuY3Rpb24gX3Jlc29sdmVGaWxlSWQoe1xuICBmcyxcbiAgY2FjaGUsXG4gIGdpdGRpcixcbiAgdHJlZSxcbiAgZmlsZUlkLFxuICBvaWQsXG4gIGZpbGVwYXRocyA9IFtdLFxuICBwYXJlbnRQYXRoID0gJycsXG59KSB7XG4gIGNvbnN0IHdhbGtzID0gdHJlZS5lbnRyaWVzKCkubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoZW50cnkub2lkID09PSBmaWxlSWQpIHtcbiAgICAgIHJlc3VsdCA9IGpvaW4ocGFyZW50UGF0aCwgZW50cnkucGF0aCk7XG4gICAgICBmaWxlcGF0aHMucHVzaChyZXN1bHQpO1xuICAgIH0gZWxzZSBpZiAoZW50cnkudHlwZSA9PT0gJ3RyZWUnKSB7XG4gICAgICByZXN1bHQgPSBfcmVhZE9iamVjdCh7XG4gICAgICAgIGZzLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICBvaWQ6IGVudHJ5Lm9pZCxcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24oeyBvYmplY3QgfSkge1xuICAgICAgICByZXR1cm4gX3Jlc29sdmVGaWxlSWQoe1xuICAgICAgICAgIGZzLFxuICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgIGdpdGRpcixcbiAgICAgICAgICB0cmVlOiBHaXRUcmVlLmZyb20ob2JqZWN0KSxcbiAgICAgICAgICBmaWxlSWQsXG4gICAgICAgICAgb2lkLFxuICAgICAgICAgIGZpbGVwYXRocyxcbiAgICAgICAgICBwYXJlbnRQYXRoOiBqb2luKHBhcmVudFBhdGgsIGVudHJ5LnBhdGgpLFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG5cbiAgYXdhaXQgUHJvbWlzZS5hbGwod2Fsa3MpO1xuICByZXR1cm4gZmlsZXBhdGhzXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEdldCBjb21taXQgZGVzY3JpcHRpb25zIGZyb20gdGhlIGdpdCBoaXN0b3J5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gYXJncy5maWxlcGF0aCBvcHRpb25hbCBnZXQgdGhlIGNvbW1pdCBmb3IgdGhlIGZpbGVwYXRoIG9ubHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlZlxuICogQHBhcmFtIHtudW1iZXJ8dm9pZH0gYXJncy5kZXB0aFxuICogQHBhcmFtIHtib29sZWFuPX0gW2FyZ3MuZm9yY2U9ZmFsc2VdIGRvIG5vdCB0aHJvdyBlcnJvciBpZiBmaWxlcGF0aCBpcyBub3QgZXhpc3QgKHdvcmtzIG9ubHkgZm9yIGEgc2luZ2xlIGZpbGUpLiBkZWZhdWx0cyB0byBmYWxzZVxuICogQHBhcmFtIHtib29sZWFuPX0gW2FyZ3MuZm9sbG93PWZhbHNlXSBDb250aW51ZSBsaXN0aW5nIHRoZSBoaXN0b3J5IG9mIGEgZmlsZSBiZXlvbmQgcmVuYW1lcyAod29ya3Mgb25seSBmb3IgYSBzaW5nbGUgZmlsZSkuIGRlZmF1bHRzIHRvIGZhbHNlXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBhcmdzLmZvbGxvdyBDb250aW51ZSBsaXN0aW5nIHRoZSBoaXN0b3J5IG9mIGEgZmlsZSBiZXlvbmQgcmVuYW1lcyAod29ya3Mgb25seSBmb3IgYSBzaW5nbGUgZmlsZSkuIGRlZmF1bHRzIHRvIGZhbHNlXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8UmVhZENvbW1pdFJlc3VsdD4+fSBSZXNvbHZlcyB0byBhbiBhcnJheSBvZiBSZWFkQ29tbWl0UmVzdWx0IG9iamVjdHNcbiAqIEBzZWUgUmVhZENvbW1pdFJlc3VsdFxuICogQHNlZSBDb21taXRPYmplY3RcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IGNvbW1pdHMgPSBhd2FpdCBnaXQubG9nKHsgZGlyOiAnJGlucHV0KCgvKSknLCBkZXB0aDogJGlucHV0KCg1KSksIHJlZjogJyRpbnB1dCgobWFzdGVyKSknIH0pXG4gKiBjb25zb2xlLmxvZyhjb21taXRzKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2xvZyh7XG4gIGZzLFxuICBjYWNoZSxcbiAgZ2l0ZGlyLFxuICBmaWxlcGF0aCxcbiAgcmVmLFxuICBkZXB0aCxcbiAgc2luY2UsXG4gIGZvcmNlLFxuICBmb2xsb3csXG59KSB7XG4gIGNvbnN0IHNpbmNlVGltZXN0YW1wID1cbiAgICB0eXBlb2Ygc2luY2UgPT09ICd1bmRlZmluZWQnXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBNYXRoLmZsb29yKHNpbmNlLnZhbHVlT2YoKSAvIDEwMDApO1xuICAvLyBUT0RPOiBJbiB0aGUgZnV0dXJlLCB3ZSBtYXkgd2FudCB0byBoYXZlIGFuIEFQSSB3aGVyZSB3ZSByZXR1cm4gYVxuICAvLyBhc3luYyBpdGVyYXRvciB0aGF0IGVtaXRzIGNvbW1pdHMuXG4gIGNvbnN0IGNvbW1pdHMgPSBbXTtcbiAgY29uc3Qgc2hhbGxvd0NvbW1pdHMgPSBhd2FpdCBHaXRTaGFsbG93TWFuYWdlci5yZWFkKHsgZnMsIGdpdGRpciB9KTtcbiAgY29uc3Qgb2lkID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHsgZnMsIGdpdGRpciwgcmVmIH0pO1xuICBjb25zdCB0aXBzID0gW2F3YWl0IF9yZWFkQ29tbWl0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KV07XG4gIGxldCBsYXN0RmlsZU9pZDtcbiAgbGV0IGxhc3RDb21taXQ7XG4gIGxldCBpc09rO1xuXG4gIGZ1bmN0aW9uIGVuZENvbW1pdChjb21taXQpIHtcbiAgICBpZiAoaXNPayAmJiBmaWxlcGF0aCkgY29tbWl0cy5wdXNoKGNvbW1pdCk7XG4gIH1cblxuICB3aGlsZSAodGlwcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY29tbWl0ID0gdGlwcy5wb3AoKTtcblxuICAgIC8vIFN0b3AgdGhlIGxvZyBpZiB3ZSd2ZSBoaXQgdGhlIGFnZSBsaW1pdFxuICAgIGlmIChcbiAgICAgIHNpbmNlVGltZXN0YW1wICE9PSB1bmRlZmluZWQgJiZcbiAgICAgIGNvbW1pdC5jb21taXQuY29tbWl0dGVyLnRpbWVzdGFtcCA8PSBzaW5jZVRpbWVzdGFtcFxuICAgICkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBpZiAoZmlsZXBhdGgpIHtcbiAgICAgIGxldCB2RmlsZU9pZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZGaWxlT2lkID0gYXdhaXQgcmVzb2x2ZUZpbGVwYXRoKHtcbiAgICAgICAgICBmcyxcbiAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICBnaXRkaXIsXG4gICAgICAgICAgb2lkOiBjb21taXQuY29tbWl0LnRyZWUsXG4gICAgICAgICAgZmlsZXBhdGgsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobGFzdENvbW1pdCAmJiBsYXN0RmlsZU9pZCAhPT0gdkZpbGVPaWQpIHtcbiAgICAgICAgICBjb21taXRzLnB1c2gobGFzdENvbW1pdCk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEZpbGVPaWQgPSB2RmlsZU9pZDtcbiAgICAgICAgbGFzdENvbW1pdCA9IGNvbW1pdDtcbiAgICAgICAgaXNPayA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvcikge1xuICAgICAgICAgIGxldCBmb3VuZCA9IGZvbGxvdyAmJiBsYXN0RmlsZU9pZDtcbiAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIGZvdW5kID0gYXdhaXQgcmVzb2x2ZUZpbGVJZEluVHJlZSh7XG4gICAgICAgICAgICAgIGZzLFxuICAgICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgICAgZ2l0ZGlyLFxuICAgICAgICAgICAgICBvaWQ6IGNvbW1pdC5jb21taXQudHJlZSxcbiAgICAgICAgICAgICAgZmlsZUlkOiBsYXN0RmlsZU9pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZvdW5kKSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0Q29tbWl0KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBsYXN0Rm91bmQgPSBhd2FpdCByZXNvbHZlRmlsZUlkSW5UcmVlKHtcbiAgICAgICAgICAgICAgICAgICAgZnMsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgICAgICAgICBnaXRkaXIsXG4gICAgICAgICAgICAgICAgICAgIG9pZDogbGFzdENvbW1pdC5jb21taXQudHJlZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsZUlkOiBsYXN0RmlsZU9pZCxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobGFzdEZvdW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZvdW5kLmZpbHRlcihwID0+IGxhc3RGb3VuZC5pbmRleE9mKHApID09PSAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZvdW5kWzBdO1xuICAgICAgICAgICAgICAgICAgICAgIGZpbGVwYXRoID0gZm91bmQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RDb21taXQpIGNvbW1pdHMucHVzaChsYXN0Q29tbWl0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0Q29tbWl0KSBjb21taXRzLnB1c2gobGFzdENvbW1pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWxlcGF0aCA9IGZvdW5kO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0Q29tbWl0KSBjb21taXRzLnB1c2gobGFzdENvbW1pdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgaWYgKCFmb3JjZSAmJiAhZm9sbG93KSB0aHJvdyBlXG4gICAgICAgICAgICBpZiAoaXNPayAmJiBsYXN0RmlsZU9pZCkge1xuICAgICAgICAgICAgICBjb21taXRzLnB1c2gobGFzdENvbW1pdCk7XG4gICAgICAgICAgICAgIC8vIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RDb21taXQgPSBjb21taXQ7XG4gICAgICAgICAgaXNPayA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgdGhyb3cgZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRzLnB1c2goY29tbWl0KTtcbiAgICB9XG5cbiAgICAvLyBTdG9wIHRoZSBsb29wIGlmIHdlIGhhdmUgZW5vdWdoIGNvbW1pdHMgbm93LlxuICAgIGlmIChkZXB0aCAhPT0gdW5kZWZpbmVkICYmIGNvbW1pdHMubGVuZ3RoID09PSBkZXB0aCkge1xuICAgICAgZW5kQ29tbWl0KGNvbW1pdCk7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgaXMgbm90IGEgc2hhbGxvdyBjb21taXQuLi5cbiAgICBpZiAoIXNoYWxsb3dDb21taXRzLmhhcyhjb21taXQub2lkKSkge1xuICAgICAgLy8gQWRkIHRoZSBwYXJlbnRzIG9mIHRoaXMgY29tbWl0IHRvIHRoZSBxdWV1ZVxuICAgICAgLy8gTm90ZTogZm9yIHRoZSBjYXNlIG9mIGEgY29tbWl0IHdpdGggbm8gcGFyZW50cywgaXQgd2lsbCBjb25jYXQgYW4gZW1wdHkgYXJyYXksIGhhdmluZyBubyBuZXQgZWZmZWN0LlxuICAgICAgZm9yIChjb25zdCBvaWQgb2YgY29tbWl0LmNvbW1pdC5wYXJlbnQpIHtcbiAgICAgICAgY29uc3QgY29tbWl0ID0gYXdhaXQgX3JlYWRDb21taXQoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pO1xuICAgICAgICBpZiAoIXRpcHMubWFwKGNvbW1pdCA9PiBjb21taXQub2lkKS5pbmNsdWRlcyhjb21taXQub2lkKSkge1xuICAgICAgICAgIHRpcHMucHVzaChjb21taXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RvcCB0aGUgbG9vcCBpZiB0aGVyZSBhcmUgbm8gbW9yZSBjb21taXQgcGFyZW50c1xuICAgIGlmICh0aXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZW5kQ29tbWl0KGNvbW1pdCk7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyB0aXBzIGluIG9yZGVyIGJ5IGFnZVxuICAgIHRpcHMuc29ydCgoYSwgYikgPT4gY29tcGFyZUFnZShhLmNvbW1pdCwgYi5jb21taXQpKTtcbiAgfVxuICByZXR1cm4gY29tbWl0c1xufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBHZXQgY29tbWl0IGRlc2NyaXB0aW9ucyBmcm9tIHRoZSBnaXQgaGlzdG9yeVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nPX0gYXJncy5maWxlcGF0aCBvcHRpb25hbCBnZXQgdGhlIGNvbW1pdCBmb3IgdGhlIGZpbGVwYXRoIG9ubHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZWYgPSAnSEVBRCddIC0gVGhlIGNvbW1pdCB0byBiZWdpbiB3YWxraW5nIGJhY2t3YXJkcyB0aHJvdWdoIHRoZSBoaXN0b3J5IGZyb21cbiAqIEBwYXJhbSB7bnVtYmVyPX0gW2FyZ3MuZGVwdGhdIC0gTGltaXQgdGhlIG51bWJlciBvZiBjb21taXRzIHJldHVybmVkLiBObyBsaW1pdCBieSBkZWZhdWx0LlxuICogQHBhcmFtIHtEYXRlfSBbYXJncy5zaW5jZV0gLSBSZXR1cm4gaGlzdG9yeSBuZXdlciB0aGFuIHRoZSBnaXZlbiBkYXRlLiBDYW4gYmUgY29tYmluZWQgd2l0aCBgZGVwdGhgIHRvIGdldCB3aGljaGV2ZXIgaXMgc2hvcnRlci5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IFthcmdzLmZvcmNlPWZhbHNlXSBkbyBub3QgdGhyb3cgZXJyb3IgaWYgZmlsZXBhdGggaXMgbm90IGV4aXN0ICh3b3JrcyBvbmx5IGZvciBhIHNpbmdsZSBmaWxlKS4gZGVmYXVsdHMgdG8gZmFsc2VcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IFthcmdzLmZvbGxvdz1mYWxzZV0gQ29udGludWUgbGlzdGluZyB0aGUgaGlzdG9yeSBvZiBhIGZpbGUgYmV5b25kIHJlbmFtZXMgKHdvcmtzIG9ubHkgZm9yIGEgc2luZ2xlIGZpbGUpLiBkZWZhdWx0cyB0byBmYWxzZVxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8UmVhZENvbW1pdFJlc3VsdD4+fSBSZXNvbHZlcyB0byBhbiBhcnJheSBvZiBSZWFkQ29tbWl0UmVzdWx0IG9iamVjdHNcbiAqIEBzZWUgUmVhZENvbW1pdFJlc3VsdFxuICogQHNlZSBDb21taXRPYmplY3RcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IGNvbW1pdHMgPSBhd2FpdCBnaXQubG9nKHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIGRlcHRoOiA1LFxuICogICByZWY6ICdtYWluJ1xuICogfSlcbiAqIGNvbnNvbGUubG9nKGNvbW1pdHMpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2coe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgZmlsZXBhdGgsXG4gIHJlZiA9ICdIRUFEJyxcbiAgZGVwdGgsXG4gIHNpbmNlLCAvLyBEYXRlXG4gIGZvcmNlLFxuICBmb2xsb3csXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdyZWYnLCByZWYpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9sb2coe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGNhY2hlLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgZmlsZXBhdGgsXG4gICAgICByZWYsXG4gICAgICBkZXB0aCxcbiAgICAgIHNpbmNlLFxuICAgICAgZm9yY2UsXG4gICAgICBmb2xsb3csXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQubG9nJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gTWVyZ2VSZXN1bHQgLSBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgc2NoZW1hIGxpa2UgdGhpczpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb2lkXSAtIFRoZSBTSEEtMSBvYmplY3QgaWQgdGhhdCBpcyBub3cgYXQgdGhlIGhlYWQgb2YgdGhlIGJyYW5jaC4gQWJzZW50IG9ubHkgaWYgYGRyeVJ1bmAgd2FzIHNwZWNpZmllZCBhbmQgYG1lcmdlQ29tbWl0YCBpcyB0cnVlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWxyZWFkeU1lcmdlZF0gLSBUcnVlIGlmIHRoZSBicmFuY2ggd2FzIGFscmVhZHkgbWVyZ2VkIHNvIG5vIGNoYW5nZXMgd2VyZSBtYWRlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmYXN0Rm9yd2FyZF0gLSBUcnVlIGlmIGl0IHdhcyBhIGZhc3QtZm9yd2FyZCBtZXJnZVxuICogQHByb3BlcnR5IHtib29sZWFufSBbbWVyZ2VDb21taXRdIC0gVHJ1ZSBpZiBtZXJnZSByZXN1bHRlZCBpbiBhIG1lcmdlIGNvbW1pdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0cmVlXSAtIFRoZSBTSEEtMSBvYmplY3QgaWQgb2YgdGhlIHRyZWUgcmVzdWx0aW5nIGZyb20gYSBtZXJnZSBjb21taXRcbiAqXG4gKi9cblxuLyoqXG4gKiBNZXJnZSB0d28gYnJhbmNoZXNcbiAqXG4gKiAjIyBMaW1pdGF0aW9uc1xuICpcbiAqIEN1cnJlbnRseSBpdCBkb2VzIG5vdCBzdXBwb3J0IGluY29tcGxldGUgbWVyZ2VzLiBUaGF0IGlzLCBpZiB0aGVyZSBhcmUgbWVyZ2UgY29uZmxpY3RzIGl0IGNhbm5vdCBzb2x2ZVxuICogd2l0aCB0aGUgYnVpbHQgaW4gZGlmZjMgYWxnb3JpdGhtIGl0IHdpbGwgbm90IG1vZGlmeSB0aGUgd29ya2luZyBkaXIsIGFuZCB3aWxsIHRocm93IGEgW2BNZXJnZU5vdFN1cHBvcnRlZEVycm9yYF0oLi9lcnJvcnMubWQjbWVyZ2Vub3RzdXBwb3J0ZWRFcnJvcikgZXJyb3IuXG4gKlxuICogQ3VycmVudGx5IGl0IHdpbGwgZmFpbCBpZiBtdWx0aXBsZSBjYW5kaWRhdGUgbWVyZ2UgYmFzZXMgYXJlIGZvdW5kLiAoSXQgZG9lc24ndCB5ZXQgaW1wbGVtZW50IHRoZSByZWN1cnNpdmUgbWVyZ2Ugc3RyYXRlZ3kuKVxuICpcbiAqIEN1cnJlbnRseSBpdCBkb2VzIG5vdCBzdXBwb3J0IHNlbGVjdGluZyBhbHRlcm5hdGl2ZSBtZXJnZSBzdHJhdGVnaWVzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7U2lnbkNhbGxiYWNrfSBbYXJncy5vblNpZ25dIC0gYSBQR1Agc2lnbmluZyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLm91cnNdIC0gVGhlIGJyYW5jaCByZWNlaXZpbmcgdGhlIG1lcmdlLiBJZiB1bmRlZmluZWQsIGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnRoZWlycyAtIFRoZSBicmFuY2ggdG8gYmUgbWVyZ2VkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmZhc3RGb3J3YXJkT25seSA9IGZhbHNlXSAtIElmIHRydWUsIHRoZW4gbm9uLWZhc3QtZm9yd2FyZCBtZXJnZXMgd2lsbCB0aHJvdyBhbiBFcnJvciBpbnN0ZWFkIG9mIHBlcmZvcm1pbmcgYSBtZXJnZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZHJ5UnVuID0gZmFsc2VdIC0gSWYgdHJ1ZSwgc2ltdWxhdGVzIGEgbWVyZ2Ugc28geW91IGNhbiB0ZXN0IHdoZXRoZXIgaXQgd291bGQgc3VjY2VlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3Mubm9VcGRhdGVCcmFuY2ggPSBmYWxzZV0gLSBJZiB0cnVlLCBkb2VzIG5vdCB1cGRhdGUgdGhlIGJyYW5jaCBwb2ludGVyIGFmdGVyIGNyZWF0aW5nIHRoZSBjb21taXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MubWVzc2FnZV0gLSBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYXV0by1nZW5lcmF0ZWQgbWVyZ2UgY29tbWl0IG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJncy5hdXRob3JdIC0gcGFzc2VkIHRvIFtjb21taXRdKGNvbW1pdC5tZCkgd2hlbiBjcmVhdGluZyBhIG1lcmdlIGNvbW1pdFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmF1dGhvci5uYW1lXSAtIERlZmF1bHQgaXMgYHVzZXIubmFtZWAgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmF1dGhvci5lbWFpbF0gLSBEZWZhdWx0IGlzIGB1c2VyLmVtYWlsYCBjb25maWcuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuYXV0aG9yLnRpbWVzdGFtcD1NYXRoLmZsb29yKERhdGUubm93KCkvMTAwMCldIC0gU2V0IHRoZSBhdXRob3IgdGltZXN0YW1wIGZpZWxkLiBUaGlzIGlzIHRoZSBpbnRlZ2VyIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBVbml4IGVwb2NoICgxOTcwLTAxLTAxIDAwOjAwOjAwKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5hdXRob3IudGltZXpvbmVPZmZzZXRdIC0gU2V0IHRoZSBhdXRob3IgdGltZXpvbmUgb2Zmc2V0IGZpZWxkLiBUaGlzIGlzIHRoZSBkaWZmZXJlbmNlLCBpbiBtaW51dGVzLCBmcm9tIHRoZSBjdXJyZW50IHRpbWV6b25lIHRvIFVUQy4gRGVmYXVsdCBpcyBgKG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KClgLlxuICogQHBhcmFtIHtPYmplY3R9IFthcmdzLmNvbW1pdHRlcl0gLSBwYXNzZWQgdG8gW2NvbW1pdF0oY29tbWl0Lm1kKSB3aGVuIGNyZWF0aW5nIGEgbWVyZ2UgY29tbWl0XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY29tbWl0dGVyLm5hbWVdIC0gRGVmYXVsdCBpcyBgdXNlci5uYW1lYCBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY29tbWl0dGVyLmVtYWlsXSAtIERlZmF1bHQgaXMgYHVzZXIuZW1haWxgIGNvbmZpZy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5jb21taXR0ZXIudGltZXN0YW1wPU1hdGguZmxvb3IoRGF0ZS5ub3coKS8xMDAwKV0gLSBTZXQgdGhlIGNvbW1pdHRlciB0aW1lc3RhbXAgZmllbGQuIFRoaXMgaXMgdGhlIGludGVnZXIgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIFVuaXggZXBvY2ggKDE5NzAtMDEtMDEgMDA6MDA6MDApLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmNvbW1pdHRlci50aW1lem9uZU9mZnNldF0gLSBTZXQgdGhlIGNvbW1pdHRlciB0aW1lem9uZSBvZmZzZXQgZmllbGQuIFRoaXMgaXMgdGhlIGRpZmZlcmVuY2UsIGluIG1pbnV0ZXMsIGZyb20gdGhlIGN1cnJlbnQgdGltZXpvbmUgdG8gVVRDLiBEZWZhdWx0IGlzIGAobmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKWAuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3Muc2lnbmluZ0tleV0gLSBwYXNzZWQgdG8gW2NvbW1pdF0oY29tbWl0Lm1kKSB3aGVuIGNyZWF0aW5nIGEgbWVyZ2UgY29tbWl0XG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZXJnZVJlc3VsdD59IFJlc29sdmVzIHRvIGEgZGVzY3JpcHRpb24gb2YgdGhlIG1lcmdlIG9wZXJhdGlvblxuICogQHNlZSBNZXJnZVJlc3VsdFxuICpcbiAqIEBleGFtcGxlXG4gKiBsZXQgbSA9IGF3YWl0IGdpdC5tZXJnZSh7XG4gKiAgIGZzLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICBvdXJzOiAnbWFpbicsXG4gKiAgIHRoZWlyczogJ3JlbW90ZXMvb3JpZ2luL21haW4nXG4gKiB9KVxuICogY29uc29sZS5sb2cobSlcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1lcmdlKHtcbiAgZnM6IF9mcyxcbiAgb25TaWduLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICBvdXJzLFxuICB0aGVpcnMsXG4gIGZhc3RGb3J3YXJkT25seSA9IGZhbHNlLFxuICBkcnlSdW4gPSBmYWxzZSxcbiAgbm9VcGRhdGVCcmFuY2ggPSBmYWxzZSxcbiAgbWVzc2FnZSxcbiAgYXV0aG9yOiBfYXV0aG9yLFxuICBjb21taXR0ZXI6IF9jb21taXR0ZXIsXG4gIHNpZ25pbmdLZXksXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIF9mcyk7XG4gICAgaWYgKHNpZ25pbmdLZXkpIHtcbiAgICAgIGFzc2VydFBhcmFtZXRlcignb25TaWduJywgb25TaWduKTtcbiAgICB9XG4gICAgY29uc3QgZnMgPSBuZXcgRmlsZVN5c3RlbShfZnMpO1xuXG4gICAgY29uc3QgYXV0aG9yID0gYXdhaXQgbm9ybWFsaXplQXV0aG9yT2JqZWN0KHsgZnMsIGdpdGRpciwgYXV0aG9yOiBfYXV0aG9yIH0pO1xuICAgIGlmICghYXV0aG9yICYmICFmYXN0Rm9yd2FyZE9ubHkpIHRocm93IG5ldyBNaXNzaW5nTmFtZUVycm9yKCdhdXRob3InKVxuXG4gICAgY29uc3QgY29tbWl0dGVyID0gYXdhaXQgbm9ybWFsaXplQ29tbWl0dGVyT2JqZWN0KHtcbiAgICAgIGZzLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgYXV0aG9yLFxuICAgICAgY29tbWl0dGVyOiBfY29tbWl0dGVyLFxuICAgIH0pO1xuICAgIGlmICghY29tbWl0dGVyICYmICFmYXN0Rm9yd2FyZE9ubHkpIHtcbiAgICAgIHRocm93IG5ldyBNaXNzaW5nTmFtZUVycm9yKCdjb21taXR0ZXInKVxuICAgIH1cblxuICAgIHJldHVybiBhd2FpdCBfbWVyZ2Uoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIG91cnMsXG4gICAgICB0aGVpcnMsXG4gICAgICBmYXN0Rm9yd2FyZE9ubHksXG4gICAgICBkcnlSdW4sXG4gICAgICBub1VwZGF0ZUJyYW5jaCxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBhdXRob3IsXG4gICAgICBjb21taXR0ZXIsXG4gICAgICBzaWduaW5nS2V5LFxuICAgICAgb25TaWduLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0Lm1lcmdlJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IHR5cGVzID0ge1xuICBjb21taXQ6IDBiMDAxMDAwMCxcbiAgdHJlZTogMGIwMTAwMDAwLFxuICBibG9iOiAwYjAxMTAwMDAsXG4gIHRhZzogMGIxMDAwMDAwLFxuICBvZnNfZGVsdGE6IDBiMTEwMDAwMCxcbiAgcmVmX2RlbHRhOiAwYjExMTAwMDAsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge2FueX0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsICcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFyZ3Mub2lkc1xuICovXG5hc3luYyBmdW5jdGlvbiBfcGFjayh7XG4gIGZzLFxuICBjYWNoZSxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgb2lkcyxcbn0pIHtcbiAgY29uc3QgaGFzaCA9IG5ldyBIYXNoKCk7XG4gIGNvbnN0IG91dHB1dFN0cmVhbSA9IFtdO1xuICBmdW5jdGlvbiB3cml0ZShjaHVuaywgZW5jKSB7XG4gICAgY29uc3QgYnVmZiA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmMpO1xuICAgIG91dHB1dFN0cmVhbS5wdXNoKGJ1ZmYpO1xuICAgIGhhc2gudXBkYXRlKGJ1ZmYpO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHdyaXRlT2JqZWN0KHsgc3R5cGUsIG9iamVjdCB9KSB7XG4gICAgLy8gT2JqZWN0IHR5cGUgaXMgZW5jb2RlZCBpbiBiaXRzIDY1NFxuICAgIGNvbnN0IHR5cGUgPSB0eXBlc1tzdHlwZV07XG4gICAgLy8gVGhlIGxlbmd0aCBlbmNvZGluZyBnZXRzIGNvbXBsaWNhdGVkLlxuICAgIGxldCBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuICAgIC8vIFdoZXRoZXIgdGhlIG5leHQgYnl0ZSBpcyBwYXJ0IG9mIHRoZSB2YXJpYWJsZS1sZW5ndGggZW5jb2RlZCBudW1iZXJcbiAgICAvLyBpcyBlbmNvZGVkIGluIGJpdCA3XG4gICAgbGV0IG11bHRpYnl0ZSA9IGxlbmd0aCA+IDBiMTExMSA/IDBiMTAwMDAwMDAgOiAwYjA7XG4gICAgLy8gTGFzdCBmb3VyIGJpdHMgb2YgbGVuZ3RoIGlzIGVuY29kZWQgaW4gYml0cyAzMjEwXG4gICAgY29uc3QgbGFzdEZvdXIgPSBsZW5ndGggJiAwYjExMTE7XG4gICAgLy8gRGlzY2FyZCB0aG9zZSBiaXRzXG4gICAgbGVuZ3RoID0gbGVuZ3RoID4+PiA0O1xuICAgIC8vIFRoZSBmaXJzdCBieXRlIGlzIHRoZW4gKDEtYml0IG11bHRpYnl0ZT8pLCAoMy1iaXQgdHlwZSksICg0LWJpdCBsZWFzdCBzaWcgNC1iaXRzIG9mIGxlbmd0aClcbiAgICBsZXQgYnl0ZSA9IChtdWx0aWJ5dGUgfCB0eXBlIHwgbGFzdEZvdXIpLnRvU3RyaW5nKDE2KTtcbiAgICB3cml0ZShieXRlLCAnaGV4Jyk7XG4gICAgLy8gTm93IHdlIGtlZXAgY2hvcHBpbmcgYXdheSBhdCBsZW5ndGggNy1iaXRzIGF0IGEgdGltZSB1bnRpbCBpdHMgemVybyxcbiAgICAvLyB3cml0aW5nIG91dCB0aGUgYnl0ZXMgaW4gd2hhdCBhbW91bnRzIHRvIGxpdHRsZS1lbmRpYW4gb3JkZXIuXG4gICAgd2hpbGUgKG11bHRpYnl0ZSkge1xuICAgICAgbXVsdGlieXRlID0gbGVuZ3RoID4gMGIwMTExMTExMSA/IDBiMTAwMDAwMDAgOiAwYjA7XG4gICAgICBieXRlID0gbXVsdGlieXRlIHwgKGxlbmd0aCAmIDBiMDExMTExMTEpO1xuICAgICAgd3JpdGUocGFkSGV4KDIsIGJ5dGUpLCAnaGV4Jyk7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDc7XG4gICAgfVxuICAgIC8vIExhc3RseSwgd2UgY2FuIGNvbXByZXNzIGFuZCB3cml0ZSB0aGUgb2JqZWN0LlxuICAgIHdyaXRlKEJ1ZmZlci5mcm9tKGF3YWl0IGRlZmxhdGUob2JqZWN0KSkpO1xuICB9XG4gIHdyaXRlKCdQQUNLJyk7XG4gIHdyaXRlKCcwMDAwMDAwMicsICdoZXgnKTtcbiAgLy8gV3JpdGUgYSA0IGJ5dGUgKDMyLWJpdCkgaW50XG4gIHdyaXRlKHBhZEhleCg4LCBvaWRzLmxlbmd0aCksICdoZXgnKTtcbiAgZm9yIChjb25zdCBvaWQgb2Ygb2lkcykge1xuICAgIGNvbnN0IHsgdHlwZSwgb2JqZWN0IH0gPSBhd2FpdCBfcmVhZE9iamVjdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG4gICAgYXdhaXQgd3JpdGVPYmplY3QoeyB3cml0ZSwgb2JqZWN0LCBzdHlwZTogdHlwZSB9KTtcbiAgfVxuICAvLyBXcml0ZSBTSEExIGNoZWNrc3VtXG4gIGNvbnN0IGRpZ2VzdCA9IGhhc2guZGlnZXN0KCk7XG4gIG91dHB1dFN0cmVhbS5wdXNoKGRpZ2VzdCk7XG4gIHJldHVybiBvdXRwdXRTdHJlYW1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhY2tPYmplY3RzUmVzdWx0IFRoZSBwYWNrT2JqZWN0cyBjb21tYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdHdvIHByb3BlcnRpZXM6XG4gKiBAcHJvcGVydHkge3N0cmluZ30gZmlsZW5hbWUgLSBUaGUgc3VnZ2VzdGVkIGZpbGVuYW1lIGZvciB0aGUgcGFja2ZpbGUgaWYgeW91IHdhbnQgdG8gc2F2ZSBpdCB0byBkaXNrIHNvbWV3aGVyZS4gSXQgaW5jbHVkZXMgdGhlIHBhY2tmaWxlIFNIQS5cbiAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW3BhY2tmaWxlXSAtIFRoZSBwYWNrZmlsZSBjb250ZW50cy4gTm90IHByZXNlbnQgaWYgYHdyaXRlYCBwYXJhbWV0ZXIgd2FzIHRydWUsIGluIHdoaWNoIGNhc2UgdGhlIHBhY2tmaWxlIHdhcyB3cml0dGVuIHN0cmFpZ2h0IHRvIGRpc2suXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHthbnl9IGFyZ3MuY2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmdbXX0gYXJncy5vaWRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFyZ3Mud3JpdGVcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxQYWNrT2JqZWN0c1Jlc3VsdD59XG4gKiBAc2VlIFBhY2tPYmplY3RzUmVzdWx0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9wYWNrT2JqZWN0cyh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWRzLCB3cml0ZSB9KSB7XG4gIGNvbnN0IGJ1ZmZlcnMgPSBhd2FpdCBfcGFjayh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWRzIH0pO1xuICBjb25zdCBwYWNrZmlsZSA9IEJ1ZmZlci5mcm9tKGF3YWl0IGNvbGxlY3QoYnVmZmVycykpO1xuICBjb25zdCBwYWNrZmlsZVNoYSA9IHBhY2tmaWxlLnNsaWNlKC0yMCkudG9TdHJpbmcoJ2hleCcpO1xuICBjb25zdCBmaWxlbmFtZSA9IGBwYWNrLSR7cGFja2ZpbGVTaGF9LnBhY2tgO1xuICBpZiAod3JpdGUpIHtcbiAgICBhd2FpdCBmcy53cml0ZShqb2luKGdpdGRpciwgYG9iamVjdHMvcGFjay8ke2ZpbGVuYW1lfWApLCBwYWNrZmlsZSk7XG4gICAgcmV0dXJuIHsgZmlsZW5hbWUgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZmlsZW5hbWUsXG4gICAgcGFja2ZpbGU6IG5ldyBVaW50OEFycmF5KHBhY2tmaWxlKSxcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gUGFja09iamVjdHNSZXN1bHQgVGhlIHBhY2tPYmplY3RzIGNvbW1hbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0d28gcHJvcGVydGllczpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaWxlbmFtZSAtIFRoZSBzdWdnZXN0ZWQgZmlsZW5hbWUgZm9yIHRoZSBwYWNrZmlsZSBpZiB5b3Ugd2FudCB0byBzYXZlIGl0IHRvIGRpc2sgc29tZXdoZXJlLiBJdCBpbmNsdWRlcyB0aGUgcGFja2ZpbGUgU0hBLlxuICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBbcGFja2ZpbGVdIC0gVGhlIHBhY2tmaWxlIGNvbnRlbnRzLiBOb3QgcHJlc2VudCBpZiBgd3JpdGVgIHBhcmFtZXRlciB3YXMgdHJ1ZSwgaW4gd2hpY2ggY2FzZSB0aGUgcGFja2ZpbGUgd2FzIHdyaXR0ZW4gc3RyYWlnaHQgdG8gZGlzay5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIHBhY2tmaWxlIGZyb20gYW4gYXJyYXkgb2YgU0hBLTEgb2JqZWN0IGlkc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCAnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhcmdzLm9pZHMgLSBBbiBhcnJheSBvZiBTSEEtMSBvYmplY3QgaWRzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBwYWNrZmlsZVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy53cml0ZSA9IGZhbHNlXSAtIFdoZXRoZXIgdG8gc2F2ZSB0aGUgcGFja2ZpbGUgdG8gZGlzayBvciBub3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFBhY2tPYmplY3RzUmVzdWx0Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gdGhlIHBhY2tmaWxlIGlzIHJlYWR5IHdpdGggdGhlIGZpbGVuYW1lIGFuZCBidWZmZXJcbiAqIEBzZWUgUGFja09iamVjdHNSZXN1bHRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ3JlYXRlIGEgcGFja2ZpbGUgY29udGFpbmluZyBvbmx5IGFuIGVtcHR5IHRyZWVcbiAqIGxldCB7IHBhY2tmaWxlIH0gPSBhd2FpdCBnaXQucGFja09iamVjdHMoe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgb2lkczogWyc0YjgyNWRjNjQyY2I2ZWI5YTA2MGU1NGJmOGQ2OTI4OGZiZWU0OTA0J11cbiAqIH0pXG4gKiBjb25zb2xlLmxvZyhwYWNrZmlsZSlcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBhY2tPYmplY3RzKHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIG9pZHMsXG4gIHdyaXRlID0gZmFsc2UsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdvaWRzJywgb2lkcyk7XG5cbiAgICByZXR1cm4gYXdhaXQgX3BhY2tPYmplY3RzKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIG9pZHMsXG4gICAgICB3cml0ZSxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5wYWNrT2JqZWN0cyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogRmV0Y2ggYW5kIG1lcmdlIGNvbW1pdHMgZnJvbSBhIHJlbW90ZSByZXBvc2l0b3J5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtIdHRwQ2xpZW50fSBhcmdzLmh0dHAgLSBhbiBIVFRQIGNsaWVudFxuICogQHBhcmFtIHtQcm9ncmVzc0NhbGxiYWNrfSBbYXJncy5vblByb2dyZXNzXSAtIG9wdGlvbmFsIHByb2dyZXNzIGV2ZW50IGNhbGxiYWNrXG4gKiBAcGFyYW0ge01lc3NhZ2VDYWxsYmFja30gW2FyZ3Mub25NZXNzYWdlXSAtIG9wdGlvbmFsIG1lc3NhZ2UgZXZlbnQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXV0aENhbGxiYWNrfSBbYXJncy5vbkF1dGhdIC0gb3B0aW9uYWwgYXV0aCBmaWxsIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhGYWlsdXJlQ2FsbGJhY2t9IFthcmdzLm9uQXV0aEZhaWx1cmVdIC0gb3B0aW9uYWwgYXV0aCByZWplY3RlZCBjYWxsYmFja1xuICogQHBhcmFtIHtBdXRoU3VjY2Vzc0NhbGxiYWNrfSBbYXJncy5vbkF1dGhTdWNjZXNzXSAtIG9wdGlvbmFsIGF1dGggYXBwcm92ZWQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZl0gLSBXaGljaCBicmFuY2ggdG8gbWVyZ2UgaW50by4gQnkgZGVmYXVsdCB0aGlzIGlzIHRoZSBjdXJyZW50bHkgY2hlY2tlZCBvdXQgYnJhbmNoLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnVybF0gLSAoQWRkZWQgaW4gMS4xLjApIFRoZSBVUkwgb2YgdGhlIHJlbW90ZSByZXBvc2l0b3J5LiBUaGUgZGVmYXVsdCBpcyB0aGUgdmFsdWUgc2V0IGluIHRoZSBnaXQgY29uZmlnIGZvciB0aGF0IHJlbW90ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZW1vdGVdIC0gKEFkZGVkIGluIDEuMS4wKSBJZiBVUkwgaXMgbm90IHNwZWNpZmllZCwgZGV0ZXJtaW5lcyB3aGljaCByZW1vdGUgdG8gdXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlbW90ZVJlZl0gLSAoQWRkZWQgaW4gMS4xLjApIFRoZSBuYW1lIG9mIHRoZSBicmFuY2ggb24gdGhlIHJlbW90ZSB0byBmZXRjaC4gQnkgZGVmYXVsdCB0aGlzIGlzIHRoZSBjb25maWd1cmVkIHJlbW90ZSB0cmFja2luZyBicmFuY2guXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuY29yc1Byb3h5XSAtIE9wdGlvbmFsIFtDT1JTIHByb3h5XShodHRwczovL3d3dy5ucG1qcy5jb20vJTQwaXNvbW9ycGhpYy1naXQvY29ycy1wcm94eSkuIE92ZXJyaWRlcyB2YWx1ZSBpbiByZXBvIGNvbmZpZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3Muc2luZ2xlQnJhbmNoID0gZmFsc2VdIC0gSW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBmZXRjaGluZyBhbGwgdGhlIGJyYW5jaGVzLCBvbmx5IGZldGNoIGEgc2luZ2xlIGJyYW5jaC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZmFzdEZvcndhcmRPbmx5ID0gZmFsc2VdIC0gT25seSBwZXJmb3JtIHNpbXBsZSBmYXN0LWZvcndhcmQgbWVyZ2VzLiAoRG9uJ3QgY3JlYXRlIG1lcmdlIGNvbW1pdHMuKVxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSBbYXJncy5oZWFkZXJzXSAtIEFkZGl0aW9uYWwgaGVhZGVycyB0byBpbmNsdWRlIGluIEhUVFAgcmVxdWVzdHMsIHNpbWlsYXIgdG8gZ2l0J3MgYGV4dHJhSGVhZGVyYCBjb25maWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJncy5hdXRob3JdIC0gVGhlIGRldGFpbHMgYWJvdXQgdGhlIGF1dGhvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5hdXRob3IubmFtZV0gLSBEZWZhdWx0IGlzIGB1c2VyLm5hbWVgIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5hdXRob3IuZW1haWxdIC0gRGVmYXVsdCBpcyBgdXNlci5lbWFpbGAgY29uZmlnLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmF1dGhvci50aW1lc3RhbXA9TWF0aC5mbG9vcihEYXRlLm5vdygpLzEwMDApXSAtIFNldCB0aGUgYXV0aG9yIHRpbWVzdGFtcCBmaWVsZC4gVGhpcyBpcyB0aGUgaW50ZWdlciBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgVW5peCBlcG9jaCAoMTk3MC0wMS0wMSAwMDowMDowMCkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuYXV0aG9yLnRpbWV6b25lT2Zmc2V0XSAtIFNldCB0aGUgYXV0aG9yIHRpbWV6b25lIG9mZnNldCBmaWVsZC4gVGhpcyBpcyB0aGUgZGlmZmVyZW5jZSwgaW4gbWludXRlcywgZnJvbSB0aGUgY3VycmVudCB0aW1lem9uZSB0byBVVEMuIERlZmF1bHQgaXMgYChuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJncy5jb21taXR0ZXIgPSBhdXRob3JdIC0gVGhlIGRldGFpbHMgYWJvdXQgdGhlIGNvbW1pdCBjb21taXR0ZXIsIGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgYXV0aG9yIHBhcmFtZXRlci4gSWYgbm90IHNwZWNpZmllZCwgdGhlIGF1dGhvciBkZXRhaWxzIGFyZSB1c2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvbW1pdHRlci5uYW1lXSAtIERlZmF1bHQgaXMgYHVzZXIubmFtZWAgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvbW1pdHRlci5lbWFpbF0gLSBEZWZhdWx0IGlzIGB1c2VyLmVtYWlsYCBjb25maWcuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuY29tbWl0dGVyLnRpbWVzdGFtcD1NYXRoLmZsb29yKERhdGUubm93KCkvMTAwMCldIC0gU2V0IHRoZSBjb21taXR0ZXIgdGltZXN0YW1wIGZpZWxkLiBUaGlzIGlzIHRoZSBpbnRlZ2VyIG51bWJlciBvZiBzZWNvbmRzIHNpbmNlIHRoZSBVbml4IGVwb2NoICgxOTcwLTAxLTAxIDAwOjAwOjAwKS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5jb21taXR0ZXIudGltZXpvbmVPZmZzZXRdIC0gU2V0IHRoZSBjb21taXR0ZXIgdGltZXpvbmUgb2Zmc2V0IGZpZWxkLiBUaGlzIGlzIHRoZSBkaWZmZXJlbmNlLCBpbiBtaW51dGVzLCBmcm9tIHRoZSBjdXJyZW50IHRpbWV6b25lIHRvIFVUQy4gRGVmYXVsdCBpcyBgKG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KClgLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnNpZ25pbmdLZXldIC0gcGFzc2VkIHRvIFtjb21taXRdKGNvbW1pdC5tZCkgd2hlbiBjcmVhdGluZyBhIG1lcmdlIGNvbW1pdFxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIHB1bGwgb3BlcmF0aW9uIGNvbXBsZXRlc1xuICpcbiAqIEBleGFtcGxlXG4gKiBhd2FpdCBnaXQucHVsbCh7XG4gKiAgIGZzLFxuICogICBodHRwLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICByZWY6ICdtYWluJyxcbiAqICAgc2luZ2xlQnJhbmNoOiB0cnVlXG4gKiB9KVxuICogY29uc29sZS5sb2coJ2RvbmUnKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHVsbCh7XG4gIGZzOiBfZnMsXG4gIGh0dHAsXG4gIG9uUHJvZ3Jlc3MsXG4gIG9uTWVzc2FnZSxcbiAgb25BdXRoLFxuICBvbkF1dGhTdWNjZXNzLFxuICBvbkF1dGhGYWlsdXJlLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICByZWYsXG4gIHVybCxcbiAgcmVtb3RlLFxuICByZW1vdGVSZWYsXG4gIGZhc3RGb3J3YXJkT25seSA9IGZhbHNlLFxuICBjb3JzUHJveHksXG4gIHNpbmdsZUJyYW5jaCxcbiAgaGVhZGVycyA9IHt9LFxuICBhdXRob3I6IF9hdXRob3IsXG4gIGNvbW1pdHRlcjogX2NvbW1pdHRlcixcbiAgc2lnbmluZ0tleSxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgX2ZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG5cbiAgICBjb25zdCBmcyA9IG5ldyBGaWxlU3lzdGVtKF9mcyk7XG5cbiAgICBjb25zdCBhdXRob3IgPSBhd2FpdCBub3JtYWxpemVBdXRob3JPYmplY3QoeyBmcywgZ2l0ZGlyLCBhdXRob3I6IF9hdXRob3IgfSk7XG4gICAgaWYgKCFhdXRob3IpIHRocm93IG5ldyBNaXNzaW5nTmFtZUVycm9yKCdhdXRob3InKVxuXG4gICAgY29uc3QgY29tbWl0dGVyID0gYXdhaXQgbm9ybWFsaXplQ29tbWl0dGVyT2JqZWN0KHtcbiAgICAgIGZzLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgYXV0aG9yLFxuICAgICAgY29tbWl0dGVyOiBfY29tbWl0dGVyLFxuICAgIH0pO1xuICAgIGlmICghY29tbWl0dGVyKSB0aHJvdyBuZXcgTWlzc2luZ05hbWVFcnJvcignY29tbWl0dGVyJylcblxuICAgIHJldHVybiBhd2FpdCBfcHVsbCh7XG4gICAgICBmcyxcbiAgICAgIGNhY2hlLFxuICAgICAgaHR0cCxcbiAgICAgIG9uUHJvZ3Jlc3MsXG4gICAgICBvbk1lc3NhZ2UsXG4gICAgICBvbkF1dGgsXG4gICAgICBvbkF1dGhTdWNjZXNzLFxuICAgICAgb25BdXRoRmFpbHVyZSxcbiAgICAgIGRpcixcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZixcbiAgICAgIHVybCxcbiAgICAgIHJlbW90ZSxcbiAgICAgIHJlbW90ZVJlZixcbiAgICAgIGZhc3RGb3J3YXJkT25seSxcbiAgICAgIGNvcnNQcm94eSxcbiAgICAgIHNpbmdsZUJyYW5jaCxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBhdXRob3IsXG4gICAgICBjb21taXR0ZXIsXG4gICAgICBzaWduaW5nS2V5LFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LnB1bGwnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPHN0cmluZz59IGFyZ3Muc3RhcnRcbiAqIEBwYXJhbSB7SXRlcmFibGU8c3RyaW5nPn0gYXJncy5maW5pc2hcbiAqIEByZXR1cm5zIHtQcm9taXNlPFNldDxzdHJpbmc+Pn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbGlzdENvbW1pdHNBbmRUYWdzKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICBzdGFydCxcbiAgZmluaXNoLFxufSkge1xuICBjb25zdCBzaGFsbG93cyA9IGF3YWl0IEdpdFNoYWxsb3dNYW5hZ2VyLnJlYWQoeyBmcywgZ2l0ZGlyIH0pO1xuICBjb25zdCBzdGFydGluZ1NldCA9IG5ldyBTZXQoKTtcbiAgY29uc3QgZmluaXNoaW5nU2V0ID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHJlZiBvZiBzdGFydCkge1xuICAgIHN0YXJ0aW5nU2V0LmFkZChhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoeyBmcywgZ2l0ZGlyLCByZWYgfSkpO1xuICB9XG4gIGZvciAoY29uc3QgcmVmIG9mIGZpbmlzaCkge1xuICAgIC8vIFdlIG1heSBub3QgaGF2ZSB0aGVzZSByZWZzIGxvY2FsbHkgc28gd2UgbXVzdCB0cnkvY2F0Y2hcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb2lkID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHsgZnMsIGdpdGRpciwgcmVmIH0pO1xuICAgICAgZmluaXNoaW5nU2V0LmFkZChvaWQpO1xuICAgIH0gY2F0Y2ggKGVycikge31cbiAgfVxuICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAvLyBCZWNhdXNlIGdpdCBjb21taXRzIGFyZSBuYW1lZCBieSB0aGVpciBoYXNoLCB0aGVyZSBpcyBub1xuICAvLyB3YXkgdG8gY29uc3RydWN0IGEgY3ljbGUuIFRoZXJlZm9yZSB3ZSB3b24ndCB3b3JyeSBhYm91dFxuICAvLyBzZXR0aW5nIGEgZGVmYXVsdCByZWN1cnNpb24gbGltaXQuXG4gIGFzeW5jIGZ1bmN0aW9uIHdhbGsob2lkKSB7XG4gICAgdmlzaXRlZC5hZGQob2lkKTtcbiAgICBjb25zdCB7IHR5cGUsIG9iamVjdCB9ID0gYXdhaXQgX3JlYWRPYmplY3QoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pO1xuICAgIC8vIFJlY3Vyc2l2ZWx5IHJlc29sdmUgYW5ub3RhdGVkIHRhZ3NcbiAgICBpZiAodHlwZSA9PT0gJ3RhZycpIHtcbiAgICAgIGNvbnN0IHRhZyA9IEdpdEFubm90YXRlZFRhZy5mcm9tKG9iamVjdCk7XG4gICAgICBjb25zdCBjb21taXQgPSB0YWcuaGVhZGVycygpLm9iamVjdDtcbiAgICAgIHJldHVybiB3YWxrKGNvbW1pdClcbiAgICB9XG4gICAgaWYgKHR5cGUgIT09ICdjb21taXQnKSB7XG4gICAgICB0aHJvdyBuZXcgT2JqZWN0VHlwZUVycm9yKG9pZCwgdHlwZSwgJ2NvbW1pdCcpXG4gICAgfVxuICAgIGlmICghc2hhbGxvd3MuaGFzKG9pZCkpIHtcbiAgICAgIGNvbnN0IGNvbW1pdCA9IEdpdENvbW1pdC5mcm9tKG9iamVjdCk7XG4gICAgICBjb25zdCBwYXJlbnRzID0gY29tbWl0LmhlYWRlcnMoKS5wYXJlbnQ7XG4gICAgICBmb3IgKG9pZCBvZiBwYXJlbnRzKSB7XG4gICAgICAgIGlmICghZmluaXNoaW5nU2V0LmhhcyhvaWQpICYmICF2aXNpdGVkLmhhcyhvaWQpKSB7XG4gICAgICAgICAgYXdhaXQgd2FsayhvaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIExldCdzIGdvIHdhbGtpbmchXG4gIGZvciAoY29uc3Qgb2lkIG9mIHN0YXJ0aW5nU2V0KSB7XG4gICAgYXdhaXQgd2FsayhvaWQpO1xuICB9XG4gIHJldHVybiB2aXNpdGVkXG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPHN0cmluZz59IGFyZ3Mub2lkc1xuICogQHJldHVybnMge1Byb21pc2U8U2V0PHN0cmluZz4+fVxuICovXG5hc3luYyBmdW5jdGlvbiBsaXN0T2JqZWN0cyh7XG4gIGZzLFxuICBjYWNoZSxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgb2lkcyxcbn0pIHtcbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgLy8gV2UgZG9uJ3QgZG8gdGhlIHB1cmVzdCBzaW1wbGVzdCByZWN1cnNpb24sIGJlY2F1c2Ugd2UgY2FuXG4gIC8vIGF2b2lkIHJlYWRpbmcgQmxvYiBvYmplY3RzIGVudGlyZWx5IHNpbmNlIHRoZSBUcmVlIG9iamVjdHNcbiAgLy8gdGVsbCB1cyB3aGljaCBvaWRzIGFyZSBCbG9icyBhbmQgd2hpY2ggYXJlIFRyZWVzLlxuICBhc3luYyBmdW5jdGlvbiB3YWxrKG9pZCkge1xuICAgIGlmICh2aXNpdGVkLmhhcyhvaWQpKSByZXR1cm5cbiAgICB2aXNpdGVkLmFkZChvaWQpO1xuICAgIGNvbnN0IHsgdHlwZSwgb2JqZWN0IH0gPSBhd2FpdCBfcmVhZE9iamVjdCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSk7XG4gICAgaWYgKHR5cGUgPT09ICd0YWcnKSB7XG4gICAgICBjb25zdCB0YWcgPSBHaXRBbm5vdGF0ZWRUYWcuZnJvbShvYmplY3QpO1xuICAgICAgY29uc3Qgb2JqID0gdGFnLmhlYWRlcnMoKS5vYmplY3Q7XG4gICAgICBhd2FpdCB3YWxrKG9iaik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY29tbWl0Jykge1xuICAgICAgY29uc3QgY29tbWl0ID0gR2l0Q29tbWl0LmZyb20ob2JqZWN0KTtcbiAgICAgIGNvbnN0IHRyZWUgPSBjb21taXQuaGVhZGVycygpLnRyZWU7XG4gICAgICBhd2FpdCB3YWxrKHRyZWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RyZWUnKSB7XG4gICAgICBjb25zdCB0cmVlID0gR2l0VHJlZS5mcm9tKG9iamVjdCk7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRyZWUpIHtcbiAgICAgICAgLy8gYWRkIGJsb2JzIHRvIHRoZSBzZXRcbiAgICAgICAgLy8gc2tpcCBvdmVyIHN1Ym1vZHVsZXMgd2hvc2UgdHlwZSBpcyAnY29tbWl0J1xuICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICAgICAgdmlzaXRlZC5hZGQoZW50cnkub2lkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWN1cnNlIGZvciB0cmVlc1xuICAgICAgICBpZiAoZW50cnkudHlwZSA9PT0gJ3RyZWUnKSB7XG4gICAgICAgICAgYXdhaXQgd2FsayhlbnRyeS5vaWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIExldCdzIGdvIHdhbGtpbmchXG4gIGZvciAoY29uc3Qgb2lkIG9mIG9pZHMpIHtcbiAgICBhd2FpdCB3YWxrKG9pZCk7XG4gIH1cbiAgcmV0dXJuIHZpc2l0ZWRcbn1cblxuYXN5bmMgZnVuY3Rpb24gcGFyc2VSZWNlaXZlUGFja1Jlc3BvbnNlKHBhY2tmaWxlKSB7XG4gIC8qKiBAdHlwZSBQdXNoUmVzdWx0ICovXG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBsZXQgcmVzcG9uc2UgPSAnJztcbiAgY29uc3QgcmVhZCA9IEdpdFBrdExpbmUuc3RyZWFtUmVhZGVyKHBhY2tmaWxlKTtcbiAgbGV0IGxpbmUgPSBhd2FpdCByZWFkKCk7XG4gIHdoaWxlIChsaW5lICE9PSB0cnVlKSB7XG4gICAgaWYgKGxpbmUgIT09IG51bGwpIHJlc3BvbnNlICs9IGxpbmUudG9TdHJpbmcoJ3V0ZjgnKSArICdcXG4nO1xuICAgIGxpbmUgPSBhd2FpdCByZWFkKCk7XG4gIH1cblxuICBjb25zdCBsaW5lcyA9IHJlc3BvbnNlLnRvU3RyaW5nKCd1dGY4Jykuc3BsaXQoJ1xcbicpO1xuICAvLyBXZSdyZSBleHBlY3RpbmcgXCJ1bnBhY2sge3VucGFjay1yZXN1bHR9XCJcbiAgbGluZSA9IGxpbmVzLnNoaWZ0KCk7XG4gIGlmICghbGluZS5zdGFydHNXaXRoKCd1bnBhY2sgJykpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigndW5wYWNrIG9rXCIgb3IgXCJ1bnBhY2sgW2Vycm9yIG1lc3NhZ2VdJywgbGluZSlcbiAgfVxuICByZXN1bHQub2sgPSBsaW5lID09PSAndW5wYWNrIG9rJztcbiAgaWYgKCFyZXN1bHQub2spIHtcbiAgICByZXN1bHQuZXJyb3IgPSBsaW5lLnNsaWNlKCd1bnBhY2sgJy5sZW5ndGgpO1xuICB9XG4gIHJlc3VsdC5yZWZzID0ge307XG4gIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgIGlmIChsaW5lLnRyaW0oKSA9PT0gJycpIGNvbnRpbnVlXG4gICAgY29uc3Qgc3RhdHVzID0gbGluZS5zbGljZSgwLCAyKTtcbiAgICBjb25zdCByZWZBbmRNZXNzYWdlID0gbGluZS5zbGljZSgzKTtcbiAgICBsZXQgc3BhY2UgPSByZWZBbmRNZXNzYWdlLmluZGV4T2YoJyAnKTtcbiAgICBpZiAoc3BhY2UgPT09IC0xKSBzcGFjZSA9IHJlZkFuZE1lc3NhZ2UubGVuZ3RoO1xuICAgIGNvbnN0IHJlZiA9IHJlZkFuZE1lc3NhZ2Uuc2xpY2UoMCwgc3BhY2UpO1xuICAgIGNvbnN0IGVycm9yID0gcmVmQW5kTWVzc2FnZS5zbGljZShzcGFjZSArIDEpO1xuICAgIHJlc3VsdC5yZWZzW3JlZl0gPSB7XG4gICAgICBvazogc3RhdHVzID09PSAnb2snLFxuICAgICAgZXJyb3IsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlUmVjZWl2ZVBhY2tSZXF1ZXN0KHtcbiAgY2FwYWJpbGl0aWVzID0gW10sXG4gIHRyaXBsZXRzID0gW10sXG59KSB7XG4gIGNvbnN0IHBhY2tzdHJlYW0gPSBbXTtcbiAgbGV0IGNhcHNGaXJzdExpbmUgPSBgXFx4MDAgJHtjYXBhYmlsaXRpZXMuam9pbignICcpfWA7XG4gIGZvciAoY29uc3QgdHJpcCBvZiB0cmlwbGV0cykge1xuICAgIHBhY2tzdHJlYW0ucHVzaChcbiAgICAgIEdpdFBrdExpbmUuZW5jb2RlKFxuICAgICAgICBgJHt0cmlwLm9sZG9pZH0gJHt0cmlwLm9pZH0gJHt0cmlwLmZ1bGxSZWZ9JHtjYXBzRmlyc3RMaW5lfVxcbmBcbiAgICAgIClcbiAgICApO1xuICAgIGNhcHNGaXJzdExpbmUgPSAnJztcbiAgfVxuICBwYWNrc3RyZWFtLnB1c2goR2l0UGt0TGluZS5mbHVzaCgpKTtcbiAgcmV0dXJuIHBhY2tzdHJlYW1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge0h0dHBDbGllbnR9IGFyZ3MuaHR0cFxuICogQHBhcmFtIHtQcm9ncmVzc0NhbGxiYWNrfSBbYXJncy5vblByb2dyZXNzXVxuICogQHBhcmFtIHtNZXNzYWdlQ2FsbGJhY2t9IFthcmdzLm9uTWVzc2FnZV1cbiAqIEBwYXJhbSB7QXV0aENhbGxiYWNrfSBbYXJncy5vbkF1dGhdXG4gKiBAcGFyYW0ge0F1dGhGYWlsdXJlQ2FsbGJhY2t9IFthcmdzLm9uQXV0aEZhaWx1cmVdXG4gKiBAcGFyYW0ge0F1dGhTdWNjZXNzQ2FsbGJhY2t9IFthcmdzLm9uQXV0aFN1Y2Nlc3NdXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZWZdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVtb3RlUmVmXVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlbW90ZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZm9yY2UgPSBmYWxzZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuZGVsZXRlID0gZmFsc2VdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MudXJsXVxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvcnNQcm94eV1cbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgc3RyaW5nPn0gW2FyZ3MuaGVhZGVyc11cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxQdXNoUmVzdWx0Pn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3B1c2goe1xuICBmcyxcbiAgY2FjaGUsXG4gIGh0dHAsXG4gIG9uUHJvZ3Jlc3MsXG4gIG9uTWVzc2FnZSxcbiAgb25BdXRoLFxuICBvbkF1dGhTdWNjZXNzLFxuICBvbkF1dGhGYWlsdXJlLFxuICBnaXRkaXIsXG4gIHJlZjogX3JlZixcbiAgcmVtb3RlUmVmOiBfcmVtb3RlUmVmLFxuICByZW1vdGUsXG4gIHVybDogX3VybCxcbiAgZm9yY2UgPSBmYWxzZSxcbiAgZGVsZXRlOiBfZGVsZXRlID0gZmFsc2UsXG4gIGNvcnNQcm94eSxcbiAgaGVhZGVycyA9IHt9LFxufSkge1xuICBjb25zdCByZWYgPSBfcmVmIHx8IChhd2FpdCBfY3VycmVudEJyYW5jaCh7IGZzLCBnaXRkaXIgfSkpO1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgTWlzc2luZ1BhcmFtZXRlckVycm9yKCdyZWYnKVxuICB9XG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuZ2V0KHsgZnMsIGdpdGRpciB9KTtcbiAgLy8gRmlndXJlIG91dCB3aGF0IHJlbW90ZSB0byB1c2UuXG4gIHJlbW90ZSA9XG4gICAgcmVtb3RlIHx8XG4gICAgKGF3YWl0IGNvbmZpZy5nZXQoYGJyYW5jaC4ke3JlZn0ucHVzaFJlbW90ZWApKSB8fFxuICAgIChhd2FpdCBjb25maWcuZ2V0KCdyZW1vdGUucHVzaERlZmF1bHQnKSkgfHxcbiAgICAoYXdhaXQgY29uZmlnLmdldChgYnJhbmNoLiR7cmVmfS5yZW1vdGVgKSkgfHxcbiAgICAnb3JpZ2luJztcbiAgLy8gTG9va3VwIHRoZSBVUkwgZm9yIHRoZSBnaXZlbiByZW1vdGUuXG4gIGNvbnN0IHVybCA9XG4gICAgX3VybCB8fFxuICAgIChhd2FpdCBjb25maWcuZ2V0KGByZW1vdGUuJHtyZW1vdGV9LnB1c2h1cmxgKSkgfHxcbiAgICAoYXdhaXQgY29uZmlnLmdldChgcmVtb3RlLiR7cmVtb3RlfS51cmxgKSk7XG4gIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBNaXNzaW5nUGFyYW1ldGVyRXJyb3IoJ3JlbW90ZSBPUiB1cmwnKVxuICB9XG4gIC8vIEZpZ3VyZSBvdXQgd2hhdCByZW1vdGUgcmVmIHRvIHVzZS5cbiAgY29uc3QgcmVtb3RlUmVmID0gX3JlbW90ZVJlZiB8fCAoYXdhaXQgY29uZmlnLmdldChgYnJhbmNoLiR7cmVmfS5tZXJnZWApKTtcbiAgaWYgKHR5cGVvZiB1cmwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IE1pc3NpbmdQYXJhbWV0ZXJFcnJvcigncmVtb3RlUmVmJylcbiAgfVxuXG4gIGlmIChjb3JzUHJveHkgPT09IHVuZGVmaW5lZCkge1xuICAgIGNvcnNQcm94eSA9IGF3YWl0IGNvbmZpZy5nZXQoJ2h0dHAuY29yc1Byb3h5Jyk7XG4gIH1cblxuICBjb25zdCBmdWxsUmVmID0gYXdhaXQgR2l0UmVmTWFuYWdlci5leHBhbmQoeyBmcywgZ2l0ZGlyLCByZWYgfSk7XG4gIGNvbnN0IG9pZCA9IF9kZWxldGVcbiAgICA/ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICAgIDogYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHsgZnMsIGdpdGRpciwgcmVmOiBmdWxsUmVmIH0pO1xuXG4gIC8qKiBAdHlwZSB0eXBlb2YgaW1wb3J0KFwiLi4vbWFuYWdlcnMvR2l0UmVtb3RlSFRUUFwiKS5HaXRSZW1vdGVIVFRQICovXG4gIGNvbnN0IEdpdFJlbW90ZUhUVFAgPSBHaXRSZW1vdGVNYW5hZ2VyLmdldFJlbW90ZUhlbHBlckZvcih7IHVybCB9KTtcbiAgY29uc3QgaHR0cFJlbW90ZSA9IGF3YWl0IEdpdFJlbW90ZUhUVFAuZGlzY292ZXIoe1xuICAgIGh0dHAsXG4gICAgb25BdXRoLFxuICAgIG9uQXV0aFN1Y2Nlc3MsXG4gICAgb25BdXRoRmFpbHVyZSxcbiAgICBjb3JzUHJveHksXG4gICAgc2VydmljZTogJ2dpdC1yZWNlaXZlLXBhY2snLFxuICAgIHVybCxcbiAgICBoZWFkZXJzLFxuICAgIHByb3RvY29sVmVyc2lvbjogMSxcbiAgfSk7XG4gIGNvbnN0IGF1dGggPSBodHRwUmVtb3RlLmF1dGg7IC8vIGhhY2sgdG8gZ2V0IG5ldyBjcmVkZW50aWFscyBmcm9tIENyZWRlbnRpYWxNYW5hZ2VyIEFQSVxuICBsZXQgZnVsbFJlbW90ZVJlZjtcbiAgaWYgKCFyZW1vdGVSZWYpIHtcbiAgICBmdWxsUmVtb3RlUmVmID0gZnVsbFJlZjtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgZnVsbFJlbW90ZVJlZiA9IGF3YWl0IEdpdFJlZk1hbmFnZXIuZXhwYW5kQWdhaW5zdE1hcCh7XG4gICAgICAgIHJlZjogcmVtb3RlUmVmLFxuICAgICAgICBtYXA6IGh0dHBSZW1vdGUucmVmcyxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIE5vdEZvdW5kRXJyb3IpIHtcbiAgICAgICAgLy8gVGhlIHJlbW90ZSByZWZlcmVuY2UgZG9lc24ndCBleGlzdCB5ZXQuXG4gICAgICAgIC8vIElmIGl0IGlzIGZ1bGx5IHNwZWNpZmllZCwgdXNlIHRoYXQgdmFsdWUuIE90aGVyd2lzZSwgdHJlYXQgaXQgYXMgYSBicmFuY2guXG4gICAgICAgIGZ1bGxSZW1vdGVSZWYgPSByZW1vdGVSZWYuc3RhcnRzV2l0aCgncmVmcy8nKVxuICAgICAgICAgID8gcmVtb3RlUmVmXG4gICAgICAgICAgOiBgcmVmcy9oZWFkcy8ke3JlbW90ZVJlZn1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IG9sZG9pZCA9XG4gICAgaHR0cFJlbW90ZS5yZWZzLmdldChmdWxsUmVtb3RlUmVmKSB8fFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJztcblxuICAvLyBSZW1vdGVzIGNhbiBhbHdheXMgYWNjZXB0IHRoaW4tcGFja3MgVU5MRVNTIHRoZXkgc3BlY2lmeSB0aGUgJ25vLXRoaW4nIGNhcGFiaWxpdHlcbiAgY29uc3QgdGhpblBhY2sgPSAhaHR0cFJlbW90ZS5jYXBhYmlsaXRpZXMuaGFzKCduby10aGluJyk7XG5cbiAgbGV0IG9iamVjdHMgPSBuZXcgU2V0KCk7XG4gIGlmICghX2RlbGV0ZSkge1xuICAgIGNvbnN0IGZpbmlzaCA9IFsuLi5odHRwUmVtb3RlLnJlZnMudmFsdWVzKCldO1xuICAgIGxldCBza2lwT2JqZWN0cyA9IG5ldyBTZXQoKTtcblxuICAgIC8vIElmIHJlbW90ZSBicmFuY2ggaXMgcHJlc2VudCwgbG9vayBmb3IgYSBjb21tb24gbWVyZ2UgYmFzZS5cbiAgICBpZiAob2xkb2lkICE9PSAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpIHtcbiAgICAgIC8vIHRyaWNrIHRvIHNwZWVkIHVwIGNvbW1vbiBmb3JjZSBwdXNoIHNjZW5hcmlvc1xuICAgICAgY29uc3QgbWVyZ2ViYXNlID0gYXdhaXQgX2ZpbmRNZXJnZUJhc2Uoe1xuICAgICAgICBmcyxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGdpdGRpcixcbiAgICAgICAgb2lkczogW29pZCwgb2xkb2lkXSxcbiAgICAgIH0pO1xuICAgICAgZm9yIChjb25zdCBvaWQgb2YgbWVyZ2ViYXNlKSBmaW5pc2gucHVzaChvaWQpO1xuICAgICAgaWYgKHRoaW5QYWNrKSB7XG4gICAgICAgIHNraXBPYmplY3RzID0gYXdhaXQgbGlzdE9iamVjdHMoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkczogbWVyZ2ViYXNlIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHJlbW90ZSBkb2VzIG5vdCBoYXZlIHRoZSBjb21taXQsIGZpZ3VyZSBvdXQgdGhlIG9iamVjdHMgdG8gc2VuZFxuICAgIGlmICghZmluaXNoLmluY2x1ZGVzKG9pZCkpIHtcbiAgICAgIGNvbnN0IGNvbW1pdHMgPSBhd2FpdCBsaXN0Q29tbWl0c0FuZFRhZ3Moe1xuICAgICAgICBmcyxcbiAgICAgICAgY2FjaGUsXG4gICAgICAgIGdpdGRpcixcbiAgICAgICAgc3RhcnQ6IFtvaWRdLFxuICAgICAgICBmaW5pc2gsXG4gICAgICB9KTtcbiAgICAgIG9iamVjdHMgPSBhd2FpdCBsaXN0T2JqZWN0cyh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWRzOiBjb21taXRzIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGluUGFjaykge1xuICAgICAgLy8gSWYgdGhlcmUncyBhIGRlZmF1bHQgYnJhbmNoIGZvciB0aGUgcmVtb3RlIGxldHMgc2tpcCB0aG9zZSBvYmplY3RzIHRvby5cbiAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYW4gb3B0aW9uYWwgb3B0aW1pemF0aW9uLCB3ZSBqdXN0IGNhdGNoIGFuZCBjb250aW51ZSBpZiB0aGVyZSBpc1xuICAgICAgLy8gYW4gZXJyb3IgKGJlY2F1c2Ugd2UgY2FuJ3QgZmluZCBhIGRlZmF1bHQgYnJhbmNoLCBvciBjYW4ndCBmaW5kIGEgY29tbWl0LCBldGMpXG4gICAgICB0cnkge1xuICAgICAgICAvLyBTYWRseSwgdGhlIGRpc2NvdmVyeSBwaGFzZSB3aXRoICdmb3JQdXNoJyBkb2Vzbid0IHJldHVybiBzeW1yZWZzLCBzbyB3ZSBoYXZlIHRvXG4gICAgICAgIC8vIHJlbHkgb24gZXhpc3Rpbmcgb25lcy5cbiAgICAgICAgY29uc3QgcmVmID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHtcbiAgICAgICAgICBmcyxcbiAgICAgICAgICBnaXRkaXIsXG4gICAgICAgICAgcmVmOiBgcmVmcy9yZW1vdGVzLyR7cmVtb3RlfS9IRUFEYCxcbiAgICAgICAgICBkZXB0aDogMixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgb2lkIH0gPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmVBZ2FpbnN0TWFwKHtcbiAgICAgICAgICByZWY6IHJlZi5yZXBsYWNlKGByZWZzL3JlbW90ZXMvJHtyZW1vdGV9L2AsICcnKSxcbiAgICAgICAgICBmdWxscmVmOiByZWYsXG4gICAgICAgICAgbWFwOiBodHRwUmVtb3RlLnJlZnMsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvaWRzID0gW29pZF07XG4gICAgICAgIGZvciAoY29uc3Qgb2lkIG9mIGF3YWl0IGxpc3RPYmplY3RzKHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZHMgfSkpIHtcbiAgICAgICAgICBza2lwT2JqZWN0cy5hZGQob2lkKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgLy8gUmVtb3ZlIG9iamVjdHMgdGhhdCB3ZSBrbm93IHRoZSByZW1vdGUgYWxyZWFkeSBoYXNcbiAgICAgIGZvciAoY29uc3Qgb2lkIG9mIHNraXBPYmplY3RzKSB7XG4gICAgICAgIG9iamVjdHMuZGVsZXRlKG9pZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmb3JjZSkge1xuICAgICAgLy8gSXMgaXQgYSB0YWcgdGhhdCBhbHJlYWR5IGV4aXN0cz9cbiAgICAgIGlmIChcbiAgICAgICAgZnVsbFJlZi5zdGFydHNXaXRoKCdyZWZzL3RhZ3MnKSAmJlxuICAgICAgICBvbGRvaWQgIT09ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBQdXNoUmVqZWN0ZWRFcnJvcigndGFnLWV4aXN0cycpXG4gICAgICB9XG4gICAgICAvLyBJcyBpdCBhIG5vbi1mYXN0LWZvcndhcmQgY29tbWl0P1xuICAgICAgaWYgKFxuICAgICAgICBvaWQgIT09ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyAmJlxuICAgICAgICBvbGRvaWQgIT09ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyAmJlxuICAgICAgICAhKGF3YWl0IF9pc0Rlc2NlbmRlbnQoe1xuICAgICAgICAgIGZzLFxuICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgIGdpdGRpcixcbiAgICAgICAgICBvaWQsXG4gICAgICAgICAgYW5jZXN0b3I6IG9sZG9pZCxcbiAgICAgICAgICBkZXB0aDogLTEsXG4gICAgICAgIH0pKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBQdXNoUmVqZWN0ZWRFcnJvcignbm90LWZhc3QtZm9yd2FyZCcpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIFdlIGNhbiBvbmx5IHNhZmVseSB1c2UgY2FwYWJpbGl0aWVzIHRoYXQgdGhlIHNlcnZlciBhbHNvIHVuZGVyc3RhbmRzLlxuICAvLyBGb3IgaW5zdGFuY2UsIEFXUyBDb2RlQ29tbWl0IGFib3J0cyBhIHB1c2ggaWYgeW91IGluY2x1ZGUgdGhlIGBhZ2VudGAhISFcbiAgY29uc3QgY2FwYWJpbGl0aWVzID0gZmlsdGVyQ2FwYWJpbGl0aWVzKFxuICAgIFsuLi5odHRwUmVtb3RlLmNhcGFiaWxpdGllc10sXG4gICAgWydyZXBvcnQtc3RhdHVzJywgJ3NpZGUtYmFuZC02NGsnLCBgYWdlbnQ9JHtwa2cuYWdlbnR9YF1cbiAgKTtcbiAgY29uc3QgcGFja3N0cmVhbTEgPSBhd2FpdCB3cml0ZVJlY2VpdmVQYWNrUmVxdWVzdCh7XG4gICAgY2FwYWJpbGl0aWVzLFxuICAgIHRyaXBsZXRzOiBbeyBvbGRvaWQsIG9pZCwgZnVsbFJlZjogZnVsbFJlbW90ZVJlZiB9XSxcbiAgfSk7XG4gIGNvbnN0IHBhY2tzdHJlYW0yID0gX2RlbGV0ZVxuICAgID8gW11cbiAgICA6IGF3YWl0IF9wYWNrKHtcbiAgICAgICAgZnMsXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBnaXRkaXIsXG4gICAgICAgIG9pZHM6IFsuLi5vYmplY3RzXSxcbiAgICAgIH0pO1xuICBjb25zdCByZXMgPSBhd2FpdCBHaXRSZW1vdGVIVFRQLmNvbm5lY3Qoe1xuICAgIGh0dHAsXG4gICAgb25Qcm9ncmVzcyxcbiAgICBjb3JzUHJveHksXG4gICAgc2VydmljZTogJ2dpdC1yZWNlaXZlLXBhY2snLFxuICAgIHVybCxcbiAgICBhdXRoLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keTogWy4uLnBhY2tzdHJlYW0xLCAuLi5wYWNrc3RyZWFtMl0sXG4gIH0pO1xuICBjb25zdCB7IHBhY2tmaWxlLCBwcm9ncmVzcyB9ID0gYXdhaXQgR2l0U2lkZUJhbmQuZGVtdXgocmVzLmJvZHkpO1xuICBpZiAob25NZXNzYWdlKSB7XG4gICAgY29uc3QgbGluZXMgPSBzcGxpdExpbmVzKHByb2dyZXNzKTtcbiAgICBmb3JBd2FpdChsaW5lcywgYXN5bmMgbGluZSA9PiB7XG4gICAgICBhd2FpdCBvbk1lc3NhZ2UobGluZSk7XG4gICAgfSk7XG4gIH1cbiAgLy8gUGFyc2UgdGhlIHJlc3BvbnNlIVxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBwYXJzZVJlY2VpdmVQYWNrUmVzcG9uc2UocGFja2ZpbGUpO1xuICBpZiAocmVzLmhlYWRlcnMpIHtcbiAgICByZXN1bHQuaGVhZGVycyA9IHJlcy5oZWFkZXJzO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBsb2NhbCBjb3B5IG9mIHRoZSByZW1vdGUgcmVmXG4gIGlmIChyZW1vdGUgJiYgcmVzdWx0Lm9rICYmIHJlc3VsdC5yZWZzW2Z1bGxSZW1vdGVSZWZdLm9rKSB7XG4gICAgLy8gVE9ETzogSSB0aGluayB0aGlzIHNob3VsZCBhY3R1YWxseSBiZSB1c2luZyBhIHJlZnNwZWMgdHJhbnNmb3JtIHJhdGhlciB0aGFuIGFzc3VtaW5nICdyZWZzL3JlbW90ZXMve3JlbW90ZX0nXG4gICAgY29uc3QgcmVmID0gYHJlZnMvcmVtb3Rlcy8ke3JlbW90ZX0vJHtmdWxsUmVtb3RlUmVmLnJlcGxhY2UoXG4gICAgICAncmVmcy9oZWFkcycsXG4gICAgICAnJ1xuICAgICl9YDtcbiAgICBpZiAoX2RlbGV0ZSkge1xuICAgICAgYXdhaXQgR2l0UmVmTWFuYWdlci5kZWxldGVSZWYoeyBmcywgZ2l0ZGlyLCByZWYgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIud3JpdGVSZWYoeyBmcywgZ2l0ZGlyLCByZWYsIHZhbHVlOiBvaWQgfSk7XG4gICAgfVxuICB9XG4gIGlmIChyZXN1bHQub2sgJiYgT2JqZWN0LnZhbHVlcyhyZXN1bHQucmVmcykuZXZlcnkocmVzdWx0ID0+IHJlc3VsdC5vaykpIHtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJldHR5RGV0YWlscyA9IE9iamVjdC5lbnRyaWVzKHJlc3VsdC5yZWZzKVxuICAgICAgLmZpbHRlcigoW2ssIHZdKSA9PiAhdi5vaylcbiAgICAgIC5tYXAoKFtrLCB2XSkgPT4gYFxcbiAgLSAke2t9OiAke3YuZXJyb3J9YClcbiAgICAgIC5qb2luKCcnKTtcbiAgICB0aHJvdyBuZXcgR2l0UHVzaEVycm9yKHByZXR0eURldGFpbHMsIHJlc3VsdClcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBQdXNoIGEgYnJhbmNoIG9yIHRhZ1xuICpcbiAqIFRoZSBwdXNoIGNvbW1hbmQgcmV0dXJucyBhbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIHJlc3VsdCBvZiB0aGUgYXR0ZW1wdGVkIHB1c2ggb3BlcmF0aW9uLlxuICogKk5vdGVzOiogSWYgdGhlcmUgd2VyZSBubyBlcnJvcnMsIHRoZW4gdGhlcmUgd2lsbCBiZSBubyBgZXJyb3JzYCBwcm9wZXJ0eS4gVGhlcmUgY2FuIGJlIGEgbWl4IG9mIGBva2AgbWVzc2FnZXMgYW5kIGBlcnJvcnNgIG1lc3NhZ2VzLlxuICpcbiAqIHwgcGFyYW0gIHwgdHlwZSBbPSBkZWZhdWx0XSB8IGRlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAtLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiB8IG9rICAgICB8IEFycmF5XFw8c3RyaW5nXFw+ICB8IFRoZSBmaXJzdCBpdGVtIGlzIFwidW5wYWNrXCIgaWYgdGhlIG92ZXJhbGwgb3BlcmF0aW9uIHdhcyBzdWNjZXNzZnVsLiBUaGUgcmVtYWluaW5nIGl0ZW1zIGFyZSB0aGUgbmFtZXMgb2YgcmVmcyB0aGF0IHdlcmUgdXBkYXRlZCBzdWNjZXNzZnVsbHkuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IGVycm9ycyB8IEFycmF5XFw8c3RyaW5nXFw+ICB8IElmIHRoZSBvdmVyYWxsIG9wZXJhdGlvbiB0aHJldyBhbmQgZXJyb3IsIHRoZSBmaXJzdCBpdGVtIHdpbGwgYmUgXCJ1bnBhY2sge092ZXJhbGwgZXJyb3IgbWVzc2FnZX1cIi4gVGhlIHJlbWFpbmluZyBpdGVtcyBhcmUgaW5kaXZpZHVhbCByZWZzIHRoYXQgZmFpbGVkIHRvIGJlIHVwZGF0ZWQgaW4gdGhlIGZvcm1hdCBcIntyZWYgbmFtZX0ge2Vycm9yIG1lc3NhZ2V9XCIuIHxcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge0h0dHBDbGllbnR9IGFyZ3MuaHR0cCAtIGFuIEhUVFAgY2xpZW50XG4gKiBAcGFyYW0ge1Byb2dyZXNzQ2FsbGJhY2t9IFthcmdzLm9uUHJvZ3Jlc3NdIC0gb3B0aW9uYWwgcHJvZ3Jlc3MgZXZlbnQgY2FsbGJhY2tcbiAqIEBwYXJhbSB7TWVzc2FnZUNhbGxiYWNrfSBbYXJncy5vbk1lc3NhZ2VdIC0gb3B0aW9uYWwgbWVzc2FnZSBldmVudCBjYWxsYmFja1xuICogQHBhcmFtIHtBdXRoQ2FsbGJhY2t9IFthcmdzLm9uQXV0aF0gLSBvcHRpb25hbCBhdXRoIGZpbGwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7QXV0aEZhaWx1cmVDYWxsYmFja30gW2FyZ3Mub25BdXRoRmFpbHVyZV0gLSBvcHRpb25hbCBhdXRoIHJlamVjdGVkIGNhbGxiYWNrXG4gKiBAcGFyYW0ge0F1dGhTdWNjZXNzQ2FsbGJhY2t9IFthcmdzLm9uQXV0aFN1Y2Nlc3NdIC0gb3B0aW9uYWwgYXV0aCBhcHByb3ZlZCBjYWxsYmFja1xuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZl0gLSBXaGljaCBicmFuY2ggdG8gcHVzaC4gQnkgZGVmYXVsdCB0aGlzIGlzIHRoZSBjdXJyZW50bHkgY2hlY2tlZCBvdXQgYnJhbmNoLlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnVybF0gLSBUaGUgVVJMIG9mIHRoZSByZW1vdGUgcmVwb3NpdG9yeS4gVGhlIGRlZmF1bHQgaXMgdGhlIHZhbHVlIHNldCBpbiB0aGUgZ2l0IGNvbmZpZyBmb3IgdGhhdCByZW1vdGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVtb3RlXSAtIElmIFVSTCBpcyBub3Qgc3BlY2lmaWVkLCBkZXRlcm1pbmVzIHdoaWNoIHJlbW90ZSB0byB1c2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVtb3RlUmVmXSAtIFRoZSBuYW1lIG9mIHRoZSByZWNlaXZpbmcgYnJhbmNoIG9uIHRoZSByZW1vdGUuIEJ5IGRlZmF1bHQgdGhpcyBpcyB0aGUgY29uZmlndXJlZCByZW1vdGUgdHJhY2tpbmcgYnJhbmNoLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JjZSA9IGZhbHNlXSAtIElmIHRydWUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMgYGdpdCBwdXNoIC0tZm9yY2VgXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmRlbGV0ZSA9IGZhbHNlXSAtIElmIHRydWUsIGRlbGV0ZSB0aGUgcmVtb3RlIHJlZlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmNvcnNQcm94eV0gLSBPcHRpb25hbCBbQ09SUyBwcm94eV0oaHR0cHM6Ly93d3cubnBtanMuY29tLyU0MGlzb21vcnBoaWMtZ2l0L2NvcnMtcHJveHkpLiBPdmVycmlkZXMgdmFsdWUgaW4gcmVwbyBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIHN0cmluZz59IFthcmdzLmhlYWRlcnNdIC0gQWRkaXRpb25hbCBoZWFkZXJzIHRvIGluY2x1ZGUgaW4gSFRUUCByZXF1ZXN0cywgc2ltaWxhciB0byBnaXQncyBgZXh0cmFIZWFkZXJgIGNvbmZpZ1xuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8UHVzaFJlc3VsdD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIHB1c2ggY29tcGxldGVzIHdpdGggYSBkZXRhaWxlZCBkZXNjcmlwdGlvbiBvZiB0aGUgb3BlcmF0aW9uIGZyb20gdGhlIHNlcnZlci5cbiAqIEBzZWUgUHVzaFJlc3VsdFxuICogQHNlZSBSZWZVcGRhdGVTdGF0dXNcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHB1c2hSZXN1bHQgPSBhd2FpdCBnaXQucHVzaCh7XG4gKiAgIGZzLFxuICogICBodHRwLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICByZW1vdGU6ICdvcmlnaW4nLFxuICogICByZWY6ICdtYWluJyxcbiAqICAgb25BdXRoOiAoKSA9PiAoeyB1c2VybmFtZTogcHJvY2Vzcy5lbnYuR0lUSFVCX1RPS0VOIH0pLFxuICogfSlcbiAqIGNvbnNvbGUubG9nKHB1c2hSZXN1bHQpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBwdXNoKHtcbiAgZnMsXG4gIGh0dHAsXG4gIG9uUHJvZ3Jlc3MsXG4gIG9uTWVzc2FnZSxcbiAgb25BdXRoLFxuICBvbkF1dGhTdWNjZXNzLFxuICBvbkF1dGhGYWlsdXJlLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICByZWYsXG4gIHJlbW90ZVJlZixcbiAgcmVtb3RlID0gJ29yaWdpbicsXG4gIHVybCxcbiAgZm9yY2UgPSBmYWxzZSxcbiAgZGVsZXRlOiBfZGVsZXRlID0gZmFsc2UsXG4gIGNvcnNQcm94eSxcbiAgaGVhZGVycyA9IHt9LFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdodHRwJywgaHR0cCk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9wdXNoKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBjYWNoZSxcbiAgICAgIGh0dHAsXG4gICAgICBvblByb2dyZXNzLFxuICAgICAgb25NZXNzYWdlLFxuICAgICAgb25BdXRoLFxuICAgICAgb25BdXRoU3VjY2VzcyxcbiAgICAgIG9uQXV0aEZhaWx1cmUsXG4gICAgICBnaXRkaXIsXG4gICAgICByZWYsXG4gICAgICByZW1vdGVSZWYsXG4gICAgICByZW1vdGUsXG4gICAgICB1cmwsXG4gICAgICBmb3JjZSxcbiAgICAgIGRlbGV0ZTogX2RlbGV0ZSxcbiAgICAgIGNvcnNQcm94eSxcbiAgICAgIGhlYWRlcnMsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQucHVzaCc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUJsb2IoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pIHtcbiAgY29uc3QgeyB0eXBlLCBvYmplY3QgfSA9IGF3YWl0IF9yZWFkT2JqZWN0KHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcbiAgLy8gUmVzb2x2ZSBhbm5vdGF0ZWQgdGFnIG9iamVjdHMgdG8gd2hhdGV2ZXJcbiAgaWYgKHR5cGUgPT09ICd0YWcnKSB7XG4gICAgb2lkID0gR2l0QW5ub3RhdGVkVGFnLmZyb20ob2JqZWN0KS5wYXJzZSgpLm9iamVjdDtcbiAgICByZXR1cm4gcmVzb2x2ZUJsb2IoeyBmcywgY2FjaGUsIGdpdGRpciwgb2lkIH0pXG4gIH1cbiAgaWYgKHR5cGUgIT09ICdibG9iJykge1xuICAgIHRocm93IG5ldyBPYmplY3RUeXBlRXJyb3Iob2lkLCB0eXBlLCAnYmxvYicpXG4gIH1cbiAgcmV0dXJuIHsgb2lkLCBibG9iOiBuZXcgVWludDhBcnJheShvYmplY3QpIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlYWRCbG9iUmVzdWx0IC0gVGhlIG9iamVjdCByZXR1cm5lZCBoYXMgdGhlIGZvbGxvd2luZyBzY2hlbWE6XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkXG4gKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IGJsb2JcbiAqXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHthbnl9IGFyZ3MuY2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Mub2lkXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZmlsZXBhdGhdXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8UmVhZEJsb2JSZXN1bHQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCBhIGJsb2Igb2JqZWN0IGRlc2NyaXB0aW9uXG4gKiBAc2VlIFJlYWRCbG9iUmVzdWx0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIF9yZWFkQmxvYih7XG4gIGZzLFxuICBjYWNoZSxcbiAgZ2l0ZGlyLFxuICBvaWQsXG4gIGZpbGVwYXRoID0gdW5kZWZpbmVkLFxufSkge1xuICBpZiAoZmlsZXBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIG9pZCA9IGF3YWl0IHJlc29sdmVGaWxlcGF0aCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQsIGZpbGVwYXRoIH0pO1xuICB9XG4gIGNvbnN0IGJsb2IgPSBhd2FpdCByZXNvbHZlQmxvYih7XG4gICAgZnMsXG4gICAgY2FjaGUsXG4gICAgZ2l0ZGlyLFxuICAgIG9pZCxcbiAgfSk7XG4gIHJldHVybiBibG9iXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZWFkQmxvYlJlc3VsdCAtIFRoZSBvYmplY3QgcmV0dXJuZWQgaGFzIHRoZSBmb2xsb3dpbmcgc2NoZW1hOlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9pZFxuICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBibG9iXG4gKlxuICovXG5cbi8qKlxuICogUmVhZCBhIGJsb2Igb2JqZWN0IGRpcmVjdGx5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Mub2lkIC0gVGhlIFNIQS0xIG9iamVjdCBpZCB0byBnZXQuIEFubm90YXRlZCB0YWdzLCBjb21taXRzLCBhbmQgdHJlZXMgYXJlIHBlZWxlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5maWxlcGF0aF0gLSBEb24ndCByZXR1cm4gdGhlIG9iamVjdCB3aXRoIGBvaWRgIGl0c2VsZiwgYnV0IHJlc29sdmUgYG9pZGAgdG8gYSB0cmVlIGFuZCB0aGVuIHJldHVybiB0aGUgYmxvYiBvYmplY3QgYXQgdGhhdCBmaWxlcGF0aC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRCbG9iUmVzdWx0Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYSBibG9iIG9iamVjdCBkZXNjcmlwdGlvblxuICogQHNlZSBSZWFkQmxvYlJlc3VsdFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBHZXQgdGhlIGNvbnRlbnRzIG9mICdSRUFETUUubWQnIGluIHRoZSBtYWluIGJyYW5jaC5cbiAqIGxldCBjb21taXRPaWQgPSBhd2FpdCBnaXQucmVzb2x2ZVJlZih7IGZzLCBkaXI6ICcvdHV0b3JpYWwnLCByZWY6ICdtYWluJyB9KVxuICogY29uc29sZS5sb2coY29tbWl0T2lkKVxuICogbGV0IHsgYmxvYiB9ID0gYXdhaXQgZ2l0LnJlYWRCbG9iKHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIG9pZDogY29tbWl0T2lkLFxuICogICBmaWxlcGF0aDogJ1JFQURNRS5tZCdcbiAqIH0pXG4gKiBjb25zb2xlLmxvZyhCdWZmZXIuZnJvbShibG9iKS50b1N0cmluZygndXRmOCcpKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVhZEJsb2Ioe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgb2lkLFxuICBmaWxlcGF0aCxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ29pZCcsIG9pZCk7XG5cbiAgICByZXR1cm4gYXdhaXQgX3JlYWRCbG9iKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIG9pZCxcbiAgICAgIGZpbGVwYXRoLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LnJlYWRCbG9iJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBSZWFkIGEgY29tbWl0IG9iamVjdCBkaXJlY3RseVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9pZCAtIFRoZSBTSEEtMSBvYmplY3QgaWQgdG8gZ2V0LiBBbm5vdGF0ZWQgdGFncyBhcmUgcGVlbGVkLlxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8UmVhZENvbW1pdFJlc3VsdD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIGEgZ2l0IGNvbW1pdCBvYmplY3RcbiAqIEBzZWUgUmVhZENvbW1pdFJlc3VsdFxuICogQHNlZSBDb21taXRPYmplY3RcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gUmVhZCBhIGNvbW1pdCBvYmplY3RcbiAqIGxldCBzaGEgPSBhd2FpdCBnaXQucmVzb2x2ZVJlZih7IGZzLCBkaXI6ICcvdHV0b3JpYWwnLCByZWY6ICdtYWluJyB9KVxuICogY29uc29sZS5sb2coc2hhKVxuICogbGV0IGNvbW1pdCA9IGF3YWl0IGdpdC5yZWFkQ29tbWl0KHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIG9pZDogc2hhIH0pXG4gKiBjb25zb2xlLmxvZyhjb21taXQpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkQ29tbWl0KHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIG9pZCxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ29pZCcsIG9pZCk7XG5cbiAgICByZXR1cm4gYXdhaXQgX3JlYWRDb21taXQoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGNhY2hlLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgb2lkLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LnJlYWRDb21taXQnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFJlYWQgdGhlIGNvbnRlbnRzIG9mIGEgbm90ZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge2FueX0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVmXSAtIFRoZSBub3RlcyByZWYgdG8gbG9vayB1bmRlclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Mub2lkXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8VWludDhBcnJheT59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIG5vdGUgY29udGVudHMgYXMgYSBCdWZmZXIuXG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gX3JlYWROb3RlKHtcbiAgZnMsXG4gIGNhY2hlLFxuICBnaXRkaXIsXG4gIHJlZiA9ICdyZWZzL25vdGVzL2NvbW1pdHMnLFxuICBvaWQsXG59KSB7XG4gIGNvbnN0IHBhcmVudCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGdpdGRpciwgZnMsIHJlZiB9KTtcbiAgY29uc3QgeyBibG9iIH0gPSBhd2FpdCBfcmVhZEJsb2Ioe1xuICAgIGZzLFxuICAgIGNhY2hlLFxuICAgIGdpdGRpcixcbiAgICBvaWQ6IHBhcmVudCxcbiAgICBmaWxlcGF0aDogb2lkLFxuICB9KTtcblxuICByZXR1cm4gYmxvYlxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBSZWFkIHRoZSBjb250ZW50cyBvZiBhIG5vdGVcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVmXSAtIFRoZSBub3RlcyByZWYgdG8gbG9vayB1bmRlclxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Mub2lkIC0gVGhlIFNIQS0xIG9iamVjdCBpZCBvZiB0aGUgb2JqZWN0IHRvIGdldCB0aGUgbm90ZSBmb3IuXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxVaW50OEFycmF5Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggbm90ZSBjb250ZW50cyBhcyBhIEJ1ZmZlci5cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiByZWFkTm90ZSh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICByZWYgPSAncmVmcy9ub3Rlcy9jb21taXRzJyxcbiAgb2lkLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBmcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcigncmVmJywgcmVmKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ29pZCcsIG9pZCk7XG5cbiAgICByZXR1cm4gYXdhaXQgX3JlYWROb3RlKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZixcbiAgICAgIG9pZCxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5yZWFkTm90ZSc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERlZmxhdGVkT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkXG4gKiBAcHJvcGVydHkgeydkZWZsYXRlZCd9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7J2RlZmxhdGVkJ30gZm9ybWF0XG4gKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IG9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzb3VyY2VdXG4gKlxuICovXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFdyYXBwZWRPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWRcbiAqIEBwcm9wZXJ0eSB7J3dyYXBwZWQnfSB0eXBlXG4gKiBAcHJvcGVydHkgeyd3cmFwcGVkJ30gZm9ybWF0XG4gKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IG9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzb3VyY2VdXG4gKlxuICovXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJhd09iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9pZFxuICogQHByb3BlcnR5IHsnYmxvYid8J2NvbW1pdCd8J3RyZWUnfCd0YWcnfSB0eXBlXG4gKiBAcHJvcGVydHkgeydjb250ZW50J30gZm9ybWF0XG4gKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IG9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzb3VyY2VdXG4gKlxuICovXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhcnNlZEJsb2JPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWRcbiAqIEBwcm9wZXJ0eSB7J2Jsb2InfSB0eXBlXG4gKiBAcHJvcGVydHkgeydwYXJzZWQnfSBmb3JtYXRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc291cmNlXVxuICpcbiAqL1xuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQYXJzZWRDb21taXRPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWRcbiAqIEBwcm9wZXJ0eSB7J2NvbW1pdCd9IHR5cGVcbiAqIEBwcm9wZXJ0eSB7J3BhcnNlZCd9IGZvcm1hdFxuICogQHByb3BlcnR5IHtDb21taXRPYmplY3R9IG9iamVjdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzb3VyY2VdXG4gKlxuICovXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBhcnNlZFRyZWVPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWRcbiAqIEBwcm9wZXJ0eSB7J3RyZWUnfSB0eXBlXG4gKiBAcHJvcGVydHkgeydwYXJzZWQnfSBmb3JtYXRcbiAqIEBwcm9wZXJ0eSB7VHJlZU9iamVjdH0gb2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NvdXJjZV1cbiAqXG4gKi9cblxuLyoqXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gUGFyc2VkVGFnT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkXG4gKiBAcHJvcGVydHkgeyd0YWcnfSB0eXBlXG4gKiBAcHJvcGVydHkgeydwYXJzZWQnfSBmb3JtYXRcbiAqIEBwcm9wZXJ0eSB7VGFnT2JqZWN0fSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc291cmNlXVxuICpcbiAqL1xuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7UGFyc2VkQmxvYk9iamVjdCB8IFBhcnNlZENvbW1pdE9iamVjdCB8IFBhcnNlZFRyZWVPYmplY3QgfCBQYXJzZWRUYWdPYmplY3R9IFBhcnNlZE9iamVjdFxuICovXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtEZWZsYXRlZE9iamVjdCB8IFdyYXBwZWRPYmplY3QgfCBSYXdPYmplY3QgfCBQYXJzZWRPYmplY3QgfSBSZWFkT2JqZWN0UmVzdWx0XG4gKi9cblxuLyoqXG4gKiBSZWFkIGEgZ2l0IG9iamVjdCBkaXJlY3RseSBieSBpdHMgU0hBLTEgb2JqZWN0IGlkXG4gKlxuICogUmVnYXJkaW5nIGBSZWFkT2JqZWN0UmVzdWx0YDpcbiAqXG4gKiAtIGBvaWRgIHdpbGwgYmUgdGhlIHNhbWUgYXMgdGhlIGBvaWRgIGFyZ3VtZW50IHVubGVzcyB0aGUgYGZpbGVwYXRoYCBhcmd1bWVudCBpcyBwcm92aWRlZCwgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGJlIHRoZSBvaWQgb2YgdGhlIHRyZWUgb3IgYmxvYiBiZWluZyByZXR1cm5lZC5cbiAqIC0gYHR5cGVgIG9mIGRlZmxhdGVkIG9iamVjdHMgaXMgYCdkZWZsYXRlZCdgLCBhbmQgYHR5cGVgIG9mIHdyYXBwZWQgb2JqZWN0cyBpcyBgJ3dyYXBwZWQnYFxuICogLSBgZm9ybWF0YCBpcyB1c3VhbGx5LCBidXQgbm90IGFsd2F5cywgdGhlIGZvcm1hdCB5b3UgcmVxdWVzdGVkLiBQYWNrZmlsZXMgZG8gbm90IHN0b3JlIGVhY2ggb2JqZWN0IGluZGl2aWR1YWxseSBjb21wcmVzc2VkIHNvIGlmIHlvdSBlbmQgdXAgcmVhZGluZyB0aGUgb2JqZWN0IGZyb20gYSBwYWNrZmlsZSBpdCB3aWxsIGJlIHJldHVybmVkIGluIGZvcm1hdCAnY29udGVudCcgZXZlbiBpZiB5b3UgcmVxdWVzdGVkICdkZWZsYXRlZCcgb3IgJ3dyYXBwZWQnLlxuICogLSBgb2JqZWN0YCB3aWxsIGJlIGFuIGFjdHVhbCBPYmplY3QgaWYgZm9ybWF0IGlzICdwYXJzZWQnIGFuZCB0aGUgb2JqZWN0IGlzIGEgY29tbWl0LCB0cmVlLCBvciBhbm5vdGF0ZWQgdGFnLiBCbG9icyBhcmUgc3RpbGwgZm9ybWF0dGVkIGFzIEJ1ZmZlcnMgdW5sZXNzIGFuIGVuY29kaW5nIGlzIHByb3ZpZGVkIGluIHdoaWNoIGNhc2UgdGhleSdsbCBiZSBzdHJpbmdzLiBJZiBmb3JtYXQgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiAncGFyc2VkJywgb2JqZWN0IHdpbGwgYmUgYSBCdWZmZXIuXG4gKiAtIGBzb3VyY2VgIGlzIHRoZSBuYW1lIG9mIHRoZSBwYWNrZmlsZSBvciBsb29zZSBvYmplY3QgZmlsZSB3aGVyZSB0aGUgb2JqZWN0IHdhcyBmb3VuZC5cbiAqXG4gKiBUaGUgYGZvcm1hdGAgcGFyYW1ldGVyIGNhbiBoYXZlIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICpcbiAqIHwgcGFyYW0gICAgICB8IGRlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IC0tLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogfCAnZGVmbGF0ZWQnIHwgUmV0dXJuIHRoZSByYXcgZGVmbGF0ZS1jb21wcmVzc2VkIGJ1ZmZlciBmb3IgYW4gb2JqZWN0IGlmIHBvc3NpYmxlLiBVc2VmdWwgZm9yIGVmZmljaWVudGx5IHNodWZmbGluZyBhcm91bmQgbG9vc2Ugb2JqZWN0cyB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0IHRoZSBjb250ZW50cyBhbmQgY2FuIHNhdmUgdGltZSBieSBub3QgaW5mbGF0aW5nIHRoZW0uIHxcbiAqIHwgJ3dyYXBwZWQnICB8IFJldHVybiB0aGUgaW5mbGF0ZWQgb2JqZWN0IGJ1ZmZlciB3cmFwcGVkIGluIHRoZSBnaXQgb2JqZWN0IGhlYWRlciBpZiBwb3NzaWJsZS4gVGhpcyBpcyB0aGUgcmF3IGRhdGEgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBTSEEtMSBvYmplY3QgaWQgb2YgYSBnaXQgb2JqZWN0LiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8ICdjb250ZW50JyAgfCBSZXR1cm4gdGhlIG9iamVjdCBidWZmZXIgd2l0aG91dCB0aGUgZ2l0IGhlYWRlci4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAncGFyc2VkJyAgIHwgUmV0dXJucyBhIHBhcnNlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0LiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgc2NoZW1hczpcbiAqXG4gKiAjIyBgJ2RlZmxhdGVkJ2AgZm9ybWF0XG4gKlxuICoge0BsaW5rIERlZmxhdGVkT2JqZWN0IHR5cGVkZWZ9XG4gKlxuICogIyMgYCd3cmFwcGVkJ2AgZm9ybWF0XG4gKlxuICoge0BsaW5rIFdyYXBwZWRPYmplY3QgdHlwZWRlZn1cbiAqXG4gKiAjIyBgJ2NvbnRlbnQnYCBmb3JtYXRcbiAqXG4gKiB7QGxpbmsgUmF3T2JqZWN0IHR5cGVkZWZ9XG4gKlxuICogIyMgYCdwYXJzZWQnYCBmb3JtYXRcbiAqXG4gKiAjIyMgcGFyc2VkIGAnYmxvYidgIHR5cGVcbiAqXG4gKiB7QGxpbmsgUGFyc2VkQmxvYk9iamVjdCB0eXBlZGVmfVxuICpcbiAqICMjIyBwYXJzZWQgYCdjb21taXQnYCB0eXBlXG4gKlxuICoge0BsaW5rIFBhcnNlZENvbW1pdE9iamVjdCB0eXBlZGVmfVxuICoge0BsaW5rIENvbW1pdE9iamVjdCB0eXBlZGVmfVxuICpcbiAqICMjIyBwYXJzZWQgYCd0cmVlJ2AgdHlwZVxuICpcbiAqIHtAbGluayBQYXJzZWRUcmVlT2JqZWN0IHR5cGVkZWZ9XG4gKiB7QGxpbmsgVHJlZU9iamVjdCB0eXBlZGVmfVxuICoge0BsaW5rIFRyZWVFbnRyeSB0eXBlZGVmfVxuICpcbiAqICMjIyBwYXJzZWQgYCd0YWcnYCB0eXBlXG4gKlxuICoge0BsaW5rIFBhcnNlZFRhZ09iamVjdCB0eXBlZGVmfVxuICoge0BsaW5rIFRhZ09iamVjdCB0eXBlZGVmfVxuICpcbiAqIEBkZXByZWNhdGVkXG4gKiA+IFRoaXMgY29tbWFuZCBpcyBvdmVybHkgY29tcGxpY2F0ZWQuXG4gKiA+XG4gKiA+IElmIHlvdSBrbm93IHRoZSB0eXBlIG9mIG9iamVjdCB5b3UgYXJlIHJlYWRpbmcsIHVzZSBbYHJlYWRCbG9iYF0oLi9yZWFkQmxvYi5tZCksIFtgcmVhZENvbW1pdGBdKC4vcmVhZENvbW1pdC5tZCksIFtgcmVhZFRhZ2BdKC4vcmVhZFRhZy5tZCksIG9yIFtgcmVhZFRyZWVgXSguL3JlYWRUcmVlLm1kKS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5vaWQgLSBUaGUgU0hBLTEgb2JqZWN0IGlkIHRvIGdldFxuICogQHBhcmFtIHsnZGVmbGF0ZWQnIHwgJ3dyYXBwZWQnIHwgJ2NvbnRlbnQnIHwgJ3BhcnNlZCd9IFthcmdzLmZvcm1hdCA9ICdwYXJzZWQnXSAtIFdoYXQgZm9ybWF0IHRvIHJldHVybiB0aGUgb2JqZWN0IGluLiBUaGUgY2hvaWNlcyBhcmUgZGVzY3JpYmVkIGluIG1vcmUgZGV0YWlsIGJlbG93LlxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmZpbGVwYXRoXSAtIERvbid0IHJldHVybiB0aGUgb2JqZWN0IHdpdGggYG9pZGAgaXRzZWxmLCBidXQgcmVzb2x2ZSBgb2lkYCB0byBhIHRyZWUgYW5kIHRoZW4gcmV0dXJuIHRoZSBvYmplY3QgYXQgdGhhdCBmaWxlcGF0aC4gVG8gcmV0dXJuIHRoZSByb290IGRpcmVjdG9yeSBvZiBhIHRyZWUgc2V0IGZpbGVwYXRoIHRvIGAnJ2BcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5lbmNvZGluZ10gLSBBIGNvbnZlbmllbmNlIGFyZ3VtZW50IHRoYXQgb25seSBhZmZlY3RzIGJsb2JzLiBJbnN0ZWFkIG9mIHJldHVybmluZyBgb2JqZWN0YCBhcyBhIGJ1ZmZlciwgaXQgcmV0dXJucyBhIHN0cmluZyBwYXJzZWQgdXNpbmcgdGhlIGdpdmVuIGVuY29kaW5nLlxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8UmVhZE9iamVjdFJlc3VsdD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIGEgZ2l0IG9iamVjdCBkZXNjcmlwdGlvblxuICogQHNlZSBSZWFkT2JqZWN0UmVzdWx0XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEdpdmVuIGEgcmFuc29tIFNIQS0xIG9iamVjdCBpZCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gKiBsZXQgeyB0eXBlLCBvYmplY3QgfSA9IGF3YWl0IGdpdC5yZWFkT2JqZWN0KHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIG9pZDogJzA2OThhNzgxYTAyMjY0YTZmMzdiYTNmZjQxZDc4MDY3ZWFmMGYwNzUnXG4gKiB9KVxuICogc3dpdGNoICh0eXBlKSB7XG4gKiAgIGNhc2UgJ2NvbW1pdCc6IHtcbiAqICAgICBjb25zb2xlLmxvZyhvYmplY3QpXG4gKiAgICAgYnJlYWtcbiAqICAgfVxuICogICBjYXNlICd0cmVlJzoge1xuICogICAgIGNvbnNvbGUubG9nKG9iamVjdClcbiAqICAgICBicmVha1xuICogICB9XG4gKiAgIGNhc2UgJ2Jsb2InOiB7XG4gKiAgICAgY29uc29sZS5sb2cob2JqZWN0KVxuICogICAgIGJyZWFrXG4gKiAgIH1cbiAqICAgY2FzZSAndGFnJzoge1xuICogICAgIGNvbnNvbGUubG9nKG9iamVjdClcbiAqICAgICBicmVha1xuICogICB9XG4gKiB9XG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkT2JqZWN0KHtcbiAgZnM6IF9mcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgb2lkLFxuICBmb3JtYXQgPSAncGFyc2VkJyxcbiAgZmlsZXBhdGggPSB1bmRlZmluZWQsXG4gIGVuY29kaW5nID0gdW5kZWZpbmVkLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBfZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ29pZCcsIG9pZCk7XG5cbiAgICBjb25zdCBmcyA9IG5ldyBGaWxlU3lzdGVtKF9mcyk7XG4gICAgaWYgKGZpbGVwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9pZCA9IGF3YWl0IHJlc29sdmVGaWxlcGF0aCh7XG4gICAgICAgIGZzLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICBvaWQsXG4gICAgICAgIGZpbGVwYXRoLFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEdpdE9iamVjdE1hbmFnZXIgZG9lcyBub3Qga25vdyBob3cgdG8gcGFyc2UgY29udGVudCwgc28gd2UgdHdlYWsgdGhhdCBwYXJhbWV0ZXIgYmVmb3JlIHBhc3NpbmcgaXQuXG4gICAgY29uc3QgX2Zvcm1hdCA9IGZvcm1hdCA9PT0gJ3BhcnNlZCcgPyAnY29udGVudCcgOiBmb3JtYXQ7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX3JlYWRPYmplY3Qoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIG9pZCxcbiAgICAgIGZvcm1hdDogX2Zvcm1hdCxcbiAgICB9KTtcbiAgICByZXN1bHQub2lkID0gb2lkO1xuICAgIGlmIChmb3JtYXQgPT09ICdwYXJzZWQnKSB7XG4gICAgICByZXN1bHQuZm9ybWF0ID0gJ3BhcnNlZCc7XG4gICAgICBzd2l0Y2ggKHJlc3VsdC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NvbW1pdCc6XG4gICAgICAgICAgcmVzdWx0Lm9iamVjdCA9IEdpdENvbW1pdC5mcm9tKHJlc3VsdC5vYmplY3QpLnBhcnNlKCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAndHJlZSc6XG4gICAgICAgICAgcmVzdWx0Lm9iamVjdCA9IEdpdFRyZWUuZnJvbShyZXN1bHQub2JqZWN0KS5lbnRyaWVzKCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnYmxvYic6XG4gICAgICAgICAgLy8gSGVyZSB3ZSBjb25zaWRlciByZXR1cm5pbmcgYSByYXcgQnVmZmVyIGFzIHRoZSAnY29udGVudCcgZm9ybWF0XG4gICAgICAgICAgLy8gYW5kIHJldHVybmluZyBhIHN0cmluZyBhcyB0aGUgJ3BhcnNlZCcgZm9ybWF0XG4gICAgICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXN1bHQub2JqZWN0ID0gcmVzdWx0Lm9iamVjdC50b1N0cmluZyhlbmNvZGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5vYmplY3QgPSBuZXcgVWludDhBcnJheShyZXN1bHQub2JqZWN0KTtcbiAgICAgICAgICAgIHJlc3VsdC5mb3JtYXQgPSAnY29udGVudCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgcmVzdWx0Lm9iamVjdCA9IEdpdEFubm90YXRlZFRhZy5mcm9tKHJlc3VsdC5vYmplY3QpLnBhcnNlKCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VHlwZUVycm9yKFxuICAgICAgICAgICAgcmVzdWx0Lm9pZCxcbiAgICAgICAgICAgIHJlc3VsdC50eXBlLFxuICAgICAgICAgICAgJ2Jsb2J8Y29tbWl0fHRhZ3x0cmVlJ1xuICAgICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlc3VsdC5mb3JtYXQgPT09ICdkZWZsYXRlZCcgfHwgcmVzdWx0LmZvcm1hdCA9PT0gJ3dyYXBwZWQnKSB7XG4gICAgICByZXN1bHQudHlwZSA9IHJlc3VsdC5mb3JtYXQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQucmVhZE9iamVjdCc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICpcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJlYWRUYWdSZXN1bHQgLSBUaGUgb2JqZWN0IHJldHVybmVkIGhhcyB0aGUgZm9sbG93aW5nIHNjaGVtYTpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWQgLSBTSEEtMSBvYmplY3QgaWQgb2YgdGhpcyB0YWdcbiAqIEBwcm9wZXJ0eSB7VGFnT2JqZWN0fSB0YWcgLSB0aGUgcGFyc2VkIHRhZyBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwYXlsb2FkIC0gUEdQIHNpZ25pbmcgcGF5bG9hZFxuICovXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7YW55fSBhcmdzLmNhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5naXRkaXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9pZFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRUYWdSZXN1bHQ+fVxuICovXG5hc3luYyBmdW5jdGlvbiBfcmVhZFRhZyh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCBvaWQgfSkge1xuICBjb25zdCB7IHR5cGUsIG9iamVjdCB9ID0gYXdhaXQgX3JlYWRPYmplY3Qoe1xuICAgIGZzLFxuICAgIGNhY2hlLFxuICAgIGdpdGRpcixcbiAgICBvaWQsXG4gICAgZm9ybWF0OiAnY29udGVudCcsXG4gIH0pO1xuICBpZiAodHlwZSAhPT0gJ3RhZycpIHtcbiAgICB0aHJvdyBuZXcgT2JqZWN0VHlwZUVycm9yKG9pZCwgdHlwZSwgJ3RhZycpXG4gIH1cbiAgY29uc3QgdGFnID0gR2l0QW5ub3RhdGVkVGFnLmZyb20ob2JqZWN0KTtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIG9pZCxcbiAgICB0YWc6IHRhZy5wYXJzZSgpLFxuICAgIHBheWxvYWQ6IHRhZy5wYXlsb2FkKCksXG4gIH07XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBSZWFkVGFnUmVzdWx0IC0gVGhlIG9iamVjdCByZXR1cm5lZCBoYXMgdGhlIGZvbGxvd2luZyBzY2hlbWE6XG4gKiBAcHJvcGVydHkge3N0cmluZ30gb2lkIC0gU0hBLTEgb2JqZWN0IGlkIG9mIHRoaXMgdGFnXG4gKiBAcHJvcGVydHkge1RhZ09iamVjdH0gdGFnIC0gdGhlIHBhcnNlZCB0YWcgb2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF5bG9hZCAtIFBHUCBzaWduaW5nIHBheWxvYWRcbiAqL1xuXG4vKipcbiAqIFJlYWQgYW4gYW5ub3RhdGVkIHRhZyBvYmplY3QgZGlyZWN0bHlcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5vaWQgLSBUaGUgU0hBLTEgb2JqZWN0IGlkIHRvIGdldFxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8UmVhZFRhZ1Jlc3VsdD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aXRoIGEgZ2l0IG9iamVjdCBkZXNjcmlwdGlvblxuICogQHNlZSBSZWFkVGFnUmVzdWx0XG4gKiBAc2VlIFRhZ09iamVjdFxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVhZFRhZyh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICBvaWQsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdvaWQnLCBvaWQpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9yZWFkVGFnKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBjYWNoZSxcbiAgICAgIGdpdGRpcixcbiAgICAgIG9pZCxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5yZWFkVGFnJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKlxuICogQHR5cGVkZWYge09iamVjdH0gUmVhZFRyZWVSZXN1bHQgLSBUaGUgb2JqZWN0IHJldHVybmVkIGhhcyB0aGUgZm9sbG93aW5nIHNjaGVtYTpcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvaWQgLSBTSEEtMSBvYmplY3QgaWQgb2YgdGhpcyB0cmVlXG4gKiBAcHJvcGVydHkge1RyZWVPYmplY3R9IHRyZWUgLSB0aGUgcGFyc2VkIHRyZWUgb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBSZWFkIGEgdHJlZSBvYmplY3QgZGlyZWN0bHlcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5vaWQgLSBUaGUgU0hBLTEgb2JqZWN0IGlkIHRvIGdldC4gQW5ub3RhdGVkIHRhZ3MgYW5kIGNvbW1pdHMgYXJlIHBlZWxlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5maWxlcGF0aF0gLSBEb24ndCByZXR1cm4gdGhlIG9iamVjdCB3aXRoIGBvaWRgIGl0c2VsZiwgYnV0IHJlc29sdmUgYG9pZGAgdG8gYSB0cmVlIGFuZCB0aGVuIHJldHVybiB0aGUgdHJlZSBvYmplY3QgYXQgdGhhdCBmaWxlcGF0aC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlYWRUcmVlUmVzdWx0Pn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYSBnaXQgdHJlZSBvYmplY3RcbiAqIEBzZWUgUmVhZFRyZWVSZXN1bHRcbiAqIEBzZWUgVHJlZU9iamVjdFxuICogQHNlZSBUcmVlRW50cnlcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRUcmVlKHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIG9pZCxcbiAgZmlsZXBhdGggPSB1bmRlZmluZWQsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdvaWQnLCBvaWQpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF9yZWFkVHJlZSh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgY2FjaGUsXG4gICAgICBnaXRkaXIsXG4gICAgICBvaWQsXG4gICAgICBmaWxlcGF0aCxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5yZWFkVHJlZSc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogUmVtb3ZlIGEgZmlsZSBmcm9tIHRoZSBnaXQgaW5kZXggKGFrYSBzdGFnaW5nIGFyZWEpXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgZG9lcyBOT1QgZGVsZXRlIHRoZSBmaWxlIGluIHRoZSB3b3JraW5nIGRpcmVjdG9yeS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwgJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZmlsZXBhdGggLSBUaGUgcGF0aCB0byB0aGUgZmlsZSB0byByZW1vdmUgZnJvbSB0aGUgaW5kZXhcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgb25jZSB0aGUgZ2l0IGluZGV4IGhhcyBiZWVuIHVwZGF0ZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZ2l0LnJlbW92ZSh7IGZzLCBkaXI6ICcvdHV0b3JpYWwnLCBmaWxlcGF0aDogJ1JFQURNRS5tZCcgfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZSh7XG4gIGZzOiBfZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIGZpbGVwYXRoLFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBfZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZpbGVwYXRoJywgZmlsZXBhdGgpO1xuXG4gICAgYXdhaXQgR2l0SW5kZXhNYW5hZ2VyLmFjcXVpcmUoXG4gICAgICB7IGZzOiBuZXcgRmlsZVN5c3RlbShfZnMpLCBnaXRkaXIsIGNhY2hlIH0sXG4gICAgICBhc3luYyBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICBpbmRleC5kZWxldGUoeyBmaWxlcGF0aCB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5yZW1vdmUnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vbW9kZWxzL0ZpbGVTeXN0ZW0uanMnKS5GaWxlU3lzdGVtfSBhcmdzLmZzXG4gKiBAcGFyYW0ge29iamVjdH0gYXJncy5jYWNoZVxuICogQHBhcmFtIHtTaWduQ2FsbGJhY2t9IFthcmdzLm9uU2lnbl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVmXVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Mub2lkXG4gKiBAcGFyYW0ge09iamVjdH0gYXJncy5hdXRob3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmF1dGhvci5uYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5hdXRob3IuZW1haWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmF1dGhvci50aW1lc3RhbXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmdzLmF1dGhvci50aW1lem9uZU9mZnNldFxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3MuY29tbWl0dGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5jb21taXR0ZXIubmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuY29tbWl0dGVyLmVtYWlsXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy5jb21taXR0ZXIudGltZXN0YW1wXG4gKiBAcGFyYW0ge251bWJlcn0gYXJncy5jb21taXR0ZXIudGltZXpvbmVPZmZzZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5zaWduaW5nS2V5XVxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59XG4gKi9cblxuYXN5bmMgZnVuY3Rpb24gX3JlbW92ZU5vdGUoe1xuICBmcyxcbiAgY2FjaGUsXG4gIG9uU2lnbixcbiAgZ2l0ZGlyLFxuICByZWYgPSAncmVmcy9ub3Rlcy9jb21taXRzJyxcbiAgb2lkLFxuICBhdXRob3IsXG4gIGNvbW1pdHRlcixcbiAgc2lnbmluZ0tleSxcbn0pIHtcbiAgLy8gR2V0IHRoZSBjdXJyZW50IG5vdGUgY29tbWl0XG4gIGxldCBwYXJlbnQ7XG4gIHRyeSB7XG4gICAgcGFyZW50ID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHsgZ2l0ZGlyLCBmcywgcmVmIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBOb3RGb3VuZEVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgLy8gSSdtIHVzaW5nIHRoZSBcImVtcHR5IHRyZWVcIiBtYWdpYyBudW1iZXIgaGVyZSBmb3IgYnJldml0eVxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBfcmVhZFRyZWUoe1xuICAgIGZzLFxuICAgIGdpdGRpcixcbiAgICBvaWQ6IHBhcmVudCB8fCAnNGI4MjVkYzY0MmNiNmViOWEwNjBlNTRiZjhkNjkyODhmYmVlNDkwNCcsXG4gIH0pO1xuICBsZXQgdHJlZSA9IHJlc3VsdC50cmVlO1xuXG4gIC8vIFJlbW92ZSB0aGUgbm90ZSBibG9iIGVudHJ5IGZyb20gdGhlIHRyZWVcbiAgdHJlZSA9IHRyZWUuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LnBhdGggIT09IG9pZCk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBuZXcgbm90ZSB0cmVlXG4gIGNvbnN0IHRyZWVPaWQgPSBhd2FpdCBfd3JpdGVUcmVlKHtcbiAgICBmcyxcbiAgICBnaXRkaXIsXG4gICAgdHJlZSxcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHRoZSBuZXcgbm90ZSBjb21taXRcbiAgY29uc3QgY29tbWl0T2lkID0gYXdhaXQgX2NvbW1pdCh7XG4gICAgZnMsXG4gICAgY2FjaGUsXG4gICAgb25TaWduLFxuICAgIGdpdGRpcixcbiAgICByZWYsXG4gICAgdHJlZTogdHJlZU9pZCxcbiAgICBwYXJlbnQ6IHBhcmVudCAmJiBbcGFyZW50XSxcbiAgICBtZXNzYWdlOiBgTm90ZSByZW1vdmVkIGJ5ICdpc29tb3JwaGljLWdpdCByZW1vdmVOb3RlJ1xcbmAsXG4gICAgYXV0aG9yLFxuICAgIGNvbW1pdHRlcixcbiAgICBzaWduaW5nS2V5LFxuICB9KTtcblxuICByZXR1cm4gY29tbWl0T2lkXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFJlbW92ZSBhbiBvYmplY3Qgbm90ZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7U2lnbkNhbGxiYWNrfSBbYXJncy5vblNpZ25dIC0gYSBQR1Agc2lnbmluZyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLnJlZl0gLSBUaGUgbm90ZXMgcmVmIHRvIGxvb2sgdW5kZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9pZCAtIFRoZSBTSEEtMSBvYmplY3QgaWQgb2YgdGhlIG9iamVjdCB0byByZW1vdmUgdGhlIG5vdGUgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJncy5hdXRob3JdIC0gVGhlIGRldGFpbHMgYWJvdXQgdGhlIGF1dGhvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5hdXRob3IubmFtZV0gLSBEZWZhdWx0IGlzIGB1c2VyLm5hbWVgIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5hdXRob3IuZW1haWxdIC0gRGVmYXVsdCBpcyBgdXNlci5lbWFpbGAgY29uZmlnLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmF1dGhvci50aW1lc3RhbXA9TWF0aC5mbG9vcihEYXRlLm5vdygpLzEwMDApXSAtIFNldCB0aGUgYXV0aG9yIHRpbWVzdGFtcCBmaWVsZC4gVGhpcyBpcyB0aGUgaW50ZWdlciBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgVW5peCBlcG9jaCAoMTk3MC0wMS0wMSAwMDowMDowMCkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuYXV0aG9yLnRpbWV6b25lT2Zmc2V0XSAtIFNldCB0aGUgYXV0aG9yIHRpbWV6b25lIG9mZnNldCBmaWVsZC4gVGhpcyBpcyB0aGUgZGlmZmVyZW5jZSwgaW4gbWludXRlcywgZnJvbSB0aGUgY3VycmVudCB0aW1lem9uZSB0byBVVEMuIERlZmF1bHQgaXMgYChuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJncy5jb21taXR0ZXIgPSBhdXRob3JdIC0gVGhlIGRldGFpbHMgYWJvdXQgdGhlIG5vdGUgY29tbWl0dGVyLCBpbiB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIGF1dGhvciBwYXJhbWV0ZXIuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBhdXRob3IgZGV0YWlscyBhcmUgdXNlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb21taXR0ZXIubmFtZV0gLSBEZWZhdWx0IGlzIGB1c2VyLm5hbWVgIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5jb21taXR0ZXIuZW1haWxdIC0gRGVmYXVsdCBpcyBgdXNlci5lbWFpbGAgY29uZmlnLlxuICogQHBhcmFtIHtudW1iZXJ9IFthcmdzLmNvbW1pdHRlci50aW1lc3RhbXA9TWF0aC5mbG9vcihEYXRlLm5vdygpLzEwMDApXSAtIFNldCB0aGUgY29tbWl0dGVyIHRpbWVzdGFtcCBmaWVsZC4gVGhpcyBpcyB0aGUgaW50ZWdlciBudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSB0aGUgVW5peCBlcG9jaCAoMTk3MC0wMS0wMSAwMDowMDowMCkuXG4gKiBAcGFyYW0ge251bWJlcn0gW2FyZ3MuY29tbWl0dGVyLnRpbWV6b25lT2Zmc2V0XSAtIFNldCB0aGUgY29tbWl0dGVyIHRpbWV6b25lIG9mZnNldCBmaWVsZC4gVGhpcyBpcyB0aGUgZGlmZmVyZW5jZSwgaW4gbWludXRlcywgZnJvbSB0aGUgY3VycmVudCB0aW1lem9uZSB0byBVVEMuIERlZmF1bHQgaXMgYChuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5zaWduaW5nS2V5XSAtIFNpZ24gdGhlIHRhZyBvYmplY3QgdXNpbmcgdGhpcyBwcml2YXRlIFBHUCBrZXkuXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCB0aGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSBjb21taXQgb2JqZWN0IGZvciB0aGUgbm90ZSByZW1vdmFsLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZU5vdGUoe1xuICBmczogX2ZzLFxuICBvblNpZ24sXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlZiA9ICdyZWZzL25vdGVzL2NvbW1pdHMnLFxuICBvaWQsXG4gIGF1dGhvcjogX2F1dGhvcixcbiAgY29tbWl0dGVyOiBfY29tbWl0dGVyLFxuICBzaWduaW5nS2V5LFxuICBjYWNoZSA9IHt9LFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBfZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ29pZCcsIG9pZCk7XG5cbiAgICBjb25zdCBmcyA9IG5ldyBGaWxlU3lzdGVtKF9mcyk7XG5cbiAgICBjb25zdCBhdXRob3IgPSBhd2FpdCBub3JtYWxpemVBdXRob3JPYmplY3QoeyBmcywgZ2l0ZGlyLCBhdXRob3I6IF9hdXRob3IgfSk7XG4gICAgaWYgKCFhdXRob3IpIHRocm93IG5ldyBNaXNzaW5nTmFtZUVycm9yKCdhdXRob3InKVxuXG4gICAgY29uc3QgY29tbWl0dGVyID0gYXdhaXQgbm9ybWFsaXplQ29tbWl0dGVyT2JqZWN0KHtcbiAgICAgIGZzLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgYXV0aG9yLFxuICAgICAgY29tbWl0dGVyOiBfY29tbWl0dGVyLFxuICAgIH0pO1xuICAgIGlmICghY29tbWl0dGVyKSB0aHJvdyBuZXcgTWlzc2luZ05hbWVFcnJvcignY29tbWl0dGVyJylcblxuICAgIHJldHVybiBhd2FpdCBfcmVtb3ZlTm90ZSh7XG4gICAgICBmcyxcbiAgICAgIGNhY2hlLFxuICAgICAgb25TaWduLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmLFxuICAgICAgb2lkLFxuICAgICAgYXV0aG9yLFxuICAgICAgY29tbWl0dGVyLFxuICAgICAgc2lnbmluZ0tleSxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5yZW1vdmVOb3RlJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBSZW5hbWUgYSBicmFuY2hcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL21vZGVscy9GaWxlU3lzdGVtLmpzJykuRmlsZVN5c3RlbX0gYXJncy5mc1xuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZ2l0ZGlyXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWYgLSBUaGUgbmFtZSBvZiB0aGUgbmV3IGJyYW5jaFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3Mub2xkcmVmIC0gVGhlIG5hbWUgb2YgdGhlIG9sZCBicmFuY2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuY2hlY2tvdXQgPSBmYWxzZV1cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gZmlsZXN5c3RlbSBvcGVyYXRpb25zIGFyZSBjb21wbGV0ZVxuICovXG5hc3luYyBmdW5jdGlvbiBfcmVuYW1lQnJhbmNoKHtcbiAgZnMsXG4gIGdpdGRpcixcbiAgb2xkcmVmLFxuICByZWYsXG4gIGNoZWNrb3V0ID0gZmFsc2UsXG59KSB7XG4gIGlmIChyZWYgIT09IGNsZWFuR2l0UmVmLmNsZWFuKHJlZikpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFJlZk5hbWVFcnJvcihyZWYsIGNsZWFuR2l0UmVmLmNsZWFuKHJlZikpXG4gIH1cblxuICBpZiAob2xkcmVmICE9PSBjbGVhbkdpdFJlZi5jbGVhbihvbGRyZWYpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRSZWZOYW1lRXJyb3Iob2xkcmVmLCBjbGVhbkdpdFJlZi5jbGVhbihvbGRyZWYpKVxuICB9XG5cbiAgY29uc3QgZnVsbG9sZHJlZiA9IGByZWZzL2hlYWRzLyR7b2xkcmVmfWA7XG4gIGNvbnN0IGZ1bGxuZXdyZWYgPSBgcmVmcy9oZWFkcy8ke3JlZn1gO1xuXG4gIGNvbnN0IG5ld2V4aXN0ID0gYXdhaXQgR2l0UmVmTWFuYWdlci5leGlzdHMoeyBmcywgZ2l0ZGlyLCByZWY6IGZ1bGxuZXdyZWYgfSk7XG5cbiAgaWYgKG5ld2V4aXN0KSB7XG4gICAgdGhyb3cgbmV3IEFscmVhZHlFeGlzdHNFcnJvcignYnJhbmNoJywgcmVmLCBmYWxzZSlcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHtcbiAgICBmcyxcbiAgICBnaXRkaXIsXG4gICAgcmVmOiBmdWxsb2xkcmVmLFxuICAgIGRlcHRoOiAxLFxuICB9KTtcblxuICBhd2FpdCBHaXRSZWZNYW5hZ2VyLndyaXRlUmVmKHsgZnMsIGdpdGRpciwgcmVmOiBmdWxsbmV3cmVmLCB2YWx1ZSB9KTtcbiAgYXdhaXQgR2l0UmVmTWFuYWdlci5kZWxldGVSZWYoeyBmcywgZ2l0ZGlyLCByZWY6IGZ1bGxvbGRyZWYgfSk7XG5cbiAgaWYgKGNoZWNrb3V0KSB7XG4gICAgLy8gVXBkYXRlIEhFQURcbiAgICBhd2FpdCBHaXRSZWZNYW5hZ2VyLndyaXRlU3ltYm9saWNSZWYoe1xuICAgICAgZnMsXG4gICAgICBnaXRkaXIsXG4gICAgICByZWY6ICdIRUFEJyxcbiAgICAgIHZhbHVlOiBmdWxsbmV3cmVmLFxuICAgIH0pO1xuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFJlbmFtZSBhIGJyYW5jaFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVmIC0gV2hhdCB0byBuYW1lIHRoZSBicmFuY2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLm9sZHJlZiAtIFdoYXQgdGhlIG5hbWUgb2YgdGhlIGJyYW5jaCB3YXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FyZ3MuY2hlY2tvdXQgPSBmYWxzZV0gLSBVcGRhdGUgYEhFQURgIHRvIHBvaW50IGF0IHRoZSBuZXdseSBjcmVhdGVkIGJyYW5jaFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2hlbiBmaWxlc3lzdGVtIG9wZXJhdGlvbnMgYXJlIGNvbXBsZXRlXG4gKlxuICogQGV4YW1wbGVcbiAqIGF3YWl0IGdpdC5yZW5hbWVCcmFuY2goeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgcmVmOiAnbWFpbicsIG9sZHJlZjogJ21hc3RlcicgfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbmFtZUJyYW5jaCh7XG4gIGZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICByZWYsXG4gIG9sZHJlZixcbiAgY2hlY2tvdXQgPSBmYWxzZSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlZicsIHJlZik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdvbGRyZWYnLCBvbGRyZWYpO1xuICAgIHJldHVybiBhd2FpdCBfcmVuYW1lQnJhbmNoKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBnaXRkaXIsXG4gICAgICByZWYsXG4gICAgICBvbGRyZWYsXG4gICAgICBjaGVja291dCxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC5yZW5hbWVCcmFuY2gnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhc2hPYmplY3QkMSh7IGdpdGRpciwgdHlwZSwgb2JqZWN0IH0pIHtcbiAgcmV0dXJuIHNoYXN1bShHaXRPYmplY3Qud3JhcCh7IHR5cGUsIG9iamVjdCB9KSlcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogUmVzZXQgYSBmaWxlIGluIHRoZSBnaXQgaW5kZXggKGFrYSBzdGFnaW5nIGFyZWEpXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgZG9lcyBOT1QgbW9kaWZ5IHRoZSBmaWxlIGluIHRoZSB3b3JraW5nIGRpcmVjdG9yeS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwgJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZmlsZXBhdGggLSBUaGUgcGF0aCB0byB0aGUgZmlsZSB0byByZXNldCBpbiB0aGUgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5yZWYgPSAnSEVBRCddIC0gQSByZWYgdG8gdGhlIGNvbW1pdCB0byB1c2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBbYXJncy5jYWNoZV0gLSBhIFtjYWNoZV0oY2FjaGUubWQpIG9iamVjdFxuICpcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgb25jZSB0aGUgZ2l0IGluZGV4IGhhcyBiZWVuIHVwZGF0ZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZ2l0LnJlc2V0SW5kZXgoeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgZmlsZXBhdGg6ICdSRUFETUUubWQnIH0pXG4gKiBjb25zb2xlLmxvZygnZG9uZScpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiByZXNldEluZGV4KHtcbiAgZnM6IF9mcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgZmlsZXBhdGgsXG4gIHJlZiA9ICdIRUFEJyxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgX2ZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmaWxlcGF0aCcsIGZpbGVwYXRoKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlZicsIHJlZik7XG5cbiAgICBjb25zdCBmcyA9IG5ldyBGaWxlU3lzdGVtKF9mcyk7XG4gICAgLy8gUmVzb2x2ZSBjb21taXRcbiAgICBsZXQgb2lkID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHsgZnMsIGdpdGRpciwgcmVmIH0pO1xuICAgIGxldCB3b3JrZGlyT2lkO1xuICAgIHRyeSB7XG4gICAgICAvLyBSZXNvbHZlIGJsb2JcbiAgICAgIG9pZCA9IGF3YWl0IHJlc29sdmVGaWxlcGF0aCh7XG4gICAgICAgIGZzLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICBvaWQsXG4gICAgICAgIGZpbGVwYXRoLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gVGhpcyBtZWFucyB3ZSdyZSByZXNldHRpbmcgdGhlIGZpbGUgdG8gYSBcImRlbGV0ZWRcIiBzdGF0ZVxuICAgICAgb2lkID0gbnVsbDtcbiAgICB9XG4gICAgLy8gRm9yIGZpbGVzIHRoYXQgYXJlbid0IGluIHRoZSB3b3JrZGlyIHVzZSB6ZXJvc1xuICAgIGxldCBzdGF0cyA9IHtcbiAgICAgIGN0aW1lOiBuZXcgRGF0ZSgwKSxcbiAgICAgIG10aW1lOiBuZXcgRGF0ZSgwKSxcbiAgICAgIGRldjogMCxcbiAgICAgIGlubzogMCxcbiAgICAgIG1vZGU6IDAsXG4gICAgICB1aWQ6IDAsXG4gICAgICBnaWQ6IDAsXG4gICAgICBzaXplOiAwLFxuICAgIH07XG4gICAgLy8gSWYgdGhlIGZpbGUgZXhpc3RzIGluIHRoZSB3b3JrZGlyLi4uXG4gICAgY29uc3Qgb2JqZWN0ID0gZGlyICYmIChhd2FpdCBmcy5yZWFkKGpvaW4oZGlyLCBmaWxlcGF0aCkpKTtcbiAgICBpZiAob2JqZWN0KSB7XG4gICAgICAvLyAuLi4gYW5kIGhhcyB0aGUgc2FtZSBoYXNoIGFzIHRoZSBkZXNpcmVkIHN0YXRlLi4uXG4gICAgICB3b3JrZGlyT2lkID0gYXdhaXQgaGFzaE9iamVjdCQxKHtcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICB0eXBlOiAnYmxvYicsXG4gICAgICAgIG9iamVjdCxcbiAgICAgIH0pO1xuICAgICAgaWYgKG9pZCA9PT0gd29ya2Rpck9pZCkge1xuICAgICAgICAvLyAuLi4gdXNlIHRoZSB3b3JrZGlyIFN0YXRzIG9iamVjdFxuICAgICAgICBzdGF0cyA9IGF3YWl0IGZzLmxzdGF0KGpvaW4oZGlyLCBmaWxlcGF0aCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCBHaXRJbmRleE1hbmFnZXIuYWNxdWlyZSh7IGZzLCBnaXRkaXIsIGNhY2hlIH0sIGFzeW5jIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpbmRleC5kZWxldGUoeyBmaWxlcGF0aCB9KTtcbiAgICAgIGlmIChvaWQpIHtcbiAgICAgICAgaW5kZXguaW5zZXJ0KHsgZmlsZXBhdGgsIHN0YXRzLCBvaWQgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LnJlc2V0JztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIG9mIGEgc3ltYm9saWMgcmVmIG9yIHJlc29sdmUgYSByZWYgdG8gaXRzIFNIQS0xIG9iamVjdCBpZFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCAnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5yZWYgLSBUaGUgcmVmIHRvIHJlc29sdmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJncy5kZXB0aCA9IHVuZGVmaW5lZF0gLSBIb3cgbWFueSBzeW1ib2xpYyByZWZlcmVuY2VzIHRvIGZvbGxvdyBiZWZvcmUgcmV0dXJuaW5nXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggYSBTSEEtMSBvYmplY3QgaWQgb3IgdGhlIHZhbHVlIG9mIGEgc3ltYm9saWMgcmVmXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCBjdXJyZW50Q29tbWl0ID0gYXdhaXQgZ2l0LnJlc29sdmVSZWYoeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgcmVmOiAnSEVBRCcgfSlcbiAqIGNvbnNvbGUubG9nKGN1cnJlbnRDb21taXQpXG4gKiBsZXQgY3VycmVudEJyYW5jaCA9IGF3YWl0IGdpdC5yZXNvbHZlUmVmKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIHJlZjogJ0hFQUQnLCBkZXB0aDogMiB9KVxuICogY29uc29sZS5sb2coY3VycmVudEJyYW5jaClcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVSZWYoe1xuICBmcyxcbiAgZGlyLFxuICBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSxcbiAgcmVmLFxuICBkZXB0aCxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlZicsIHJlZik7XG5cbiAgICBjb25zdCBvaWQgPSBhd2FpdCBHaXRSZWZNYW5hZ2VyLnJlc29sdmUoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGdpdGRpcixcbiAgICAgIHJlZixcbiAgICAgIGRlcHRoLFxuICAgIH0pO1xuICAgIHJldHVybiBvaWRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQucmVzb2x2ZVJlZic7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogV3JpdGUgYW4gZW50cnkgdG8gdGhlIGdpdCBjb25maWcgZmlsZXMuXG4gKlxuICogKkNhdmVhdHM6KlxuICogLSBDdXJyZW50bHkgb25seSB0aGUgbG9jYWwgYCRHSVRfRElSL2NvbmZpZ2AgZmlsZSBjYW4gYmUgcmVhZCBvciB3cml0dGVuLiBIb3dldmVyIHN1cHBvcnQgZm9yIHRoZSBnbG9iYWwgYH4vLmdpdGNvbmZpZ2AgYW5kIHN5c3RlbSBgJChwcmVmaXgpL2V0Yy9naXRjb25maWdgIHdpbGwgYmUgYWRkZWQgaW4gdGhlIGZ1dHVyZS5cbiAqIC0gVGhlIGN1cnJlbnQgcGFyc2VyIGRvZXMgbm90IHN1cHBvcnQgdGhlIG1vcmUgZXhvdGljIGZlYXR1cmVzIG9mIHRoZSBnaXQtY29uZmlnIGZpbGUgZm9ybWF0IHN1Y2ggYXMgYFtpbmNsdWRlXWAgYW5kIGBbaW5jbHVkZUlmXWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gYXJncy5wYXRoIC0gVGhlIGtleSBvZiB0aGUgZ2l0IGNvbmZpZyBlbnRyeVxuICogQHBhcmFtIHtzdHJpbmcgfCBib29sZWFuIHwgbnVtYmVyIHwgdm9pZH0gYXJncy52YWx1ZSAtIEEgdmFsdWUgdG8gc3RvcmUgYXQgdGhhdCBwYXRoLiAoVXNlIGB1bmRlZmluZWRgIGFzIHRoZSB2YWx1ZSB0byBkZWxldGUgYSBjb25maWcgZW50cnkuKVxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5hcHBlbmQgPSBmYWxzZV0gLSBJZiB0cnVlLCB3aWxsIGFwcGVuZCByYXRoZXIgdGhhbiByZXBsYWNlIHdoZW4gc2V0dGluZyAodXNlIHdpdGggbXVsdGktdmFsdWVkIGNvbmZpZyBvcHRpb25zKS5cbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdoZW4gb3BlcmF0aW9uIGNvbXBsZXRlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBXcml0ZSBjb25maWcgdmFsdWVcbiAqIGF3YWl0IGdpdC5zZXRDb25maWcoe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgcGF0aDogJ3VzZXIubmFtZScsXG4gKiAgIHZhbHVlOiAnTXIuIFRlc3QnXG4gKiB9KVxuICpcbiAqIC8vIFByaW50IG91dCBjb25maWcgZmlsZVxuICogbGV0IGZpbGUgPSBhd2FpdCBmcy5wcm9taXNlcy5yZWFkRmlsZSgnL3R1dG9yaWFsLy5naXQvY29uZmlnJywgJ3V0ZjgnKVxuICogY29uc29sZS5sb2coZmlsZSlcbiAqXG4gKiAvLyBEZWxldGUgYSBjb25maWcgZW50cnlcbiAqIGF3YWl0IGdpdC5zZXRDb25maWcoe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgcGF0aDogJ3VzZXIubmFtZScsXG4gKiAgIHZhbHVlOiB1bmRlZmluZWRcbiAqIH0pXG4gKlxuICogLy8gUHJpbnQgb3V0IGNvbmZpZyBmaWxlXG4gKiBmaWxlID0gYXdhaXQgZnMucHJvbWlzZXMucmVhZEZpbGUoJy90dXRvcmlhbC8uZ2l0L2NvbmZpZycsICd1dGY4JylcbiAqIGNvbnNvbGUubG9nKGZpbGUpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNldENvbmZpZyh7XG4gIGZzOiBfZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHBhdGgsXG4gIHZhbHVlLFxuICBhcHBlbmQgPSBmYWxzZSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgX2ZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdwYXRoJywgcGF0aCk7XG4gICAgLy8gYXNzZXJ0UGFyYW1ldGVyKCd2YWx1ZScsIHZhbHVlKSAvLyBXZSBhY3R1YWxseSBhbGxvdyAndW5kZWZpbmVkJyBhcyBhIHZhbHVlIHRvIHVuc2V0L2RlbGV0ZVxuXG4gICAgY29uc3QgZnMgPSBuZXcgRmlsZVN5c3RlbShfZnMpO1xuICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuZ2V0KHsgZnMsIGdpdGRpciB9KTtcbiAgICBpZiAoYXBwZW5kKSB7XG4gICAgICBhd2FpdCBjb25maWcuYXBwZW5kKHBhdGgsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgY29uZmlnLnNldChwYXRoLCB2YWx1ZSk7XG4gICAgfVxuICAgIGF3YWl0IEdpdENvbmZpZ01hbmFnZXIuc2F2ZSh7IGZzLCBnaXRkaXIsIGNvbmZpZyB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuc2V0Q29uZmlnJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBUZWxsIHdoZXRoZXIgYSBmaWxlIGhhcyBiZWVuIGNoYW5nZWRcbiAqXG4gKiBUaGUgcG9zc2libGUgcmVzb2x2ZSB2YWx1ZXMgYXJlOlxuICpcbiAqIHwgc3RhdHVzICAgICAgICAgICAgICAgIHwgZGVzY3JpcHRpb24gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxuICogfCBgXCJpZ25vcmVkXCJgICAgICAgICAgICB8IGZpbGUgaWdub3JlZCBieSBhIC5naXRpZ25vcmUgcnVsZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgXCJ1bm1vZGlmaWVkXCJgICAgICAgICB8IGZpbGUgdW5jaGFuZ2VkIGZyb20gSEVBRCBjb21taXQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgXCIqbW9kaWZpZWRcImAgICAgICAgICB8IGZpbGUgaGFzIG1vZGlmaWNhdGlvbnMsIG5vdCB5ZXQgc3RhZ2VkICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgXCIqZGVsZXRlZFwiYCAgICAgICAgICB8IGZpbGUgaGFzIGJlZW4gcmVtb3ZlZCwgYnV0IHRoZSByZW1vdmFsIGlzIG5vdCB5ZXQgc3RhZ2VkICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgXCIqYWRkZWRcImAgICAgICAgICAgICB8IGZpbGUgaXMgdW50cmFja2VkLCBub3QgeWV0IHN0YWdlZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgXCJhYnNlbnRcImAgICAgICAgICAgICB8IGZpbGUgbm90IHByZXNlbnQgaW4gSEVBRCBjb21taXQsIHN0YWdpbmcgYXJlYSwgb3Igd29ya2luZyBkaXIgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgXCJtb2RpZmllZFwiYCAgICAgICAgICB8IGZpbGUgaGFzIG1vZGlmaWNhdGlvbnMsIHN0YWdlZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgXCJkZWxldGVkXCJgICAgICAgICAgICB8IGZpbGUgaGFzIGJlZW4gcmVtb3ZlZCwgc3RhZ2VkICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgXCJhZGRlZFwiYCAgICAgICAgICAgICB8IHByZXZpb3VzbHkgdW50cmFja2VkIGZpbGUsIHN0YWdlZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgXCIqdW5tb2RpZmllZFwiYCAgICAgICB8IHdvcmtpbmcgZGlyIGFuZCBIRUFEIGNvbW1pdCBtYXRjaCwgYnV0IGluZGV4IGRpZmZlcnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgXCIqYWJzZW50XCJgICAgICAgICAgICB8IGZpbGUgbm90IHByZXNlbnQgaW4gd29ya2luZyBkaXIgb3IgSEVBRCBjb21taXQsIGJ1dCBwcmVzZW50IGluIHRoZSBpbmRleCAgICAgICAgICAgICAgfFxuICogfCBgXCIqdW5kZWxldGVkXCJgICAgICAgICB8IGZpbGUgd2FzIGRlbGV0ZWQgZnJvbSB0aGUgaW5kZXgsIGJ1dCBpcyBzdGlsbCBpbiB0aGUgd29ya2luZyBkaXIgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCBgXCIqdW5kZWxldGVtb2RpZmllZFwiYCB8IGZpbGUgd2FzIGRlbGV0ZWQgZnJvbSB0aGUgaW5kZXgsIGJ1dCBpcyBwcmVzZW50IHdpdGggbW9kaWZpY2F0aW9ucyBpbiB0aGUgd29ya2luZyBkaXIgfFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmRpciAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwgJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZmlsZXBhdGggLSBUaGUgcGF0aCB0byB0aGUgZmlsZSB0byBxdWVyeVxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8J2lnbm9yZWQnfCd1bm1vZGlmaWVkJ3wnKm1vZGlmaWVkJ3wnKmRlbGV0ZWQnfCcqYWRkZWQnfCdhYnNlbnQnfCdtb2RpZmllZCd8J2RlbGV0ZWQnfCdhZGRlZCd8Jyp1bm1vZGlmaWVkJ3wnKmFic2VudCd8Jyp1bmRlbGV0ZWQnfCcqdW5kZWxldGVtb2RpZmllZCc+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCB0aGUgZmlsZSdzIGdpdCBzdGF0dXNcbiAqXG4gKiBAZXhhbXBsZVxuICogbGV0IHN0YXR1cyA9IGF3YWl0IGdpdC5zdGF0dXMoeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgZmlsZXBhdGg6ICdSRUFETUUubWQnIH0pXG4gKiBjb25zb2xlLmxvZyhzdGF0dXMpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBzdGF0dXMoe1xuICBmczogX2ZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICBmaWxlcGF0aCxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgX2ZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmaWxlcGF0aCcsIGZpbGVwYXRoKTtcblxuICAgIGNvbnN0IGZzID0gbmV3IEZpbGVTeXN0ZW0oX2ZzKTtcbiAgICBjb25zdCBpZ25vcmVkID0gYXdhaXQgR2l0SWdub3JlTWFuYWdlci5pc0lnbm9yZWQoe1xuICAgICAgZnMsXG4gICAgICBnaXRkaXIsXG4gICAgICBkaXIsXG4gICAgICBmaWxlcGF0aCxcbiAgICB9KTtcbiAgICBpZiAoaWdub3JlZCkge1xuICAgICAgcmV0dXJuICdpZ25vcmVkJ1xuICAgIH1cbiAgICBjb25zdCBoZWFkVHJlZSA9IGF3YWl0IGdldEhlYWRUcmVlKHsgZnMsIGNhY2hlLCBnaXRkaXIgfSk7XG4gICAgY29uc3QgdHJlZU9pZCA9IGF3YWl0IGdldE9pZEF0UGF0aCh7XG4gICAgICBmcyxcbiAgICAgIGNhY2hlLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgdHJlZTogaGVhZFRyZWUsXG4gICAgICBwYXRoOiBmaWxlcGF0aCxcbiAgICB9KTtcbiAgICBjb25zdCBpbmRleEVudHJ5ID0gYXdhaXQgR2l0SW5kZXhNYW5hZ2VyLmFjcXVpcmUoXG4gICAgICB7IGZzLCBnaXRkaXIsIGNhY2hlIH0sXG4gICAgICBhc3luYyBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGluZGV4KSB7XG4gICAgICAgICAgaWYgKGVudHJ5LnBhdGggPT09IGZpbGVwYXRoKSByZXR1cm4gZW50cnlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICk7XG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBmcy5sc3RhdChqb2luKGRpciwgZmlsZXBhdGgpKTtcblxuICAgIGNvbnN0IEggPSB0cmVlT2lkICE9PSBudWxsOyAvLyBoZWFkXG4gICAgY29uc3QgSSA9IGluZGV4RW50cnkgIT09IG51bGw7IC8vIGluZGV4XG4gICAgY29uc3QgVyA9IHN0YXRzICE9PSBudWxsOyAvLyB3b3JraW5nIGRpclxuXG4gICAgY29uc3QgZ2V0V29ya2Rpck9pZCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmIChJICYmICFjb21wYXJlU3RhdHMoaW5kZXhFbnRyeSwgc3RhdHMpKSB7XG4gICAgICAgIHJldHVybiBpbmRleEVudHJ5Lm9pZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gYXdhaXQgZnMucmVhZChqb2luKGRpciwgZmlsZXBhdGgpKTtcbiAgICAgICAgY29uc3Qgd29ya2Rpck9pZCA9IGF3YWl0IGhhc2hPYmplY3QkMSh7XG4gICAgICAgICAgZ2l0ZGlyLFxuICAgICAgICAgIHR5cGU6ICdibG9iJyxcbiAgICAgICAgICBvYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZiB0aGUgb2lkIGluIHRoZSBpbmRleCA9PT0gd29ya2luZyBkaXIgb2lkIGJ1dCBzdGF0cyBkaWZmZXJlZCB1cGRhdGUgY2FjaGVcbiAgICAgICAgaWYgKEkgJiYgaW5kZXhFbnRyeS5vaWQgPT09IHdvcmtkaXJPaWQpIHtcbiAgICAgICAgICAvLyBhbmQgYXMgbG9uZyBhcyBvdXIgZnMuc3RhdHMgYXJlbid0IGJhZC5cbiAgICAgICAgICAvLyBzaXplIG9mIC0xIGhhcHBlbnMgb3ZlciBhIEJyb3dzZXJGUyBIVFRQIEJhY2tlbmQgdGhhdCBkb2Vzbid0IHNlcnZlIENvbnRlbnQtTGVuZ3RoIGhlYWRlcnNcbiAgICAgICAgICAvLyAobGlrZSB0aGUgS2FybWEgd2Vic2VydmVyKSBiZWNhdXNlIEJyb3dzZXJGUyBIVFRQIEJhY2tlbmQgdXNlcyBIVFRQIEhFQUQgcmVxdWVzdHMgdG8gZG8gZnMuc3RhdFxuICAgICAgICAgIGlmIChzdGF0cy5zaXplICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgYXdhaXQgdGhpcyBzbyB3ZSBjYW4gcmV0dXJuIGZhc3RlciBmb3Igb25lLW9mZiBjYXNlcy5cbiAgICAgICAgICAgIEdpdEluZGV4TWFuYWdlci5hY3F1aXJlKHsgZnMsIGdpdGRpciwgY2FjaGUgfSwgYXN5bmMgZnVuY3Rpb24oXG4gICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaW5kZXguaW5zZXJ0KHsgZmlsZXBhdGgsIHN0YXRzLCBvaWQ6IHdvcmtkaXJPaWQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmtkaXJPaWRcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFIICYmICFXICYmICFJKSByZXR1cm4gJ2Fic2VudCcgLy8gLS0tXG4gICAgaWYgKCFIICYmICFXICYmIEkpIHJldHVybiAnKmFic2VudCcgLy8gLUEtXG4gICAgaWYgKCFIICYmIFcgJiYgIUkpIHJldHVybiAnKmFkZGVkJyAvLyAtLUFcbiAgICBpZiAoIUggJiYgVyAmJiBJKSB7XG4gICAgICBjb25zdCB3b3JrZGlyT2lkID0gYXdhaXQgZ2V0V29ya2Rpck9pZCgpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmV0dXJuIHdvcmtkaXJPaWQgPT09IGluZGV4RW50cnkub2lkID8gJ2FkZGVkJyA6ICcqYWRkZWQnIC8vIC1BQSA6IC1BQlxuICAgIH1cbiAgICBpZiAoSCAmJiAhVyAmJiAhSSkgcmV0dXJuICdkZWxldGVkJyAvLyBBLS1cbiAgICBpZiAoSCAmJiAhVyAmJiBJKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICByZXR1cm4gdHJlZU9pZCA9PT0gaW5kZXhFbnRyeS5vaWQgPyAnKmRlbGV0ZWQnIDogJypkZWxldGVkJyAvLyBBQS0gOiBBQi1cbiAgICB9XG4gICAgaWYgKEggJiYgVyAmJiAhSSkge1xuICAgICAgY29uc3Qgd29ya2Rpck9pZCA9IGF3YWl0IGdldFdvcmtkaXJPaWQoKTtcbiAgICAgIHJldHVybiB3b3JrZGlyT2lkID09PSB0cmVlT2lkID8gJyp1bmRlbGV0ZWQnIDogJyp1bmRlbGV0ZW1vZGlmaWVkJyAvLyBBLUEgOiBBLUJcbiAgICB9XG4gICAgaWYgKEggJiYgVyAmJiBJKSB7XG4gICAgICBjb25zdCB3b3JrZGlyT2lkID0gYXdhaXQgZ2V0V29ya2Rpck9pZCgpO1xuICAgICAgaWYgKHdvcmtkaXJPaWQgPT09IHRyZWVPaWQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gd29ya2Rpck9pZCA9PT0gaW5kZXhFbnRyeS5vaWQgPyAndW5tb2RpZmllZCcgOiAnKnVubW9kaWZpZWQnIC8vIEFBQSA6IEFCQVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gd29ya2Rpck9pZCA9PT0gaW5kZXhFbnRyeS5vaWQgPyAnbW9kaWZpZWQnIDogJyptb2RpZmllZCcgLy8gQUJCIDogQUFCXG4gICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgLS0tXG4gICAgLUEtXG4gICAgLS1BXG4gICAgLUFBXG4gICAgLUFCXG4gICAgQS0tXG4gICAgQUEtXG4gICAgQUItXG4gICAgQS1BXG4gICAgQS1CXG4gICAgQUFBXG4gICAgQUJBXG4gICAgQUJCXG4gICAgQUFCXG4gICAgKi9cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQuc3RhdHVzJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRPaWRBdFBhdGgoeyBmcywgY2FjaGUsIGdpdGRpciwgdHJlZSwgcGF0aCB9KSB7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBwYXRoLnNwbGl0KCcvJyk7XG4gIGNvbnN0IGRpcm5hbWUgPSBwYXRoLnNoaWZ0KCk7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgdHJlZSkge1xuICAgIGlmIChlbnRyeS5wYXRoID09PSBkaXJuYW1lKSB7XG4gICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5Lm9pZFxuICAgICAgfVxuICAgICAgY29uc3QgeyB0eXBlLCBvYmplY3QgfSA9IGF3YWl0IF9yZWFkT2JqZWN0KHtcbiAgICAgICAgZnMsXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBnaXRkaXIsXG4gICAgICAgIG9pZDogZW50cnkub2lkLFxuICAgICAgfSk7XG4gICAgICBpZiAodHlwZSA9PT0gJ3RyZWUnKSB7XG4gICAgICAgIGNvbnN0IHRyZWUgPSBHaXRUcmVlLmZyb20ob2JqZWN0KTtcbiAgICAgICAgcmV0dXJuIGdldE9pZEF0UGF0aCh7IGZzLCBjYWNoZSwgZ2l0ZGlyLCB0cmVlLCBwYXRoIH0pXG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICAgIHRocm93IG5ldyBPYmplY3RUeXBlRXJyb3IoZW50cnkub2lkLCB0eXBlLCAnYmxvYicsIHBhdGguam9pbignLycpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRIZWFkVHJlZSh7IGZzLCBjYWNoZSwgZ2l0ZGlyIH0pIHtcbiAgLy8gR2V0IHRoZSB0cmVlIGZyb20gdGhlIEhFQUQgY29tbWl0LlxuICBsZXQgb2lkO1xuICB0cnkge1xuICAgIG9pZCA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7IGZzLCBnaXRkaXIsIHJlZjogJ0hFQUQnIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSGFuZGxlIGZyZXNoIGJyYW5jaGVzIHdpdGggbm8gY29tbWl0c1xuICAgIGlmIChlIGluc3RhbmNlb2YgTm90Rm91bmRFcnJvcikge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICB9XG4gIGNvbnN0IHsgdHJlZSB9ID0gYXdhaXQgX3JlYWRUcmVlKHsgZnMsIGNhY2hlLCBnaXRkaXIsIG9pZCB9KTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogRWZmaWNpZW50bHkgZ2V0IHRoZSBzdGF0dXMgb2YgbXVsdGlwbGUgZmlsZXMgYXQgb25jZS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgYFN0YXR1c01hdHJpeGAgaXMgYWRtaXR0ZWRseSBub3QgdGhlIGVhc2llc3QgZm9ybWF0IHRvIHJlYWQuXG4gKiBIb3dldmVyIGl0IGNvbnZleXMgYSBsYXJnZSBhbW91bnQgb2YgaW5mb3JtYXRpb24gaW4gZGVuc2UgZm9ybWF0IHRoYXQgc2hvdWxkIG1ha2UgaXQgZWFzeSB0byBjcmVhdGUgcmVwb3J0cyBhYm91dCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcmVwb3NpdG9yeTtcbiAqIHdpdGhvdXQgaGF2aW5nIHRvIGRvIG11bHRpcGxlLCB0aW1lLWNvbnN1bWluZyBpc29tb3JwaGljLWdpdCBjYWxscy5cbiAqIE15IGhvcGUgaXMgdGhhdCB0aGUgc3BlZWQgYW5kIGZsZXhpYmlsaXR5IG9mIHRoZSBmdW5jdGlvbiB3aWxsIG1ha2UgdXAgZm9yIHRoZSBsZWFybmluZyBjdXJ2ZSBvZiBpbnRlcnByZXRpbmcgdGhlIHJldHVybiB2YWx1ZS5cbiAqXG4gKiBgYGBqcyBsaXZlXG4gKiAvLyBnZXQgdGhlIHN0YXR1cyBvZiBhbGwgdGhlIGZpbGVzIGluICdzcmMnXG4gKiBsZXQgc3RhdHVzID0gYXdhaXQgZ2l0LnN0YXR1c01hdHJpeCh7XG4gKiAgIGZzLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICBmaWx0ZXI6IGYgPT4gZi5zdGFydHNXaXRoKCdzcmMvJylcbiAqIH0pXG4gKiBjb25zb2xlLmxvZyhzdGF0dXMpXG4gKiBgYGBcbiAqXG4gKiBgYGBqcyBsaXZlXG4gKiAvLyBnZXQgdGhlIHN0YXR1cyBvZiBhbGwgdGhlIEpTT04gYW5kIE1hcmtkb3duIGZpbGVzXG4gKiBsZXQgc3RhdHVzID0gYXdhaXQgZ2l0LnN0YXR1c01hdHJpeCh7XG4gKiAgIGZzLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICBmaWx0ZXI6IGYgPT4gZi5lbmRzV2l0aCgnLmpzb24nKSB8fCBmLmVuZHNXaXRoKCcubWQnKVxuICogfSlcbiAqIGNvbnNvbGUubG9nKHN0YXR1cylcbiAqIGBgYFxuICpcbiAqIFRoZSByZXN1bHQgaXMgcmV0dXJuZWQgYXMgYSAyRCBhcnJheS5cbiAqIFRoZSBvdXRlciBhcnJheSByZXByZXNlbnRzIHRoZSBmaWxlcyBhbmQvb3IgYmxvYnMgaW4gdGhlIHJlcG8sIGluIGFscGhhYmV0aWNhbCBvcmRlci5cbiAqIFRoZSBpbm5lciBhcnJheXMgZGVzY3JpYmUgdGhlIHN0YXR1cyBvZiB0aGUgZmlsZTpcbiAqIHRoZSBmaXJzdCB2YWx1ZSBpcyB0aGUgZmlsZXBhdGgsIGFuZCB0aGUgbmV4dCB0aHJlZSBhcmUgaW50ZWdlcnNcbiAqIHJlcHJlc2VudGluZyB0aGUgSEVBRCBzdGF0dXMsIFdPUktESVIgc3RhdHVzLCBhbmQgU1RBR0Ugc3RhdHVzIG9mIHRoZSBlbnRyeS5cbiAqXG4gKiBgYGBqc1xuICogLy8gZXhhbXBsZSBTdGF0dXNNYXRyaXhcbiAqIFtcbiAqICAgW1wiYS50eHRcIiwgMCwgMiwgMF0sIC8vIG5ldywgdW50cmFja2VkXG4gKiAgIFtcImIudHh0XCIsIDAsIDIsIDJdLCAvLyBhZGRlZCwgc3RhZ2VkXG4gKiAgIFtcImMudHh0XCIsIDAsIDIsIDNdLCAvLyBhZGRlZCwgc3RhZ2VkLCB3aXRoIHVuc3RhZ2VkIGNoYW5nZXNcbiAqICAgW1wiZC50eHRcIiwgMSwgMSwgMV0sIC8vIHVubW9kaWZpZWRcbiAqICAgW1wiZS50eHRcIiwgMSwgMiwgMV0sIC8vIG1vZGlmaWVkLCB1bnN0YWdlZFxuICogICBbXCJmLnR4dFwiLCAxLCAyLCAyXSwgLy8gbW9kaWZpZWQsIHN0YWdlZFxuICogICBbXCJnLnR4dFwiLCAxLCAyLCAzXSwgLy8gbW9kaWZpZWQsIHN0YWdlZCwgd2l0aCB1bnN0YWdlZCBjaGFuZ2VzXG4gKiAgIFtcImgudHh0XCIsIDEsIDAsIDFdLCAvLyBkZWxldGVkLCB1bnN0YWdlZFxuICogICBbXCJpLnR4dFwiLCAxLCAwLCAwXSwgLy8gZGVsZXRlZCwgc3RhZ2VkXG4gKiBdXG4gKiBgYGBcbiAqXG4gKiAtIFRoZSBIRUFEIHN0YXR1cyBpcyBlaXRoZXIgYWJzZW50ICgwKSBvciBwcmVzZW50ICgxKS5cbiAqIC0gVGhlIFdPUktESVIgc3RhdHVzIGlzIGVpdGhlciBhYnNlbnQgKDApLCBpZGVudGljYWwgdG8gSEVBRCAoMSksIG9yIGRpZmZlcmVudCBmcm9tIEhFQUQgKDIpLlxuICogLSBUaGUgU1RBR0Ugc3RhdHVzIGlzIGVpdGhlciBhYnNlbnQgKDApLCBpZGVudGljYWwgdG8gSEVBRCAoMSksIGlkZW50aWNhbCB0byBXT1JLRElSICgyKSwgb3IgZGlmZmVyZW50IGZyb20gV09SS0RJUiAoMykuXG4gKlxuICogYGBgdHNcbiAqIHR5cGUgRmlsZW5hbWUgICAgICA9IHN0cmluZ1xuICogdHlwZSBIZWFkU3RhdHVzICAgID0gMCB8IDFcbiAqIHR5cGUgV29ya2RpclN0YXR1cyA9IDAgfCAxIHwgMlxuICogdHlwZSBTdGFnZVN0YXR1cyAgID0gMCB8IDEgfCAyIHwgM1xuICpcbiAqIHR5cGUgU3RhdHVzUm93ICAgICA9IFtGaWxlbmFtZSwgSGVhZFN0YXR1cywgV29ya2RpclN0YXR1cywgU3RhZ2VTdGF0dXNdXG4gKlxuICogdHlwZSBTdGF0dXNNYXRyaXggID0gU3RhdHVzUm93W11cbiAqIGBgYFxuICpcbiAqID4gVGhpbmsgb2YgdGhlIG5hdHVyYWwgcHJvZ3Jlc3Npb24gb2YgZmlsZSBtb2RpZmljYXRpb25zIGFzIGJlaW5nIGZyb20gSEVBRCAocHJldmlvdXMpIC0+IFdPUktESVIgKGN1cnJlbnQpIC0+IFNUQUdFIChuZXh0KS5cbiAqID4gVGhlbiBIRUFEIGlzIFwidmVyc2lvbiAxXCIsIFdPUktESVIgaXMgXCJ2ZXJzaW9uIDJcIiwgYW5kIFNUQUdFIGlzIFwidmVyc2lvbiAzXCIuXG4gKiA+IFRoZW4sIGltYWdpbmUgYSBcInZlcnNpb24gMFwiIHdoaWNoIGlzIGJlZm9yZSB0aGUgZmlsZSB3YXMgY3JlYXRlZC5cbiAqID4gVGhlbiB0aGUgc3RhdHVzIHZhbHVlIGluIGVhY2ggY29sdW1uIGNvcnJlc3BvbmRzIHRvIHRoZSBvbGRlc3QgdmVyc2lvbiBvZiB0aGUgZmlsZSBpdCBpcyBpZGVudGljYWwgdG8uXG4gKiA+IChGb3IgYSBmaWxlIHRvIGJlIGlkZW50aWNhbCB0byBcInZlcnNpb24gMFwiIG1lYW5zIHRoZSBmaWxlIGlzIGRlbGV0ZWQuKVxuICpcbiAqIEhlcmUgYXJlIHNvbWUgZXhhbXBsZXMgb2YgcXVlcmllcyB5b3UgY2FuIGFuc3dlciB1c2luZyB0aGUgcmVzdWx0OlxuICpcbiAqICMjIyMgUTogV2hhdCBmaWxlcyBoYXZlIGJlZW4gZGVsZXRlZD9cbiAqIGBgYGpzXG4gKiBjb25zdCBGSUxFID0gMCwgV09SS0RJUiA9IDJcbiAqXG4gKiBjb25zdCBmaWxlbmFtZXMgPSAoYXdhaXQgc3RhdHVzTWF0cml4KHsgZGlyIH0pKVxuICogICAuZmlsdGVyKHJvdyA9PiByb3dbV09SS0RJUl0gPT09IDApXG4gKiAgIC5tYXAocm93ID0+IHJvd1tGSUxFXSlcbiAqIGBgYFxuICpcbiAqICMjIyMgUTogV2hhdCBmaWxlcyBoYXZlIHVuc3RhZ2VkIGNoYW5nZXM/XG4gKiBgYGBqc1xuICogY29uc3QgRklMRSA9IDAsIFdPUktESVIgPSAyLCBTVEFHRSA9IDNcbiAqXG4gKiBjb25zdCBmaWxlbmFtZXMgPSAoYXdhaXQgc3RhdHVzTWF0cml4KHsgZGlyIH0pKVxuICogICAuZmlsdGVyKHJvdyA9PiByb3dbV09SS0RJUl0gIT09IHJvd1tTVEFHRV0pXG4gKiAgIC5tYXAocm93ID0+IHJvd1tGSUxFXSlcbiAqIGBgYFxuICpcbiAqICMjIyMgUTogV2hhdCBmaWxlcyBoYXZlIGJlZW4gbW9kaWZpZWQgc2luY2UgdGhlIGxhc3QgY29tbWl0P1xuICogYGBganNcbiAqIGNvbnN0IEZJTEUgPSAwLCBIRUFEID0gMSwgV09SS0RJUiA9IDJcbiAqXG4gKiBjb25zdCBmaWxlbmFtZXMgPSAoYXdhaXQgc3RhdHVzTWF0cml4KHsgZGlyIH0pKVxuICogICAuZmlsdGVyKHJvdyA9PiByb3dbSEVBRF0gIT09IHJvd1tXT1JLRElSXSlcbiAqICAgLm1hcChyb3cgPT4gcm93W0ZJTEVdKVxuICogYGBgXG4gKlxuICogIyMjIyBROiBXaGF0IGZpbGVzIHdpbGwgTk9UIGJlIGNoYW5nZWQgaWYgSSBjb21taXQgcmlnaHQgbm93P1xuICogYGBganNcbiAqIGNvbnN0IEZJTEUgPSAwLCBIRUFEID0gMSwgU1RBR0UgPSAzXG4gKlxuICogY29uc3QgZmlsZW5hbWVzID0gKGF3YWl0IHN0YXR1c01hdHJpeCh7IGRpciB9KSlcbiAqICAgLmZpbHRlcihyb3cgPT4gcm93W0hFQURdID09PSByb3dbU1RBR0VdKVxuICogICAubWFwKHJvdyA9PiByb3dbRklMRV0pXG4gKiBgYGBcbiAqXG4gKiBGb3IgcmVmZXJlbmNlLCBoZXJlIGFyZSBhbGwgcG9zc2libGUgY29tYmluYXRpb25zOlxuICpcbiAqIHwgSEVBRCB8IFdPUktESVIgfCBTVEFHRSB8IGBnaXQgc3RhdHVzIC0tc2hvcnRgIGVxdWl2YWxlbnQgfFxuICogfCAtLS0tIHwgLS0tLS0tLSB8IC0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiB8IDAgICAgfCAwICAgICAgIHwgMCAgICAgfCBgYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMCAgICB8IDAgICAgICAgfCAzICAgICB8IGBBRGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAwICAgIHwgMiAgICAgICB8IDAgICAgIHwgYD8/YCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IDAgICAgfCAyICAgICAgIHwgMiAgICAgfCBgQSBgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMCAgICB8IDIgICAgICAgfCAzICAgICB8IGBBTWAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAxICAgIHwgMCAgICAgICB8IDAgICAgIHwgYEQgYCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IDEgICAgfCAwICAgICAgIHwgMSAgICAgfCBgIERgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMSAgICB8IDAgICAgICAgfCAzICAgICB8IGBNRGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAxICAgIHwgMSAgICAgICB8IDAgICAgIHwgYEQgYCArIGA/P2AgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IDEgICAgfCAxICAgICAgIHwgMSAgICAgfCBgYCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMSAgICB8IDEgICAgICAgfCAzICAgICB8IGBNTWAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAxICAgIHwgMiAgICAgICB8IDAgICAgIHwgYEQgYCArIGA/P2AgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IDEgICAgfCAyICAgICAgIHwgMSAgICAgfCBgIE1gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgMSAgICB8IDIgICAgICAgfCAyICAgICB8IGBNIGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAxICAgIHwgMiAgICAgICB8IDMgICAgIHwgYE1NYCAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MuZGlyIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCAnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MucmVmID0gJ0hFQUQnXSAtIE9wdGlvbmFsbHkgc3BlY2lmeSBhIGRpZmZlcmVudCBjb21taXQgdG8gY29tcGFyZSBhZ2FpbnN0IHRoZSB3b3JrZGlyIGFuZCBzdGFnZSBpbnN0ZWFkIG9mIHRoZSBIRUFEXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbYXJncy5maWxlcGF0aHMgPSBbJy4nXV0gLSBMaW1pdCB0aGUgcXVlcnkgdG8gdGhlIGdpdmVuIGZpbGVzIGFuZCBkaXJlY3Rvcmllc1xuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcpOiBib29sZWFufSBbYXJncy5maWx0ZXJdIC0gRmlsdGVyIHRoZSByZXN1bHRzIHRvIG9ubHkgdGhvc2Ugd2hvc2UgZmlsZXBhdGggbWF0Y2hlcyBhIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IFthcmdzLmNhY2hlXSAtIGEgW2NhY2hlXShjYWNoZS5tZCkgb2JqZWN0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8U3RhdHVzUm93Pj59IFJlc29sdmVzIHdpdGggYSBzdGF0dXMgbWF0cml4LCBkZXNjcmliZWQgYmVsb3cuXG4gKiBAc2VlIFN0YXR1c1Jvd1xuICovXG5hc3luYyBmdW5jdGlvbiBzdGF0dXNNYXRyaXgoe1xuICBmczogX2ZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICByZWYgPSAnSEVBRCcsXG4gIGZpbGVwYXRocyA9IFsnLiddLFxuICBmaWx0ZXIsXG4gIGNhY2hlID0ge30sXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIF9mcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcigncmVmJywgcmVmKTtcblxuICAgIGNvbnN0IGZzID0gbmV3IEZpbGVTeXN0ZW0oX2ZzKTtcbiAgICByZXR1cm4gYXdhaXQgX3dhbGsoe1xuICAgICAgZnMsXG4gICAgICBjYWNoZSxcbiAgICAgIGRpcixcbiAgICAgIGdpdGRpcixcbiAgICAgIHRyZWVzOiBbVFJFRSh7IHJlZiB9KSwgV09SS0RJUigpLCBTVEFHRSgpXSxcbiAgICAgIG1hcDogYXN5bmMgZnVuY3Rpb24oZmlsZXBhdGgsIFtoZWFkLCB3b3JrZGlyLCBzdGFnZV0pIHtcbiAgICAgICAgLy8gSWdub3JlIGlnbm9yZWQgZmlsZXMsIGJ1dCBvbmx5IGlmIHRoZXkgYXJlIG5vdCBhbHJlYWR5IHRyYWNrZWQuXG4gICAgICAgIGlmICghaGVhZCAmJiAhc3RhZ2UgJiYgd29ya2Rpcikge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGF3YWl0IEdpdElnbm9yZU1hbmFnZXIuaXNJZ25vcmVkKHtcbiAgICAgICAgICAgICAgZnMsXG4gICAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgICAgZmlsZXBhdGgsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWF0Y2ggYWdhaW5zdCBiYXNlIHBhdGhzXG4gICAgICAgIGlmICghZmlsZXBhdGhzLnNvbWUoYmFzZSA9PiB3b3J0aFdhbGtpbmcoZmlsZXBhdGgsIGJhc2UpKSkge1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgICAgLy8gTGF0ZSBmaWx0ZXIgYWdhaW5zdCBmaWxlIG5hbWVzXG4gICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICBpZiAoIWZpbHRlcihmaWxlcGF0aCkpIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIG5vdywganVzdCBiYWlsIG9uIGRpcmVjdG9yaWVzXG4gICAgICAgIGNvbnN0IGhlYWRUeXBlID0gaGVhZCAmJiAoYXdhaXQgaGVhZC50eXBlKCkpO1xuICAgICAgICBpZiAoaGVhZFR5cGUgPT09ICd0cmVlJyB8fCBoZWFkVHlwZSA9PT0gJ3NwZWNpYWwnKSByZXR1cm5cbiAgICAgICAgaWYgKGhlYWRUeXBlID09PSAnY29tbWl0JykgcmV0dXJuIG51bGxcblxuICAgICAgICBjb25zdCB3b3JrZGlyVHlwZSA9IHdvcmtkaXIgJiYgKGF3YWl0IHdvcmtkaXIudHlwZSgpKTtcbiAgICAgICAgaWYgKHdvcmtkaXJUeXBlID09PSAndHJlZScgfHwgd29ya2RpclR5cGUgPT09ICdzcGVjaWFsJykgcmV0dXJuXG5cbiAgICAgICAgY29uc3Qgc3RhZ2VUeXBlID0gc3RhZ2UgJiYgKGF3YWl0IHN0YWdlLnR5cGUoKSk7XG4gICAgICAgIGlmIChzdGFnZVR5cGUgPT09ICdjb21taXQnKSByZXR1cm4gbnVsbFxuICAgICAgICBpZiAoc3RhZ2VUeXBlID09PSAndHJlZScgfHwgc3RhZ2VUeXBlID09PSAnc3BlY2lhbCcpIHJldHVyblxuXG4gICAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIG9pZHMsIHVzaW5nIHRoZSBzdGFnZWQgb2lkIGZvciB0aGUgd29ya2luZyBkaXIgb2lkIGlmIHRoZSBzdGF0cyBtYXRjaC5cbiAgICAgICAgY29uc3QgaGVhZE9pZCA9IGhlYWQgPyBhd2FpdCBoZWFkLm9pZCgpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGFnZU9pZCA9IHN0YWdlID8gYXdhaXQgc3RhZ2Uub2lkKCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB3b3JrZGlyT2lkO1xuICAgICAgICBpZiAoIWhlYWQgJiYgd29ya2RpciAmJiAhc3RhZ2UpIHtcbiAgICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBORUVEIHRoZSBzaGEuIEFueSBzaGEgd2lsbCBkb1xuICAgICAgICAgIC8vIFRPRE86IHVwZGF0ZSB0aGlzIGxvZ2ljIHRvIGhhbmRsZSBOIHRyZWVzIGluc3RlYWQgb2YganVzdCAzLlxuICAgICAgICAgIHdvcmtkaXJPaWQgPSAnNDInO1xuICAgICAgICB9IGVsc2UgaWYgKHdvcmtkaXIpIHtcbiAgICAgICAgICB3b3JrZGlyT2lkID0gYXdhaXQgd29ya2Rpci5vaWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyeSA9IFt1bmRlZmluZWQsIGhlYWRPaWQsIHdvcmtkaXJPaWQsIHN0YWdlT2lkXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZW50cnkubWFwKHZhbHVlID0+IGVudHJ5LmluZGV4T2YodmFsdWUpKTtcbiAgICAgICAgcmVzdWx0LnNoaWZ0KCk7IC8vIHJlbW92ZSBsZWFkaW5nIHVuZGVmaW5lZCBlbnRyeVxuICAgICAgICByZXR1cm4gW2ZpbGVwYXRoLCAuLi5yZXN1bHRdXG4gICAgICB9LFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LnN0YXR1c01hdHJpeCc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQ3JlYXRlIGEgbGlnaHR3ZWlnaHQgdGFnXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IGFyZ3MucmVmIC0gV2hhdCB0byBuYW1lIHRoZSB0YWdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5vYmplY3QgPSAnSEVBRCddIC0gV2hhdCBvaWQgdGhlIHRhZyByZWZlcnMgdG8uIChXaWxsIHJlc29sdmUgdG8gb2lkIGlmIHZhbHVlIGlzIGEgcmVmLikgQnkgZGVmYXVsdCwgdGhlIGNvbW1pdCBvYmplY3Qgd2hpY2ggaXMgcmVmZXJyZWQgYnkgdGhlIGN1cnJlbnQgYEhFQURgIGlzIHVzZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFthcmdzLmZvcmNlID0gZmFsc2VdIC0gSW5zdGVhZCBvZiB0aHJvd2luZyBhbiBlcnJvciBpZiBhIHRhZyBuYW1lZCBgcmVmYCBhbHJlYWR5IGV4aXN0cywgb3ZlcndyaXRlIHRoZSBleGlzdGluZyB0YWcuXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIGZpbGVzeXN0ZW0gb3BlcmF0aW9ucyBhcmUgY29tcGxldGVcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZ2l0LnRhZyh7IGZzLCBkaXI6ICcvdHV0b3JpYWwnLCByZWY6ICd0ZXN0LXRhZycgfSlcbiAqIGNvbnNvbGUubG9nKCdkb25lJylcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRhZyh7XG4gIGZzOiBfZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlZixcbiAgb2JqZWN0LFxuICBmb3JjZSA9IGZhbHNlLFxufSkge1xuICB0cnkge1xuICAgIGFzc2VydFBhcmFtZXRlcignZnMnLCBfZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3JlZicsIHJlZik7XG5cbiAgICBjb25zdCBmcyA9IG5ldyBGaWxlU3lzdGVtKF9mcyk7XG5cbiAgICBpZiAocmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBNaXNzaW5nUGFyYW1ldGVyRXJyb3IoJ3JlZicpXG4gICAgfVxuXG4gICAgcmVmID0gcmVmLnN0YXJ0c1dpdGgoJ3JlZnMvdGFncy8nKSA/IHJlZiA6IGByZWZzL3RhZ3MvJHtyZWZ9YDtcblxuICAgIC8vIFJlc29sdmUgcGFzc2VkIG9iamVjdFxuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgR2l0UmVmTWFuYWdlci5yZXNvbHZlKHtcbiAgICAgIGZzLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgcmVmOiBvYmplY3QgfHwgJ0hFQUQnLFxuICAgIH0pO1xuXG4gICAgaWYgKCFmb3JjZSAmJiAoYXdhaXQgR2l0UmVmTWFuYWdlci5leGlzdHMoeyBmcywgZ2l0ZGlyLCByZWYgfSkpKSB7XG4gICAgICB0aHJvdyBuZXcgQWxyZWFkeUV4aXN0c0Vycm9yKCd0YWcnLCByZWYpXG4gICAgfVxuXG4gICAgYXdhaXQgR2l0UmVmTWFuYWdlci53cml0ZVJlZih7IGZzLCBnaXRkaXIsIHJlZiwgdmFsdWUgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LnRhZyc7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogUmV0dXJuIHRoZSB2ZXJzaW9uIG51bWJlciBvZiBpc29tb3JwaGljLWdpdFxuICpcbiAqIEkgZG9uJ3Qga25vdyB3aHkgeW91IG1pZ2h0IG5lZWQgdGhpcy4gSSBhZGRlZCBpdCBqdXN0IHNvIEkgY291bGQgY2hlY2sgdGhhdCBJIHdhcyBnZXR0aW5nXG4gKiB0aGUgY29ycmVjdCB2ZXJzaW9uIG9mIHRoZSBsaWJyYXJ5IGFuZCBub3QgYSBjYWNoZWQgdmVyc2lvbi5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdmVyc2lvbiBzdHJpbmcgdGFrZW4gZnJvbSBwYWNrYWdlLmpzb24gYXQgcHVibGljYXRpb24gdGltZVxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zb2xlLmxvZyhnaXQudmVyc2lvbigpKVxuICpcbiAqL1xuZnVuY3Rpb24gdmVyc2lvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcGtnLnZlcnNpb25cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQudmVyc2lvbic7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQGNhbGxiYWNrIFdhbGtlck1hcFxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lXG4gKiBAcGFyYW0ge0FycmF5PFdhbGtlckVudHJ5IHwgbnVsbD59IGVudHJpZXNcbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgV2Fsa2VyUmVkdWNlXG4gKiBAcGFyYW0ge2FueX0gcGFyZW50XG4gKiBAcGFyYW0ge2FueVtdfSBjaGlsZHJlblxuICogQHJldHVybnMge1Byb21pc2U8YW55Pn1cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBXYWxrZXJJdGVyYXRlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7V2Fsa2VyRW50cnlbXX0gZW50cmllc1xuICogQHJldHVybnMge1Byb21pc2U8YW55W10+fVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFdhbGtlckl0ZXJhdGVcbiAqIEBwYXJhbSB7V2Fsa2VySXRlcmF0ZUNhbGxiYWNrfSB3YWxrXG4gKiBAcGFyYW0ge0l0ZXJhYmxlSXRlcmF0b3I8V2Fsa2VyRW50cnlbXT59IGNoaWxkcmVuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnlbXT59XG4gKi9cblxuLyoqXG4gKiBBIHBvd2VyZnVsIHJlY3Vyc2l2ZSB0cmVlLXdhbGtpbmcgdXRpbGl0eS5cbiAqXG4gKiBUaGUgYHdhbGtgIEFQSSBzaW1wbGlmaWVzIGdhdGhlcmluZyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBhIHRyZWUgb3IgY29tcGFyaW5nIGFsbCB0aGUgZmlsZXBhdGhzIGluIHR3byBvciBtb3JlIHRyZWVzLlxuICogVHJlZXMgY2FuIGJlIGdpdCBjb21taXRzLCB0aGUgd29ya2luZyBkaXJlY3RvcnksIG9yIHRoZSBvciBnaXQgaW5kZXggKHN0YWdpbmcgYXJlYSkuXG4gKiBBcyBsb25nIGFzIGEgZmlsZSBvciBkaXJlY3RvcnkgaXMgcHJlc2VudCBpbiBhdCBsZWFzdCBvbmUgb2YgdGhlIHRyZWVzLCBpdCB3aWxsIGJlIHRyYXZlcnNlZC5cbiAqIEVudHJpZXMgYXJlIHRyYXZlcnNlZCBpbiBhbHBoYWJldGljYWwgb3JkZXIuXG4gKlxuICogVGhlIGFyZ3VtZW50cyB0byBgd2Fsa2AgYXJlIHRoZSBgdHJlZXNgIHlvdSB3YW50IHRvIHRyYXZlcnNlLCBhbmQgMyBvcHRpb25hbCB0cmFuc2Zvcm0gZnVuY3Rpb25zOlxuICogIGBtYXBgLCBgcmVkdWNlYCwgYW5kIGBpdGVyYXRlYC5cbiAqXG4gKiAjIyBgVFJFRWAsIGBXT1JLRElSYCwgYW5kIGBTVEFHRWBcbiAqXG4gKiBUcmVlIHdhbGtlcnMgYXJlIHJlcHJlc2VudGVkIGJ5IHRocmVlIHNlcGFyYXRlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSBpbXBvcnRlZDpcbiAqXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgVFJFRSwgV09SS0RJUiwgU1RBR0UgfSBmcm9tICdpc29tb3JwaGljLWdpdCdcbiAqIGBgYFxuICpcbiAqIFRoZXNlIGZ1bmN0aW9ucyByZXR1cm4gb3BhcXVlIGhhbmRsZXMgY2FsbGVkIGBXYWxrZXJgcy5cbiAqIFRoZSBvbmx5IHRoaW5nIHRoYXQgYFdhbGtlcmAgb2JqZWN0cyBhcmUgZ29vZCBmb3IgaXMgcGFzc2luZyBpbnRvIGB3YWxrYC5cbiAqIEhlcmUgYXJlIHRoZSB0aHJlZSBgV2Fsa2VyYHMgcGFzc2VkIGludG8gYHdhbGtgIGJ5IHRoZSBgc3RhdHVzTWF0cml4YCBjb21tYW5kIGZvciBleGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBsZXQgcmVmID0gJ0hFQUQnXG4gKlxuICogbGV0IHRyZWVzID0gW1RSRUUoeyByZWYgfSksIFdPUktESVIoKSwgU1RBR0UoKV1cbiAqIGBgYFxuICpcbiAqIEZvciB0aGUgYXJndW1lbnRzLCBzZWUgdGhlIGRvYyBwYWdlcyBmb3IgW1RSRUVdKC4vVFJFRS5tZCksIFtXT1JLRElSXSguL1dPUktESVIubWQpLCBhbmQgW1NUQUdFXSguL1NUQUdFLm1kKS5cbiAqXG4gKiBgbWFwYCwgYHJlZHVjZWAsIGFuZCBgaXRlcmF0ZWAgYWxsb3cgeW91IGNvbnRyb2wgdGhlIHJlY3Vyc2l2ZSB3YWxrIGJ5IHBydW5pbmcgYW5kIHRyYW5zZm9ybWluZyBgV2Fsa2VyRW50cnlgcyBpbnRvIHRoZSBkZXNpcmVkIHJlc3VsdC5cbiAqXG4gKiAjIyBXYWxrZXJFbnRyeVxuICpcbiAqIHtAbGluayBXYWxrZXJFbnRyeSB0eXBlZGVmfVxuICpcbiAqIGBtYXBgIHJlY2VpdmVzIGFuIGFycmF5IG9mIGBXYWxrZXJFbnRyeVtdYCBhcyBpdHMgbWFpbiBhcmd1bWVudCwgb25lIGBXYWxrZXJFbnRyeWAgZm9yIGVhY2ggYFdhbGtlcmAgaW4gdGhlIGB0cmVlc2AgYXJndW1lbnQuXG4gKiBUaGUgbWV0aG9kcyBhcmUgbWVtb2l6ZWQgcGVyIGBXYWxrZXJFbnRyeWAgc28gY2FsbGluZyB0aGVtIG11bHRpcGxlIHRpbWVzIGluIGEgYG1hcGAgZnVuY3Rpb24gZG9lcyBub3QgYWR2ZXJzZWx5IGltcGFjdCBwZXJmb3JtYW5jZS5cbiAqIEJ5IG9ubHkgY29tcHV0aW5nIHRoZXNlIHZhbHVlcyBpZiBuZWVkZWQsIHlvdSBidWlsZCBjYW4gYnVpbGQgbGVhbiwgbWVhbiwgZWZmaWNpZW50IHdhbGtpbmcgbWFjaGluZXMuXG4gKlxuICogIyMjIFdhbGtlckVudHJ5I3R5cGUoKVxuICpcbiAqIFJldHVybnMgdGhlIGtpbmQgYXMgYSBzdHJpbmcuIFRoaXMgaXMgbm9ybWFsbHkgZWl0aGVyIGB0cmVlYCBvciBgYmxvYmAuXG4gKlxuICogYFRSRUVgLCBgU1RBR0VgLCBhbmQgYFdPUktESVJgIHdhbGtlcnMgYWxsIHJldHVybiBhIHN0cmluZy5cbiAqXG4gKiBQb3NzaWJsZSB2YWx1ZXM6XG4gKlxuICogLSBgJ3RyZWUnYCBkaXJlY3RvcnlcbiAqIC0gYCdibG9iJ2AgZmlsZVxuICogLSBgJ3NwZWNpYWwnYCB1c2VkIGJ5IGBXT1JLRElSYCB0byByZXByZXNlbnQgaXJyZWd1bGFyIGZpbGVzIGxpa2Ugc29ja2V0cyBhbmQgRklGT3NcbiAqIC0gYCdjb21taXQnYCB1c2VkIGJ5IGBUUkVFYCB0byByZXByZXNlbnQgc3VibW9kdWxlc1xuICpcbiAqIGBgYGpzXG4gKiBhd2FpdCBlbnRyeS50eXBlKClcbiAqIGBgYFxuICpcbiAqICMjIyBXYWxrZXJFbnRyeSNtb2RlKClcbiAqXG4gKiBSZXR1cm5zIHRoZSBmaWxlIG1vZGUgYXMgYSBudW1iZXIuIFVzZSB0aGlzIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gcmVndWxhciBmaWxlcywgc3ltbGlua3MsIGFuZCBleGVjdXRhYmxlIGZpbGVzLlxuICpcbiAqIGBUUkVFYCwgYFNUQUdFYCwgYW5kIGBXT1JLRElSYCB3YWxrZXJzIGFsbCByZXR1cm4gYSBudW1iZXIgZm9yIGFsbCBgdHlwZWBzIG9mIGVudHJpZXMuXG4gKlxuICogSXQgaGFzIGJlZW4gbm9ybWFsaXplZCB0byBvbmUgb2YgdGhlIDQgdmFsdWVzIHRoYXQgYXJlIGFsbG93ZWQgaW4gZ2l0IGNvbW1pdHM6XG4gKlxuICogLSBgMG80MDAwMGAgZGlyZWN0b3J5XG4gKiAtIGAwbzEwMDY0NGAgZmlsZVxuICogLSBgMG8xMDA3NTVgIGZpbGUgKGV4ZWN1dGFibGUpXG4gKiAtIGAwbzEyMDAwMGAgc3ltbGlua1xuICpcbiAqIFRpcDogdG8gbWFrZSBtb2RlcyBtb3JlIHJlYWRhYmxlLCB5b3UgY2FuIHByaW50IHRoZW0gdG8gb2N0YWwgdXNpbmcgYC50b1N0cmluZyg4KWAuXG4gKlxuICogYGBganNcbiAqIGF3YWl0IGVudHJ5Lm1vZGUoKVxuICogYGBgXG4gKlxuICogIyMjIFdhbGtlckVudHJ5I29pZCgpXG4gKlxuICogUmV0dXJucyB0aGUgU0hBLTEgb2JqZWN0IGlkIGZvciBibG9icyBhbmQgdHJlZXMuXG4gKlxuICogYFRSRUVgIHdhbGtlcnMgcmV0dXJuIGEgc3RyaW5nIGZvciBgYmxvYmAgYW5kIGB0cmVlYCBlbnRyaWVzLlxuICpcbiAqIGBTVEFHRWAgYW5kIGBXT1JLRElSYCB3YWxrZXJzIHJldHVybiBhIHN0cmluZyBmb3IgYGJsb2JgIGVudHJpZXMgYW5kIGB1bmRlZmluZWRgIGZvciBgdHJlZWAgZW50cmllcy5cbiAqXG4gKiBgYGBqc1xuICogYXdhaXQgZW50cnkub2lkKClcbiAqIGBgYFxuICpcbiAqICMjIyBXYWxrZXJFbnRyeSNjb250ZW50KClcbiAqXG4gKiBSZXR1cm5zIHRoZSBmaWxlIGNvbnRlbnRzIGFzIGEgQnVmZmVyLlxuICpcbiAqIGBUUkVFYCBhbmQgYFdPUktESVJgIHdhbGtlcnMgcmV0dXJuIGEgQnVmZmVyIGZvciBgYmxvYmAgZW50cmllcyBhbmQgYHVuZGVmaW5lZGAgZm9yIGB0cmVlYCBlbnRyaWVzLlxuICpcbiAqIGBTVEFHRWAgd2Fsa2VycyBhbHdheXMgcmV0dXJuIGB1bmRlZmluZWRgIHNpbmNlIHRoZSBmaWxlIGNvbnRlbnRzIGFyZSBuZXZlciBzdG9yZWQgaW4gdGhlIHN0YWdlLlxuICpcbiAqIGBgYGpzXG4gKiBhd2FpdCBlbnRyeS5jb250ZW50KClcbiAqIGBgYFxuICpcbiAqICMjIyBXYWxrZXJFbnRyeSNzdGF0KClcbiAqXG4gKiBSZXR1cm5zIGEgbm9ybWFsaXplZCBzdWJzZXQgb2YgZmlsZXN5c3RlbSBTdGF0IGRhdGEuXG4gKlxuICogYFdPUktESVJgIHdhbGtlcnMgcmV0dXJuIGEgYFN0YXRgIGZvciBgYmxvYmAgYW5kIGB0cmVlYCBlbnRyaWVzLlxuICpcbiAqIGBTVEFHRWAgd2Fsa2VycyByZXR1cm4gYSBgU3RhdGAgZm9yIGBibG9iYCBlbnRyaWVzIGFuZCBgdW5kZWZpbmVkYCBmb3IgYHRyZWVgIGVudHJpZXMuXG4gKlxuICogYFRSRUVgIHdhbGtlcnMgcmV0dXJuIGB1bmRlZmluZWRgIGZvciBhbGwgZW50cnkgdHlwZXMuXG4gKlxuICogYGBganNcbiAqIGF3YWl0IGVudHJ5LnN0YXQoKVxuICogYGBgXG4gKlxuICoge0BsaW5rIFN0YXQgdHlwZWRlZn1cbiAqXG4gKiAjIyBtYXAoc3RyaW5nLCBBcnJheTxXYWxrZXJFbnRyeXxudWxsPikgPT4gUHJvbWlzZTxhbnk+XG4gKlxuICoge0BsaW5rIFdhbGtlck1hcCB0eXBlZGVmfVxuICpcbiAqIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uY2UgcGVyIGVudHJ5IEJFRk9SRSB2aXNpdGluZyB0aGUgY2hpbGRyZW4gb2YgdGhhdCBub2RlLlxuICpcbiAqIElmIHlvdSByZXR1cm4gYG51bGxgIGZvciBhIGB0cmVlYCBlbnRyeSwgdGhlbiBub25lIG9mIHRoZSBjaGlsZHJlbiBvZiB0aGF0IGB0cmVlYCBlbnRyeSB3aWxsIGJlIHdhbGtlZC5cbiAqXG4gKiBUaGlzIGlzIGEgZ29vZCBwbGFjZSBmb3IgcXVlcnkgbG9naWMsIHN1Y2ggYXMgZXhhbWluaW5nIHRoZSBjb250ZW50cyBvZiBhIGZpbGUuXG4gKiBVbHRpbWF0ZWx5LCBjb21wYXJlIGFsbCB0aGUgZW50cmllcyBhbmQgcmV0dXJuIGFueSB2YWx1ZXMgeW91IGFyZSBpbnRlcmVzdGVkIGluLlxuICogSWYgeW91IGRvIG5vdCByZXR1cm4gYSB2YWx1ZSAob3IgcmV0dXJuIHVuZGVmaW5lZCkgdGhhdCBlbnRyeSB3aWxsIGJlIGZpbHRlcmVkIGZyb20gdGhlIHJlc3VsdHMuXG4gKlxuICogRXhhbXBsZSAxOiBGaW5kIGFsbCB0aGUgZmlsZXMgY29udGFpbmluZyB0aGUgd29yZCAnZm9vJy5cbiAqIGBgYGpzXG4gKiBhc3luYyBmdW5jdGlvbiBtYXAoZmlsZXBhdGgsIFtoZWFkLCB3b3JrZGlyXSkge1xuICogICBsZXQgY29udGVudCA9IChhd2FpdCB3b3JrZGlyLmNvbnRlbnQoKSkudG9TdHJpbmcoJ3V0ZjgnKVxuICogICBpZiAoY29udGVudC5jb250YWlucygnZm9vJykpIHtcbiAqICAgICByZXR1cm4ge1xuICogICAgICAgZmlsZXBhdGgsXG4gKiAgICAgICBjb250ZW50XG4gKiAgICAgfVxuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBFeGFtcGxlIDI6IFJldHVybiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB3b3JraW5nIGRpcmVjdG9yeSBhbmQgdGhlIEhFQUQgY29tbWl0XG4gKiBgYGBqc1xuICogY29uc3QgZGlmZiA9IHJlcXVpcmUoJ2RpZmYtbGluZXMnKVxuICogYXN5bmMgZnVuY3Rpb24gbWFwKGZpbGVwYXRoLCBbaGVhZCwgd29ya2Rpcl0pIHtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBmaWxlcGF0aCxcbiAqICAgICBvaWQ6IGF3YWl0IGhlYWQub2lkKCksXG4gKiAgICAgZGlmZjogZGlmZigoYXdhaXQgaGVhZC5jb250ZW50KCkpLnRvU3RyaW5nKCd1dGY4JyksIChhd2FpdCB3b3JrZGlyLmNvbnRlbnQoKSkudG9TdHJpbmcoJ3V0ZjgnKSlcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogRXhhbXBsZSAzOlxuICogYGBganNcbiAqIGxldCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG4gKiAvLyBPbmx5IGV4YW1pbmUgZmlsZXMgaW4gdGhlIGRpcmVjdG9yeSBgY3dkYFxuICogbGV0IGN3ZCA9ICdzcmMvYXBwJ1xuICogYXN5bmMgZnVuY3Rpb24gbWFwIChmaWxlcGF0aCwgW2hlYWQsIHdvcmtkaXIsIHN0YWdlXSkge1xuICogICBpZiAoXG4gKiAgICAgLy8gZG9uJ3Qgc2tpcCB0aGUgcm9vdCBkaXJlY3RvcnlcbiAqICAgICBoZWFkLmZ1bGxwYXRoICE9PSAnLicgJiZcbiAqICAgICAvLyByZXR1cm4gdHJ1ZSBmb3IgJ3NyYycgYW5kICdzcmMvYXBwJ1xuICogICAgICFjd2Quc3RhcnRzV2l0aChmaWxlcGF0aCkgJiZcbiAqICAgICAvLyByZXR1cm4gdHJ1ZSBmb3IgJ3NyYy9hcHAvKidcbiAqICAgICBwYXRoLmRpcm5hbWUoZmlsZXBhdGgpICE9PSBjd2RcbiAqICAgKSB7XG4gKiAgICAgcmV0dXJuIG51bGxcbiAqICAgfSBlbHNlIHtcbiAqICAgICByZXR1cm4gZmlsZXBhdGhcbiAqICAgfVxuICogfVxuICogYGBgXG4gKlxuICogIyMgcmVkdWNlKHBhcmVudCwgY2hpbGRyZW4pXG4gKlxuICoge0BsaW5rIFdhbGtlclJlZHVjZSB0eXBlZGVmfVxuICpcbiAqIFRoaXMgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uY2UgcGVyIGVudHJ5IEFGVEVSIHZpc2l0aW5nIHRoZSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUuXG4gKlxuICogRGVmYXVsdDogYGFzeW5jIChwYXJlbnQsIGNoaWxkcmVuKSA9PiBwYXJlbnQgPT09IHVuZGVmaW5lZCA/IGNoaWxkcmVuLmZsYXQoKSA6IFtwYXJlbnQsIGNoaWxkcmVuXS5mbGF0KClgXG4gKlxuICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFsbCBkaXJlY3RvcmllcyBhbmQgY2hpbGRyZW4gaW4gYSBnaWFudCBmbGF0IGFycmF5LlxuICogWW91IGNhbiBkZWZpbmUgYSBkaWZmZXJlbnQgYWNjdW11bGF0aW9uIG1ldGhvZCB0aG91Z2guXG4gKlxuICogRXhhbXBsZTogUmV0dXJuIGEgaGllcmFyY2hpY2FsIHN0cnVjdHVyZVxuICogYGBganNcbiAqIGFzeW5jIGZ1bmN0aW9uIHJlZHVjZSAocGFyZW50LCBjaGlsZHJlbikge1xuICogICByZXR1cm4gT2JqZWN0LmFzc2lnbihwYXJlbnQsIHsgY2hpbGRyZW4gfSlcbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIGl0ZXJhdGUod2FsaywgY2hpbGRyZW4pXG4gKlxuICoge0BsaW5rIFdhbGtlckl0ZXJhdGUgdHlwZWRlZn1cbiAqXG4gKiB7QGxpbmsgV2Fsa2VySXRlcmF0ZUNhbGxiYWNrIHR5cGVkZWZ9XG4gKlxuICogRGVmYXVsdDogYCh3YWxrLCBjaGlsZHJlbikgPT4gUHJvbWlzZS5hbGwoWy4uLmNoaWxkcmVuXS5tYXAod2FsaykpYFxuICpcbiAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJlY3Vyc2VzIGFsbCBjaGlsZHJlbiBjb25jdXJyZW50bHkgdXNpbmcgUHJvbWlzZS5hbGwuXG4gKiBIb3dldmVyIHlvdSBjb3VsZCB1c2UgYSBjdXN0b20gZnVuY3Rpb24gdG8gdHJhdmVyc2UgY2hpbGRyZW4gc2VyaWFsbHkgb3IgdXNlIGEgZ2xvYmFsIHF1ZXVlIHRvIHRocm90dGxlIHJlY3Vyc2lvbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gYXJnc1xuICogQHBhcmFtIHtGc0NsaWVudH0gYXJncy5mcyAtIGEgZmlsZSBzeXN0ZW0gY2xpZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZGlyXSAtIFRoZSBbd29ya2luZyB0cmVlXShkaXItdnMtZ2l0ZGlyLm1kKSBkaXJlY3RvcnkgcGF0aFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmdpdGRpcj1qb2luKGRpciwnLmdpdCcpXSAtIFtyZXF1aXJlZF0gVGhlIFtnaXQgZGlyZWN0b3J5XShkaXItdnMtZ2l0ZGlyLm1kKSBwYXRoXG4gKiBAcGFyYW0ge1dhbGtlcltdfSBhcmdzLnRyZWVzIC0gVGhlIHRyZWVzIHlvdSB3YW50IHRvIHRyYXZlcnNlXG4gKiBAcGFyYW0ge1dhbGtlck1hcH0gW2FyZ3MubWFwXSAtIFRyYW5zZm9ybSBgV2Fsa2VyRW50cnlgcyBpbnRvIGEgcmVzdWx0IGZvcm1cbiAqIEBwYXJhbSB7V2Fsa2VyUmVkdWNlfSBbYXJncy5yZWR1Y2VdIC0gQ29udHJvbCBob3cgbWFwcGVkIGVudHJpZXMgYXJlIGNvbWJpbmVkIHdpdGggdGhlaXIgcGFyZW50IHJlc3VsdFxuICogQHBhcmFtIHtXYWxrZXJJdGVyYXRlfSBbYXJncy5pdGVyYXRlXSAtIEZpbmUtdHVuZSBob3cgZW50cmllcyB3aXRoaW4gYSB0cmVlIGFyZSBpdGVyYXRlZCBvdmVyXG4gKiBAcGFyYW0ge29iamVjdH0gW2FyZ3MuY2FjaGVdIC0gYSBbY2FjaGVdKGNhY2hlLm1kKSBvYmplY3RcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgZmluaXNoZWQgdHJlZS13YWxraW5nIHJlc3VsdFxuICovXG5hc3luYyBmdW5jdGlvbiB3YWxrKHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHRyZWVzLFxuICBtYXAsXG4gIHJlZHVjZSxcbiAgaXRlcmF0ZSxcbiAgY2FjaGUgPSB7fSxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3RyZWVzJywgdHJlZXMpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF93YWxrKHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBjYWNoZSxcbiAgICAgIGRpcixcbiAgICAgIGdpdGRpcixcbiAgICAgIHRyZWVzLFxuICAgICAgbWFwLFxuICAgICAgcmVkdWNlLFxuICAgICAgaXRlcmF0ZSxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC53YWxrJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBXcml0ZSBhIGJsb2Igb2JqZWN0IGRpcmVjdGx5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtVaW50OEFycmF5fSBhcmdzLmJsb2IgLSBUaGUgYmxvYiBvYmplY3QgdG8gd3JpdGVcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCB0aGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSBuZXdseSB3cml0dGVuIG9iamVjdFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBNYW51YWxseSBjcmVhdGUgYSBibG9iLlxuICogbGV0IG9pZCA9IGF3YWl0IGdpdC53cml0ZUJsb2Ioe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgYmxvYjogbmV3IFVpbnQ4QXJyYXkoW10pXG4gKiB9KVxuICpcbiAqIGNvbnNvbGUubG9nKCdvaWQnLCBvaWQpIC8vIHNob3VsZCBiZSAnZTY5ZGUyOWJiMmQxZDY0MzRiOGIyOWFlNzc1YWQ4YzJlNDhjNTM5MSdcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlQmxvYih7IGZzLCBkaXIsIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLCBibG9iIH0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2Jsb2InLCBibG9iKTtcblxuICAgIHJldHVybiBhd2FpdCBfd3JpdGVPYmplY3Qoe1xuICAgICAgZnM6IG5ldyBGaWxlU3lzdGVtKGZzKSxcbiAgICAgIGdpdGRpcixcbiAgICAgIHR5cGU6ICdibG9iJyxcbiAgICAgIG9iamVjdDogYmxvYixcbiAgICAgIGZvcm1hdDogJ2NvbnRlbnQnLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LndyaXRlQmxvYic7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtDb21taXRPYmplY3R9IGFyZ3MuY29tbWl0XG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAqIEBzZWUgQ29tbWl0T2JqZWN0XG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiBfd3JpdGVDb21taXQoeyBmcywgZ2l0ZGlyLCBjb21taXQgfSkge1xuICAvLyBDb252ZXJ0IG9iamVjdCB0byBidWZmZXJcbiAgY29uc3Qgb2JqZWN0ID0gR2l0Q29tbWl0LmZyb20oY29tbWl0KS50b09iamVjdCgpO1xuICBjb25zdCBvaWQgPSBhd2FpdCBfd3JpdGVPYmplY3Qoe1xuICAgIGZzLFxuICAgIGdpdGRpcixcbiAgICB0eXBlOiAnY29tbWl0JyxcbiAgICBvYmplY3QsXG4gICAgZm9ybWF0OiAnY29udGVudCcsXG4gIH0pO1xuICByZXR1cm4gb2lkXG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFdyaXRlIGEgY29tbWl0IG9iamVjdCBkaXJlY3RseVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7Q29tbWl0T2JqZWN0fSBhcmdzLmNvbW1pdCAtIFRoZSBvYmplY3QgdG8gd3JpdGVcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCB0aGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSBuZXdseSB3cml0dGVuIG9iamVjdFxuICogQHNlZSBDb21taXRPYmplY3RcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlQ29tbWl0KHtcbiAgZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIGNvbW1pdCxcbn0pIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2ZzJywgZnMpO1xuICAgIGFzc2VydFBhcmFtZXRlcignZ2l0ZGlyJywgZ2l0ZGlyKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2NvbW1pdCcsIGNvbW1pdCk7XG5cbiAgICByZXR1cm4gYXdhaXQgX3dyaXRlQ29tbWl0KHtcbiAgICAgIGZzOiBuZXcgRmlsZVN5c3RlbShmcyksXG4gICAgICBnaXRkaXIsXG4gICAgICBjb21taXQsXG4gICAgfSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQud3JpdGVDb21taXQnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFdyaXRlIGEgZ2l0IG9iamVjdCBkaXJlY3RseVxuICpcbiAqIGBmb3JtYXRgIGNhbiBoYXZlIHRoZSBmb2xsb3dpbmcgdmFsdWVzOlxuICpcbiAqIHwgcGFyYW0gICAgICB8IGRlc2NyaXB0aW9uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAtLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8XG4gKiB8ICdkZWZsYXRlZCcgfCBUcmVhdCBgb2JqZWN0YCBhcyB0aGUgcmF3IGRlZmxhdGUtY29tcHJlc3NlZCBidWZmZXIgZm9yIGFuIG9iamVjdCwgbWVhbmluZyBjYW4gYmUgd3JpdHRlbiB0byBgLmdpdC9vYmplY3RzLyoqYCBhcy1pcy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCAnd3JhcHBlZCcgIHwgVHJlYXQgYG9iamVjdGAgYXMgdGhlIGluZmxhdGVkIG9iamVjdCBidWZmZXIgd3JhcHBlZCBpbiB0aGUgZ2l0IG9iamVjdCBoZWFkZXIuIFRoaXMgaXMgdGhlIHJhdyBidWZmZXIgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBTSEEtMSBvYmplY3QgaWQgb2YgYSBnaXQgb2JqZWN0LiB8XG4gKiB8ICdjb250ZW50JyAgfCBUcmVhdCBgb2JqZWN0YCBhcyB0aGUgb2JqZWN0IGJ1ZmZlciB3aXRob3V0IHRoZSBnaXQgaGVhZGVyLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgJ3BhcnNlZCcgICB8IFRyZWF0IGBvYmplY3RgIGFzIGEgcGFyc2VkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3QuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICpcbiAqIElmIGBmb3JtYXRgIGlzIGAncGFyc2VkJ2AsIHRoZW4gYG9iamVjdGAgbXVzdCBtYXRjaCBvbmUgb2YgdGhlIHNjaGVtYXMgZm9yIGBDb21taXRPYmplY3RgLCBgVHJlZU9iamVjdGAsIGBUYWdPYmplY3RgLCBvciBhIGBzdHJpbmdgIChmb3IgYmxvYnMpLlxuICpcbiAqIHtAbGluayBDb21taXRPYmplY3QgdHlwZWRlZn1cbiAqXG4gKiB7QGxpbmsgVHJlZU9iamVjdCB0eXBlZGVmfVxuICpcbiAqIHtAbGluayBUYWdPYmplY3QgdHlwZWRlZn1cbiAqXG4gKiBJZiBgZm9ybWF0YCBpcyBgJ2NvbnRlbnQnYCwgYCd3cmFwcGVkJ2AsIG9yIGAnZGVmbGF0ZWQnYCwgYG9iamVjdGAgc2hvdWxkIGJlIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBkZXByZWNhdGVkXG4gKiA+IFRoaXMgY29tbWFuZCBpcyBvdmVybHkgY29tcGxpY2F0ZWQuXG4gKiA+XG4gKiA+IElmIHlvdSBrbm93IHRoZSB0eXBlIG9mIG9iamVjdCB5b3UgYXJlIHdyaXRpbmcsIHVzZSBbYHdyaXRlQmxvYmBdKC4vd3JpdGVCbG9iLm1kKSwgW2B3cml0ZUNvbW1pdGBdKC4vd3JpdGVDb21taXQubWQpLCBbYHdyaXRlVGFnYF0oLi93cml0ZVRhZy5tZCksIG9yIFtgd3JpdGVUcmVlYF0oLi93cml0ZVRyZWUubWQpLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nIHwgVWludDhBcnJheSB8IENvbW1pdE9iamVjdCB8IFRyZWVPYmplY3QgfCBUYWdPYmplY3R9IGFyZ3Mub2JqZWN0IC0gVGhlIG9iamVjdCB0byB3cml0ZS5cbiAqIEBwYXJhbSB7J2Jsb2InfCd0cmVlJ3wnY29tbWl0J3wndGFnJ30gW2FyZ3MudHlwZV0gLSBUaGUga2luZCBvZiBvYmplY3QgdG8gd3JpdGUuXG4gKiBAcGFyYW0geydkZWZsYXRlZCcgfCAnd3JhcHBlZCcgfCAnY29udGVudCcgfCAncGFyc2VkJ30gW2FyZ3MuZm9ybWF0ID0gJ3BhcnNlZCddIC0gV2hhdCBmb3JtYXQgdGhlIG9iamVjdCBpcyBpbi4gVGhlIHBvc3NpYmxlIGNob2ljZXMgYXJlIGxpc3RlZCBiZWxvdy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5vaWRdIC0gSWYgYGZvcm1hdGAgaXMgYCdkZWZsYXRlZCdgIHRoZW4gdGhpcyBwYXJhbSBpcyByZXF1aXJlZC4gT3RoZXJ3aXNlIGl0IGlzIGNhbGN1bGF0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZW5jb2RpbmddIC0gSWYgYHR5cGVgIGlzIGAnYmxvYidgIHRoZW4gYG9iamVjdGAgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBVaW50OEFycmF5IHVzaW5nIGBlbmNvZGluZ2AuXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggdGhlIFNIQS0xIG9iamVjdCBpZCBvZiB0aGUgbmV3bHkgd3JpdHRlbiBvYmplY3QuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIE1hbnVhbGx5IGNyZWF0ZSBhbiBhbm5vdGF0ZWQgdGFnLlxuICogbGV0IHNoYSA9IGF3YWl0IGdpdC5yZXNvbHZlUmVmKHsgZnMsIGRpcjogJy90dXRvcmlhbCcsIHJlZjogJ0hFQUQnIH0pXG4gKiBjb25zb2xlLmxvZygnY29tbWl0Jywgc2hhKVxuICpcbiAqIGxldCBvaWQgPSBhd2FpdCBnaXQud3JpdGVPYmplY3Qoe1xuICogICBmcyxcbiAqICAgZGlyOiAnL3R1dG9yaWFsJyxcbiAqICAgdHlwZTogJ3RhZycsXG4gKiAgIG9iamVjdDoge1xuICogICAgIG9iamVjdDogc2hhLFxuICogICAgIHR5cGU6ICdjb21taXQnLFxuICogICAgIHRhZzogJ215LXRhZycsXG4gKiAgICAgdGFnZ2VyOiB7XG4gKiAgICAgICBuYW1lOiAneW91ciBuYW1lJyxcbiAqICAgICAgIGVtYWlsOiAnZW1haWxAZXhhbXBsZS5jb20nLFxuICogICAgICAgdGltZXN0YW1wOiBNYXRoLmZsb29yKERhdGUubm93KCkvMTAwMCksXG4gKiAgICAgICB0aW1lem9uZU9mZnNldDogbmV3IERhdGUoKS5nZXRUaW1lem9uZU9mZnNldCgpXG4gKiAgICAgfSxcbiAqICAgICBtZXNzYWdlOiAnT3B0aW9uYWwgbWVzc2FnZSdcbiAqICAgfVxuICogfSlcbiAqXG4gKiBjb25zb2xlLmxvZygndGFnJywgb2lkKVxuICpcbiAqL1xuYXN5bmMgZnVuY3Rpb24gd3JpdGVPYmplY3Qoe1xuICBmczogX2ZzLFxuICBkaXIsXG4gIGdpdGRpciA9IGpvaW4oZGlyLCAnLmdpdCcpLFxuICB0eXBlLFxuICBvYmplY3QsXG4gIGZvcm1hdCA9ICdwYXJzZWQnLFxuICBvaWQsXG4gIGVuY29kaW5nID0gdW5kZWZpbmVkLFxufSkge1xuICB0cnkge1xuICAgIGNvbnN0IGZzID0gbmV3IEZpbGVTeXN0ZW0oX2ZzKTtcbiAgICAvLyBDb252ZXJ0IG9iamVjdCB0byBidWZmZXJcbiAgICBpZiAoZm9ybWF0ID09PSAncGFyc2VkJykge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NvbW1pdCc6XG4gICAgICAgICAgb2JqZWN0ID0gR2l0Q29tbWl0LmZyb20ob2JqZWN0KS50b09iamVjdCgpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3RyZWUnOlxuICAgICAgICAgIG9iamVjdCA9IEdpdFRyZWUuZnJvbShvYmplY3QpLnRvT2JqZWN0KCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnYmxvYic6XG4gICAgICAgICAgb2JqZWN0ID0gQnVmZmVyLmZyb20ob2JqZWN0LCBlbmNvZGluZyk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICBvYmplY3QgPSBHaXRBbm5vdGF0ZWRUYWcuZnJvbShvYmplY3QpLnRvT2JqZWN0KCk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VHlwZUVycm9yKG9pZCB8fCAnJywgdHlwZSwgJ2Jsb2J8Y29tbWl0fHRhZ3x0cmVlJylcbiAgICAgIH1cbiAgICAgIC8vIEdpdE9iamVjdE1hbmFnZXIgZG9lcyBub3Qga25vdyBob3cgdG8gc2VyaWFsaXplIGNvbnRlbnQsIHNvIHdlIHR3ZWFrIHRoYXQgcGFyYW1ldGVyIGJlZm9yZSBwYXNzaW5nIGl0LlxuICAgICAgZm9ybWF0ID0gJ2NvbnRlbnQnO1xuICAgIH1cbiAgICBvaWQgPSBhd2FpdCBfd3JpdGVPYmplY3Qoe1xuICAgICAgZnMsXG4gICAgICBnaXRkaXIsXG4gICAgICB0eXBlLFxuICAgICAgb2JqZWN0LFxuICAgICAgb2lkLFxuICAgICAgZm9ybWF0LFxuICAgIH0pO1xuICAgIHJldHVybiBvaWRcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyLmNhbGxlciA9ICdnaXQud3JpdGVPYmplY3QnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIEB0cy1jaGVja1xuXG4vKipcbiAqIFdyaXRlIGEgcmVmIHdoaWNoIHJlZmVycyB0byB0aGUgc3BlY2lmaWVkIFNIQS0xIG9iamVjdCBpZCwgb3IgYSBzeW1ib2xpYyByZWYgd2hpY2ggcmVmZXJzIHRvIHRoZSBzcGVjaWZpZWQgcmVmLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnJlZiAtIFRoZSBuYW1lIG9mIHRoZSByZWYgdG8gd3JpdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLnZhbHVlIC0gV2hlbiBgc3ltYm9saWNgIGlzIGZhbHNlLCBhIHJlZiBvciBhbiBTSEEtMSBvYmplY3QgaWQuIFdoZW4gdHJ1ZSwgYSByZWYgc3RhcnRpbmcgd2l0aCBgcmVmcy9gLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5mb3JjZSA9IGZhbHNlXSAtIEluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3IgaWYgYSByZWYgbmFtZWQgYHJlZmAgYWxyZWFkeSBleGlzdHMsIG92ZXJ3cml0ZSB0aGUgZXhpc3RpbmcgcmVmLlxuICogQHBhcmFtIHtib29sZWFufSBbYXJncy5zeW1ib2xpYyA9IGZhbHNlXSAtIFdoZXRoZXIgdGhlIHJlZiBpcyBzeW1ib2xpYyBvciBub3QuXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IFJlc29sdmVzIHN1Y2Nlc3NmdWxseSB3aGVuIGZpbGVzeXN0ZW0gb3BlcmF0aW9ucyBhcmUgY29tcGxldGVcbiAqXG4gKiBAZXhhbXBsZVxuICogYXdhaXQgZ2l0LndyaXRlUmVmKHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIHJlZjogJ3JlZnMvaGVhZHMvYW5vdGhlci1icmFuY2gnLFxuICogICB2YWx1ZTogJ0hFQUQnXG4gKiB9KVxuICogYXdhaXQgZ2l0LndyaXRlUmVmKHtcbiAqICAgZnMsXG4gKiAgIGRpcjogJy90dXRvcmlhbCcsXG4gKiAgIHJlZjogJ0hFQUQnLFxuICogICB2YWx1ZTogJ3JlZnMvaGVhZHMvYW5vdGhlci1icmFuY2gnLFxuICogICBmb3JjZTogdHJ1ZSxcbiAqICAgc3ltYm9saWM6IHRydWVcbiAqIH0pXG4gKiBjb25zb2xlLmxvZygnZG9uZScpXG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiB3cml0ZVJlZih7XG4gIGZzOiBfZnMsXG4gIGRpcixcbiAgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksXG4gIHJlZixcbiAgdmFsdWUsXG4gIGZvcmNlID0gZmFsc2UsXG4gIHN5bWJvbGljID0gZmFsc2UsXG59KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIF9mcyk7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdnaXRkaXInLCBnaXRkaXIpO1xuICAgIGFzc2VydFBhcmFtZXRlcigncmVmJywgcmVmKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ3ZhbHVlJywgdmFsdWUpO1xuXG4gICAgY29uc3QgZnMgPSBuZXcgRmlsZVN5c3RlbShfZnMpO1xuXG4gICAgaWYgKHJlZiAhPT0gY2xlYW5HaXRSZWYuY2xlYW4ocmVmKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRSZWZOYW1lRXJyb3IocmVmLCBjbGVhbkdpdFJlZi5jbGVhbihyZWYpKVxuICAgIH1cblxuICAgIGlmICghZm9yY2UgJiYgKGF3YWl0IEdpdFJlZk1hbmFnZXIuZXhpc3RzKHsgZnMsIGdpdGRpciwgcmVmIH0pKSkge1xuICAgICAgdGhyb3cgbmV3IEFscmVhZHlFeGlzdHNFcnJvcigncmVmJywgcmVmKVxuICAgIH1cblxuICAgIGlmIChzeW1ib2xpYykge1xuICAgICAgYXdhaXQgR2l0UmVmTWFuYWdlci53cml0ZVN5bWJvbGljUmVmKHtcbiAgICAgICAgZnMsXG4gICAgICAgIGdpdGRpcixcbiAgICAgICAgcmVmLFxuICAgICAgICB2YWx1ZSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGF3YWl0IEdpdFJlZk1hbmFnZXIucmVzb2x2ZSh7XG4gICAgICAgIGZzLFxuICAgICAgICBnaXRkaXIsXG4gICAgICAgIHJlZjogdmFsdWUsXG4gICAgICB9KTtcbiAgICAgIGF3YWl0IEdpdFJlZk1hbmFnZXIud3JpdGVSZWYoe1xuICAgICAgICBmcyxcbiAgICAgICAgZ2l0ZGlyLFxuICAgICAgICByZWYsXG4gICAgICAgIHZhbHVlLFxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC53cml0ZVJlZic7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLy8gQHRzLWNoZWNrXG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9tb2RlbHMvRmlsZVN5c3RlbS5qcycpLkZpbGVTeXN0ZW19IGFyZ3MuZnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBhcmdzLmdpdGRpclxuICogQHBhcmFtIHtUYWdPYmplY3R9IGFyZ3MudGFnXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3dyaXRlVGFnKHsgZnMsIGdpdGRpciwgdGFnIH0pIHtcbiAgLy8gQ29udmVydCBvYmplY3QgdG8gYnVmZmVyXG4gIGNvbnN0IG9iamVjdCA9IEdpdEFubm90YXRlZFRhZy5mcm9tKHRhZykudG9PYmplY3QoKTtcbiAgY29uc3Qgb2lkID0gYXdhaXQgX3dyaXRlT2JqZWN0KHtcbiAgICBmcyxcbiAgICBnaXRkaXIsXG4gICAgdHlwZTogJ3RhZycsXG4gICAgb2JqZWN0LFxuICAgIGZvcm1hdDogJ2NvbnRlbnQnLFxuICB9KTtcbiAgcmV0dXJuIG9pZFxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBXcml0ZSBhbiBhbm5vdGF0ZWQgdGFnIG9iamVjdCBkaXJlY3RseVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzXG4gKiBAcGFyYW0ge0ZzQ2xpZW50fSBhcmdzLmZzIC0gYSBmaWxlIHN5c3RlbSBjbGllbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5kaXJdIC0gVGhlIFt3b3JraW5nIHRyZWVdKGRpci12cy1naXRkaXIubWQpIGRpcmVjdG9yeSBwYXRoXG4gKiBAcGFyYW0ge3N0cmluZ30gW2FyZ3MuZ2l0ZGlyPWpvaW4oZGlyLCcuZ2l0JyldIC0gW3JlcXVpcmVkXSBUaGUgW2dpdCBkaXJlY3RvcnldKGRpci12cy1naXRkaXIubWQpIHBhdGhcbiAqIEBwYXJhbSB7VGFnT2JqZWN0fSBhcmdzLnRhZyAtIFRoZSBvYmplY3QgdG8gd3JpdGVcbiAqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBSZXNvbHZlcyBzdWNjZXNzZnVsbHkgd2l0aCB0aGUgU0hBLTEgb2JqZWN0IGlkIG9mIHRoZSBuZXdseSB3cml0dGVuIG9iamVjdFxuICogQHNlZSBUYWdPYmplY3RcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gTWFudWFsbHkgY3JlYXRlIGFuIGFubm90YXRlZCB0YWcuXG4gKiBsZXQgc2hhID0gYXdhaXQgZ2l0LnJlc29sdmVSZWYoeyBmcywgZGlyOiAnL3R1dG9yaWFsJywgcmVmOiAnSEVBRCcgfSlcbiAqIGNvbnNvbGUubG9nKCdjb21taXQnLCBzaGEpXG4gKlxuICogbGV0IG9pZCA9IGF3YWl0IGdpdC53cml0ZVRhZyh7XG4gKiAgIGZzLFxuICogICBkaXI6ICcvdHV0b3JpYWwnLFxuICogICB0YWc6IHtcbiAqICAgICBvYmplY3Q6IHNoYSxcbiAqICAgICB0eXBlOiAnY29tbWl0JyxcbiAqICAgICB0YWc6ICdteS10YWcnLFxuICogICAgIHRhZ2dlcjoge1xuICogICAgICAgbmFtZTogJ3lvdXIgbmFtZScsXG4gKiAgICAgICBlbWFpbDogJ2VtYWlsQGV4YW1wbGUuY29tJyxcbiAqICAgICAgIHRpbWVzdGFtcDogTWF0aC5mbG9vcihEYXRlLm5vdygpLzEwMDApLFxuICogICAgICAgdGltZXpvbmVPZmZzZXQ6IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKVxuICogICAgIH0sXG4gKiAgICAgbWVzc2FnZTogJ09wdGlvbmFsIG1lc3NhZ2UnXG4gKiAgIH1cbiAqIH0pXG4gKlxuICogY29uc29sZS5sb2coJ3RhZycsIG9pZClcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlVGFnKHsgZnMsIGRpciwgZ2l0ZGlyID0gam9pbihkaXIsICcuZ2l0JyksIHRhZyB9KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCd0YWcnLCB0YWcpO1xuXG4gICAgcmV0dXJuIGF3YWl0IF93cml0ZVRhZyh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgdGFnLFxuICAgIH0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVyci5jYWxsZXIgPSAnZ2l0LndyaXRlVGFnJztcbiAgICB0aHJvdyBlcnJcbiAgfVxufVxuXG4vLyBAdHMtY2hlY2tcblxuLyoqXG4gKiBXcml0ZSBhIHRyZWUgb2JqZWN0IGRpcmVjdGx5XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGFyZ3NcbiAqIEBwYXJhbSB7RnNDbGllbnR9IGFyZ3MuZnMgLSBhIGZpbGUgc3lzdGVtIGNsaWVudFxuICogQHBhcmFtIHtzdHJpbmd9IFthcmdzLmRpcl0gLSBUaGUgW3dvcmtpbmcgdHJlZV0oZGlyLXZzLWdpdGRpci5tZCkgZGlyZWN0b3J5IHBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBbYXJncy5naXRkaXI9am9pbihkaXIsJy5naXQnKV0gLSBbcmVxdWlyZWRdIFRoZSBbZ2l0IGRpcmVjdG9yeV0oZGlyLXZzLWdpdGRpci5tZCkgcGF0aFxuICogQHBhcmFtIHtUcmVlT2JqZWN0fSBhcmdzLnRyZWUgLSBUaGUgb2JqZWN0IHRvIHdyaXRlXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gUmVzb2x2ZXMgc3VjY2Vzc2Z1bGx5IHdpdGggdGhlIFNIQS0xIG9iamVjdCBpZCBvZiB0aGUgbmV3bHkgd3JpdHRlbiBvYmplY3QuXG4gKiBAc2VlIFRyZWVPYmplY3RcbiAqIEBzZWUgVHJlZUVudHJ5XG4gKlxuICovXG5hc3luYyBmdW5jdGlvbiB3cml0ZVRyZWUoeyBmcywgZGlyLCBnaXRkaXIgPSBqb2luKGRpciwgJy5naXQnKSwgdHJlZSB9KSB7XG4gIHRyeSB7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCdmcycsIGZzKTtcbiAgICBhc3NlcnRQYXJhbWV0ZXIoJ2dpdGRpcicsIGdpdGRpcik7XG4gICAgYXNzZXJ0UGFyYW1ldGVyKCd0cmVlJywgdHJlZSk7XG5cbiAgICByZXR1cm4gYXdhaXQgX3dyaXRlVHJlZSh7XG4gICAgICBmczogbmV3IEZpbGVTeXN0ZW0oZnMpLFxuICAgICAgZ2l0ZGlyLFxuICAgICAgdHJlZSxcbiAgICB9KVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBlcnIuY2FsbGVyID0gJ2dpdC53cml0ZVRyZWUnO1xuICAgIHRocm93IGVyclxuICB9XG59XG5cbi8vIGRlZmF1bHQgZXhwb3J0XG52YXIgaW5kZXggPSB7XG4gIEVycm9ycyxcbiAgU1RBR0UsXG4gIFRSRUUsXG4gIFdPUktESVIsXG4gIGFkZCxcbiAgYWRkTm90ZSxcbiAgYWRkUmVtb3RlLFxuICBhbm5vdGF0ZWRUYWcsXG4gIGJyYW5jaCxcbiAgY2hlY2tvdXQsXG4gIGNsb25lLFxuICBjb21taXQsXG4gIGdldENvbmZpZyxcbiAgZ2V0Q29uZmlnQWxsLFxuICBzZXRDb25maWcsXG4gIGN1cnJlbnRCcmFuY2gsXG4gIGRlbGV0ZUJyYW5jaCxcbiAgZGVsZXRlUmVmLFxuICBkZWxldGVSZW1vdGUsXG4gIGRlbGV0ZVRhZyxcbiAgZXhwYW5kT2lkLFxuICBleHBhbmRSZWYsXG4gIGZhc3RGb3J3YXJkLFxuICBmZXRjaCxcbiAgZmluZE1lcmdlQmFzZSxcbiAgZmluZFJvb3QsXG4gIGdldFJlbW90ZUluZm8sXG4gIGdldFJlbW90ZUluZm8yLFxuICBoYXNoQmxvYixcbiAgaW5kZXhQYWNrLFxuICBpbml0LFxuICBpc0Rlc2NlbmRlbnQsXG4gIGlzSWdub3JlZCxcbiAgbGlzdEJyYW5jaGVzLFxuICBsaXN0RmlsZXMsXG4gIGxpc3ROb3RlcyxcbiAgbGlzdFJlbW90ZXMsXG4gIGxpc3RTZXJ2ZXJSZWZzLFxuICBsaXN0VGFncyxcbiAgbG9nLFxuICBtZXJnZSxcbiAgcGFja09iamVjdHMsXG4gIHB1bGwsXG4gIHB1c2gsXG4gIHJlYWRCbG9iLFxuICByZWFkQ29tbWl0LFxuICByZWFkTm90ZSxcbiAgcmVhZE9iamVjdCxcbiAgcmVhZFRhZyxcbiAgcmVhZFRyZWUsXG4gIHJlbW92ZSxcbiAgcmVtb3ZlTm90ZSxcbiAgcmVuYW1lQnJhbmNoLFxuICByZXNldEluZGV4LFxuICByZXNvbHZlUmVmLFxuICBzdGF0dXMsXG4gIHN0YXR1c01hdHJpeCxcbiAgdGFnLFxuICB2ZXJzaW9uLFxuICB3YWxrLFxuICB3cml0ZUJsb2IsXG4gIHdyaXRlQ29tbWl0LFxuICB3cml0ZU9iamVjdCxcbiAgd3JpdGVSZWYsXG4gIHdyaXRlVGFnLFxuICB3cml0ZVRyZWUsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBpbmRleDtcbmV4cG9ydCB7IEVycm9ycywgU1RBR0UsIFRSRUUsIFdPUktESVIsIGFkZCwgYWRkTm90ZSwgYWRkUmVtb3RlLCBhbm5vdGF0ZWRUYWcsIGJyYW5jaCwgY2hlY2tvdXQsIGNsb25lLCBjb21taXQsIGN1cnJlbnRCcmFuY2gsIGRlbGV0ZUJyYW5jaCwgZGVsZXRlUmVmLCBkZWxldGVSZW1vdGUsIGRlbGV0ZVRhZywgZXhwYW5kT2lkLCBleHBhbmRSZWYsIGZhc3RGb3J3YXJkLCBmZXRjaCwgZmluZE1lcmdlQmFzZSwgZmluZFJvb3QsIGdldENvbmZpZywgZ2V0Q29uZmlnQWxsLCBnZXRSZW1vdGVJbmZvLCBnZXRSZW1vdGVJbmZvMiwgaGFzaEJsb2IsIGluZGV4UGFjaywgaW5pdCwgaXNEZXNjZW5kZW50LCBpc0lnbm9yZWQsIGxpc3RCcmFuY2hlcywgbGlzdEZpbGVzLCBsaXN0Tm90ZXMsIGxpc3RSZW1vdGVzLCBsaXN0U2VydmVyUmVmcywgbGlzdFRhZ3MsIGxvZywgbWVyZ2UsIHBhY2tPYmplY3RzLCBwdWxsLCBwdXNoLCByZWFkQmxvYiwgcmVhZENvbW1pdCwgcmVhZE5vdGUsIHJlYWRPYmplY3QsIHJlYWRUYWcsIHJlYWRUcmVlLCByZW1vdmUsIHJlbW92ZU5vdGUsIHJlbmFtZUJyYW5jaCwgcmVzZXRJbmRleCwgcmVzb2x2ZVJlZiwgc2V0Q29uZmlnLCBzdGF0dXMsIHN0YXR1c01hdHJpeCwgdGFnLCB2ZXJzaW9uLCB3YWxrLCB3cml0ZUJsb2IsIHdyaXRlQ29tbWl0LCB3cml0ZU9iamVjdCwgd3JpdGVSZWYsIHdyaXRlVGFnLCB3cml0ZVRyZWUgfTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBSZWQgSGF0LCBJbmMuIGFuZC9vciBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVXb3Jrc3BhY2VTZXJ2aWNlcyB9IGZyb20gXCJAa2llLXRvb2xzLWNvcmUvd29ya3NwYWNlcy1naXQtZnMvZGlzdC93b3JrZXIvY3JlYXRlV29ya3NwYWNlU2VydmljZXNcIjtcbmltcG9ydCB7IFdvcmtzcGFjZXNXb3JrZXJBcGlJbXBsIH0gZnJvbSBcIkBraWUtdG9vbHMtY29yZS93b3Jrc3BhY2VzLWdpdC1mcy9kaXN0L3dvcmtlci9Xb3Jrc3BhY2VzV29ya2VyQXBpSW1wbFwiO1xuaW1wb3J0IHsgc2V0dXBXb3JrZXJDb25uZWN0aW9uIH0gZnJvbSBcIkBraWUtdG9vbHMtY29yZS93b3Jrc3BhY2VzLWdpdC1mcy9kaXN0L3dvcmtlci9zZXR1cFdvcmtlckNvbm5lY3Rpb25cIjtcbmltcG9ydCB7IEVOVl9GSUxFX1BBVEggfSBmcm9tIFwiLi4vLi4vZW52L0VudkNvbnN0YW50c1wiO1xuaW1wb3J0IHsgQVBQX05BTUUgfSBmcm9tIFwiLi4vLi4vQXBwQ29uc3RhbnRzXCI7XG5pbXBvcnQgeyBpc01vZGVsLCBpc0VkaXRhYmxlIH0gZnJvbSBcIi4uLy4uL2V4dGVuc2lvblwiO1xuaW1wb3J0IHsgRW52VmFycyB9IGZyb20gXCIuLi8uLi9lbnYvRW52Q29udGV4dFwiO1xuaW1wb3J0IHsgRWRpdG9yRW52ZWxvcGVMb2NhdG9yRmFjdG9yeSB9IGZyb20gXCIuLi8uLi9lbnZlbG9wZUxvY2F0b3IvRWRpdG9yRW52ZWxvcGVMb2NhdG9yRmFjdG9yeVwiO1xuXG5kZWNsYXJlIGNvbnN0IGltcG9ydFNjcmlwdHM6IGFueTtcbmltcG9ydFNjcmlwdHMoXCJmc01haW4uanNcIik7XG5cbmFzeW5jIGZ1bmN0aW9uIGdpdENvcnNQcm94eVVybCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCBlbnZGaWxlUGF0aCA9IGAuLi8uLi8ke0VOVl9GSUxFX1BBVEh9YDsgLy8gTmVlZHMgdG8gZ28gYmFjayB0d28gZGlycywgc2luY2UgdGhpcyBmaWxlIGlzIGF0IGB3b3Jrc3BhY2VzL3dvcmtlcmAuXG4gIGNvbnN0IGVudiA9IChhd2FpdCAoYXdhaXQgZmV0Y2goZW52RmlsZVBhdGgpKS5qc29uKCkpIGFzIEVudlZhcnM7XG4gIHJldHVybiBlbnYuU0VSVkVSTEVTU19MT0dJQ19XRUJfVE9PTFNfR0lUX0NPUlNfUFJPWFlfVVJMID8/IHByb2Nlc3MuZW52LldFQlBBQ0tfUkVQTEFDRV9fZ2l0Q29yc1Byb3h5VXJsID8/IFwiXCI7XG59XG5cbmNvbnN0IGVkaXRvckVudmVsb3BlTG9jYXRvciA9IG5ldyBFZGl0b3JFbnZlbG9wZUxvY2F0b3JGYWN0b3J5KCkuY3JlYXRlKHsgdGFyZ2V0T3JpZ2luOiBcIlwiIH0pO1xuY29uc3Qgd29ya3NwYWNlU2VydmljZXMgPSBjcmVhdGVXb3Jrc3BhY2VTZXJ2aWNlcyh7IGdpdENvcnNQcm94eVVybDogZ2l0Q29yc1Byb3h5VXJsKCkgfSk7XG5cbi8vIHNoYXJlZCB3b3JrZXIgY29ubmVjdGlvblxuXG5kZWNsYXJlIGxldCBvbmNvbm5lY3Q6IGFueTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3Rcbm9uY29ubmVjdCA9IGFzeW5jIChlOiBNZXNzYWdlRXZlbnQpID0+IHtcbiAgY29uc29sZS5sb2coXCJDb25uZWN0ZWQgdG8gV29ya3NwYWNlcyBTaGFyZWQgV29ya2VyXCIpO1xuXG4gIHNldHVwV29ya2VyQ29ubmVjdGlvbih7XG4gICAgZnNGbHVzaE1hbmFnZXI6IHdvcmtzcGFjZVNlcnZpY2VzLmZzRmx1c2hNYW5hZ2VyLFxuICAgIGFwaUltcGw6IG5ldyBXb3Jrc3BhY2VzV29ya2VyQXBpSW1wbCh7XG4gICAgICBhcHBOYW1lOiBBUFBfTkFNRSxcbiAgICAgIHNlcnZpY2VzOiB3b3Jrc3BhY2VTZXJ2aWNlcyxcbiAgICAgIGZpbGVGaWx0ZXI6IHtcbiAgICAgICAgaXNNb2RlbDogKHBhdGgpID0+IGlzTW9kZWwocGF0aCksXG4gICAgICAgIGlzRWRpdGFibGU6IChwYXRoKSA9PiBpc0VkaXRhYmxlKHBhdGgpLFxuICAgICAgICBpc1N1cHBvcnRlZDogKHBhdGgpID0+IGVkaXRvckVudmVsb3BlTG9jYXRvci5oYXNNYXBwaW5nRm9yKHBhdGgpLFxuICAgICAgfSxcbiAgICB9KSxcbiAgICBwb3J0OiBlLnBvcnRzWzBdLFxuICB9KTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=